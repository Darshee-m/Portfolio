"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chevrotain";
exports.ids = ["vendor-chunks/chevrotain"];
exports.modules = {

/***/ "(ssr)/./node_modules/chevrotain/lib/src/api.js":
/*!************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/api.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/* istanbul ignore file - tricky to import some things from this module during testing */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Parser = exports.createSyntaxDiagramsCode = exports.clearCache = exports.generateCstDts = exports.GAstVisitor = exports.serializeProduction = exports.serializeGrammar = exports.Terminal = exports.Rule = exports.RepetitionWithSeparator = exports.RepetitionMandatoryWithSeparator = exports.RepetitionMandatory = exports.Repetition = exports.Option = exports.NonTerminal = exports.Alternative = exports.Alternation = exports.defaultLexerErrorProvider = exports.NoViableAltException = exports.NotAllInputParsedException = exports.MismatchedTokenException = exports.isRecognitionException = exports.EarlyExitException = exports.defaultParserErrorProvider = exports.LLkLookaheadStrategy = exports.getLookaheadPaths = exports.tokenName = exports.tokenMatcher = exports.tokenLabel = exports.EOF = exports.createTokenInstance = exports.createToken = exports.LexerDefinitionErrorType = exports.Lexer = exports.EMPTY_ALT = exports.ParserDefinitionErrorType = exports.EmbeddedActionsParser = exports.CstParser = exports.VERSION = void 0;\n// semantic version\nvar version_1 = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/chevrotain/lib/src/version.js\");\nObject.defineProperty(exports, \"VERSION\", ({ enumerable: true, get: function () { return version_1.VERSION; } }));\nvar parser_1 = __webpack_require__(/*! ./parse/parser/parser */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\");\nObject.defineProperty(exports, \"CstParser\", ({ enumerable: true, get: function () { return parser_1.CstParser; } }));\nObject.defineProperty(exports, \"EmbeddedActionsParser\", ({ enumerable: true, get: function () { return parser_1.EmbeddedActionsParser; } }));\nObject.defineProperty(exports, \"ParserDefinitionErrorType\", ({ enumerable: true, get: function () { return parser_1.ParserDefinitionErrorType; } }));\nObject.defineProperty(exports, \"EMPTY_ALT\", ({ enumerable: true, get: function () { return parser_1.EMPTY_ALT; } }));\nvar lexer_public_1 = __webpack_require__(/*! ./scan/lexer_public */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/lexer_public.js\");\nObject.defineProperty(exports, \"Lexer\", ({ enumerable: true, get: function () { return lexer_public_1.Lexer; } }));\nObject.defineProperty(exports, \"LexerDefinitionErrorType\", ({ enumerable: true, get: function () { return lexer_public_1.LexerDefinitionErrorType; } }));\n// Tokens utilities\nvar tokens_public_1 = __webpack_require__(/*! ./scan/tokens_public */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/tokens_public.js\");\nObject.defineProperty(exports, \"createToken\", ({ enumerable: true, get: function () { return tokens_public_1.createToken; } }));\nObject.defineProperty(exports, \"createTokenInstance\", ({ enumerable: true, get: function () { return tokens_public_1.createTokenInstance; } }));\nObject.defineProperty(exports, \"EOF\", ({ enumerable: true, get: function () { return tokens_public_1.EOF; } }));\nObject.defineProperty(exports, \"tokenLabel\", ({ enumerable: true, get: function () { return tokens_public_1.tokenLabel; } }));\nObject.defineProperty(exports, \"tokenMatcher\", ({ enumerable: true, get: function () { return tokens_public_1.tokenMatcher; } }));\nObject.defineProperty(exports, \"tokenName\", ({ enumerable: true, get: function () { return tokens_public_1.tokenName; } }));\n// Lookahead\nvar lookahead_1 = __webpack_require__(/*! ./parse/grammar/lookahead */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js\");\nObject.defineProperty(exports, \"getLookaheadPaths\", ({ enumerable: true, get: function () { return lookahead_1.getLookaheadPaths; } }));\nvar llk_lookahead_1 = __webpack_require__(/*! ./parse/grammar/llk_lookahead */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js\");\nObject.defineProperty(exports, \"LLkLookaheadStrategy\", ({ enumerable: true, get: function () { return llk_lookahead_1.LLkLookaheadStrategy; } }));\n// Other Utilities\nvar errors_public_1 = __webpack_require__(/*! ./parse/errors_public */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/errors_public.js\");\nObject.defineProperty(exports, \"defaultParserErrorProvider\", ({ enumerable: true, get: function () { return errors_public_1.defaultParserErrorProvider; } }));\nvar exceptions_public_1 = __webpack_require__(/*! ./parse/exceptions_public */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/exceptions_public.js\");\nObject.defineProperty(exports, \"EarlyExitException\", ({ enumerable: true, get: function () { return exceptions_public_1.EarlyExitException; } }));\nObject.defineProperty(exports, \"isRecognitionException\", ({ enumerable: true, get: function () { return exceptions_public_1.isRecognitionException; } }));\nObject.defineProperty(exports, \"MismatchedTokenException\", ({ enumerable: true, get: function () { return exceptions_public_1.MismatchedTokenException; } }));\nObject.defineProperty(exports, \"NotAllInputParsedException\", ({ enumerable: true, get: function () { return exceptions_public_1.NotAllInputParsedException; } }));\nObject.defineProperty(exports, \"NoViableAltException\", ({ enumerable: true, get: function () { return exceptions_public_1.NoViableAltException; } }));\nvar lexer_errors_public_1 = __webpack_require__(/*! ./scan/lexer_errors_public */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/lexer_errors_public.js\");\nObject.defineProperty(exports, \"defaultLexerErrorProvider\", ({ enumerable: true, get: function () { return lexer_errors_public_1.defaultLexerErrorProvider; } }));\n// grammar reflection API\nvar gast_1 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nObject.defineProperty(exports, \"Alternation\", ({ enumerable: true, get: function () { return gast_1.Alternation; } }));\nObject.defineProperty(exports, \"Alternative\", ({ enumerable: true, get: function () { return gast_1.Alternative; } }));\nObject.defineProperty(exports, \"NonTerminal\", ({ enumerable: true, get: function () { return gast_1.NonTerminal; } }));\nObject.defineProperty(exports, \"Option\", ({ enumerable: true, get: function () { return gast_1.Option; } }));\nObject.defineProperty(exports, \"Repetition\", ({ enumerable: true, get: function () { return gast_1.Repetition; } }));\nObject.defineProperty(exports, \"RepetitionMandatory\", ({ enumerable: true, get: function () { return gast_1.RepetitionMandatory; } }));\nObject.defineProperty(exports, \"RepetitionMandatoryWithSeparator\", ({ enumerable: true, get: function () { return gast_1.RepetitionMandatoryWithSeparator; } }));\nObject.defineProperty(exports, \"RepetitionWithSeparator\", ({ enumerable: true, get: function () { return gast_1.RepetitionWithSeparator; } }));\nObject.defineProperty(exports, \"Rule\", ({ enumerable: true, get: function () { return gast_1.Rule; } }));\nObject.defineProperty(exports, \"Terminal\", ({ enumerable: true, get: function () { return gast_1.Terminal; } }));\n// GAST Utilities\nvar gast_2 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nObject.defineProperty(exports, \"serializeGrammar\", ({ enumerable: true, get: function () { return gast_2.serializeGrammar; } }));\nObject.defineProperty(exports, \"serializeProduction\", ({ enumerable: true, get: function () { return gast_2.serializeProduction; } }));\nObject.defineProperty(exports, \"GAstVisitor\", ({ enumerable: true, get: function () { return gast_2.GAstVisitor; } }));\nvar cst_dts_gen_1 = __webpack_require__(/*! @chevrotain/cst-dts-gen */ \"(ssr)/./node_modules/@chevrotain/cst-dts-gen/lib/src/api.js\");\nObject.defineProperty(exports, \"generateCstDts\", ({ enumerable: true, get: function () { return cst_dts_gen_1.generateCstDts; } }));\n/* istanbul ignore next */\nfunction clearCache() {\n    console.warn(\"The clearCache function was 'soft' removed from the Chevrotain API.\" +\n        \"\\n\\t It performs no action other than printing this message.\" +\n        \"\\n\\t Please avoid using it as it will be completely removed in the future\");\n}\nexports.clearCache = clearCache;\nvar render_public_1 = __webpack_require__(/*! ./diagrams/render_public */ \"(ssr)/./node_modules/chevrotain/lib/src/diagrams/render_public.js\");\nObject.defineProperty(exports, \"createSyntaxDiagramsCode\", ({ enumerable: true, get: function () { return render_public_1.createSyntaxDiagramsCode; } }));\nvar Parser = /** @class */ (function () {\n    function Parser() {\n        throw new Error(\"The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.\\t\\n\" +\n            \"See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0\");\n    }\n    return Parser;\n}());\nexports.Parser = Parser;\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL2FwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxnQ0FBZ0MsR0FBRyxrQkFBa0IsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0IsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsK0JBQStCLEdBQUcsd0NBQXdDLEdBQUcsMkJBQTJCLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLGlDQUFpQyxHQUFHLDRCQUE0QixHQUFHLGtDQUFrQyxHQUFHLGdDQUFnQyxHQUFHLDhCQUE4QixHQUFHLDBCQUEwQixHQUFHLGtDQUFrQyxHQUFHLDRCQUE0QixHQUFHLHlCQUF5QixHQUFHLGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLFdBQVcsR0FBRywyQkFBMkIsR0FBRyxtQkFBbUIsR0FBRyxnQ0FBZ0MsR0FBRyxhQUFhLEdBQUcsaUJBQWlCLEdBQUcsaUNBQWlDLEdBQUcsNkJBQTZCLEdBQUcsaUJBQWlCLEdBQUcsZUFBZTtBQUMvL0I7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxxRUFBVztBQUNuQywyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0csZUFBZSxtQkFBTyxDQUFDLDZGQUF1QjtBQUM5Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDbEgseURBQXdELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQzFJLDZEQUE0RCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUNsSiw2Q0FBNEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDbEgscUJBQXFCLG1CQUFPLENBQUMseUZBQXFCO0FBQ2xELHlDQUF3QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNoSCw0REFBMkQsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDdEo7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQywyRkFBc0I7QUFDcEQsK0NBQThDLEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQzdILHVEQUFzRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUM3SSx1Q0FBc0MsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDN0csOENBQTZDLEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQzNILGdEQUErQyxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUMvSCw2Q0FBNEMsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDekg7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBMkI7QUFDckQscURBQW9ELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ3JJLHNCQUFzQixtQkFBTyxDQUFDLDZHQUErQjtBQUM3RCx3REFBdUQsRUFBRSxxQ0FBcUMsZ0RBQWdELEVBQUM7QUFDL0k7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBdUI7QUFDckQsOERBQTZELEVBQUUscUNBQXFDLHNEQUFzRCxFQUFDO0FBQzNKLDBCQUEwQixtQkFBTyxDQUFDLHFHQUEyQjtBQUM3RCxzREFBcUQsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDL0ksMERBQXlELEVBQUUscUNBQXFDLHNEQUFzRCxFQUFDO0FBQ3ZKLDREQUEyRCxFQUFFLHFDQUFxQyx3REFBd0QsRUFBQztBQUMzSiw4REFBNkQsRUFBRSxxQ0FBcUMsMERBQTBELEVBQUM7QUFDL0osd0RBQXVELEVBQUUscUNBQXFDLG9EQUFvRCxFQUFDO0FBQ25KLDRCQUE0QixtQkFBTyxDQUFDLHVHQUE0QjtBQUNoRSw2REFBNEQsRUFBRSxxQ0FBcUMsMkRBQTJELEVBQUM7QUFDL0o7QUFDQSxhQUFhLG1CQUFPLENBQUMsOEVBQWtCO0FBQ3ZDLCtDQUE4QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNwSCwrQ0FBOEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDcEgsK0NBQThDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ3BILDBDQUF5QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUMxRyw4Q0FBNkMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDbEgsdURBQXNELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ3BJLG9FQUFtRSxFQUFFLHFDQUFxQyxtREFBbUQsRUFBQztBQUM5SiwyREFBMEQsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDNUksd0NBQXVDLEVBQUUscUNBQXFDLHVCQUF1QixFQUFDO0FBQ3RHLDRDQUEyQyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM5RztBQUNBLGFBQWEsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDdkMsb0RBQW1ELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzlILHVEQUFzRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNwSSwrQ0FBOEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDcEgsb0JBQW9CLG1CQUFPLENBQUMsNEZBQXlCO0FBQ3JELGtEQUFpRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsc0JBQXNCLG1CQUFPLENBQUMsbUdBQTBCO0FBQ3hELDREQUEyRCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvYXBpLmpzPzJmMWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAtIHRyaWNreSB0byBpbXBvcnQgc29tZSB0aGluZ3MgZnJvbSB0aGlzIG1vZHVsZSBkdXJpbmcgdGVzdGluZyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJzZXIgPSBleHBvcnRzLmNyZWF0ZVN5bnRheERpYWdyYW1zQ29kZSA9IGV4cG9ydHMuY2xlYXJDYWNoZSA9IGV4cG9ydHMuZ2VuZXJhdGVDc3REdHMgPSBleHBvcnRzLkdBc3RWaXNpdG9yID0gZXhwb3J0cy5zZXJpYWxpemVQcm9kdWN0aW9uID0gZXhwb3J0cy5zZXJpYWxpemVHcmFtbWFyID0gZXhwb3J0cy5UZXJtaW5hbCA9IGV4cG9ydHMuUnVsZSA9IGV4cG9ydHMuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgPSBleHBvcnRzLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yID0gZXhwb3J0cy5SZXBldGl0aW9uTWFuZGF0b3J5ID0gZXhwb3J0cy5SZXBldGl0aW9uID0gZXhwb3J0cy5PcHRpb24gPSBleHBvcnRzLk5vblRlcm1pbmFsID0gZXhwb3J0cy5BbHRlcm5hdGl2ZSA9IGV4cG9ydHMuQWx0ZXJuYXRpb24gPSBleHBvcnRzLmRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXIgPSBleHBvcnRzLk5vVmlhYmxlQWx0RXhjZXB0aW9uID0gZXhwb3J0cy5Ob3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbiA9IGV4cG9ydHMuTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uID0gZXhwb3J0cy5pc1JlY29nbml0aW9uRXhjZXB0aW9uID0gZXhwb3J0cy5FYXJseUV4aXRFeGNlcHRpb24gPSBleHBvcnRzLmRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyID0gZXhwb3J0cy5MTGtMb29rYWhlYWRTdHJhdGVneSA9IGV4cG9ydHMuZ2V0TG9va2FoZWFkUGF0aHMgPSBleHBvcnRzLnRva2VuTmFtZSA9IGV4cG9ydHMudG9rZW5NYXRjaGVyID0gZXhwb3J0cy50b2tlbkxhYmVsID0gZXhwb3J0cy5FT0YgPSBleHBvcnRzLmNyZWF0ZVRva2VuSW5zdGFuY2UgPSBleHBvcnRzLmNyZWF0ZVRva2VuID0gZXhwb3J0cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUgPSBleHBvcnRzLkxleGVyID0gZXhwb3J0cy5FTVBUWV9BTFQgPSBleHBvcnRzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUgPSBleHBvcnRzLkVtYmVkZGVkQWN0aW9uc1BhcnNlciA9IGV4cG9ydHMuQ3N0UGFyc2VyID0gZXhwb3J0cy5WRVJTSU9OID0gdm9pZCAwO1xuLy8gc2VtYW50aWMgdmVyc2lvblxudmFyIHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWRVJTSU9OXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2ZXJzaW9uXzEuVkVSU0lPTjsgfSB9KTtcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3BhcnNlL3BhcnNlci9wYXJzZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDc3RQYXJzZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcnNlcl8xLkNzdFBhcnNlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVtYmVkZGVkQWN0aW9uc1BhcnNlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyXzEuRW1iZWRkZWRBY3Rpb25zUGFyc2VyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyXzEuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVNUFRZX0FMVFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyXzEuRU1QVFlfQUxUOyB9IH0pO1xudmFyIGxleGVyX3B1YmxpY18xID0gcmVxdWlyZShcIi4vc2Nhbi9sZXhlcl9wdWJsaWNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMZXhlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGV4ZXJfcHVibGljXzEuTGV4ZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMZXhlckRlZmluaXRpb25FcnJvclR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxleGVyX3B1YmxpY18xLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZTsgfSB9KTtcbi8vIFRva2VucyB1dGlsaXRpZXNcbnZhciB0b2tlbnNfcHVibGljXzEgPSByZXF1aXJlKFwiLi9zY2FuL3Rva2Vuc19wdWJsaWNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVUb2tlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdG9rZW5zX3B1YmxpY18xLmNyZWF0ZVRva2VuOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVG9rZW5JbnN0YW5jZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdG9rZW5zX3B1YmxpY18xLmNyZWF0ZVRva2VuSW5zdGFuY2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFT0ZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRva2Vuc19wdWJsaWNfMS5FT0Y7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b2tlbkxhYmVsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0b2tlbnNfcHVibGljXzEudG9rZW5MYWJlbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRva2VuTWF0Y2hlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdG9rZW5zX3B1YmxpY18xLnRva2VuTWF0Y2hlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRva2VuTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdG9rZW5zX3B1YmxpY18xLnRva2VuTmFtZTsgfSB9KTtcbi8vIExvb2thaGVhZFxudmFyIGxvb2thaGVhZF8xID0gcmVxdWlyZShcIi4vcGFyc2UvZ3JhbW1hci9sb29rYWhlYWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRMb29rYWhlYWRQYXRoc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9va2FoZWFkXzEuZ2V0TG9va2FoZWFkUGF0aHM7IH0gfSk7XG52YXIgbGxrX2xvb2thaGVhZF8xID0gcmVxdWlyZShcIi4vcGFyc2UvZ3JhbW1hci9sbGtfbG9va2FoZWFkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTExrTG9va2FoZWFkU3RyYXRlZ3lcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxsa19sb29rYWhlYWRfMS5MTGtMb29rYWhlYWRTdHJhdGVneTsgfSB9KTtcbi8vIE90aGVyIFV0aWxpdGllc1xudmFyIGVycm9yc19wdWJsaWNfMSA9IHJlcXVpcmUoXCIuL3BhcnNlL2Vycm9yc19wdWJsaWNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX3B1YmxpY18xLmRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyOyB9IH0pO1xudmFyIGV4Y2VwdGlvbnNfcHVibGljXzEgPSByZXF1aXJlKFwiLi9wYXJzZS9leGNlcHRpb25zX3B1YmxpY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVhcmx5RXhpdEV4Y2VwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc19wdWJsaWNfMS5FYXJseUV4aXRFeGNlcHRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1JlY29nbml0aW9uRXhjZXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zX3B1YmxpY18xLmlzUmVjb2duaXRpb25FeGNlcHRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfcHVibGljXzEuTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfcHVibGljXzEuTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb1ZpYWJsZUFsdEV4Y2VwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc19wdWJsaWNfMS5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbjsgfSB9KTtcbnZhciBsZXhlcl9lcnJvcnNfcHVibGljXzEgPSByZXF1aXJlKFwiLi9zY2FuL2xleGVyX2Vycm9yc19wdWJsaWNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsZXhlcl9lcnJvcnNfcHVibGljXzEuZGVmYXVsdExleGVyRXJyb3JQcm92aWRlcjsgfSB9KTtcbi8vIGdyYW1tYXIgcmVmbGVjdGlvbiBBUElcbnZhciBnYXN0XzEgPSByZXF1aXJlKFwiQGNoZXZyb3RhaW4vZ2FzdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFsdGVybmF0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnYXN0XzEuQWx0ZXJuYXRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbHRlcm5hdGl2ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2FzdF8xLkFsdGVybmF0aXZlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9uVGVybWluYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdhc3RfMS5Ob25UZXJtaW5hbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9wdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2FzdF8xLk9wdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcGV0aXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdhc3RfMS5SZXBldGl0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVwZXRpdGlvbk1hbmRhdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2FzdF8xLlJlcGV0aXRpb25NYW5kYXRvcnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2FzdF8xLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVwZXRpdGlvbldpdGhTZXBhcmF0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdhc3RfMS5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJ1bGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdhc3RfMS5SdWxlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGVybWluYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdhc3RfMS5UZXJtaW5hbDsgfSB9KTtcbi8vIEdBU1QgVXRpbGl0aWVzXG52YXIgZ2FzdF8yID0gcmVxdWlyZShcIkBjaGV2cm90YWluL2dhc3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXJpYWxpemVHcmFtbWFyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnYXN0XzIuc2VyaWFsaXplR3JhbW1hcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlcmlhbGl6ZVByb2R1Y3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdhc3RfMi5zZXJpYWxpemVQcm9kdWN0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR0FzdFZpc2l0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdhc3RfMi5HQXN0VmlzaXRvcjsgfSB9KTtcbnZhciBjc3RfZHRzX2dlbl8xID0gcmVxdWlyZShcIkBjaGV2cm90YWluL2NzdC1kdHMtZ2VuXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2VuZXJhdGVDc3REdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNzdF9kdHNfZ2VuXzEuZ2VuZXJhdGVDc3REdHM7IH0gfSk7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgY2xlYXJDYWNoZSBmdW5jdGlvbiB3YXMgJ3NvZnQnIHJlbW92ZWQgZnJvbSB0aGUgQ2hldnJvdGFpbiBBUEkuXCIgK1xuICAgICAgICBcIlxcblxcdCBJdCBwZXJmb3JtcyBubyBhY3Rpb24gb3RoZXIgdGhhbiBwcmludGluZyB0aGlzIG1lc3NhZ2UuXCIgK1xuICAgICAgICBcIlxcblxcdCBQbGVhc2UgYXZvaWQgdXNpbmcgaXQgYXMgaXQgd2lsbCBiZSBjb21wbGV0ZWx5IHJlbW92ZWQgaW4gdGhlIGZ1dHVyZVwiKTtcbn1cbmV4cG9ydHMuY2xlYXJDYWNoZSA9IGNsZWFyQ2FjaGU7XG52YXIgcmVuZGVyX3B1YmxpY18xID0gcmVxdWlyZShcIi4vZGlhZ3JhbXMvcmVuZGVyX3B1YmxpY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVN5bnRheERpYWdyYW1zQ29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVuZGVyX3B1YmxpY18xLmNyZWF0ZVN5bnRheERpYWdyYW1zQ29kZTsgfSB9KTtcbnZhciBQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgUGFyc2VyIGNsYXNzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSBDc3RQYXJzZXIgb3IgRW1iZWRkZWRBY3Rpb25zUGFyc2VyIGluc3RlYWQuXFx0XFxuXCIgK1xuICAgICAgICAgICAgXCJTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2NoYW5nZXMvQlJFQUtJTkdfQ0hBTkdFUy5odG1sI183LTAtMFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlcjtcbn0oKSk7XG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/api.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/diagrams/render_public.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/diagrams/render_public.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createSyntaxDiagramsCode = void 0;\nvar version_1 = __webpack_require__(/*! ../version */ \"(ssr)/./node_modules/chevrotain/lib/src/version.js\");\nfunction createSyntaxDiagramsCode(grammar, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.resourceBase, resourceBase = _c === void 0 ? \"https://unpkg.com/chevrotain@\".concat(version_1.VERSION, \"/diagrams/\") : _c, _d = _b.css, css = _d === void 0 ? \"https://unpkg.com/chevrotain@\".concat(version_1.VERSION, \"/diagrams/diagrams.css\") : _d;\n    var header = \"\\n<!-- This is a generated file -->\\n<!DOCTYPE html>\\n<meta charset=\\\"utf-8\\\">\\n<style>\\n  body {\\n    background-color: hsl(30, 20%, 95%)\\n  }\\n</style>\\n\\n\";\n    var cssHtml = \"\\n<link rel='stylesheet' href='\".concat(css, \"'>\\n\");\n    var scripts = \"\\n<script src='\".concat(resourceBase, \"vendor/railroad-diagrams.js'></script>\\n<script src='\").concat(resourceBase, \"src/diagrams_builder.js'></script>\\n<script src='\").concat(resourceBase, \"src/diagrams_behavior.js'></script>\\n<script src='\").concat(resourceBase, \"src/main.js'></script>\\n\");\n    var diagramsDiv = \"\\n<div id=\\\"diagrams\\\" align=\\\"center\\\"></div>    \\n\";\n    var serializedGrammar = \"\\n<script>\\n    window.serializedGrammar = \".concat(JSON.stringify(grammar, null, \"  \"), \";\\n</script>\\n\");\n    var initLogic = \"\\n<script>\\n    var diagramsDiv = document.getElementById(\\\"diagrams\\\");\\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\\n</script>\\n\";\n    return (header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic);\n}\nexports.createSyntaxDiagramsCode = createSyntaxDiagramsCode;\n//# sourceMappingURL=render_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL2RpYWdyYW1zL3JlbmRlcl9wdWJsaWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFZO0FBQ3BDO0FBQ0EsZ0NBQWdDO0FBQ2hDLG1IQUFtSCw4Q0FBOEM7QUFDaks7QUFDQTtBQUNBO0FBQ0Esd0hBQXdIO0FBQ3hILDZGQUE2Riw2RUFBNkU7QUFDMUs7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL2RpYWdyYW1zL3JlbmRlcl9wdWJsaWMuanM/ZTkyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlU3ludGF4RGlhZ3JhbXNDb2RlID0gdm9pZCAwO1xudmFyIHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuLi92ZXJzaW9uXCIpO1xuZnVuY3Rpb24gY3JlYXRlU3ludGF4RGlhZ3JhbXNDb2RlKGdyYW1tYXIsIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IucmVzb3VyY2VCYXNlLCByZXNvdXJjZUJhc2UgPSBfYyA9PT0gdm9pZCAwID8gXCJodHRwczovL3VucGtnLmNvbS9jaGV2cm90YWluQFwiLmNvbmNhdCh2ZXJzaW9uXzEuVkVSU0lPTiwgXCIvZGlhZ3JhbXMvXCIpIDogX2MsIF9kID0gX2IuY3NzLCBjc3MgPSBfZCA9PT0gdm9pZCAwID8gXCJodHRwczovL3VucGtnLmNvbS9jaGV2cm90YWluQFwiLmNvbmNhdCh2ZXJzaW9uXzEuVkVSU0lPTiwgXCIvZGlhZ3JhbXMvZGlhZ3JhbXMuY3NzXCIpIDogX2Q7XG4gICAgdmFyIGhlYWRlciA9IFwiXFxuPCEtLSBUaGlzIGlzIGEgZ2VuZXJhdGVkIGZpbGUgLS0+XFxuPCFET0NUWVBFIGh0bWw+XFxuPG1ldGEgY2hhcnNldD1cXFwidXRmLThcXFwiPlxcbjxzdHlsZT5cXG4gIGJvZHkge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2woMzAsIDIwJSwgOTUlKVxcbiAgfVxcbjwvc3R5bGU+XFxuXFxuXCI7XG4gICAgdmFyIGNzc0h0bWwgPSBcIlxcbjxsaW5rIHJlbD0nc3R5bGVzaGVldCcgaHJlZj0nXCIuY29uY2F0KGNzcywgXCInPlxcblwiKTtcbiAgICB2YXIgc2NyaXB0cyA9IFwiXFxuPHNjcmlwdCBzcmM9J1wiLmNvbmNhdChyZXNvdXJjZUJhc2UsIFwidmVuZG9yL3JhaWxyb2FkLWRpYWdyYW1zLmpzJz48L3NjcmlwdD5cXG48c2NyaXB0IHNyYz0nXCIpLmNvbmNhdChyZXNvdXJjZUJhc2UsIFwic3JjL2RpYWdyYW1zX2J1aWxkZXIuanMnPjwvc2NyaXB0PlxcbjxzY3JpcHQgc3JjPSdcIikuY29uY2F0KHJlc291cmNlQmFzZSwgXCJzcmMvZGlhZ3JhbXNfYmVoYXZpb3IuanMnPjwvc2NyaXB0PlxcbjxzY3JpcHQgc3JjPSdcIikuY29uY2F0KHJlc291cmNlQmFzZSwgXCJzcmMvbWFpbi5qcyc+PC9zY3JpcHQ+XFxuXCIpO1xuICAgIHZhciBkaWFncmFtc0RpdiA9IFwiXFxuPGRpdiBpZD1cXFwiZGlhZ3JhbXNcXFwiIGFsaWduPVxcXCJjZW50ZXJcXFwiPjwvZGl2PiAgICBcXG5cIjtcbiAgICB2YXIgc2VyaWFsaXplZEdyYW1tYXIgPSBcIlxcbjxzY3JpcHQ+XFxuICAgIHdpbmRvdy5zZXJpYWxpemVkR3JhbW1hciA9IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShncmFtbWFyLCBudWxsLCBcIiAgXCIpLCBcIjtcXG48L3NjcmlwdD5cXG5cIik7XG4gICAgdmFyIGluaXRMb2dpYyA9IFwiXFxuPHNjcmlwdD5cXG4gICAgdmFyIGRpYWdyYW1zRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXFxcImRpYWdyYW1zXFxcIik7XFxuICAgIG1haW4uZHJhd0RpYWdyYW1zRnJvbVNlcmlhbGl6ZWRHcmFtbWFyKHNlcmlhbGl6ZWRHcmFtbWFyLCBkaWFncmFtc0Rpdik7XFxuPC9zY3JpcHQ+XFxuXCI7XG4gICAgcmV0dXJuIChoZWFkZXIgKyBjc3NIdG1sICsgc2NyaXB0cyArIGRpYWdyYW1zRGl2ICsgc2VyaWFsaXplZEdyYW1tYXIgKyBpbml0TG9naWMpO1xufVxuZXhwb3J0cy5jcmVhdGVTeW50YXhEaWFncmFtc0NvZGUgPSBjcmVhdGVTeW50YXhEaWFncmFtc0NvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW5kZXJfcHVibGljLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/diagrams/render_public.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/lang/lang_extensions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/lang/lang_extensions.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defineNameProp = void 0;\nvar NAME = \"name\";\nfunction defineNameProp(obj, nameValue) {\n    Object.defineProperty(obj, NAME, {\n        enumerable: false,\n        configurable: true,\n        writable: false,\n        value: nameValue\n    });\n}\nexports.defineNameProp = defineNameProp;\n//# sourceMappingURL=lang_extensions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL2xhbmcvbGFuZ19leHRlbnNpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL2xhbmcvbGFuZ19leHRlbnNpb25zLmpzP2Y1NzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmluZU5hbWVQcm9wID0gdm9pZCAwO1xudmFyIE5BTUUgPSBcIm5hbWVcIjtcbmZ1bmN0aW9uIGRlZmluZU5hbWVQcm9wKG9iaiwgbmFtZVZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgTkFNRSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBuYW1lVmFsdWVcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmaW5lTmFtZVByb3AgPSBkZWZpbmVOYW1lUHJvcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmdfZXh0ZW5zaW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/lang/lang_extensions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/constants.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IN = void 0;\n// TODO: can this be removed? where is it used?\nexports.IN = \"_~IN~_\";\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9jb25zdGFudHMuanM/OGI5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSU4gPSB2b2lkIDA7XG4vLyBUT0RPOiBjYW4gdGhpcyBiZSByZW1vdmVkPyB3aGVyZSBpcyBpdCB1c2VkP1xuZXhwb3J0cy5JTiA9IFwiX35JTn5fXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/cst/cst.js":
/*!**********************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/cst/cst.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addNoneTerminalToCst = exports.addTerminalToCst = exports.setNodeLocationFull = exports.setNodeLocationOnlyOffset = void 0;\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nfunction setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (both start/end offsets exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n}\nexports.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nfunction setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (all start/end props exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n}\nexports.setNodeLocationFull = setNodeLocationFull;\nfunction addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n        node.children[tokenTypeName] = [token];\n    }\n    else {\n        node.children[tokenTypeName].push(token);\n    }\n}\nexports.addTerminalToCst = addTerminalToCst;\nfunction addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n        node.children[ruleName] = [ruleResult];\n    }\n    else {\n        node.children[ruleName].push(ruleResult);\n    }\n}\nexports.addNoneTerminalToCst = addNoneTerminalToCst;\n//# sourceMappingURL=cst.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2NzdC9jc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsd0JBQXdCLEdBQUcsMkJBQTJCLEdBQUcsaUNBQWlDO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvY3N0L2NzdC5qcz83ZGZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGROb25lVGVybWluYWxUb0NzdCA9IGV4cG9ydHMuYWRkVGVybWluYWxUb0NzdCA9IGV4cG9ydHMuc2V0Tm9kZUxvY2F0aW9uRnVsbCA9IGV4cG9ydHMuc2V0Tm9kZUxvY2F0aW9uT25seU9mZnNldCA9IHZvaWQgMDtcbi8qKlxuICogVGhpcyBub2RlTG9jYXRpb24gdHJhY2tpbmcgaXMgbm90IGVmZmljaWVudCBhbmQgc2hvdWxkIG9ubHkgYmUgdXNlZFxuICogd2hlbiBlcnJvciByZWNvdmVyeSBpcyBlbmFibGVkIG9yIHRoZSBUb2tlbiBWZWN0b3IgY29udGFpbnMgdmlydHVhbCBUb2tlbnNcbiAqIChlLmcsIFB5dGhvbiBJbmRlbnQvT3V0ZGVudClcbiAqIEFzIGl0IGV4ZWN1dGVzIHRoZSBjYWxjdWxhdGlvbiBmb3IgZXZlcnkgc2luZ2xlIHRlcm1pbmFsL25vblRlcm1pbmFsXG4gKiBhbmQgZG9lcyBub3QgcmVseSBvbiB0aGUgZmFjdCB0aGUgdG9rZW4gdmVjdG9yIGlzICoqc29ydGVkKipcbiAqL1xuZnVuY3Rpb24gc2V0Tm9kZUxvY2F0aW9uT25seU9mZnNldChjdXJyTm9kZUxvY2F0aW9uLCBuZXdMb2NhdGlvbkluZm8pIHtcbiAgICAvLyBGaXJzdCAodmFsaWQpIHVwZGF0ZSBmb3IgdGhpcyBjc3Qgbm9kZVxuICAgIGlmIChpc05hTihjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0T2Zmc2V0KSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBhc3N1bXB0aW9uMTogVG9rZW4gbG9jYXRpb24gaW5mb3JtYXRpb24gaXMgZWl0aGVyIE5hTiBvciBhIHZhbGlkIG51bWJlclxuICAgICAgICAvLyBhc3N1bXB0aW9uMjogVG9rZW4gbG9jYXRpb24gaW5mb3JtYXRpb24gaXMgZnVsbHkgdmFsaWQgaWYgaXQgZXhpc3RcbiAgICAgICAgLy8gKGJvdGggc3RhcnQvZW5kIG9mZnNldHMgZXhpc3QgYW5kIGFyZSBudW1iZXJzKS5cbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5zdGFydE9mZnNldCA9IG5ld0xvY2F0aW9uSW5mby5zdGFydE9mZnNldDtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRPZmZzZXQgPSBuZXdMb2NhdGlvbkluZm8uZW5kT2Zmc2V0O1xuICAgIH1cbiAgICAvLyBPbmNlIHRoZSBzdGFydE9mZnNldCBoYXMgYmVlbiB1cGRhdGVkIHdpdGggYSB2YWxpZCBudW1iZXIgaXQgc2hvdWxkIG5ldmVyIHJlY2VpdmVcbiAgICAvLyBhbnkgZmFydGhlciB1cGRhdGVzIGFzIHRoZSBUb2tlbiB2ZWN0b3IgaXMgc29ydGVkLlxuICAgIC8vIFdlIHN0aWxsIGhhdmUgdG8gY2hlY2sgdGhpcyB0aGlzIGNvbmRpdGlvbiBmb3IgZXZlcnkgbmV3IHBvc3NpYmxlIGxvY2F0aW9uIGluZm9cbiAgICAvLyBiZWNhdXNlIHdpdGggZXJyb3IgcmVjb3ZlcnkgZW5hYmxlZCB3ZSBtYXkgZW5jb3VudGVyIGludmFsaWQgdG9rZW5zIChOYU4gbG9jYXRpb24gcHJvcHMpXG4gICAgZWxzZSBpZiAoY3Vyck5vZGVMb2NhdGlvbi5lbmRPZmZzZXQgPCBuZXdMb2NhdGlvbkluZm8uZW5kT2Zmc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kT2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLmVuZE9mZnNldDtcbiAgICB9XG59XG5leHBvcnRzLnNldE5vZGVMb2NhdGlvbk9ubHlPZmZzZXQgPSBzZXROb2RlTG9jYXRpb25Pbmx5T2Zmc2V0O1xuLyoqXG4gKiBUaGlzIG5vZGVMb2NhdGlvbiB0cmFja2luZyBpcyBub3QgZWZmaWNpZW50IGFuZCBzaG91bGQgb25seSBiZSB1c2VkXG4gKiB3aGVuIGVycm9yIHJlY292ZXJ5IGlzIGVuYWJsZWQgb3IgdGhlIFRva2VuIFZlY3RvciBjb250YWlucyB2aXJ0dWFsIFRva2Vuc1xuICogKGUuZywgUHl0aG9uIEluZGVudC9PdXRkZW50KVxuICogQXMgaXQgZXhlY3V0ZXMgdGhlIGNhbGN1bGF0aW9uIGZvciBldmVyeSBzaW5nbGUgdGVybWluYWwvbm9uVGVybWluYWxcbiAqIGFuZCBkb2VzIG5vdCByZWx5IG9uIHRoZSBmYWN0IHRoZSB0b2tlbiB2ZWN0b3IgaXMgKipzb3J0ZWQqKlxuICovXG5mdW5jdGlvbiBzZXROb2RlTG9jYXRpb25GdWxsKGN1cnJOb2RlTG9jYXRpb24sIG5ld0xvY2F0aW9uSW5mbykge1xuICAgIC8vIEZpcnN0ICh2YWxpZCkgdXBkYXRlIGZvciB0aGlzIGNzdCBub2RlXG4gICAgaWYgKGlzTmFOKGN1cnJOb2RlTG9jYXRpb24uc3RhcnRPZmZzZXQpID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGFzc3VtcHRpb24xOiBUb2tlbiBsb2NhdGlvbiBpbmZvcm1hdGlvbiBpcyBlaXRoZXIgTmFOIG9yIGEgdmFsaWQgbnVtYmVyXG4gICAgICAgIC8vIGFzc3VtcHRpb24yOiBUb2tlbiBsb2NhdGlvbiBpbmZvcm1hdGlvbiBpcyBmdWxseSB2YWxpZCBpZiBpdCBleGlzdFxuICAgICAgICAvLyAoYWxsIHN0YXJ0L2VuZCBwcm9wcyBleGlzdCBhbmQgYXJlIG51bWJlcnMpLlxuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0T2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0Q29sdW1uID0gbmV3TG9jYXRpb25JbmZvLnN0YXJ0Q29sdW1uO1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0TGluZSA9IG5ld0xvY2F0aW9uSW5mby5zdGFydExpbmU7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kT2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLmVuZE9mZnNldDtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRDb2x1bW4gPSBuZXdMb2NhdGlvbkluZm8uZW5kQ29sdW1uO1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZExpbmUgPSBuZXdMb2NhdGlvbkluZm8uZW5kTGluZTtcbiAgICB9XG4gICAgLy8gT25jZSB0aGUgc3RhcnQgcHJvcHMgaGFzIGJlZW4gdXBkYXRlZCB3aXRoIGEgdmFsaWQgbnVtYmVyIGl0IHNob3VsZCBuZXZlciByZWNlaXZlXG4gICAgLy8gYW55IGZhcnRoZXIgdXBkYXRlcyBhcyB0aGUgVG9rZW4gdmVjdG9yIGlzIHNvcnRlZC5cbiAgICAvLyBXZSBzdGlsbCBoYXZlIHRvIGNoZWNrIHRoaXMgdGhpcyBjb25kaXRpb24gZm9yIGV2ZXJ5IG5ldyBwb3NzaWJsZSBsb2NhdGlvbiBpbmZvXG4gICAgLy8gYmVjYXVzZSB3aXRoIGVycm9yIHJlY292ZXJ5IGVuYWJsZWQgd2UgbWF5IGVuY291bnRlciBpbnZhbGlkIHRva2VucyAoTmFOIGxvY2F0aW9uIHByb3BzKVxuICAgIGVsc2UgaWYgKGN1cnJOb2RlTG9jYXRpb24uZW5kT2Zmc2V0IDwgbmV3TG9jYXRpb25JbmZvLmVuZE9mZnNldCA9PT0gdHJ1ZSkge1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZE9mZnNldCA9IG5ld0xvY2F0aW9uSW5mby5lbmRPZmZzZXQ7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kQ29sdW1uID0gbmV3TG9jYXRpb25JbmZvLmVuZENvbHVtbjtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRMaW5lID0gbmV3TG9jYXRpb25JbmZvLmVuZExpbmU7XG4gICAgfVxufVxuZXhwb3J0cy5zZXROb2RlTG9jYXRpb25GdWxsID0gc2V0Tm9kZUxvY2F0aW9uRnVsbDtcbmZ1bmN0aW9uIGFkZFRlcm1pbmFsVG9Dc3Qobm9kZSwgdG9rZW4sIHRva2VuVHlwZU5hbWUpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlblt0b2tlblR5cGVOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW5bdG9rZW5UeXBlTmFtZV0gPSBbdG9rZW5dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlblt0b2tlblR5cGVOYW1lXS5wdXNoKHRva2VuKTtcbiAgICB9XG59XG5leHBvcnRzLmFkZFRlcm1pbmFsVG9Dc3QgPSBhZGRUZXJtaW5hbFRvQ3N0O1xuZnVuY3Rpb24gYWRkTm9uZVRlcm1pbmFsVG9Dc3Qobm9kZSwgcnVsZU5hbWUsIHJ1bGVSZXN1bHQpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlbltydWxlTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmNoaWxkcmVuW3J1bGVOYW1lXSA9IFtydWxlUmVzdWx0XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW5bcnVsZU5hbWVdLnB1c2gocnVsZVJlc3VsdCk7XG4gICAgfVxufVxuZXhwb3J0cy5hZGROb25lVGVybWluYWxUb0NzdCA9IGFkZE5vbmVUZXJtaW5hbFRvQ3N0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3N0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/cst/cst.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js":
/*!******************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateMissingCstMethods = exports.validateVisitor = exports.CstVisitorDefinitionError = exports.createBaseVisitorConstructorWithDefaults = exports.createBaseSemanticVisitorConstructor = exports.defaultVisit = void 0;\nvar isEmpty_1 = __importDefault(__webpack_require__(/*! lodash/isEmpty */ \"(ssr)/./node_modules/lodash/isEmpty.js\"));\nvar compact_1 = __importDefault(__webpack_require__(/*! lodash/compact */ \"(ssr)/./node_modules/lodash/compact.js\"));\nvar isArray_1 = __importDefault(__webpack_require__(/*! lodash/isArray */ \"(ssr)/./node_modules/lodash/isArray.js\"));\nvar map_1 = __importDefault(__webpack_require__(/*! lodash/map */ \"(ssr)/./node_modules/lodash/map.js\"));\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar filter_1 = __importDefault(__webpack_require__(/*! lodash/filter */ \"(ssr)/./node_modules/lodash/filter.js\"));\nvar keys_1 = __importDefault(__webpack_require__(/*! lodash/keys */ \"(ssr)/./node_modules/lodash/keys.js\"));\nvar isFunction_1 = __importDefault(__webpack_require__(/*! lodash/isFunction */ \"(ssr)/./node_modules/lodash/isFunction.js\"));\nvar isUndefined_1 = __importDefault(__webpack_require__(/*! lodash/isUndefined */ \"(ssr)/./node_modules/lodash/isUndefined.js\"));\nvar lang_extensions_1 = __webpack_require__(/*! ../../lang/lang_extensions */ \"(ssr)/./node_modules/chevrotain/lib/src/lang/lang_extensions.js\");\nfunction defaultVisit(ctx, param) {\n    var childrenNames = (0, keys_1.default)(ctx);\n    var childrenNamesLength = childrenNames.length;\n    for (var i = 0; i < childrenNamesLength; i++) {\n        var currChildName = childrenNames[i];\n        var currChildArray = ctx[currChildName];\n        var currChildArrayLength = currChildArray.length;\n        for (var j = 0; j < currChildArrayLength; j++) {\n            var currChild = currChildArray[j];\n            // distinction between Tokens Children and CstNode children\n            if (currChild.tokenTypeIdx === undefined) {\n                this[currChild.name](currChild.children, param);\n            }\n        }\n    }\n    // defaultVisit does not support generic out param\n}\nexports.defaultVisit = defaultVisit;\nfunction createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    var derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + \"BaseSemantics\");\n    var semanticProto = {\n        visit: function (cstNode, param) {\n            // enables writing more concise visitor methods when CstNode has only a single child\n            if ((0, isArray_1.default)(cstNode)) {\n                // A CST Node's children dictionary can never have empty arrays as values\n                // If a key is defined there will be at least one element in the corresponding value array.\n                cstNode = cstNode[0];\n            }\n            // enables passing optional CstNodes concisely.\n            if ((0, isUndefined_1.default)(cstNode)) {\n                return undefined;\n            }\n            return this[cstNode.name](cstNode.children, param);\n        },\n        validateVisitor: function () {\n            var semanticDefinitionErrors = validateVisitor(this, ruleNames);\n            if (!(0, isEmpty_1.default)(semanticDefinitionErrors)) {\n                var errorMessages = (0, map_1.default)(semanticDefinitionErrors, function (currDefError) { return currDefError.msg; });\n                throw Error(\"Errors Detected in CST Visitor <\".concat(this.constructor.name, \">:\\n\\t\") +\n                    \"\".concat(errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")));\n            }\n        }\n    };\n    derivedConstructor.prototype = semanticProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    derivedConstructor._RULE_NAMES = ruleNames;\n    return derivedConstructor;\n}\nexports.createBaseSemanticVisitorConstructor = createBaseSemanticVisitorConstructor;\nfunction createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    var derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n    var withDefaultsProto = Object.create(baseConstructor.prototype);\n    (0, forEach_1.default)(ruleNames, function (ruleName) {\n        withDefaultsProto[ruleName] = defaultVisit;\n    });\n    derivedConstructor.prototype = withDefaultsProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    return derivedConstructor;\n}\nexports.createBaseVisitorConstructorWithDefaults = createBaseVisitorConstructorWithDefaults;\nvar CstVisitorDefinitionError;\n(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError = exports.CstVisitorDefinitionError || (exports.CstVisitorDefinitionError = {}));\nfunction validateVisitor(visitorInstance, ruleNames) {\n    var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n    return missingErrors;\n}\nexports.validateVisitor = validateVisitor;\nfunction validateMissingCstMethods(visitorInstance, ruleNames) {\n    var missingRuleNames = (0, filter_1.default)(ruleNames, function (currRuleName) {\n        return (0, isFunction_1.default)(visitorInstance[currRuleName]) === false;\n    });\n    var errors = (0, map_1.default)(missingRuleNames, function (currRuleName) {\n        return {\n            msg: \"Missing visitor method: <\".concat(currRuleName, \"> on \").concat((visitorInstance.constructor.name), \" CST Visitor.\"),\n            type: CstVisitorDefinitionError.MISSING_METHOD,\n            methodName: currRuleName\n        };\n    });\n    return (0, compact_1.default)(errors);\n}\nexports.validateMissingCstMethods = validateMissingCstMethods;\n//# sourceMappingURL=cst_visitor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2NzdC9jc3RfdmlzaXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxHQUFHLHVCQUF1QixHQUFHLGlDQUFpQyxHQUFHLGdEQUFnRCxHQUFHLDRDQUE0QyxHQUFHLG9CQUFvQjtBQUN4TixnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCw0QkFBNEIsbUJBQU8sQ0FBQyxzREFBWTtBQUNoRCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsK0JBQStCLG1CQUFPLENBQUMsNERBQWU7QUFDdEQsNkJBQTZCLG1CQUFPLENBQUMsd0RBQWE7QUFDbEQsbUNBQW1DLG1CQUFPLENBQUMsb0VBQW1CO0FBQzlELG9DQUFvQyxtQkFBTyxDQUFDLHNFQUFvQjtBQUNoRSx3QkFBd0IsbUJBQU8sQ0FBQyxtR0FBNEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsMEJBQTBCO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0VBQW9FLGlDQUFpQyxLQUFLO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2NzdC9jc3RfdmlzaXRvci5qcz9iZmQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZU1pc3NpbmdDc3RNZXRob2RzID0gZXhwb3J0cy52YWxpZGF0ZVZpc2l0b3IgPSBleHBvcnRzLkNzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3IgPSBleHBvcnRzLmNyZWF0ZUJhc2VWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHMgPSBleHBvcnRzLmNyZWF0ZUJhc2VTZW1hbnRpY1Zpc2l0b3JDb25zdHJ1Y3RvciA9IGV4cG9ydHMuZGVmYXVsdFZpc2l0ID0gdm9pZCAwO1xudmFyIGlzRW1wdHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRW1wdHlcIikpO1xudmFyIGNvbXBhY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2NvbXBhY3RcIikpO1xudmFyIGlzQXJyYXlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIikpO1xudmFyIG1hcF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvbWFwXCIpKTtcbnZhciBmb3JFYWNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9mb3JFYWNoXCIpKTtcbnZhciBmaWx0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZpbHRlclwiKSk7XG52YXIga2V5c18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gva2V5c1wiKSk7XG52YXIgaXNGdW5jdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgaXNVbmRlZmluZWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzVW5kZWZpbmVkXCIpKTtcbnZhciBsYW5nX2V4dGVuc2lvbnNfMSA9IHJlcXVpcmUoXCIuLi8uLi9sYW5nL2xhbmdfZXh0ZW5zaW9uc1wiKTtcbmZ1bmN0aW9uIGRlZmF1bHRWaXNpdChjdHgsIHBhcmFtKSB7XG4gICAgdmFyIGNoaWxkcmVuTmFtZXMgPSAoMCwga2V5c18xLmRlZmF1bHQpKGN0eCk7XG4gICAgdmFyIGNoaWxkcmVuTmFtZXNMZW5ndGggPSBjaGlsZHJlbk5hbWVzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTmFtZXNMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VyckNoaWxkTmFtZSA9IGNoaWxkcmVuTmFtZXNbaV07XG4gICAgICAgIHZhciBjdXJyQ2hpbGRBcnJheSA9IGN0eFtjdXJyQ2hpbGROYW1lXTtcbiAgICAgICAgdmFyIGN1cnJDaGlsZEFycmF5TGVuZ3RoID0gY3VyckNoaWxkQXJyYXkubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGN1cnJDaGlsZEFycmF5TGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyQ2hpbGQgPSBjdXJyQ2hpbGRBcnJheVtqXTtcbiAgICAgICAgICAgIC8vIGRpc3RpbmN0aW9uIGJldHdlZW4gVG9rZW5zIENoaWxkcmVuIGFuZCBDc3ROb2RlIGNoaWxkcmVuXG4gICAgICAgICAgICBpZiAoY3VyckNoaWxkLnRva2VuVHlwZUlkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tjdXJyQ2hpbGQubmFtZV0oY3VyckNoaWxkLmNoaWxkcmVuLCBwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZGVmYXVsdFZpc2l0IGRvZXMgbm90IHN1cHBvcnQgZ2VuZXJpYyBvdXQgcGFyYW1cbn1cbmV4cG9ydHMuZGVmYXVsdFZpc2l0ID0gZGVmYXVsdFZpc2l0O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNlbWFudGljVmlzaXRvckNvbnN0cnVjdG9yKGdyYW1tYXJOYW1lLCBydWxlTmFtZXMpIHtcbiAgICB2YXIgZGVyaXZlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8vIGNhbiBiZSBvdmVyd3JpdHRlbiBhY2NvcmRpbmcgdG86XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vXG4gICAgLy8gbmFtZT9yZWRpcmVjdGxvY2FsZT1lbi1VUyZyZWRpcmVjdHNsdWc9SmF2YVNjcmlwdCUyRlJlZmVyZW5jZSUyRkdsb2JhbF9PYmplY3RzJTJGRnVuY3Rpb24lMkZuYW1lXG4gICAgKDAsIGxhbmdfZXh0ZW5zaW9uc18xLmRlZmluZU5hbWVQcm9wKShkZXJpdmVkQ29uc3RydWN0b3IsIGdyYW1tYXJOYW1lICsgXCJCYXNlU2VtYW50aWNzXCIpO1xuICAgIHZhciBzZW1hbnRpY1Byb3RvID0ge1xuICAgICAgICB2aXNpdDogZnVuY3Rpb24gKGNzdE5vZGUsIHBhcmFtKSB7XG4gICAgICAgICAgICAvLyBlbmFibGVzIHdyaXRpbmcgbW9yZSBjb25jaXNlIHZpc2l0b3IgbWV0aG9kcyB3aGVuIENzdE5vZGUgaGFzIG9ubHkgYSBzaW5nbGUgY2hpbGRcbiAgICAgICAgICAgIGlmICgoMCwgaXNBcnJheV8xLmRlZmF1bHQpKGNzdE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gQSBDU1QgTm9kZSdzIGNoaWxkcmVuIGRpY3Rpb25hcnkgY2FuIG5ldmVyIGhhdmUgZW1wdHkgYXJyYXlzIGFzIHZhbHVlc1xuICAgICAgICAgICAgICAgIC8vIElmIGEga2V5IGlzIGRlZmluZWQgdGhlcmUgd2lsbCBiZSBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBhcnJheS5cbiAgICAgICAgICAgICAgICBjc3ROb2RlID0gY3N0Tm9kZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVuYWJsZXMgcGFzc2luZyBvcHRpb25hbCBDc3ROb2RlcyBjb25jaXNlbHkuXG4gICAgICAgICAgICBpZiAoKDAsIGlzVW5kZWZpbmVkXzEuZGVmYXVsdCkoY3N0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbY3N0Tm9kZS5uYW1lXShjc3ROb2RlLmNoaWxkcmVuLCBwYXJhbSk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRlVmlzaXRvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbWFudGljRGVmaW5pdGlvbkVycm9ycyA9IHZhbGlkYXRlVmlzaXRvcih0aGlzLCBydWxlTmFtZXMpO1xuICAgICAgICAgICAgaWYgKCEoMCwgaXNFbXB0eV8xLmRlZmF1bHQpKHNlbWFudGljRGVmaW5pdGlvbkVycm9ycykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlcyA9ICgwLCBtYXBfMS5kZWZhdWx0KShzZW1hbnRpY0RlZmluaXRpb25FcnJvcnMsIGZ1bmN0aW9uIChjdXJyRGVmRXJyb3IpIHsgcmV0dXJuIGN1cnJEZWZFcnJvci5tc2c7IH0pO1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXJyb3JzIERldGVjdGVkIGluIENTVCBWaXNpdG9yIDxcIi5jb25jYXQodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBcIj46XFxuXFx0XCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJcIi5jb25jYXQoZXJyb3JNZXNzYWdlcy5qb2luKFwiXFxuXFxuXCIpLnJlcGxhY2UoL1xcbi9nLCBcIlxcblxcdFwiKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBkZXJpdmVkQ29uc3RydWN0b3IucHJvdG90eXBlID0gc2VtYW50aWNQcm90bztcbiAgICBkZXJpdmVkQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZGVyaXZlZENvbnN0cnVjdG9yO1xuICAgIGRlcml2ZWRDb25zdHJ1Y3Rvci5fUlVMRV9OQU1FUyA9IHJ1bGVOYW1lcztcbiAgICByZXR1cm4gZGVyaXZlZENvbnN0cnVjdG9yO1xufVxuZXhwb3J0cy5jcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3IgPSBjcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3I7XG5mdW5jdGlvbiBjcmVhdGVCYXNlVmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzKGdyYW1tYXJOYW1lLCBydWxlTmFtZXMsIGJhc2VDb25zdHJ1Y3Rvcikge1xuICAgIHZhciBkZXJpdmVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLy8gY2FuIGJlIG92ZXJ3cml0dGVuIGFjY29yZGluZyB0bzpcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9cbiAgICAvLyBuYW1lP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZGdW5jdGlvbiUyRm5hbWVcbiAgICAoMCwgbGFuZ19leHRlbnNpb25zXzEuZGVmaW5lTmFtZVByb3ApKGRlcml2ZWRDb25zdHJ1Y3RvciwgZ3JhbW1hck5hbWUgKyBcIkJhc2VTZW1hbnRpY3NXaXRoRGVmYXVsdHNcIik7XG4gICAgdmFyIHdpdGhEZWZhdWx0c1Byb3RvID0gT2JqZWN0LmNyZWF0ZShiYXNlQ29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKHJ1bGVOYW1lcywgZnVuY3Rpb24gKHJ1bGVOYW1lKSB7XG4gICAgICAgIHdpdGhEZWZhdWx0c1Byb3RvW3J1bGVOYW1lXSA9IGRlZmF1bHRWaXNpdDtcbiAgICB9KTtcbiAgICBkZXJpdmVkQ29uc3RydWN0b3IucHJvdG90eXBlID0gd2l0aERlZmF1bHRzUHJvdG87XG4gICAgZGVyaXZlZENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGRlcml2ZWRDb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gZGVyaXZlZENvbnN0cnVjdG9yO1xufVxuZXhwb3J0cy5jcmVhdGVCYXNlVmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzID0gY3JlYXRlQmFzZVZpc2l0b3JDb25zdHJ1Y3RvcldpdGhEZWZhdWx0cztcbnZhciBDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yO1xuKGZ1bmN0aW9uIChDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yKSB7XG4gICAgQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcltDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yW1wiUkVEVU5EQU5UX01FVEhPRFwiXSA9IDBdID0gXCJSRURVTkRBTlRfTUVUSE9EXCI7XG4gICAgQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcltDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yW1wiTUlTU0lOR19NRVRIT0RcIl0gPSAxXSA9IFwiTUlTU0lOR19NRVRIT0RcIjtcbn0pKENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3IgPSBleHBvcnRzLkNzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3IgfHwgKGV4cG9ydHMuQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvciA9IHt9KSk7XG5mdW5jdGlvbiB2YWxpZGF0ZVZpc2l0b3IodmlzaXRvckluc3RhbmNlLCBydWxlTmFtZXMpIHtcbiAgICB2YXIgbWlzc2luZ0Vycm9ycyA9IHZhbGlkYXRlTWlzc2luZ0NzdE1ldGhvZHModmlzaXRvckluc3RhbmNlLCBydWxlTmFtZXMpO1xuICAgIHJldHVybiBtaXNzaW5nRXJyb3JzO1xufVxuZXhwb3J0cy52YWxpZGF0ZVZpc2l0b3IgPSB2YWxpZGF0ZVZpc2l0b3I7XG5mdW5jdGlvbiB2YWxpZGF0ZU1pc3NpbmdDc3RNZXRob2RzKHZpc2l0b3JJbnN0YW5jZSwgcnVsZU5hbWVzKSB7XG4gICAgdmFyIG1pc3NpbmdSdWxlTmFtZXMgPSAoMCwgZmlsdGVyXzEuZGVmYXVsdCkocnVsZU5hbWVzLCBmdW5jdGlvbiAoY3VyclJ1bGVOYW1lKSB7XG4gICAgICAgIHJldHVybiAoMCwgaXNGdW5jdGlvbl8xLmRlZmF1bHQpKHZpc2l0b3JJbnN0YW5jZVtjdXJyUnVsZU5hbWVdKSA9PT0gZmFsc2U7XG4gICAgfSk7XG4gICAgdmFyIGVycm9ycyA9ICgwLCBtYXBfMS5kZWZhdWx0KShtaXNzaW5nUnVsZU5hbWVzLCBmdW5jdGlvbiAoY3VyclJ1bGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtc2c6IFwiTWlzc2luZyB2aXNpdG9yIG1ldGhvZDogPFwiLmNvbmNhdChjdXJyUnVsZU5hbWUsIFwiPiBvbiBcIikuY29uY2F0KCh2aXNpdG9ySW5zdGFuY2UuY29uc3RydWN0b3IubmFtZSksIFwiIENTVCBWaXNpdG9yLlwiKSxcbiAgICAgICAgICAgIHR5cGU6IENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3IuTUlTU0lOR19NRVRIT0QsXG4gICAgICAgICAgICBtZXRob2ROYW1lOiBjdXJyUnVsZU5hbWVcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gKDAsIGNvbXBhY3RfMS5kZWZhdWx0KShlcnJvcnMpO1xufVxuZXhwb3J0cy52YWxpZGF0ZU1pc3NpbmdDc3RNZXRob2RzID0gdmFsaWRhdGVNaXNzaW5nQ3N0TWV0aG9kcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzdF92aXNpdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/errors_public.js":
/*!****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/errors_public.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultGrammarValidatorErrorProvider = exports.defaultGrammarResolverErrorProvider = exports.defaultParserErrorProvider = void 0;\nvar tokens_public_1 = __webpack_require__(/*! ../scan/tokens_public */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/tokens_public.js\");\nvar first_1 = __importDefault(__webpack_require__(/*! lodash/first */ \"(ssr)/./node_modules/lodash/first.js\"));\nvar map_1 = __importDefault(__webpack_require__(/*! lodash/map */ \"(ssr)/./node_modules/lodash/map.js\"));\nvar reduce_1 = __importDefault(__webpack_require__(/*! lodash/reduce */ \"(ssr)/./node_modules/lodash/reduce.js\"));\nvar gast_1 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nvar gast_2 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nexports.defaultParserErrorProvider = {\n    buildMismatchTokenMessage: function (_a) {\n        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;\n        var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);\n        var expectedMsg = hasLabel\n            ? \"--> \".concat((0, tokens_public_1.tokenLabel)(expected), \" <--\")\n            : \"token of type --> \".concat(expected.name, \" <--\");\n        var msg = \"Expecting \".concat(expectedMsg, \" but found --> '\").concat(actual.image, \"' <--\");\n        return msg;\n    },\n    buildNotAllInputParsedMessage: function (_a) {\n        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;\n        return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n    },\n    buildNoViableAltMessage: function (_a) {\n        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\n        var errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        var actualText = (0, first_1.default)(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            var allLookAheadPaths = (0, reduce_1.default)(expectedPathsPerAlt, function (result, currAltPaths) { return result.concat(currAltPaths); }, []);\n            var nextValidTokenSequences = (0, map_1.default)(allLookAheadPaths, function (currPath) {\n                return \"[\".concat((0, map_1.default)(currPath, function (currTokenType) { return (0, tokens_public_1.tokenLabel)(currTokenType); }).join(\", \"), \"]\");\n            });\n            var nextValidSequenceItems = (0, map_1.default)(nextValidTokenSequences, function (itemMsg, idx) { return \"  \".concat(idx + 1, \". \").concat(itemMsg); });\n            var calculatedDescription = \"one of these possible Token sequences:\\n\".concat(nextValidSequenceItems.join(\"\\n\"));\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n    buildEarlyExitMessage: function (_a) {\n        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\n        var errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        var actualText = (0, first_1.default)(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            var nextValidTokenSequences = (0, map_1.default)(expectedIterationPaths, function (currPath) {\n                return \"[\".concat((0, map_1.default)(currPath, function (currTokenType) { return (0, tokens_public_1.tokenLabel)(currTokenType); }).join(\",\"), \"]\");\n            });\n            var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" +\n                \"<\".concat(nextValidTokenSequences.join(\" ,\"), \">\");\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    }\n};\nObject.freeze(exports.defaultParserErrorProvider);\nexports.defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError: function (topLevelRule, undefinedRule) {\n        var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" +\n            undefinedRule.nonTerminalName +\n            \"<-\\n\" +\n            \"inside top level rule: ->\" +\n            topLevelRule.name +\n            \"<-\";\n        return msg;\n    }\n};\nexports.defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError: function (topLevelRule, duplicateProds) {\n        function getExtraProductionArgument(prod) {\n            if (prod instanceof gast_1.Terminal) {\n                return prod.terminalType.name;\n            }\n            else if (prod instanceof gast_1.NonTerminal) {\n                return prod.nonTerminalName;\n            }\n            else {\n                return \"\";\n            }\n        }\n        var topLevelName = topLevelRule.name;\n        var duplicateProd = (0, first_1.default)(duplicateProds);\n        var index = duplicateProd.idx;\n        var dslName = (0, gast_2.getProductionDslName)(duplicateProd);\n        var extraArgument = getExtraProductionArgument(duplicateProd);\n        var hasExplicitIndex = index > 0;\n        var msg = \"->\".concat(dslName).concat(hasExplicitIndex ? index : \"\", \"<- \").concat(extraArgument ? \"with argument: ->\".concat(extraArgument, \"<-\") : \"\", \"\\n                  appears more than once (\").concat(duplicateProds.length, \" times) in the top level rule: ->\").concat(topLevelName, \"<-.                  \\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \");\n        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n    },\n    buildNamespaceConflictError: function (rule) {\n        var errMsg = \"Namespace conflict found in grammar.\\n\" +\n            \"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\".concat(rule.name, \">.\\n\") +\n            \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" +\n            \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" +\n            \"and Non-Terminal names start with a lower case letter.\";\n        return errMsg;\n    },\n    buildAlternationPrefixAmbiguityError: function (options) {\n        var pathMsg = (0, map_1.default)(options.prefixPath, function (currTok) {\n            return (0, tokens_public_1.tokenLabel)(currTok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var errMsg = \"Ambiguous alternatives: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> due to common lookahead prefix\\n\") +\n            \"in <OR\".concat(occurrence, \"> inside <\").concat(options.topLevelRule.name, \"> Rule,\\n\") +\n            \"<\".concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\n\") +\n            \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" +\n            \"For Further details.\";\n        return errMsg;\n    },\n    buildAlternationAmbiguityError: function (options) {\n        var pathMsg = (0, map_1.default)(options.prefixPath, function (currtok) {\n            return (0, tokens_public_1.tokenLabel)(currtok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var currMessage = \"Ambiguous Alternatives Detected: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> in <OR\").concat(occurrence, \">\") +\n            \" inside <\".concat(options.topLevelRule.name, \"> Rule,\\n\") +\n            \"<\".concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\n\");\n        currMessage =\n            currMessage +\n                \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" +\n                \"For Further details.\";\n        return currMessage;\n    },\n    buildEmptyRepetitionError: function (options) {\n        var dslName = (0, gast_2.getProductionDslName)(options.repetition);\n        if (options.repetition.idx !== 0) {\n            dslName += options.repetition.idx;\n        }\n        var errMsg = \"The repetition <\".concat(dslName, \"> within Rule <\").concat(options.topLevelRule.name, \"> can never consume any tokens.\\n\") +\n            \"This could lead to an infinite loop.\";\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError: function (options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildEmptyAlternationError: function (options) {\n        var errMsg = \"Ambiguous empty alternative: <\".concat(options.emptyChoiceIdx + 1, \">\") +\n            \" in <OR\".concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\n\") +\n            \"Only the last alternative may be an empty alternative.\";\n        return errMsg;\n    },\n    buildTooManyAlternativesError: function (options) {\n        var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" +\n            \"<OR\".concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\n has \").concat(options.alternation.definition.length + 1, \" alternatives.\");\n        return errMsg;\n    },\n    buildLeftRecursionError: function (options) {\n        var ruleName = options.topLevelRule.name;\n        var pathNames = (0, map_1.default)(options.leftRecursionPath, function (currRule) { return currRule.name; });\n        var leftRecursivePath = \"\".concat(ruleName, \" --> \").concat(pathNames\n            .concat([ruleName])\n            .join(\" --> \"));\n        var errMsg = \"Left Recursion found in grammar.\\n\" +\n            \"rule: <\".concat(ruleName, \"> can be invoked from itself (directly or indirectly)\\n\") +\n            \"without consuming any Tokens. The grammar path that causes this is: \\n \".concat(leftRecursivePath, \"\\n\") +\n            \" To fix this refactor your grammar to remove the left recursion.\\n\" +\n            \"see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.\";\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError: function (options) {\n        /* istanbul ignore next */\n        return \"deprecated\";\n    },\n    buildDuplicateRuleNameError: function (options) {\n        var ruleName;\n        if (options.topLevelRule instanceof gast_1.Rule) {\n            ruleName = options.topLevelRule.name;\n        }\n        else {\n            ruleName = options.topLevelRule;\n        }\n        var errMsg = \"Duplicate definition, rule: ->\".concat(ruleName, \"<- is already defined in the grammar: ->\").concat(options.grammarName, \"<-\");\n        return errMsg;\n    }\n};\n//# sourceMappingURL=errors_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2Vycm9yc19wdWJsaWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0Q0FBNEMsR0FBRywyQ0FBMkMsR0FBRyxrQ0FBa0M7QUFDL0gsc0JBQXNCLG1CQUFPLENBQUMsNEZBQXVCO0FBQ3JELDhCQUE4QixtQkFBTyxDQUFDLDBEQUFjO0FBQ3BELDRCQUE0QixtQkFBTyxDQUFDLHNEQUFZO0FBQ2hELCtCQUErQixtQkFBTyxDQUFDLDREQUFlO0FBQ3RELGFBQWEsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLDhFQUFrQjtBQUN2QyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUgscUNBQXFDO0FBQ3RKO0FBQ0EsMEZBQTBGLHdEQUF3RDtBQUNsSixhQUFhO0FBQ2IsK0dBQStHLG9EQUFvRDtBQUNuSztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRix3REFBd0Q7QUFDbEosYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRGQUE0Rix1QkFBdUI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9lcnJvcnNfcHVibGljLmpzPzU5ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlciA9IGV4cG9ydHMuZGVmYXVsdEdyYW1tYXJSZXNvbHZlckVycm9yUHJvdmlkZXIgPSBleHBvcnRzLmRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyID0gdm9pZCAwO1xudmFyIHRva2Vuc19wdWJsaWNfMSA9IHJlcXVpcmUoXCIuLi9zY2FuL3Rva2Vuc19wdWJsaWNcIik7XG52YXIgZmlyc3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZpcnN0XCIpKTtcbnZhciBtYXBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL21hcFwiKSk7XG52YXIgcmVkdWNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9yZWR1Y2VcIikpO1xudmFyIGdhc3RfMSA9IHJlcXVpcmUoXCJAY2hldnJvdGFpbi9nYXN0XCIpO1xudmFyIGdhc3RfMiA9IHJlcXVpcmUoXCJAY2hldnJvdGFpbi9nYXN0XCIpO1xuZXhwb3J0cy5kZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlciA9IHtcbiAgICBidWlsZE1pc21hdGNoVG9rZW5NZXNzYWdlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkID0gX2EuZXhwZWN0ZWQsIGFjdHVhbCA9IF9hLmFjdHVhbCwgcHJldmlvdXMgPSBfYS5wcmV2aW91cywgcnVsZU5hbWUgPSBfYS5ydWxlTmFtZTtcbiAgICAgICAgdmFyIGhhc0xhYmVsID0gKDAsIHRva2Vuc19wdWJsaWNfMS5oYXNUb2tlbkxhYmVsKShleHBlY3RlZCk7XG4gICAgICAgIHZhciBleHBlY3RlZE1zZyA9IGhhc0xhYmVsXG4gICAgICAgICAgICA/IFwiLS0+IFwiLmNvbmNhdCgoMCwgdG9rZW5zX3B1YmxpY18xLnRva2VuTGFiZWwpKGV4cGVjdGVkKSwgXCIgPC0tXCIpXG4gICAgICAgICAgICA6IFwidG9rZW4gb2YgdHlwZSAtLT4gXCIuY29uY2F0KGV4cGVjdGVkLm5hbWUsIFwiIDwtLVwiKTtcbiAgICAgICAgdmFyIG1zZyA9IFwiRXhwZWN0aW5nIFwiLmNvbmNhdChleHBlY3RlZE1zZywgXCIgYnV0IGZvdW5kIC0tPiAnXCIpLmNvbmNhdChhY3R1YWwuaW1hZ2UsIFwiJyA8LS1cIik7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfSxcbiAgICBidWlsZE5vdEFsbElucHV0UGFyc2VkTWVzc2FnZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBmaXJzdFJlZHVuZGFudCA9IF9hLmZpcnN0UmVkdW5kYW50LCBydWxlTmFtZSA9IF9hLnJ1bGVOYW1lO1xuICAgICAgICByZXR1cm4gXCJSZWR1bmRhbnQgaW5wdXQsIGV4cGVjdGluZyBFT0YgYnV0IGZvdW5kOiBcIiArIGZpcnN0UmVkdW5kYW50LmltYWdlO1xuICAgIH0sXG4gICAgYnVpbGROb1ZpYWJsZUFsdE1lc3NhZ2U6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRQYXRoc1BlckFsdCA9IF9hLmV4cGVjdGVkUGF0aHNQZXJBbHQsIGFjdHVhbCA9IF9hLmFjdHVhbCwgcHJldmlvdXMgPSBfYS5wcmV2aW91cywgY3VzdG9tVXNlckRlc2NyaXB0aW9uID0gX2EuY3VzdG9tVXNlckRlc2NyaXB0aW9uLCBydWxlTmFtZSA9IF9hLnJ1bGVOYW1lO1xuICAgICAgICB2YXIgZXJyUHJlZml4ID0gXCJFeHBlY3Rpbmc6IFwiO1xuICAgICAgICAvLyBUT0RPOiBpc3N1ZTogTm8gVmlhYmxlIEFsdGVybmF0aXZlIEVycm9yIG1heSBoYXZlIGluY29tcGxldGUgZGV0YWlscy4gIzUwMlxuICAgICAgICB2YXIgYWN0dWFsVGV4dCA9ICgwLCBmaXJzdF8xLmRlZmF1bHQpKGFjdHVhbCkuaW1hZ2U7XG4gICAgICAgIHZhciBlcnJTdWZmaXggPSBcIlxcbmJ1dCBmb3VuZDogJ1wiICsgYWN0dWFsVGV4dCArIFwiJ1wiO1xuICAgICAgICBpZiAoY3VzdG9tVXNlckRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyUHJlZml4ICsgY3VzdG9tVXNlckRlc2NyaXB0aW9uICsgZXJyU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFsbExvb2tBaGVhZFBhdGhzID0gKDAsIHJlZHVjZV8xLmRlZmF1bHQpKGV4cGVjdGVkUGF0aHNQZXJBbHQsIGZ1bmN0aW9uIChyZXN1bHQsIGN1cnJBbHRQYXRocykgeyByZXR1cm4gcmVzdWx0LmNvbmNhdChjdXJyQWx0UGF0aHMpOyB9LCBbXSk7XG4gICAgICAgICAgICB2YXIgbmV4dFZhbGlkVG9rZW5TZXF1ZW5jZXMgPSAoMCwgbWFwXzEuZGVmYXVsdCkoYWxsTG9va0FoZWFkUGF0aHMsIGZ1bmN0aW9uIChjdXJyUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltcIi5jb25jYXQoKDAsIG1hcF8xLmRlZmF1bHQpKGN1cnJQYXRoLCBmdW5jdGlvbiAoY3VyclRva2VuVHlwZSkgeyByZXR1cm4gKDAsIHRva2Vuc19wdWJsaWNfMS50b2tlbkxhYmVsKShjdXJyVG9rZW5UeXBlKTsgfSkuam9pbihcIiwgXCIpLCBcIl1cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBuZXh0VmFsaWRTZXF1ZW5jZUl0ZW1zID0gKDAsIG1hcF8xLmRlZmF1bHQpKG5leHRWYWxpZFRva2VuU2VxdWVuY2VzLCBmdW5jdGlvbiAoaXRlbU1zZywgaWR4KSB7IHJldHVybiBcIiAgXCIuY29uY2F0KGlkeCArIDEsIFwiLiBcIikuY29uY2F0KGl0ZW1Nc2cpOyB9KTtcbiAgICAgICAgICAgIHZhciBjYWxjdWxhdGVkRGVzY3JpcHRpb24gPSBcIm9uZSBvZiB0aGVzZSBwb3NzaWJsZSBUb2tlbiBzZXF1ZW5jZXM6XFxuXCIuY29uY2F0KG5leHRWYWxpZFNlcXVlbmNlSXRlbXMuam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICByZXR1cm4gZXJyUHJlZml4ICsgY2FsY3VsYXRlZERlc2NyaXB0aW9uICsgZXJyU3VmZml4O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBidWlsZEVhcmx5RXhpdE1lc3NhZ2U6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRJdGVyYXRpb25QYXRocyA9IF9hLmV4cGVjdGVkSXRlcmF0aW9uUGF0aHMsIGFjdHVhbCA9IF9hLmFjdHVhbCwgY3VzdG9tVXNlckRlc2NyaXB0aW9uID0gX2EuY3VzdG9tVXNlckRlc2NyaXB0aW9uLCBydWxlTmFtZSA9IF9hLnJ1bGVOYW1lO1xuICAgICAgICB2YXIgZXJyUHJlZml4ID0gXCJFeHBlY3Rpbmc6IFwiO1xuICAgICAgICAvLyBUT0RPOiBpc3N1ZTogTm8gVmlhYmxlIEFsdGVybmF0aXZlIEVycm9yIG1heSBoYXZlIGluY29tcGxldGUgZGV0YWlscy4gIzUwMlxuICAgICAgICB2YXIgYWN0dWFsVGV4dCA9ICgwLCBmaXJzdF8xLmRlZmF1bHQpKGFjdHVhbCkuaW1hZ2U7XG4gICAgICAgIHZhciBlcnJTdWZmaXggPSBcIlxcbmJ1dCBmb3VuZDogJ1wiICsgYWN0dWFsVGV4dCArIFwiJ1wiO1xuICAgICAgICBpZiAoY3VzdG9tVXNlckRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyUHJlZml4ICsgY3VzdG9tVXNlckRlc2NyaXB0aW9uICsgZXJyU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5leHRWYWxpZFRva2VuU2VxdWVuY2VzID0gKDAsIG1hcF8xLmRlZmF1bHQpKGV4cGVjdGVkSXRlcmF0aW9uUGF0aHMsIGZ1bmN0aW9uIChjdXJyUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltcIi5jb25jYXQoKDAsIG1hcF8xLmRlZmF1bHQpKGN1cnJQYXRoLCBmdW5jdGlvbiAoY3VyclRva2VuVHlwZSkgeyByZXR1cm4gKDAsIHRva2Vuc19wdWJsaWNfMS50b2tlbkxhYmVsKShjdXJyVG9rZW5UeXBlKTsgfSkuam9pbihcIixcIiksIFwiXVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZWREZXNjcmlwdGlvbiA9IFwiZXhwZWN0aW5nIGF0IGxlYXN0IG9uZSBpdGVyYXRpb24gd2hpY2ggc3RhcnRzIHdpdGggb25lIG9mIHRoZXNlIHBvc3NpYmxlIFRva2VuIHNlcXVlbmNlczo6XFxuICBcIiArXG4gICAgICAgICAgICAgICAgXCI8XCIuY29uY2F0KG5leHRWYWxpZFRva2VuU2VxdWVuY2VzLmpvaW4oXCIgLFwiKSwgXCI+XCIpO1xuICAgICAgICAgICAgcmV0dXJuIGVyclByZWZpeCArIGNhbGN1bGF0ZWREZXNjcmlwdGlvbiArIGVyclN1ZmZpeDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5PYmplY3QuZnJlZXplKGV4cG9ydHMuZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIpO1xuZXhwb3J0cy5kZWZhdWx0R3JhbW1hclJlc29sdmVyRXJyb3JQcm92aWRlciA9IHtcbiAgICBidWlsZFJ1bGVOb3RGb3VuZEVycm9yOiBmdW5jdGlvbiAodG9wTGV2ZWxSdWxlLCB1bmRlZmluZWRSdWxlKSB7XG4gICAgICAgIHZhciBtc2cgPSBcIkludmFsaWQgZ3JhbW1hciwgcmVmZXJlbmNlIHRvIGEgcnVsZSB3aGljaCBpcyBub3QgZGVmaW5lZDogLT5cIiArXG4gICAgICAgICAgICB1bmRlZmluZWRSdWxlLm5vblRlcm1pbmFsTmFtZSArXG4gICAgICAgICAgICBcIjwtXFxuXCIgK1xuICAgICAgICAgICAgXCJpbnNpZGUgdG9wIGxldmVsIHJ1bGU6IC0+XCIgK1xuICAgICAgICAgICAgdG9wTGV2ZWxSdWxlLm5hbWUgK1xuICAgICAgICAgICAgXCI8LVwiO1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlciA9IHtcbiAgICBidWlsZER1cGxpY2F0ZUZvdW5kRXJyb3I6IGZ1bmN0aW9uICh0b3BMZXZlbFJ1bGUsIGR1cGxpY2F0ZVByb2RzKSB7XG4gICAgICAgIGZ1bmN0aW9uIGdldEV4dHJhUHJvZHVjdGlvbkFyZ3VtZW50KHByb2QpIHtcbiAgICAgICAgICAgIGlmIChwcm9kIGluc3RhbmNlb2YgZ2FzdF8xLlRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2QudGVybWluYWxUeXBlLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgZ2FzdF8xLk5vblRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Qubm9uVGVybWluYWxOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvcExldmVsTmFtZSA9IHRvcExldmVsUnVsZS5uYW1lO1xuICAgICAgICB2YXIgZHVwbGljYXRlUHJvZCA9ICgwLCBmaXJzdF8xLmRlZmF1bHQpKGR1cGxpY2F0ZVByb2RzKTtcbiAgICAgICAgdmFyIGluZGV4ID0gZHVwbGljYXRlUHJvZC5pZHg7XG4gICAgICAgIHZhciBkc2xOYW1lID0gKDAsIGdhc3RfMi5nZXRQcm9kdWN0aW9uRHNsTmFtZSkoZHVwbGljYXRlUHJvZCk7XG4gICAgICAgIHZhciBleHRyYUFyZ3VtZW50ID0gZ2V0RXh0cmFQcm9kdWN0aW9uQXJndW1lbnQoZHVwbGljYXRlUHJvZCk7XG4gICAgICAgIHZhciBoYXNFeHBsaWNpdEluZGV4ID0gaW5kZXggPiAwO1xuICAgICAgICB2YXIgbXNnID0gXCItPlwiLmNvbmNhdChkc2xOYW1lKS5jb25jYXQoaGFzRXhwbGljaXRJbmRleCA/IGluZGV4IDogXCJcIiwgXCI8LSBcIikuY29uY2F0KGV4dHJhQXJndW1lbnQgPyBcIndpdGggYXJndW1lbnQ6IC0+XCIuY29uY2F0KGV4dHJhQXJndW1lbnQsIFwiPC1cIikgOiBcIlwiLCBcIlxcbiAgICAgICAgICAgICAgICAgIGFwcGVhcnMgbW9yZSB0aGFuIG9uY2UgKFwiKS5jb25jYXQoZHVwbGljYXRlUHJvZHMubGVuZ3RoLCBcIiB0aW1lcykgaW4gdGhlIHRvcCBsZXZlbCBydWxlOiAtPlwiKS5jb25jYXQodG9wTGV2ZWxOYW1lLCBcIjwtLiAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgIEZvciBmdXJ0aGVyIGRldGFpbHMgc2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9GQVEuaHRtbCNOVU1FUklDQUxfU1VGRklYRVMgXFxuICAgICAgICAgICAgICAgICAgXCIpO1xuICAgICAgICAvLyB3aGl0ZSBzcGFjZSB0cmltbWluZyB0aW1lISBiZXR0ZXIgdG8gdHJpbSBhZnRlcndhcmRzIGFzIGl0IGFsbG93cyB0byB1c2UgV0VMTCBmb3JtYXR0ZWQgbXVsdGkgbGluZSB0ZW1wbGF0ZSBzdHJpbmdzLi4uXG4gICAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bIFxcdF0rL2csIFwiIFwiKTtcbiAgICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL1xcc1xccysvZywgXCJcXG5cIik7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfSxcbiAgICBidWlsZE5hbWVzcGFjZUNvbmZsaWN0RXJyb3I6IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgIHZhciBlcnJNc2cgPSBcIk5hbWVzcGFjZSBjb25mbGljdCBmb3VuZCBpbiBncmFtbWFyLlxcblwiICtcbiAgICAgICAgICAgIFwiVGhlIGdyYW1tYXIgaGFzIGJvdGggYSBUZXJtaW5hbChUb2tlbikgYW5kIGEgTm9uLVRlcm1pbmFsKFJ1bGUpIG5hbWVkOiA8XCIuY29uY2F0KHJ1bGUubmFtZSwgXCI+LlxcblwiKSArXG4gICAgICAgICAgICBcIlRvIHJlc29sdmUgdGhpcyBtYWtlIHN1cmUgZWFjaCBUZXJtaW5hbCBhbmQgTm9uLVRlcm1pbmFsIG5hbWVzIGFyZSB1bmlxdWVcXG5cIiArXG4gICAgICAgICAgICBcIlRoaXMgaXMgZWFzeSB0byBhY2NvbXBsaXNoIGJ5IHVzaW5nIHRoZSBjb252ZW50aW9uIHRoYXQgVGVybWluYWwgbmFtZXMgc3RhcnQgd2l0aCBhbiB1cHBlcmNhc2UgbGV0dGVyXFxuXCIgK1xuICAgICAgICAgICAgXCJhbmQgTm9uLVRlcm1pbmFsIG5hbWVzIHN0YXJ0IHdpdGggYSBsb3dlciBjYXNlIGxldHRlci5cIjtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIGJ1aWxkQWx0ZXJuYXRpb25QcmVmaXhBbWJpZ3VpdHlFcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhdGhNc2cgPSAoMCwgbWFwXzEuZGVmYXVsdCkob3B0aW9ucy5wcmVmaXhQYXRoLCBmdW5jdGlvbiAoY3VyclRvaykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB0b2tlbnNfcHVibGljXzEudG9rZW5MYWJlbCkoY3VyclRvayk7XG4gICAgICAgIH0pLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdmFyIG9jY3VycmVuY2UgPSBvcHRpb25zLmFsdGVybmF0aW9uLmlkeCA9PT0gMCA/IFwiXCIgOiBvcHRpb25zLmFsdGVybmF0aW9uLmlkeDtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiQW1iaWd1b3VzIGFsdGVybmF0aXZlczogPFwiLmNvbmNhdChvcHRpb25zLmFtYmlndWl0eUluZGljZXMuam9pbihcIiAsXCIpLCBcIj4gZHVlIHRvIGNvbW1vbiBsb29rYWhlYWQgcHJlZml4XFxuXCIpICtcbiAgICAgICAgICAgIFwiaW4gPE9SXCIuY29uY2F0KG9jY3VycmVuY2UsIFwiPiBpbnNpZGUgPFwiKS5jb25jYXQob3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZSwgXCI+IFJ1bGUsXFxuXCIpICtcbiAgICAgICAgICAgIFwiPFwiLmNvbmNhdChwYXRoTXNnLCBcIj4gbWF5IGFwcGVhcnMgYXMgYSBwcmVmaXggcGF0aCBpbiBhbGwgdGhlc2UgYWx0ZXJuYXRpdmVzLlxcblwiKSArXG4gICAgICAgICAgICBcIlNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2dyYW1tYXJfZXJyb3JzLmh0bWwjQ09NTU9OX1BSRUZJWFxcblwiICtcbiAgICAgICAgICAgIFwiRm9yIEZ1cnRoZXIgZGV0YWlscy5cIjtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIGJ1aWxkQWx0ZXJuYXRpb25BbWJpZ3VpdHlFcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhdGhNc2cgPSAoMCwgbWFwXzEuZGVmYXVsdCkob3B0aW9ucy5wcmVmaXhQYXRoLCBmdW5jdGlvbiAoY3VycnRvaykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB0b2tlbnNfcHVibGljXzEudG9rZW5MYWJlbCkoY3VycnRvayk7XG4gICAgICAgIH0pLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdmFyIG9jY3VycmVuY2UgPSBvcHRpb25zLmFsdGVybmF0aW9uLmlkeCA9PT0gMCA/IFwiXCIgOiBvcHRpb25zLmFsdGVybmF0aW9uLmlkeDtcbiAgICAgICAgdmFyIGN1cnJNZXNzYWdlID0gXCJBbWJpZ3VvdXMgQWx0ZXJuYXRpdmVzIERldGVjdGVkOiA8XCIuY29uY2F0KG9wdGlvbnMuYW1iaWd1aXR5SW5kaWNlcy5qb2luKFwiICxcIiksIFwiPiBpbiA8T1JcIikuY29uY2F0KG9jY3VycmVuY2UsIFwiPlwiKSArXG4gICAgICAgICAgICBcIiBpbnNpZGUgPFwiLmNvbmNhdChvcHRpb25zLnRvcExldmVsUnVsZS5uYW1lLCBcIj4gUnVsZSxcXG5cIikgK1xuICAgICAgICAgICAgXCI8XCIuY29uY2F0KHBhdGhNc2csIFwiPiBtYXkgYXBwZWFycyBhcyBhIHByZWZpeCBwYXRoIGluIGFsbCB0aGVzZSBhbHRlcm5hdGl2ZXMuXFxuXCIpO1xuICAgICAgICBjdXJyTWVzc2FnZSA9XG4gICAgICAgICAgICBjdXJyTWVzc2FnZSArXG4gICAgICAgICAgICAgICAgXCJTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19ncmFtbWFyX2Vycm9ycy5odG1sI0FNQklHVU9VU19BTFRFUk5BVElWRVNcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJGb3IgRnVydGhlciBkZXRhaWxzLlwiO1xuICAgICAgICByZXR1cm4gY3Vyck1lc3NhZ2U7XG4gICAgfSxcbiAgICBidWlsZEVtcHR5UmVwZXRpdGlvbkVycm9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgZHNsTmFtZSA9ICgwLCBnYXN0XzIuZ2V0UHJvZHVjdGlvbkRzbE5hbWUpKG9wdGlvbnMucmVwZXRpdGlvbik7XG4gICAgICAgIGlmIChvcHRpb25zLnJlcGV0aXRpb24uaWR4ICE9PSAwKSB7XG4gICAgICAgICAgICBkc2xOYW1lICs9IG9wdGlvbnMucmVwZXRpdGlvbi5pZHg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyck1zZyA9IFwiVGhlIHJlcGV0aXRpb24gPFwiLmNvbmNhdChkc2xOYW1lLCBcIj4gd2l0aGluIFJ1bGUgPFwiKS5jb25jYXQob3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZSwgXCI+IGNhbiBuZXZlciBjb25zdW1lIGFueSB0b2tlbnMuXFxuXCIpICtcbiAgICAgICAgICAgIFwiVGhpcyBjb3VsZCBsZWFkIHRvIGFuIGluZmluaXRlIGxvb3AuXCI7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICAvLyBUT0RPOiByZW1vdmUgLSBgZXJyb3JzX3B1YmxpY2AgZnJvbSBueWMuY29uZmlnLmpzIGV4Y2x1ZGVcbiAgICAvLyAgICAgICBvbmNlIHRoaXMgbWV0aG9kIGlzIGZ1bGx5IHJlbW92ZWQgZnJvbSB0aGlzIGZpbGVcbiAgICBidWlsZFRva2VuTmFtZUVycm9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gXCJkZXByZWNhdGVkXCI7XG4gICAgfSxcbiAgICBidWlsZEVtcHR5QWx0ZXJuYXRpb25FcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiQW1iaWd1b3VzIGVtcHR5IGFsdGVybmF0aXZlOiA8XCIuY29uY2F0KG9wdGlvbnMuZW1wdHlDaG9pY2VJZHggKyAxLCBcIj5cIikgK1xuICAgICAgICAgICAgXCIgaW4gPE9SXCIuY29uY2F0KG9wdGlvbnMuYWx0ZXJuYXRpb24uaWR4LCBcIj4gaW5zaWRlIDxcIikuY29uY2F0KG9wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWUsIFwiPiBSdWxlLlxcblwiKSArXG4gICAgICAgICAgICBcIk9ubHkgdGhlIGxhc3QgYWx0ZXJuYXRpdmUgbWF5IGJlIGFuIGVtcHR5IGFsdGVybmF0aXZlLlwiO1xuICAgICAgICByZXR1cm4gZXJyTXNnO1xuICAgIH0sXG4gICAgYnVpbGRUb29NYW55QWx0ZXJuYXRpdmVzRXJyb3I6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBlcnJNc2cgPSBcIkFuIEFsdGVybmF0aW9uIGNhbm5vdCBoYXZlIG1vcmUgdGhhbiAyNTYgYWx0ZXJuYXRpdmVzOlxcblwiICtcbiAgICAgICAgICAgIFwiPE9SXCIuY29uY2F0KG9wdGlvbnMuYWx0ZXJuYXRpb24uaWR4LCBcIj4gaW5zaWRlIDxcIikuY29uY2F0KG9wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWUsIFwiPiBSdWxlLlxcbiBoYXMgXCIpLmNvbmNhdChvcHRpb25zLmFsdGVybmF0aW9uLmRlZmluaXRpb24ubGVuZ3RoICsgMSwgXCIgYWx0ZXJuYXRpdmVzLlwiKTtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIGJ1aWxkTGVmdFJlY3Vyc2lvbkVycm9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcnVsZU5hbWUgPSBvcHRpb25zLnRvcExldmVsUnVsZS5uYW1lO1xuICAgICAgICB2YXIgcGF0aE5hbWVzID0gKDAsIG1hcF8xLmRlZmF1bHQpKG9wdGlvbnMubGVmdFJlY3Vyc2lvblBhdGgsIGZ1bmN0aW9uIChjdXJyUnVsZSkgeyByZXR1cm4gY3VyclJ1bGUubmFtZTsgfSk7XG4gICAgICAgIHZhciBsZWZ0UmVjdXJzaXZlUGF0aCA9IFwiXCIuY29uY2F0KHJ1bGVOYW1lLCBcIiAtLT4gXCIpLmNvbmNhdChwYXRoTmFtZXNcbiAgICAgICAgICAgIC5jb25jYXQoW3J1bGVOYW1lXSlcbiAgICAgICAgICAgIC5qb2luKFwiIC0tPiBcIikpO1xuICAgICAgICB2YXIgZXJyTXNnID0gXCJMZWZ0IFJlY3Vyc2lvbiBmb3VuZCBpbiBncmFtbWFyLlxcblwiICtcbiAgICAgICAgICAgIFwicnVsZTogPFwiLmNvbmNhdChydWxlTmFtZSwgXCI+IGNhbiBiZSBpbnZva2VkIGZyb20gaXRzZWxmIChkaXJlY3RseSBvciBpbmRpcmVjdGx5KVxcblwiKSArXG4gICAgICAgICAgICBcIndpdGhvdXQgY29uc3VtaW5nIGFueSBUb2tlbnMuIFRoZSBncmFtbWFyIHBhdGggdGhhdCBjYXVzZXMgdGhpcyBpczogXFxuIFwiLmNvbmNhdChsZWZ0UmVjdXJzaXZlUGF0aCwgXCJcXG5cIikgK1xuICAgICAgICAgICAgXCIgVG8gZml4IHRoaXMgcmVmYWN0b3IgeW91ciBncmFtbWFyIHRvIHJlbW92ZSB0aGUgbGVmdCByZWN1cnNpb24uXFxuXCIgK1xuICAgICAgICAgICAgXCJzZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xMX3BhcnNlciNMZWZ0X2ZhY3RvcmluZy5cIjtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIC8vIFRPRE86IHJlbW92ZSAtIGBlcnJvcnNfcHVibGljYCBmcm9tIG55Yy5jb25maWcuanMgZXhjbHVkZVxuICAgIC8vICAgICAgIG9uY2UgdGhpcyBtZXRob2QgaXMgZnVsbHkgcmVtb3ZlZCBmcm9tIHRoaXMgZmlsZVxuICAgIGJ1aWxkSW52YWxpZFJ1bGVOYW1lRXJyb3I6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBcImRlcHJlY2F0ZWRcIjtcbiAgICB9LFxuICAgIGJ1aWxkRHVwbGljYXRlUnVsZU5hbWVFcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJ1bGVOYW1lO1xuICAgICAgICBpZiAob3B0aW9ucy50b3BMZXZlbFJ1bGUgaW5zdGFuY2VvZiBnYXN0XzEuUnVsZSkge1xuICAgICAgICAgICAgcnVsZU5hbWUgPSBvcHRpb25zLnRvcExldmVsUnVsZS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcnVsZU5hbWUgPSBvcHRpb25zLnRvcExldmVsUnVsZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyTXNnID0gXCJEdXBsaWNhdGUgZGVmaW5pdGlvbiwgcnVsZTogLT5cIi5jb25jYXQocnVsZU5hbWUsIFwiPC0gaXMgYWxyZWFkeSBkZWZpbmVkIGluIHRoZSBncmFtbWFyOiAtPlwiKS5jb25jYXQob3B0aW9ucy5ncmFtbWFyTmFtZSwgXCI8LVwiKTtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzX3B1YmxpYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/errors_public.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/exceptions_public.js":
/*!********************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/exceptions_public.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EarlyExitException = exports.NotAllInputParsedException = exports.NoViableAltException = exports.MismatchedTokenException = exports.isRecognitionException = void 0;\nvar includes_1 = __importDefault(__webpack_require__(/*! lodash/includes */ \"(ssr)/./node_modules/lodash/includes.js\"));\nvar MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\nvar NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\nvar EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\nvar NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\nvar RECOGNITION_EXCEPTION_NAMES = [\n    MISMATCHED_TOKEN_EXCEPTION,\n    NO_VIABLE_ALT_EXCEPTION,\n    EARLY_EXIT_EXCEPTION,\n    NOT_ALL_INPUT_PARSED_EXCEPTION\n];\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\n// hacks to bypass no support for custom Errors in javascript/typescript\nfunction isRecognitionException(error) {\n    // can't do instanceof on hacked custom js exceptions\n    return (0, includes_1.default)(RECOGNITION_EXCEPTION_NAMES, error.name);\n}\nexports.isRecognitionException = isRecognitionException;\nvar RecognitionException = /** @class */ (function (_super) {\n    __extends(RecognitionException, _super);\n    function RecognitionException(message, token) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, message) || this;\n        _this.token = token;\n        _this.resyncedTokens = [];\n        // fix prototype chain when typescript target is ES5\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, _this.constructor);\n        }\n        return _this;\n    }\n    return RecognitionException;\n}(Error));\nvar MismatchedTokenException = /** @class */ (function (_super) {\n    __extends(MismatchedTokenException, _super);\n    function MismatchedTokenException(message, token, previousToken) {\n        var _this = _super.call(this, message, token) || this;\n        _this.previousToken = previousToken;\n        _this.name = MISMATCHED_TOKEN_EXCEPTION;\n        return _this;\n    }\n    return MismatchedTokenException;\n}(RecognitionException));\nexports.MismatchedTokenException = MismatchedTokenException;\nvar NoViableAltException = /** @class */ (function (_super) {\n    __extends(NoViableAltException, _super);\n    function NoViableAltException(message, token, previousToken) {\n        var _this = _super.call(this, message, token) || this;\n        _this.previousToken = previousToken;\n        _this.name = NO_VIABLE_ALT_EXCEPTION;\n        return _this;\n    }\n    return NoViableAltException;\n}(RecognitionException));\nexports.NoViableAltException = NoViableAltException;\nvar NotAllInputParsedException = /** @class */ (function (_super) {\n    __extends(NotAllInputParsedException, _super);\n    function NotAllInputParsedException(message, token) {\n        var _this = _super.call(this, message, token) || this;\n        _this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n        return _this;\n    }\n    return NotAllInputParsedException;\n}(RecognitionException));\nexports.NotAllInputParsedException = NotAllInputParsedException;\nvar EarlyExitException = /** @class */ (function (_super) {\n    __extends(EarlyExitException, _super);\n    function EarlyExitException(message, token, previousToken) {\n        var _this = _super.call(this, message, token) || this;\n        _this.previousToken = previousToken;\n        _this.name = EARLY_EXIT_EXCEPTION;\n        return _this;\n    }\n    return EarlyExitException;\n}(RecognitionException));\nexports.EarlyExitException = EarlyExitException;\n//# sourceMappingURL=exceptions_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2V4Y2VwdGlvbnNfcHVibGljLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsa0NBQWtDLEdBQUcsNEJBQTRCLEdBQUcsZ0NBQWdDLEdBQUcsOEJBQThCO0FBQ2xLLGlDQUFpQyxtQkFBTyxDQUFDLGdFQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2V4Y2VwdGlvbnNfcHVibGljLmpzP2ViN2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FYXJseUV4aXRFeGNlcHRpb24gPSBleHBvcnRzLk5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uID0gZXhwb3J0cy5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IGV4cG9ydHMuTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uID0gZXhwb3J0cy5pc1JlY29nbml0aW9uRXhjZXB0aW9uID0gdm9pZCAwO1xudmFyIGluY2x1ZGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pbmNsdWRlc1wiKSk7XG52YXIgTUlTTUFUQ0hFRF9UT0tFTl9FWENFUFRJT04gPSBcIk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvblwiO1xudmFyIE5PX1ZJQUJMRV9BTFRfRVhDRVBUSU9OID0gXCJOb1ZpYWJsZUFsdEV4Y2VwdGlvblwiO1xudmFyIEVBUkxZX0VYSVRfRVhDRVBUSU9OID0gXCJFYXJseUV4aXRFeGNlcHRpb25cIjtcbnZhciBOT1RfQUxMX0lOUFVUX1BBUlNFRF9FWENFUFRJT04gPSBcIk5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uXCI7XG52YXIgUkVDT0dOSVRJT05fRVhDRVBUSU9OX05BTUVTID0gW1xuICAgIE1JU01BVENIRURfVE9LRU5fRVhDRVBUSU9OLFxuICAgIE5PX1ZJQUJMRV9BTFRfRVhDRVBUSU9OLFxuICAgIEVBUkxZX0VYSVRfRVhDRVBUSU9OLFxuICAgIE5PVF9BTExfSU5QVVRfUEFSU0VEX0VYQ0VQVElPTlxuXTtcbk9iamVjdC5mcmVlemUoUkVDT0dOSVRJT05fRVhDRVBUSU9OX05BTUVTKTtcbi8vIGhhY2tzIHRvIGJ5cGFzcyBubyBzdXBwb3J0IGZvciBjdXN0b20gRXJyb3JzIGluIGphdmFzY3JpcHQvdHlwZXNjcmlwdFxuZnVuY3Rpb24gaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlcnJvcikge1xuICAgIC8vIGNhbid0IGRvIGluc3RhbmNlb2Ygb24gaGFja2VkIGN1c3RvbSBqcyBleGNlcHRpb25zXG4gICAgcmV0dXJuICgwLCBpbmNsdWRlc18xLmRlZmF1bHQpKFJFQ09HTklUSU9OX0VYQ0VQVElPTl9OQU1FUywgZXJyb3IubmFtZSk7XG59XG5leHBvcnRzLmlzUmVjb2duaXRpb25FeGNlcHRpb24gPSBpc1JlY29nbml0aW9uRXhjZXB0aW9uO1xudmFyIFJlY29nbml0aW9uRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWNvZ25pdGlvbkV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWNvZ25pdGlvbkV4Y2VwdGlvbihtZXNzYWdlLCB0b2tlbikge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIF90aGlzLnJlc3luY2VkVG9rZW5zID0gW107XG4gICAgICAgIC8vIGZpeCBwcm90b3R5cGUgY2hhaW4gd2hlbiB0eXBlc2NyaXB0IHRhcmdldCBpcyBFUzVcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBfbmV3VGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gVjggd29ya2Fyb3VuZCB0byByZW1vdmUgY29uc3RydWN0b3IgZnJvbSBzdGFja3RyYWNlIHdoZW4gdHlwZXNjcmlwdCB0YXJnZXQgaXMgRVM1ICovXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIF90aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZWNvZ25pdGlvbkV4Y2VwdGlvbjtcbn0oRXJyb3IpKTtcbnZhciBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24obWVzc2FnZSwgdG9rZW4sIHByZXZpb3VzVG9rZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSwgdG9rZW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByZXZpb3VzVG9rZW4gPSBwcmV2aW91c1Rva2VuO1xuICAgICAgICBfdGhpcy5uYW1lID0gTUlTTUFUQ0hFRF9UT0tFTl9FWENFUFRJT047XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbjtcbn0oUmVjb2duaXRpb25FeGNlcHRpb24pKTtcbmV4cG9ydHMuTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uID0gTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uO1xudmFyIE5vVmlhYmxlQWx0RXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb1ZpYWJsZUFsdEV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb1ZpYWJsZUFsdEV4Y2VwdGlvbihtZXNzYWdlLCB0b2tlbiwgcHJldmlvdXNUb2tlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlLCB0b2tlbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJldmlvdXNUb2tlbiA9IHByZXZpb3VzVG9rZW47XG4gICAgICAgIF90aGlzLm5hbWUgPSBOT19WSUFCTEVfQUxUX0VYQ0VQVElPTjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTm9WaWFibGVBbHRFeGNlcHRpb247XG59KFJlY29nbml0aW9uRXhjZXB0aW9uKSk7XG5leHBvcnRzLk5vVmlhYmxlQWx0RXhjZXB0aW9uID0gTm9WaWFibGVBbHRFeGNlcHRpb247XG52YXIgTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uKG1lc3NhZ2UsIHRva2VuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UsIHRva2VuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gTk9UX0FMTF9JTlBVVF9QQVJTRURfRVhDRVBUSU9OO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbjtcbn0oUmVjb2duaXRpb25FeGNlcHRpb24pKTtcbmV4cG9ydHMuTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb24gPSBOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbjtcbnZhciBFYXJseUV4aXRFeGNlcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVhcmx5RXhpdEV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFYXJseUV4aXRFeGNlcHRpb24obWVzc2FnZSwgdG9rZW4sIHByZXZpb3VzVG9rZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSwgdG9rZW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByZXZpb3VzVG9rZW4gPSBwcmV2aW91c1Rva2VuO1xuICAgICAgICBfdGhpcy5uYW1lID0gRUFSTFlfRVhJVF9FWENFUFRJT047XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEVhcmx5RXhpdEV4Y2VwdGlvbjtcbn0oUmVjb2duaXRpb25FeGNlcHRpb24pKTtcbmV4cG9ydHMuRWFybHlFeGl0RXhjZXB0aW9uID0gRWFybHlFeGl0RXhjZXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhjZXB0aW9uc19wdWJsaWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/exceptions_public.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/checks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/checks.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetitionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = exports.validateLookahead = void 0;\nvar first_1 = __importDefault(__webpack_require__(/*! lodash/first */ \"(ssr)/./node_modules/lodash/first.js\"));\nvar isEmpty_1 = __importDefault(__webpack_require__(/*! lodash/isEmpty */ \"(ssr)/./node_modules/lodash/isEmpty.js\"));\nvar drop_1 = __importDefault(__webpack_require__(/*! lodash/drop */ \"(ssr)/./node_modules/lodash/drop.js\"));\nvar flatten_1 = __importDefault(__webpack_require__(/*! lodash/flatten */ \"(ssr)/./node_modules/lodash/flatten.js\"));\nvar filter_1 = __importDefault(__webpack_require__(/*! lodash/filter */ \"(ssr)/./node_modules/lodash/filter.js\"));\nvar reject_1 = __importDefault(__webpack_require__(/*! lodash/reject */ \"(ssr)/./node_modules/lodash/reject.js\"));\nvar difference_1 = __importDefault(__webpack_require__(/*! lodash/difference */ \"(ssr)/./node_modules/lodash/difference.js\"));\nvar map_1 = __importDefault(__webpack_require__(/*! lodash/map */ \"(ssr)/./node_modules/lodash/map.js\"));\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar groupBy_1 = __importDefault(__webpack_require__(/*! lodash/groupBy */ \"(ssr)/./node_modules/lodash/groupBy.js\"));\nvar reduce_1 = __importDefault(__webpack_require__(/*! lodash/reduce */ \"(ssr)/./node_modules/lodash/reduce.js\"));\nvar pickBy_1 = __importDefault(__webpack_require__(/*! lodash/pickBy */ \"(ssr)/./node_modules/lodash/pickBy.js\"));\nvar values_1 = __importDefault(__webpack_require__(/*! lodash/values */ \"(ssr)/./node_modules/lodash/values.js\"));\nvar includes_1 = __importDefault(__webpack_require__(/*! lodash/includes */ \"(ssr)/./node_modules/lodash/includes.js\"));\nvar flatMap_1 = __importDefault(__webpack_require__(/*! lodash/flatMap */ \"(ssr)/./node_modules/lodash/flatMap.js\"));\nvar clone_1 = __importDefault(__webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"));\nvar parser_1 = __webpack_require__(/*! ../parser/parser */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\");\nvar gast_1 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nvar lookahead_1 = __webpack_require__(/*! ./lookahead */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js\");\nvar interpreter_1 = __webpack_require__(/*! ./interpreter */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js\");\nvar gast_2 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nvar gast_3 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nvar dropRight_1 = __importDefault(__webpack_require__(/*! lodash/dropRight */ \"(ssr)/./node_modules/lodash/dropRight.js\"));\nvar compact_1 = __importDefault(__webpack_require__(/*! lodash/compact */ \"(ssr)/./node_modules/lodash/compact.js\"));\nvar tokens_1 = __webpack_require__(/*! ../../scan/tokens */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/tokens.js\");\nfunction validateLookahead(options) {\n    var lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n        rules: options.rules,\n        tokenTypes: options.tokenTypes,\n        grammarName: options.grammarName\n    });\n    return (0, map_1.default)(lookaheadValidationErrorMessages, function (errorMessage) { return (__assign({ type: parser_1.ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage)); });\n}\nexports.validateLookahead = validateLookahead;\nfunction validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {\n    var duplicateErrors = (0, flatMap_1.default)(topLevels, function (currTopLevel) { return validateDuplicateProductions(currTopLevel, errMsgProvider); });\n    var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function (curRule) {\n        return validateTooManyAlts(curRule, errMsgProvider);\n    });\n    var duplicateRulesError = (0, flatMap_1.default)(topLevels, function (curRule) {\n        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n    });\n    return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\nexports.validateGrammar = validateGrammar;\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    var collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);\n    var duplicates = (0, pickBy_1.default)(productionGroups, function (currGroup) {\n        return currGroup.length > 1;\n    });\n    var errors = (0, map_1.default)((0, values_1.default)(duplicates), function (currDuplicates) {\n        var firstProd = (0, first_1.default)(currDuplicates);\n        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        var dslName = (0, gast_1.getProductionDslName)(firstProd);\n        var defError = {\n            message: msg,\n            type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx\n        };\n        var param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nfunction identifyProductionForDuplicates(prod) {\n    return \"\".concat((0, gast_1.getProductionDslName)(prod), \"_#_\").concat(prod.idx, \"_#_\").concat(getExtraProductionArgument(prod));\n}\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof gast_2.Terminal) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof gast_2.NonTerminal) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return \"\";\n    }\n}\nvar OccurrenceValidationCollector = /** @class */ (function (_super) {\n    __extends(OccurrenceValidationCollector, _super);\n    function OccurrenceValidationCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n        this.allProductions.push(subrule);\n    };\n    OccurrenceValidationCollector.prototype.visitOption = function (option) {\n        this.allProductions.push(option);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n        this.allProductions.push(or);\n    };\n    OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n        this.allProductions.push(terminal);\n    };\n    return OccurrenceValidationCollector;\n}(gast_3.GAstVisitor));\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    var errors = [];\n    var occurrences = (0, reduce_1.default)(allRules, function (result, curRule) {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className\n        });\n        errors.push({\n            message: errMsg,\n            type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name\n        });\n    }\n    return errors;\n}\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    var errors = [];\n    var errMsg;\n    if (!(0, includes_1.default)(definedRulesNames, ruleName)) {\n        errMsg =\n            \"Invalid rule override, rule: ->\".concat(ruleName, \"<- cannot be overridden in the grammar: ->\").concat(className, \"<-\") +\n                \"as it is not defined in any of the super grammars \";\n        errors.push({\n            message: errMsg,\n            type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n    if (path === void 0) { path = []; }\n    var errors = [];\n    var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if ((0, isEmpty_1.default)(nextNonTerminals)) {\n        return [];\n    }\n    else {\n        var ruleName = topRule.name;\n        var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path\n                }),\n                type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\n                ruleName: ruleName\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        var validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));\n        var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function (currRefRule) {\n            var newPath = (0, clone_1.default)(path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(errorsFromNextSteps);\n    }\n}\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\nfunction getFirstNoneTerminal(definition) {\n    var result = [];\n    if ((0, isEmpty_1.default)(definition)) {\n        return result;\n    }\n    var firstProd = (0, first_1.default)(definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof gast_2.NonTerminal) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof gast_2.Alternative ||\n        firstProd instanceof gast_2.Option ||\n        firstProd instanceof gast_2.RepetitionMandatory ||\n        firstProd instanceof gast_2.RepetitionMandatoryWithSeparator ||\n        firstProd instanceof gast_2.RepetitionWithSeparator ||\n        firstProd instanceof gast_2.Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof gast_2.Alternation) {\n        // each sub definition in alternation is a FLAT\n        result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function (currSubDef) {\n            return getFirstNoneTerminal(currSubDef.definition);\n        }));\n    }\n    else if (firstProd instanceof gast_2.Terminal) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n    var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);\n    var hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        var rest = (0, drop_1.default)(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\nvar OrCollector = /** @class */ (function (_super) {\n    __extends(OrCollector, _super);\n    function OrCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.alternations = [];\n        return _this;\n    }\n    OrCollector.prototype.visitAlternation = function (node) {\n        this.alternations.push(node);\n    };\n    return OrCollector;\n}(gast_3.GAstVisitor));\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = (0, flatMap_1.default)(ors, function (currOr) {\n        var exceptLast = (0, dropRight_1.default)(currOr.definition);\n        return (0, flatMap_1.default)(exceptLast, function (currAlternative, currAltIdx) {\n            var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);\n            if ((0, isEmpty_1.default)(possibleFirstInAlt)) {\n                return [\n                    {\n                        message: errMsgProvider.buildEmptyAlternationError({\n                            topLevelRule: topLevelRule,\n                            alternation: currOr,\n                            emptyChoiceIdx: currAltIdx\n                        }),\n                        type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                        ruleName: topLevelRule.name,\n                        occurrence: currOr.idx,\n                        alternative: currAltIdx + 1\n                    }\n                ];\n            }\n            else {\n                return [];\n            }\n        });\n    });\n    return errors;\n}\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    // New Handling of ignoring ambiguities\n    // - https://github.com/chevrotain/chevrotain/issues/869\n    ors = (0, reject_1.default)(ors, function (currOr) { return currOr.ignoreAmbiguities === true; });\n    var errors = (0, flatMap_1.default)(ors, function (currOr) {\n        var currOccurrence = currOr.idx;\n        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n    });\n    return errors;\n}\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\nvar RepetitionCollector = /** @class */ (function (_super) {\n    __extends(RepetitionCollector, _super);\n    function RepetitionCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    RepetitionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    RepetitionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    RepetitionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    RepetitionCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    return RepetitionCollector;\n}(gast_3.GAstVisitor));\nexports.RepetitionCollector = RepetitionCollector;\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = (0, flatMap_1.default)(ors, function (currOr) {\n        if (currOr.definition.length > 255) {\n            return [\n                {\n                    message: errMsgProvider.buildTooManyAlternativesError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr\n                    }),\n                    type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx\n                }\n            ];\n        }\n        else {\n            return [];\n        }\n    });\n    return errors;\n}\nexports.validateTooManyAlts = validateTooManyAlts;\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    var errors = [];\n    (0, forEach_1.default)(topLevelRules, function (currTopRule) {\n        var collectorVisitor = new RepetitionCollector();\n        currTopRule.accept(collectorVisitor);\n        var allRuleProductions = collectorVisitor.allProductions;\n        (0, forEach_1.default)(allRuleProductions, function (currProd) {\n            var prodType = (0, lookahead_1.getProdType)(currProd);\n            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            var currOccurrence = currProd.idx;\n            var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            var pathsInsideProduction = paths[0];\n            if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {\n                var errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd\n                });\n                errors.push({\n                    message: errMsg,\n                    type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name\n                });\n            }\n        });\n    });\n    return errors;\n}\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var foundAmbiguousPaths = [];\n    var identicalAmbiguities = (0, reduce_1.default)(alternatives, function (result, currAlt, currAltIdx) {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        (0, forEach_1.default)(currAlt, function (currPath) {\n            var altsCurrPathAppearsIn = [currAltIdx];\n            (0, forEach_1.default)(alternatives, function (currOtherAlt, currOtherAltIdx) {\n                if (currAltIdx !== currOtherAltIdx &&\n                    (0, lookahead_1.containsPath)(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this \"other\" alternative\n                    alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath\n                });\n            }\n        });\n        return result;\n    }, []);\n    var currErrors = (0, map_1.default)(identicalAmbiguities, function (currAmbDescriptor) {\n        var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function (currAltIdx) { return currAltIdx + 1; });\n        var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path\n        });\n        return {\n            message: currMessage,\n            type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: currAmbDescriptor.alts\n        };\n    });\n    return currErrors;\n}\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    // flatten\n    var pathsAndIndices = (0, reduce_1.default)(alternatives, function (result, currAlt, idx) {\n        var currPathsAndIdx = (0, map_1.default)(currAlt, function (currPath) {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function (currPathAndIdx) {\n        var alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return [];\n        }\n        var targetIdx = currPathAndIdx.idx;\n        var targetPath = currPathAndIdx.path;\n        var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function (searchPathAndIdx) {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n                true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath));\n        });\n        var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path\n            });\n            return {\n                message: message,\n                type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices\n            };\n        });\n        return currPathPrefixErrors;\n    }));\n    return errors;\n}\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    var errors = [];\n    var tokenNames = (0, map_1.default)(tokenTypes, function (currToken) { return currToken.name; });\n    (0, forEach_1.default)(topLevels, function (currRule) {\n        var currRuleName = currRule.name;\n        if ((0, includes_1.default)(tokenNames, currRuleName)) {\n            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName\n            });\n        }\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvY2hlY2tzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQ0FBMEMsR0FBRyx5Q0FBeUMsR0FBRywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyxnREFBZ0QsR0FBRyxrQ0FBa0MsR0FBRyw0QkFBNEIsR0FBRywrQkFBK0IsR0FBRyxnQ0FBZ0MsR0FBRyx1Q0FBdUMsR0FBRyxxQ0FBcUMsR0FBRyx1Q0FBdUMsR0FBRyx1QkFBdUIsR0FBRyx5QkFBeUI7QUFDaGdCLDhCQUE4QixtQkFBTyxDQUFDLDBEQUFjO0FBQ3BELGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCw2QkFBNkIsbUJBQU8sQ0FBQyx3REFBYTtBQUNsRCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsK0JBQStCLG1CQUFPLENBQUMsNERBQWU7QUFDdEQsK0JBQStCLG1CQUFPLENBQUMsNERBQWU7QUFDdEQsbUNBQW1DLG1CQUFPLENBQUMsb0VBQW1CO0FBQzlELDRCQUE0QixtQkFBTyxDQUFDLHNEQUFZO0FBQ2hELGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsK0JBQStCLG1CQUFPLENBQUMsNERBQWU7QUFDdEQsK0JBQStCLG1CQUFPLENBQUMsNERBQWU7QUFDdEQsK0JBQStCLG1CQUFPLENBQUMsNERBQWU7QUFDdEQsaUNBQWlDLG1CQUFPLENBQUMsZ0VBQWlCO0FBQzFELGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCw4QkFBOEIsbUJBQU8sQ0FBQywwREFBYztBQUNwRCxlQUFlLG1CQUFPLENBQUMsd0ZBQWtCO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMsdUZBQWE7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMsMkZBQWU7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLDhFQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsOEVBQWtCO0FBQ3ZDLGtDQUFrQyxtQkFBTyxDQUFDLGtFQUFrQjtBQUM1RCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsZUFBZSxtQkFBTyxDQUFDLGlGQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBGQUEwRixtQkFBbUIsc0VBQXNFLG1CQUFtQjtBQUN0TTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHNGQUFzRixvRUFBb0U7QUFDMUo7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwyQ0FBMkM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLDZGQUE2Rix3QkFBd0I7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDJFQUEyRSx3QkFBd0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9ncmFtbWFyL2NoZWNrcy5qcz84ZmUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoZWNrUHJlZml4QWx0ZXJuYXRpdmVzQW1iaWd1aXRpZXMgPSBleHBvcnRzLnZhbGlkYXRlU29tZU5vbkVtcHR5TG9va2FoZWFkUGF0aCA9IGV4cG9ydHMudmFsaWRhdGVUb29NYW55QWx0cyA9IGV4cG9ydHMuUmVwZXRpdGlvbkNvbGxlY3RvciA9IGV4cG9ydHMudmFsaWRhdGVBbWJpZ3VvdXNBbHRlcm5hdGlvbkFsdGVybmF0aXZlcyA9IGV4cG9ydHMudmFsaWRhdGVFbXB0eU9yQWx0ZXJuYXRpdmUgPSBleHBvcnRzLmdldEZpcnN0Tm9uZVRlcm1pbmFsID0gZXhwb3J0cy52YWxpZGF0ZU5vTGVmdFJlY3Vyc2lvbiA9IGV4cG9ydHMudmFsaWRhdGVSdWxlSXNPdmVycmlkZGVuID0gZXhwb3J0cy52YWxpZGF0ZVJ1bGVEb2VzTm90QWxyZWFkeUV4aXN0ID0gZXhwb3J0cy5PY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3RvciA9IGV4cG9ydHMuaWRlbnRpZnlQcm9kdWN0aW9uRm9yRHVwbGljYXRlcyA9IGV4cG9ydHMudmFsaWRhdGVHcmFtbWFyID0gZXhwb3J0cy52YWxpZGF0ZUxvb2thaGVhZCA9IHZvaWQgMDtcbnZhciBmaXJzdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZmlyc3RcIikpO1xudmFyIGlzRW1wdHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRW1wdHlcIikpO1xudmFyIGRyb3BfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2Ryb3BcIikpO1xudmFyIGZsYXR0ZW5fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZsYXR0ZW5cIikpO1xudmFyIGZpbHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZmlsdGVyXCIpKTtcbnZhciByZWplY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3JlamVjdFwiKSk7XG52YXIgZGlmZmVyZW5jZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZGlmZmVyZW5jZVwiKSk7XG52YXIgbWFwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9tYXBcIikpO1xudmFyIGZvckVhY2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZvckVhY2hcIikpO1xudmFyIGdyb3VwQnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2dyb3VwQnlcIikpO1xudmFyIHJlZHVjZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvcmVkdWNlXCIpKTtcbnZhciBwaWNrQnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3BpY2tCeVwiKSk7XG52YXIgdmFsdWVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC92YWx1ZXNcIikpO1xudmFyIGluY2x1ZGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pbmNsdWRlc1wiKSk7XG52YXIgZmxhdE1hcF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZmxhdE1hcFwiKSk7XG52YXIgY2xvbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpKTtcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9wYXJzZXIvcGFyc2VyXCIpO1xudmFyIGdhc3RfMSA9IHJlcXVpcmUoXCJAY2hldnJvdGFpbi9nYXN0XCIpO1xudmFyIGxvb2thaGVhZF8xID0gcmVxdWlyZShcIi4vbG9va2FoZWFkXCIpO1xudmFyIGludGVycHJldGVyXzEgPSByZXF1aXJlKFwiLi9pbnRlcnByZXRlclwiKTtcbnZhciBnYXN0XzIgPSByZXF1aXJlKFwiQGNoZXZyb3RhaW4vZ2FzdFwiKTtcbnZhciBnYXN0XzMgPSByZXF1aXJlKFwiQGNoZXZyb3RhaW4vZ2FzdFwiKTtcbnZhciBkcm9wUmlnaHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2Ryb3BSaWdodFwiKSk7XG52YXIgY29tcGFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvY29tcGFjdFwiKSk7XG52YXIgdG9rZW5zXzEgPSByZXF1aXJlKFwiLi4vLi4vc2Nhbi90b2tlbnNcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZUxvb2thaGVhZChvcHRpb25zKSB7XG4gICAgdmFyIGxvb2thaGVhZFZhbGlkYXRpb25FcnJvck1lc3NhZ2VzID0gb3B0aW9ucy5sb29rYWhlYWRTdHJhdGVneS52YWxpZGF0ZSh7XG4gICAgICAgIHJ1bGVzOiBvcHRpb25zLnJ1bGVzLFxuICAgICAgICB0b2tlblR5cGVzOiBvcHRpb25zLnRva2VuVHlwZXMsXG4gICAgICAgIGdyYW1tYXJOYW1lOiBvcHRpb25zLmdyYW1tYXJOYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCBtYXBfMS5kZWZhdWx0KShsb29rYWhlYWRWYWxpZGF0aW9uRXJyb3JNZXNzYWdlcywgZnVuY3Rpb24gKGVycm9yTWVzc2FnZSkgeyByZXR1cm4gKF9fYXNzaWduKHsgdHlwZTogcGFyc2VyXzEuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5DVVNUT01fTE9PS0FIRUFEX1ZBTElEQVRJT04gfSwgZXJyb3JNZXNzYWdlKSk7IH0pO1xufVxuZXhwb3J0cy52YWxpZGF0ZUxvb2thaGVhZCA9IHZhbGlkYXRlTG9va2FoZWFkO1xuZnVuY3Rpb24gdmFsaWRhdGVHcmFtbWFyKHRvcExldmVscywgdG9rZW5UeXBlcywgZXJyTXNnUHJvdmlkZXIsIGdyYW1tYXJOYW1lKSB7XG4gICAgdmFyIGR1cGxpY2F0ZUVycm9ycyA9ICgwLCBmbGF0TWFwXzEuZGVmYXVsdCkodG9wTGV2ZWxzLCBmdW5jdGlvbiAoY3VyclRvcExldmVsKSB7IHJldHVybiB2YWxpZGF0ZUR1cGxpY2F0ZVByb2R1Y3Rpb25zKGN1cnJUb3BMZXZlbCwgZXJyTXNnUHJvdmlkZXIpOyB9KTtcbiAgICB2YXIgdGVybXNOYW1lc3BhY2VDb25mbGljdEVycm9ycyA9IGNoZWNrVGVybWluYWxBbmROb25lVGVybWluYWxzTmFtZVNwYWNlKHRvcExldmVscywgdG9rZW5UeXBlcywgZXJyTXNnUHJvdmlkZXIpO1xuICAgIHZhciB0b29NYW55QWx0c0Vycm9ycyA9ICgwLCBmbGF0TWFwXzEuZGVmYXVsdCkodG9wTGV2ZWxzLCBmdW5jdGlvbiAoY3VyUnVsZSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVUb29NYW55QWx0cyhjdXJSdWxlLCBlcnJNc2dQcm92aWRlcik7XG4gICAgfSk7XG4gICAgdmFyIGR1cGxpY2F0ZVJ1bGVzRXJyb3IgPSAoMCwgZmxhdE1hcF8xLmRlZmF1bHQpKHRvcExldmVscywgZnVuY3Rpb24gKGN1clJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlUnVsZURvZXNOb3RBbHJlYWR5RXhpc3QoY3VyUnVsZSwgdG9wTGV2ZWxzLCBncmFtbWFyTmFtZSwgZXJyTXNnUHJvdmlkZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBkdXBsaWNhdGVFcnJvcnMuY29uY2F0KHRlcm1zTmFtZXNwYWNlQ29uZmxpY3RFcnJvcnMsIHRvb01hbnlBbHRzRXJyb3JzLCBkdXBsaWNhdGVSdWxlc0Vycm9yKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVHcmFtbWFyID0gdmFsaWRhdGVHcmFtbWFyO1xuZnVuY3Rpb24gdmFsaWRhdGVEdXBsaWNhdGVQcm9kdWN0aW9ucyh0b3BMZXZlbFJ1bGUsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgdmFyIGNvbGxlY3RvclZpc2l0b3IgPSBuZXcgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IoKTtcbiAgICB0b3BMZXZlbFJ1bGUuYWNjZXB0KGNvbGxlY3RvclZpc2l0b3IpO1xuICAgIHZhciBhbGxSdWxlUHJvZHVjdGlvbnMgPSBjb2xsZWN0b3JWaXNpdG9yLmFsbFByb2R1Y3Rpb25zO1xuICAgIHZhciBwcm9kdWN0aW9uR3JvdXBzID0gKDAsIGdyb3VwQnlfMS5kZWZhdWx0KShhbGxSdWxlUHJvZHVjdGlvbnMsIGlkZW50aWZ5UHJvZHVjdGlvbkZvckR1cGxpY2F0ZXMpO1xuICAgIHZhciBkdXBsaWNhdGVzID0gKDAsIHBpY2tCeV8xLmRlZmF1bHQpKHByb2R1Y3Rpb25Hcm91cHMsIGZ1bmN0aW9uIChjdXJyR3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGN1cnJHcm91cC5sZW5ndGggPiAxO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSAoMCwgbWFwXzEuZGVmYXVsdCkoKDAsIHZhbHVlc18xLmRlZmF1bHQpKGR1cGxpY2F0ZXMpLCBmdW5jdGlvbiAoY3VyckR1cGxpY2F0ZXMpIHtcbiAgICAgICAgdmFyIGZpcnN0UHJvZCA9ICgwLCBmaXJzdF8xLmRlZmF1bHQpKGN1cnJEdXBsaWNhdGVzKTtcbiAgICAgICAgdmFyIG1zZyA9IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkRHVwbGljYXRlRm91bmRFcnJvcih0b3BMZXZlbFJ1bGUsIGN1cnJEdXBsaWNhdGVzKTtcbiAgICAgICAgdmFyIGRzbE5hbWUgPSAoMCwgZ2FzdF8xLmdldFByb2R1Y3Rpb25Ec2xOYW1lKShmaXJzdFByb2QpO1xuICAgICAgICB2YXIgZGVmRXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICB0eXBlOiBwYXJzZXJfMS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9QUk9EVUNUSU9OUyxcbiAgICAgICAgICAgIHJ1bGVOYW1lOiB0b3BMZXZlbFJ1bGUubmFtZSxcbiAgICAgICAgICAgIGRzbE5hbWU6IGRzbE5hbWUsXG4gICAgICAgICAgICBvY2N1cnJlbmNlOiBmaXJzdFByb2QuaWR4XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwYXJhbSA9IGdldEV4dHJhUHJvZHVjdGlvbkFyZ3VtZW50KGZpcnN0UHJvZCk7XG4gICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgZGVmRXJyb3IucGFyYW1ldGVyID0gcGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZkVycm9yO1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBpZGVudGlmeVByb2R1Y3Rpb25Gb3JEdXBsaWNhdGVzKHByb2QpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoKDAsIGdhc3RfMS5nZXRQcm9kdWN0aW9uRHNsTmFtZSkocHJvZCksIFwiXyNfXCIpLmNvbmNhdChwcm9kLmlkeCwgXCJfI19cIikuY29uY2F0KGdldEV4dHJhUHJvZHVjdGlvbkFyZ3VtZW50KHByb2QpKTtcbn1cbmV4cG9ydHMuaWRlbnRpZnlQcm9kdWN0aW9uRm9yRHVwbGljYXRlcyA9IGlkZW50aWZ5UHJvZHVjdGlvbkZvckR1cGxpY2F0ZXM7XG5mdW5jdGlvbiBnZXRFeHRyYVByb2R1Y3Rpb25Bcmd1bWVudChwcm9kKSB7XG4gICAgaWYgKHByb2QgaW5zdGFuY2VvZiBnYXN0XzIuVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIHByb2QudGVybWluYWxUeXBlLm5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBnYXN0XzIuTm9uVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIHByb2Qubm9uVGVybWluYWxOYW1lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxudmFyIE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3RvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFsbFByb2R1Y3Rpb25zID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0Tm9uVGVybWluYWwgPSBmdW5jdGlvbiAoc3VicnVsZSkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2goc3VicnVsZSk7XG4gICAgfTtcbiAgICBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChvcHRpb24pO1xuICAgIH07XG4gICAgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAobWFueVNlcCkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gobWFueVNlcCk7XG4gICAgfTtcbiAgICBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5ID0gZnVuY3Rpb24gKGF0TGVhc3RPbmUpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKGF0TGVhc3RPbmUpO1xuICAgIH07XG4gICAgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAoYXRMZWFzdE9uZVNlcCkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2goYXRMZWFzdE9uZVNlcCk7XG4gICAgfTtcbiAgICBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uID0gZnVuY3Rpb24gKG1hbnkpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG1hbnkpO1xuICAgIH07XG4gICAgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpb24gPSBmdW5jdGlvbiAob3IpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG9yKTtcbiAgICB9O1xuICAgIE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yLnByb3RvdHlwZS52aXNpdFRlcm1pbmFsID0gZnVuY3Rpb24gKHRlcm1pbmFsKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0ZXJtaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3I7XG59KGdhc3RfMy5HQXN0VmlzaXRvcikpO1xuZXhwb3J0cy5PY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3RvciA9IE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yO1xuZnVuY3Rpb24gdmFsaWRhdGVSdWxlRG9lc05vdEFscmVhZHlFeGlzdChydWxlLCBhbGxSdWxlcywgY2xhc3NOYW1lLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgb2NjdXJyZW5jZXMgPSAoMCwgcmVkdWNlXzEuZGVmYXVsdCkoYWxsUnVsZXMsIGZ1bmN0aW9uIChyZXN1bHQsIGN1clJ1bGUpIHtcbiAgICAgICAgaWYgKGN1clJ1bGUubmFtZSA9PT0gcnVsZS5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIDApO1xuICAgIGlmIChvY2N1cnJlbmNlcyA+IDEpIHtcbiAgICAgICAgdmFyIGVyck1zZyA9IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkRHVwbGljYXRlUnVsZU5hbWVFcnJvcih7XG4gICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHJ1bGUsXG4gICAgICAgICAgICBncmFtbWFyTmFtZTogY2xhc3NOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICB0eXBlOiBwYXJzZXJfMS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9SVUxFX05BTUUsXG4gICAgICAgICAgICBydWxlTmFtZTogcnVsZS5uYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0cy52YWxpZGF0ZVJ1bGVEb2VzTm90QWxyZWFkeUV4aXN0ID0gdmFsaWRhdGVSdWxlRG9lc05vdEFscmVhZHlFeGlzdDtcbi8vIFRPRE86IGlzIHRoZXJlIGFueXdheSB0byBnZXQgb25seSB0aGUgcnVsZSBuYW1lcyBvZiBydWxlcyBpbmhlcml0ZWQgZnJvbSB0aGUgc3VwZXIgZ3JhbW1hcnM/XG4vLyBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBJR3JhbW1hckVycm9yUHJvdmlkZXIgYmVjYXVzZSB0aGUgdmFsaWRhdGlvbiBjYW5ub3QgYmUgcGVyZm9ybWVkIG9uXG4vLyBUaGUgZ3JhbW1hciBzdHJ1Y3R1cmUsIG9ubHkgYXQgcnVudGltZS5cbmZ1bmN0aW9uIHZhbGlkYXRlUnVsZUlzT3ZlcnJpZGRlbihydWxlTmFtZSwgZGVmaW5lZFJ1bGVzTmFtZXMsIGNsYXNzTmFtZSkge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgZXJyTXNnO1xuICAgIGlmICghKDAsIGluY2x1ZGVzXzEuZGVmYXVsdCkoZGVmaW5lZFJ1bGVzTmFtZXMsIHJ1bGVOYW1lKSkge1xuICAgICAgICBlcnJNc2cgPVxuICAgICAgICAgICAgXCJJbnZhbGlkIHJ1bGUgb3ZlcnJpZGUsIHJ1bGU6IC0+XCIuY29uY2F0KHJ1bGVOYW1lLCBcIjwtIGNhbm5vdCBiZSBvdmVycmlkZGVuIGluIHRoZSBncmFtbWFyOiAtPlwiKS5jb25jYXQoY2xhc3NOYW1lLCBcIjwtXCIpICtcbiAgICAgICAgICAgICAgICBcImFzIGl0IGlzIG5vdCBkZWZpbmVkIGluIGFueSBvZiB0aGUgc3VwZXIgZ3JhbW1hcnMgXCI7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZyxcbiAgICAgICAgICAgIHR5cGU6IHBhcnNlcl8xLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9SVUxFX09WRVJSSURFLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGVOYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0cy52YWxpZGF0ZVJ1bGVJc092ZXJyaWRkZW4gPSB2YWxpZGF0ZVJ1bGVJc092ZXJyaWRkZW47XG5mdW5jdGlvbiB2YWxpZGF0ZU5vTGVmdFJlY3Vyc2lvbih0b3BSdWxlLCBjdXJyUnVsZSwgZXJyTXNnUHJvdmlkZXIsIHBhdGgpIHtcbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBbXTsgfVxuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgbmV4dE5vblRlcm1pbmFscyA9IGdldEZpcnN0Tm9uZVRlcm1pbmFsKGN1cnJSdWxlLmRlZmluaXRpb24pO1xuICAgIGlmICgoMCwgaXNFbXB0eV8xLmRlZmF1bHQpKG5leHROb25UZXJtaW5hbHMpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBydWxlTmFtZSA9IHRvcFJ1bGUubmFtZTtcbiAgICAgICAgdmFyIGZvdW5kTGVmdFJlY3Vyc2lvbiA9ICgwLCBpbmNsdWRlc18xLmRlZmF1bHQpKG5leHROb25UZXJtaW5hbHMsIHRvcFJ1bGUpO1xuICAgICAgICBpZiAoZm91bmRMZWZ0UmVjdXJzaW9uKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnUHJvdmlkZXIuYnVpbGRMZWZ0UmVjdXJzaW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHRvcFJ1bGUsXG4gICAgICAgICAgICAgICAgICAgIGxlZnRSZWN1cnNpb25QYXRoOiBwYXRoXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdHlwZTogcGFyc2VyXzEuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5MRUZUX1JFQ1VSU0lPTixcbiAgICAgICAgICAgICAgICBydWxlTmFtZTogcnVsZU5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGFyZSBvbmx5IGxvb2tpbmcgZm9yIGN5Y2xpYyBwYXRocyBsZWFkaW5nIGJhY2sgdG8gdGhlIHNwZWNpZmljIHRvcFJ1bGVcbiAgICAgICAgLy8gb3RoZXIgY3ljbGljIHBhdGhzIGFyZSBpZ25vcmVkLCB3ZSBzdGlsbCBuZWVkIHRoaXMgZGlmZmVyZW5jZSB0byBhdm9pZCBpbmZpbml0ZSBsb29wcy4uLlxuICAgICAgICB2YXIgdmFsaWROZXh0U3RlcHMgPSAoMCwgZGlmZmVyZW5jZV8xLmRlZmF1bHQpKG5leHROb25UZXJtaW5hbHMsIHBhdGguY29uY2F0KFt0b3BSdWxlXSkpO1xuICAgICAgICB2YXIgZXJyb3JzRnJvbU5leHRTdGVwcyA9ICgwLCBmbGF0TWFwXzEuZGVmYXVsdCkodmFsaWROZXh0U3RlcHMsIGZ1bmN0aW9uIChjdXJyUmVmUnVsZSkge1xuICAgICAgICAgICAgdmFyIG5ld1BhdGggPSAoMCwgY2xvbmVfMS5kZWZhdWx0KShwYXRoKTtcbiAgICAgICAgICAgIG5ld1BhdGgucHVzaChjdXJyUmVmUnVsZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVOb0xlZnRSZWN1cnNpb24odG9wUnVsZSwgY3VyclJlZlJ1bGUsIGVyck1zZ1Byb3ZpZGVyLCBuZXdQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcnMuY29uY2F0KGVycm9yc0Zyb21OZXh0U3RlcHMpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVOb0xlZnRSZWN1cnNpb24gPSB2YWxpZGF0ZU5vTGVmdFJlY3Vyc2lvbjtcbmZ1bmN0aW9uIGdldEZpcnN0Tm9uZVRlcm1pbmFsKGRlZmluaXRpb24pIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKCgwLCBpc0VtcHR5XzEuZGVmYXVsdCkoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIGZpcnN0UHJvZCA9ICgwLCBmaXJzdF8xLmRlZmF1bHQpKGRlZmluaXRpb24pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGZpcnN0UHJvZCBpbnN0YW5jZW9mIGdhc3RfMi5Ob25UZXJtaW5hbCkge1xuICAgICAgICByZXN1bHQucHVzaChmaXJzdFByb2QucmVmZXJlbmNlZFJ1bGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdFByb2QgaW5zdGFuY2VvZiBnYXN0XzIuQWx0ZXJuYXRpdmUgfHxcbiAgICAgICAgZmlyc3RQcm9kIGluc3RhbmNlb2YgZ2FzdF8yLk9wdGlvbiB8fFxuICAgICAgICBmaXJzdFByb2QgaW5zdGFuY2VvZiBnYXN0XzIuUmVwZXRpdGlvbk1hbmRhdG9yeSB8fFxuICAgICAgICBmaXJzdFByb2QgaW5zdGFuY2VvZiBnYXN0XzIuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgfHxcbiAgICAgICAgZmlyc3RQcm9kIGluc3RhbmNlb2YgZ2FzdF8yLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yIHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIGdhc3RfMi5SZXBldGl0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZ2V0Rmlyc3ROb25lVGVybWluYWwoZmlyc3RQcm9kLmRlZmluaXRpb24pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RQcm9kIGluc3RhbmNlb2YgZ2FzdF8yLkFsdGVybmF0aW9uKSB7XG4gICAgICAgIC8vIGVhY2ggc3ViIGRlZmluaXRpb24gaW4gYWx0ZXJuYXRpb24gaXMgYSBGTEFUXG4gICAgICAgIHJlc3VsdCA9ICgwLCBmbGF0dGVuXzEuZGVmYXVsdCkoKDAsIG1hcF8xLmRlZmF1bHQpKGZpcnN0UHJvZC5kZWZpbml0aW9uLCBmdW5jdGlvbiAoY3VyclN1YkRlZikge1xuICAgICAgICAgICAgcmV0dXJuIGdldEZpcnN0Tm9uZVRlcm1pbmFsKGN1cnJTdWJEZWYuZGVmaW5pdGlvbik7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RQcm9kIGluc3RhbmNlb2YgZ2FzdF8yLlRlcm1pbmFsKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgdG8gc2VlLCBtb3ZlIGFsb25nXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbiAgICB2YXIgaXNGaXJzdE9wdGlvbmFsID0gKDAsIGdhc3RfMS5pc09wdGlvbmFsUHJvZCkoZmlyc3RQcm9kKTtcbiAgICB2YXIgaGFzTW9yZSA9IGRlZmluaXRpb24ubGVuZ3RoID4gMTtcbiAgICBpZiAoaXNGaXJzdE9wdGlvbmFsICYmIGhhc01vcmUpIHtcbiAgICAgICAgdmFyIHJlc3QgPSAoMCwgZHJvcF8xLmRlZmF1bHQpKGRlZmluaXRpb24pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChnZXRGaXJzdE5vbmVUZXJtaW5hbChyZXN0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0Rmlyc3ROb25lVGVybWluYWwgPSBnZXRGaXJzdE5vbmVUZXJtaW5hbDtcbnZhciBPckNvbGxlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3JDb2xsZWN0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3JDb2xsZWN0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hbHRlcm5hdGlvbnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPckNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuYWx0ZXJuYXRpb25zLnB1c2gobm9kZSk7XG4gICAgfTtcbiAgICByZXR1cm4gT3JDb2xsZWN0b3I7XG59KGdhc3RfMy5HQXN0VmlzaXRvcikpO1xuZnVuY3Rpb24gdmFsaWRhdGVFbXB0eU9yQWx0ZXJuYXRpdmUodG9wTGV2ZWxSdWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBvckNvbGxlY3RvciA9IG5ldyBPckNvbGxlY3RvcigpO1xuICAgIHRvcExldmVsUnVsZS5hY2NlcHQob3JDb2xsZWN0b3IpO1xuICAgIHZhciBvcnMgPSBvckNvbGxlY3Rvci5hbHRlcm5hdGlvbnM7XG4gICAgdmFyIGVycm9ycyA9ICgwLCBmbGF0TWFwXzEuZGVmYXVsdCkob3JzLCBmdW5jdGlvbiAoY3Vyck9yKSB7XG4gICAgICAgIHZhciBleGNlcHRMYXN0ID0gKDAsIGRyb3BSaWdodF8xLmRlZmF1bHQpKGN1cnJPci5kZWZpbml0aW9uKTtcbiAgICAgICAgcmV0dXJuICgwLCBmbGF0TWFwXzEuZGVmYXVsdCkoZXhjZXB0TGFzdCwgZnVuY3Rpb24gKGN1cnJBbHRlcm5hdGl2ZSwgY3VyckFsdElkeCkge1xuICAgICAgICAgICAgdmFyIHBvc3NpYmxlRmlyc3RJbkFsdCA9ICgwLCBpbnRlcnByZXRlcl8xLm5leHRQb3NzaWJsZVRva2Vuc0FmdGVyKShbY3VyckFsdGVybmF0aXZlXSwgW10sIHRva2Vuc18xLnRva2VuU3RydWN0dXJlZE1hdGNoZXIsIDEpO1xuICAgICAgICAgICAgaWYgKCgwLCBpc0VtcHR5XzEuZGVmYXVsdCkocG9zc2libGVGaXJzdEluQWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkRW1wdHlBbHRlcm5hdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHRvcExldmVsUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGlvbjogY3Vyck9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5Q2hvaWNlSWR4OiBjdXJyQWx0SWR4XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHBhcnNlcl8xLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuTk9ORV9MQVNUX0VNUFRZX0FMVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0b3BMZXZlbFJ1bGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9jY3VycmVuY2U6IGN1cnJPci5pZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZTogY3VyckFsdElkeCArIDFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnRzLnZhbGlkYXRlRW1wdHlPckFsdGVybmF0aXZlID0gdmFsaWRhdGVFbXB0eU9yQWx0ZXJuYXRpdmU7XG5mdW5jdGlvbiB2YWxpZGF0ZUFtYmlndW91c0FsdGVybmF0aW9uQWx0ZXJuYXRpdmVzKHRvcExldmVsUnVsZSwgZ2xvYmFsTWF4TG9va2FoZWFkLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBvckNvbGxlY3RvciA9IG5ldyBPckNvbGxlY3RvcigpO1xuICAgIHRvcExldmVsUnVsZS5hY2NlcHQob3JDb2xsZWN0b3IpO1xuICAgIHZhciBvcnMgPSBvckNvbGxlY3Rvci5hbHRlcm5hdGlvbnM7XG4gICAgLy8gTmV3IEhhbmRsaW5nIG9mIGlnbm9yaW5nIGFtYmlndWl0aWVzXG4gICAgLy8gLSBodHRwczovL2dpdGh1Yi5jb20vY2hldnJvdGFpbi9jaGV2cm90YWluL2lzc3Vlcy84NjlcbiAgICBvcnMgPSAoMCwgcmVqZWN0XzEuZGVmYXVsdCkob3JzLCBmdW5jdGlvbiAoY3Vyck9yKSB7IHJldHVybiBjdXJyT3IuaWdub3JlQW1iaWd1aXRpZXMgPT09IHRydWU7IH0pO1xuICAgIHZhciBlcnJvcnMgPSAoMCwgZmxhdE1hcF8xLmRlZmF1bHQpKG9ycywgZnVuY3Rpb24gKGN1cnJPcikge1xuICAgICAgICB2YXIgY3Vyck9jY3VycmVuY2UgPSBjdXJyT3IuaWR4O1xuICAgICAgICB2YXIgYWN0dWFsTWF4TG9va2FoZWFkID0gY3Vyck9yLm1heExvb2thaGVhZCB8fCBnbG9iYWxNYXhMb29rYWhlYWQ7XG4gICAgICAgIHZhciBhbHRlcm5hdGl2ZXMgPSAoMCwgbG9va2FoZWFkXzEuZ2V0TG9va2FoZWFkUGF0aHNGb3JPcikoY3Vyck9jY3VycmVuY2UsIHRvcExldmVsUnVsZSwgYWN0dWFsTWF4TG9va2FoZWFkLCBjdXJyT3IpO1xuICAgICAgICB2YXIgYWx0c0FtYmlndWl0eUVycm9ycyA9IGNoZWNrQWx0ZXJuYXRpdmVzQW1iaWd1aXRpZXMoYWx0ZXJuYXRpdmVzLCBjdXJyT3IsIHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpO1xuICAgICAgICB2YXIgYWx0c1ByZWZpeEFtYmlndWl0eUVycm9ycyA9IGNoZWNrUHJlZml4QWx0ZXJuYXRpdmVzQW1iaWd1aXRpZXMoYWx0ZXJuYXRpdmVzLCBjdXJyT3IsIHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpO1xuICAgICAgICByZXR1cm4gYWx0c0FtYmlndWl0eUVycm9ycy5jb25jYXQoYWx0c1ByZWZpeEFtYmlndWl0eUVycm9ycyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydHMudmFsaWRhdGVBbWJpZ3VvdXNBbHRlcm5hdGlvbkFsdGVybmF0aXZlcyA9IHZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXM7XG52YXIgUmVwZXRpdGlvbkNvbGxlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVwZXRpdGlvbkNvbGxlY3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXBldGl0aW9uQ29sbGVjdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWxsUHJvZHVjdGlvbnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXBldGl0aW9uQ29sbGVjdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKG1hbnlTZXApIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG1hbnlTZXApO1xuICAgIH07XG4gICAgUmVwZXRpdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5ID0gZnVuY3Rpb24gKGF0TGVhc3RPbmUpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKGF0TGVhc3RPbmUpO1xuICAgIH07XG4gICAgUmVwZXRpdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciA9IGZ1bmN0aW9uIChhdExlYXN0T25lU2VwKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChhdExlYXN0T25lU2VwKTtcbiAgICB9O1xuICAgIFJlcGV0aXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbiA9IGZ1bmN0aW9uIChtYW55KSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChtYW55KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXBldGl0aW9uQ29sbGVjdG9yO1xufShnYXN0XzMuR0FzdFZpc2l0b3IpKTtcbmV4cG9ydHMuUmVwZXRpdGlvbkNvbGxlY3RvciA9IFJlcGV0aXRpb25Db2xsZWN0b3I7XG5mdW5jdGlvbiB2YWxpZGF0ZVRvb01hbnlBbHRzKHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgb3JDb2xsZWN0b3IgPSBuZXcgT3JDb2xsZWN0b3IoKTtcbiAgICB0b3BMZXZlbFJ1bGUuYWNjZXB0KG9yQ29sbGVjdG9yKTtcbiAgICB2YXIgb3JzID0gb3JDb2xsZWN0b3IuYWx0ZXJuYXRpb25zO1xuICAgIHZhciBlcnJvcnMgPSAoMCwgZmxhdE1hcF8xLmRlZmF1bHQpKG9ycywgZnVuY3Rpb24gKGN1cnJPcikge1xuICAgICAgICBpZiAoY3Vyck9yLmRlZmluaXRpb24ubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnUHJvdmlkZXIuYnVpbGRUb29NYW55QWx0ZXJuYXRpdmVzRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiB0b3BMZXZlbFJ1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGlvbjogY3Vyck9yXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXJzZXJfMS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLlRPT19NQU5ZX0FMVFMsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0b3BMZXZlbFJ1bGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb2NjdXJyZW5jZTogY3Vyck9yLmlkeFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0cy52YWxpZGF0ZVRvb01hbnlBbHRzID0gdmFsaWRhdGVUb29NYW55QWx0cztcbmZ1bmN0aW9uIHZhbGlkYXRlU29tZU5vbkVtcHR5TG9va2FoZWFkUGF0aCh0b3BMZXZlbFJ1bGVzLCBtYXhMb29rYWhlYWQsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICgwLCBmb3JFYWNoXzEuZGVmYXVsdCkodG9wTGV2ZWxSdWxlcywgZnVuY3Rpb24gKGN1cnJUb3BSdWxlKSB7XG4gICAgICAgIHZhciBjb2xsZWN0b3JWaXNpdG9yID0gbmV3IFJlcGV0aXRpb25Db2xsZWN0b3IoKTtcbiAgICAgICAgY3VyclRvcFJ1bGUuYWNjZXB0KGNvbGxlY3RvclZpc2l0b3IpO1xuICAgICAgICB2YXIgYWxsUnVsZVByb2R1Y3Rpb25zID0gY29sbGVjdG9yVmlzaXRvci5hbGxQcm9kdWN0aW9ucztcbiAgICAgICAgKDAsIGZvckVhY2hfMS5kZWZhdWx0KShhbGxSdWxlUHJvZHVjdGlvbnMsIGZ1bmN0aW9uIChjdXJyUHJvZCkge1xuICAgICAgICAgICAgdmFyIHByb2RUeXBlID0gKDAsIGxvb2thaGVhZF8xLmdldFByb2RUeXBlKShjdXJyUHJvZCk7XG4gICAgICAgICAgICB2YXIgYWN0dWFsTWF4TG9va2FoZWFkID0gY3VyclByb2QubWF4TG9va2FoZWFkIHx8IG1heExvb2thaGVhZDtcbiAgICAgICAgICAgIHZhciBjdXJyT2NjdXJyZW5jZSA9IGN1cnJQcm9kLmlkeDtcbiAgICAgICAgICAgIHZhciBwYXRocyA9ICgwLCBsb29rYWhlYWRfMS5nZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZCkoY3Vyck9jY3VycmVuY2UsIGN1cnJUb3BSdWxlLCBwcm9kVHlwZSwgYWN0dWFsTWF4TG9va2FoZWFkKTtcbiAgICAgICAgICAgIHZhciBwYXRoc0luc2lkZVByb2R1Y3Rpb24gPSBwYXRoc1swXTtcbiAgICAgICAgICAgIGlmICgoMCwgaXNFbXB0eV8xLmRlZmF1bHQpKCgwLCBmbGF0dGVuXzEuZGVmYXVsdCkocGF0aHNJbnNpZGVQcm9kdWN0aW9uKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyTXNnID0gZXJyTXNnUHJvdmlkZXIuYnVpbGRFbXB0eVJlcGV0aXRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHRvcExldmVsUnVsZTogY3VyclRvcFJ1bGUsXG4gICAgICAgICAgICAgICAgICAgIHJlcGV0aXRpb246IGN1cnJQcm9kXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHBhcnNlcl8xLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuTk9fTk9OX0VNUFRZX0xPT0tBSEVBRCxcbiAgICAgICAgICAgICAgICAgICAgcnVsZU5hbWU6IGN1cnJUb3BSdWxlLm5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydHMudmFsaWRhdGVTb21lTm9uRW1wdHlMb29rYWhlYWRQYXRoID0gdmFsaWRhdGVTb21lTm9uRW1wdHlMb29rYWhlYWRQYXRoO1xuZnVuY3Rpb24gY2hlY2tBbHRlcm5hdGl2ZXNBbWJpZ3VpdGllcyhhbHRlcm5hdGl2ZXMsIGFsdGVybmF0aW9uLCBydWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBmb3VuZEFtYmlndW91c1BhdGhzID0gW107XG4gICAgdmFyIGlkZW50aWNhbEFtYmlndWl0aWVzID0gKDAsIHJlZHVjZV8xLmRlZmF1bHQpKGFsdGVybmF0aXZlcywgZnVuY3Rpb24gKHJlc3VsdCwgY3VyckFsdCwgY3VyckFsdElkeCkge1xuICAgICAgICAvLyBpZ25vcmUgKHNraXApIGFtYmlndWl0aWVzIHdpdGggdGhpcyBhbHRlcm5hdGl2ZVxuICAgICAgICBpZiAoYWx0ZXJuYXRpb24uZGVmaW5pdGlvbltjdXJyQWx0SWR4XS5pZ25vcmVBbWJpZ3VpdGllcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKGN1cnJBbHQsIGZ1bmN0aW9uIChjdXJyUGF0aCkge1xuICAgICAgICAgICAgdmFyIGFsdHNDdXJyUGF0aEFwcGVhcnNJbiA9IFtjdXJyQWx0SWR4XTtcbiAgICAgICAgICAgICgwLCBmb3JFYWNoXzEuZGVmYXVsdCkoYWx0ZXJuYXRpdmVzLCBmdW5jdGlvbiAoY3Vyck90aGVyQWx0LCBjdXJyT3RoZXJBbHRJZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyckFsdElkeCAhPT0gY3Vyck90aGVyQWx0SWR4ICYmXG4gICAgICAgICAgICAgICAgICAgICgwLCBsb29rYWhlYWRfMS5jb250YWluc1BhdGgpKGN1cnJPdGhlckFsdCwgY3VyclBhdGgpICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSAoc2tpcCkgYW1iaWd1aXRpZXMgd2l0aCB0aGlzIFwib3RoZXJcIiBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGlvbi5kZWZpbml0aW9uW2N1cnJPdGhlckFsdElkeF0uaWdub3JlQW1iaWd1aXRpZXMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWx0c0N1cnJQYXRoQXBwZWFyc0luLnB1c2goY3Vyck90aGVyQWx0SWR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhbHRzQ3VyclBhdGhBcHBlYXJzSW4ubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgICAgICEoMCwgbG9va2FoZWFkXzEuY29udGFpbnNQYXRoKShmb3VuZEFtYmlndW91c1BhdGhzLCBjdXJyUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZEFtYmlndW91c1BhdGhzLnB1c2goY3VyclBhdGgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYWx0czogYWx0c0N1cnJQYXRoQXBwZWFyc0luLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdXJyUGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGN1cnJFcnJvcnMgPSAoMCwgbWFwXzEuZGVmYXVsdCkoaWRlbnRpY2FsQW1iaWd1aXRpZXMsIGZ1bmN0aW9uIChjdXJyQW1iRGVzY3JpcHRvcikge1xuICAgICAgICB2YXIgYW1iZ0luZGljZXMgPSAoMCwgbWFwXzEuZGVmYXVsdCkoY3VyckFtYkRlc2NyaXB0b3IuYWx0cywgZnVuY3Rpb24gKGN1cnJBbHRJZHgpIHsgcmV0dXJuIGN1cnJBbHRJZHggKyAxOyB9KTtcbiAgICAgICAgdmFyIGN1cnJNZXNzYWdlID0gZXJyTXNnUHJvdmlkZXIuYnVpbGRBbHRlcm5hdGlvbkFtYmlndWl0eUVycm9yKHtcbiAgICAgICAgICAgIHRvcExldmVsUnVsZTogcnVsZSxcbiAgICAgICAgICAgIGFsdGVybmF0aW9uOiBhbHRlcm5hdGlvbixcbiAgICAgICAgICAgIGFtYmlndWl0eUluZGljZXM6IGFtYmdJbmRpY2VzLFxuICAgICAgICAgICAgcHJlZml4UGF0aDogY3VyckFtYkRlc2NyaXB0b3IucGF0aFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGN1cnJNZXNzYWdlLFxuICAgICAgICAgICAgdHlwZTogcGFyc2VyXzEuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5BTUJJR1VPVVNfQUxUUyxcbiAgICAgICAgICAgIHJ1bGVOYW1lOiBydWxlLm5hbWUsXG4gICAgICAgICAgICBvY2N1cnJlbmNlOiBhbHRlcm5hdGlvbi5pZHgsXG4gICAgICAgICAgICBhbHRlcm5hdGl2ZXM6IGN1cnJBbWJEZXNjcmlwdG9yLmFsdHNcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gY3VyckVycm9ycztcbn1cbmZ1bmN0aW9uIGNoZWNrUHJlZml4QWx0ZXJuYXRpdmVzQW1iaWd1aXRpZXMoYWx0ZXJuYXRpdmVzLCBhbHRlcm5hdGlvbiwgcnVsZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICAvLyBmbGF0dGVuXG4gICAgdmFyIHBhdGhzQW5kSW5kaWNlcyA9ICgwLCByZWR1Y2VfMS5kZWZhdWx0KShhbHRlcm5hdGl2ZXMsIGZ1bmN0aW9uIChyZXN1bHQsIGN1cnJBbHQsIGlkeCkge1xuICAgICAgICB2YXIgY3VyclBhdGhzQW5kSWR4ID0gKDAsIG1hcF8xLmRlZmF1bHQpKGN1cnJBbHQsIGZ1bmN0aW9uIChjdXJyUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWR4OiBpZHgsIHBhdGg6IGN1cnJQYXRoIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChjdXJyUGF0aHNBbmRJZHgpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgZXJyb3JzID0gKDAsIGNvbXBhY3RfMS5kZWZhdWx0KSgoMCwgZmxhdE1hcF8xLmRlZmF1bHQpKHBhdGhzQW5kSW5kaWNlcywgZnVuY3Rpb24gKGN1cnJQYXRoQW5kSWR4KSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGl2ZUdhc3QgPSBhbHRlcm5hdGlvbi5kZWZpbml0aW9uW2N1cnJQYXRoQW5kSWR4LmlkeF07XG4gICAgICAgIC8vIGlnbm9yZSAoc2tpcCkgYW1iaWd1aXRpZXMgd2l0aCB0aGlzIGFsdGVybmF0aXZlXG4gICAgICAgIGlmIChhbHRlcm5hdGl2ZUdhc3QuaWdub3JlQW1iaWd1aXRpZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFyZ2V0SWR4ID0gY3VyclBhdGhBbmRJZHguaWR4O1xuICAgICAgICB2YXIgdGFyZ2V0UGF0aCA9IGN1cnJQYXRoQW5kSWR4LnBhdGg7XG4gICAgICAgIHZhciBwcmVmaXhBbWJpZ3VpdGllc1BhdGhzQW5kSW5kaWNlcyA9ICgwLCBmaWx0ZXJfMS5kZWZhdWx0KShwYXRoc0FuZEluZGljZXMsIGZ1bmN0aW9uIChzZWFyY2hQYXRoQW5kSWR4KSB7XG4gICAgICAgICAgICAvLyBwcmVmaXggYW1iaWd1aXR5IGNhbiBvbmx5IGJlIGNyZWF0ZWQgZnJvbSBsb3dlciBpZHggKGhpZ2hlciBwcmlvcml0eSkgcGF0aFxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIGlnbm9yZSAoc2tpcCkgYW1iaWd1aXRpZXMgd2l0aCB0aGlzIFwib3RoZXJcIiBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgYWx0ZXJuYXRpb24uZGVmaW5pdGlvbltzZWFyY2hQYXRoQW5kSWR4LmlkeF0uaWdub3JlQW1iaWd1aXRpZXMgIT09XG4gICAgICAgICAgICAgICAgdHJ1ZSAmJlxuICAgICAgICAgICAgICAgIHNlYXJjaFBhdGhBbmRJZHguaWR4IDwgdGFyZ2V0SWR4ICYmXG4gICAgICAgICAgICAgICAgLy8gY2hlY2tpbmcgZm9yIHN0cmljdCBwcmVmaXggYmVjYXVzZSBpZGVudGljYWwgbG9va2FoZWFkc1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgYmUgZGV0ZWN0ZWQgdXNpbmcgYSBkaWZmZXJlbnQgdmFsaWRhdGlvbi5cbiAgICAgICAgICAgICAgICAoMCwgbG9va2FoZWFkXzEuaXNTdHJpY3RQcmVmaXhPZlBhdGgpKHNlYXJjaFBhdGhBbmRJZHgucGF0aCwgdGFyZ2V0UGF0aCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGN1cnJQYXRoUHJlZml4RXJyb3JzID0gKDAsIG1hcF8xLmRlZmF1bHQpKHByZWZpeEFtYmlndWl0aWVzUGF0aHNBbmRJbmRpY2VzLCBmdW5jdGlvbiAoY3VyckFtYlBhdGhBbmRJZHgpIHtcbiAgICAgICAgICAgIHZhciBhbWJnSW5kaWNlcyA9IFtjdXJyQW1iUGF0aEFuZElkeC5pZHggKyAxLCB0YXJnZXRJZHggKyAxXTtcbiAgICAgICAgICAgIHZhciBvY2N1cnJlbmNlID0gYWx0ZXJuYXRpb24uaWR4ID09PSAwID8gXCJcIiA6IGFsdGVybmF0aW9uLmlkeDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXJyTXNnUHJvdmlkZXIuYnVpbGRBbHRlcm5hdGlvblByZWZpeEFtYmlndWl0eUVycm9yKHtcbiAgICAgICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHJ1bGUsXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpb246IGFsdGVybmF0aW9uLFxuICAgICAgICAgICAgICAgIGFtYmlndWl0eUluZGljZXM6IGFtYmdJbmRpY2VzLFxuICAgICAgICAgICAgICAgIHByZWZpeFBhdGg6IGN1cnJBbWJQYXRoQW5kSWR4LnBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHR5cGU6IHBhcnNlcl8xLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuQU1CSUdVT1VTX1BSRUZJWF9BTFRTLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBydWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZTogb2NjdXJyZW5jZSxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZXM6IGFtYmdJbmRpY2VzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGN1cnJQYXRoUHJlZml4RXJyb3JzO1xuICAgIH0pKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0cy5jaGVja1ByZWZpeEFsdGVybmF0aXZlc0FtYmlndWl0aWVzID0gY2hlY2tQcmVmaXhBbHRlcm5hdGl2ZXNBbWJpZ3VpdGllcztcbmZ1bmN0aW9uIGNoZWNrVGVybWluYWxBbmROb25lVGVybWluYWxzTmFtZVNwYWNlKHRvcExldmVscywgdG9rZW5UeXBlcywgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHRva2VuTmFtZXMgPSAoMCwgbWFwXzEuZGVmYXVsdCkodG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUb2tlbikgeyByZXR1cm4gY3VyclRva2VuLm5hbWU7IH0pO1xuICAgICgwLCBmb3JFYWNoXzEuZGVmYXVsdCkodG9wTGV2ZWxzLCBmdW5jdGlvbiAoY3VyclJ1bGUpIHtcbiAgICAgICAgdmFyIGN1cnJSdWxlTmFtZSA9IGN1cnJSdWxlLm5hbWU7XG4gICAgICAgIGlmICgoMCwgaW5jbHVkZXNfMS5kZWZhdWx0KSh0b2tlbk5hbWVzLCBjdXJyUnVsZU5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgZXJyTXNnID0gZXJyTXNnUHJvdmlkZXIuYnVpbGROYW1lc3BhY2VDb25mbGljdEVycm9yKGN1cnJSdWxlKTtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgdHlwZTogcGFyc2VyXzEuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5DT05GTElDVF9UT0tFTlNfUlVMRVNfTkFNRVNQQUNFLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBjdXJyUnVsZU5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/checks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/first.js":
/*!****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/first.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.firstForTerminal = exports.firstForBranching = exports.firstForSequence = exports.first = void 0;\nvar flatten_1 = __importDefault(__webpack_require__(/*! lodash/flatten */ \"(ssr)/./node_modules/lodash/flatten.js\"));\nvar uniq_1 = __importDefault(__webpack_require__(/*! lodash/uniq */ \"(ssr)/./node_modules/lodash/uniq.js\"));\nvar map_1 = __importDefault(__webpack_require__(/*! lodash/map */ \"(ssr)/./node_modules/lodash/map.js\"));\nvar gast_1 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nvar gast_2 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nfunction first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof gast_1.NonTerminal) {\n        // this could in theory cause infinite loops if\n        // (1) prod A refs prod B.\n        // (2) prod B refs prod A\n        // (3) AB can match the empty set\n        // in other words a cycle where everything is optional so the first will keep\n        // looking ahead for the next optional part and will never exit\n        // currently there is no safeguard for this unique edge case because\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\n        return first(prod.referencedRule);\n    }\n    else if (prod instanceof gast_1.Terminal) {\n        return firstForTerminal(prod);\n    }\n    else if ((0, gast_2.isSequenceProd)(prod)) {\n        return firstForSequence(prod);\n    }\n    else if ((0, gast_2.isBranchingProd)(prod)) {\n        return firstForBranching(prod);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexports.first = first;\nfunction firstForSequence(prod) {\n    var firstSet = [];\n    var seq = prod.definition;\n    var nextSubProdIdx = 0;\n    var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    var currSubProd;\n    // so we enter the loop at least once (if the definition is not empty\n    var isLastInnerProdOptional = true;\n    // scan a sequence until it's end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = (0, gast_2.isOptionalProd)(currSubProd);\n        firstSet = firstSet.concat(first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    }\n    return (0, uniq_1.default)(firstSet);\n}\nexports.firstForSequence = firstForSequence;\nfunction firstForBranching(prod) {\n    var allAlternativesFirsts = (0, map_1.default)(prod.definition, function (innerProd) {\n        return first(innerProd);\n    });\n    return (0, uniq_1.default)((0, flatten_1.default)(allAlternativesFirsts));\n}\nexports.firstForBranching = firstForBranching;\nfunction firstForTerminal(terminal) {\n    return [terminal.terminalType];\n}\nexports.firstForTerminal = firstForTerminal;\n//# sourceMappingURL=first.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvZmlyc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyxhQUFhO0FBQy9GLGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCw2QkFBNkIsbUJBQU8sQ0FBQyx3REFBYTtBQUNsRCw0QkFBNEIsbUJBQU8sQ0FBQyxzREFBWTtBQUNoRCxhQUFhLG1CQUFPLENBQUMsOEVBQWtCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZ3JhbW1hci9maXJzdC5qcz80OGM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5maXJzdEZvclRlcm1pbmFsID0gZXhwb3J0cy5maXJzdEZvckJyYW5jaGluZyA9IGV4cG9ydHMuZmlyc3RGb3JTZXF1ZW5jZSA9IGV4cG9ydHMuZmlyc3QgPSB2b2lkIDA7XG52YXIgZmxhdHRlbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZmxhdHRlblwiKSk7XG52YXIgdW5pcV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvdW5pcVwiKSk7XG52YXIgbWFwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9tYXBcIikpO1xudmFyIGdhc3RfMSA9IHJlcXVpcmUoXCJAY2hldnJvdGFpbi9nYXN0XCIpO1xudmFyIGdhc3RfMiA9IHJlcXVpcmUoXCJAY2hldnJvdGFpbi9nYXN0XCIpO1xuZnVuY3Rpb24gZmlyc3QocHJvZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2QgaW5zdGFuY2VvZiBnYXN0XzEuTm9uVGVybWluYWwpIHtcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBpbiB0aGVvcnkgY2F1c2UgaW5maW5pdGUgbG9vcHMgaWZcbiAgICAgICAgLy8gKDEpIHByb2QgQSByZWZzIHByb2QgQi5cbiAgICAgICAgLy8gKDIpIHByb2QgQiByZWZzIHByb2QgQVxuICAgICAgICAvLyAoMykgQUIgY2FuIG1hdGNoIHRoZSBlbXB0eSBzZXRcbiAgICAgICAgLy8gaW4gb3RoZXIgd29yZHMgYSBjeWNsZSB3aGVyZSBldmVyeXRoaW5nIGlzIG9wdGlvbmFsIHNvIHRoZSBmaXJzdCB3aWxsIGtlZXBcbiAgICAgICAgLy8gbG9va2luZyBhaGVhZCBmb3IgdGhlIG5leHQgb3B0aW9uYWwgcGFydCBhbmQgd2lsbCBuZXZlciBleGl0XG4gICAgICAgIC8vIGN1cnJlbnRseSB0aGVyZSBpcyBubyBzYWZlZ3VhcmQgZm9yIHRoaXMgdW5pcXVlIGVkZ2UgY2FzZSBiZWNhdXNlXG4gICAgICAgIC8vICgxKSBub3Qgc3VyZSBhIGdyYW1tYXIgaW4gd2hpY2ggdGhpcyBjYW4gaGFwcGVuIGlzIHVzZWZ1bCBmb3IgYW55dGhpbmcgKHByb2R1Y3RpdmUpXG4gICAgICAgIHJldHVybiBmaXJzdChwcm9kLnJlZmVyZW5jZWRSdWxlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIGdhc3RfMS5UZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gZmlyc3RGb3JUZXJtaW5hbChwcm9kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIGdhc3RfMi5pc1NlcXVlbmNlUHJvZCkocHJvZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Rm9yU2VxdWVuY2UocHJvZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBnYXN0XzIuaXNCcmFuY2hpbmdQcm9kKShwcm9kKSkge1xuICAgICAgICByZXR1cm4gZmlyc3RGb3JCcmFuY2hpbmcocHJvZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZmlyc3QgPSBmaXJzdDtcbmZ1bmN0aW9uIGZpcnN0Rm9yU2VxdWVuY2UocHJvZCkge1xuICAgIHZhciBmaXJzdFNldCA9IFtdO1xuICAgIHZhciBzZXEgPSBwcm9kLmRlZmluaXRpb247XG4gICAgdmFyIG5leHRTdWJQcm9kSWR4ID0gMDtcbiAgICB2YXIgaGFzSW5uZXJQcm9kc1JlbWFpbmluZyA9IHNlcS5sZW5ndGggPiBuZXh0U3ViUHJvZElkeDtcbiAgICB2YXIgY3VyclN1YlByb2Q7XG4gICAgLy8gc28gd2UgZW50ZXIgdGhlIGxvb3AgYXQgbGVhc3Qgb25jZSAoaWYgdGhlIGRlZmluaXRpb24gaXMgbm90IGVtcHR5XG4gICAgdmFyIGlzTGFzdElubmVyUHJvZE9wdGlvbmFsID0gdHJ1ZTtcbiAgICAvLyBzY2FuIGEgc2VxdWVuY2UgdW50aWwgaXQncyBlbmQgb3IgdW50aWwgd2UgaGF2ZSBmb3VuZCBhIE5PTkUgb3B0aW9uYWwgcHJvZHVjdGlvbiBpbiBpdFxuICAgIHdoaWxlIChoYXNJbm5lclByb2RzUmVtYWluaW5nICYmIGlzTGFzdElubmVyUHJvZE9wdGlvbmFsKSB7XG4gICAgICAgIGN1cnJTdWJQcm9kID0gc2VxW25leHRTdWJQcm9kSWR4XTtcbiAgICAgICAgaXNMYXN0SW5uZXJQcm9kT3B0aW9uYWwgPSAoMCwgZ2FzdF8yLmlzT3B0aW9uYWxQcm9kKShjdXJyU3ViUHJvZCk7XG4gICAgICAgIGZpcnN0U2V0ID0gZmlyc3RTZXQuY29uY2F0KGZpcnN0KGN1cnJTdWJQcm9kKSk7XG4gICAgICAgIG5leHRTdWJQcm9kSWR4ID0gbmV4dFN1YlByb2RJZHggKyAxO1xuICAgICAgICBoYXNJbm5lclByb2RzUmVtYWluaW5nID0gc2VxLmxlbmd0aCA+IG5leHRTdWJQcm9kSWR4O1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHVuaXFfMS5kZWZhdWx0KShmaXJzdFNldCk7XG59XG5leHBvcnRzLmZpcnN0Rm9yU2VxdWVuY2UgPSBmaXJzdEZvclNlcXVlbmNlO1xuZnVuY3Rpb24gZmlyc3RGb3JCcmFuY2hpbmcocHJvZCkge1xuICAgIHZhciBhbGxBbHRlcm5hdGl2ZXNGaXJzdHMgPSAoMCwgbWFwXzEuZGVmYXVsdCkocHJvZC5kZWZpbml0aW9uLCBmdW5jdGlvbiAoaW5uZXJQcm9kKSB7XG4gICAgICAgIHJldHVybiBmaXJzdChpbm5lclByb2QpO1xuICAgIH0pO1xuICAgIHJldHVybiAoMCwgdW5pcV8xLmRlZmF1bHQpKCgwLCBmbGF0dGVuXzEuZGVmYXVsdCkoYWxsQWx0ZXJuYXRpdmVzRmlyc3RzKSk7XG59XG5leHBvcnRzLmZpcnN0Rm9yQnJhbmNoaW5nID0gZmlyc3RGb3JCcmFuY2hpbmc7XG5mdW5jdGlvbiBmaXJzdEZvclRlcm1pbmFsKHRlcm1pbmFsKSB7XG4gICAgcmV0dXJuIFt0ZXJtaW5hbC50ZXJtaW5hbFR5cGVdO1xufVxuZXhwb3J0cy5maXJzdEZvclRlcm1pbmFsID0gZmlyc3RGb3JUZXJtaW5hbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcnN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/first.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/follow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/follow.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.buildInProdFollowPrefix = exports.buildBetweenProdsFollowPrefix = exports.computeAllProdsFollows = exports.ResyncFollowsWalker = void 0;\nvar rest_1 = __webpack_require__(/*! ./rest */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/rest.js\");\nvar first_1 = __webpack_require__(/*! ./first */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/first.js\");\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar assign_1 = __importDefault(__webpack_require__(/*! lodash/assign */ \"(ssr)/./node_modules/lodash/assign.js\"));\nvar constants_1 = __webpack_require__(/*! ../constants */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/constants.js\");\nvar gast_1 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\n// (skipping reference production).\nvar ResyncFollowsWalker = /** @class */ (function (_super) {\n    __extends(ResyncFollowsWalker, _super);\n    function ResyncFollowsWalker(topProd) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.follows = {};\n        return _this;\n    }\n    ResyncFollowsWalker.prototype.startWalking = function () {\n        this.walk(this.topProd);\n        return this.follows;\n    };\n    ResyncFollowsWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n        // do nothing! just like in the public sector after 13:00\n    };\n    ResyncFollowsWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n        var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\n            this.topProd.name;\n        var fullRest = currRest.concat(prevRest);\n        var restProd = new gast_1.Alternative({ definition: fullRest });\n        var t_in_topProd_follows = (0, first_1.first)(restProd);\n        this.follows[followName] = t_in_topProd_follows;\n    };\n    return ResyncFollowsWalker;\n}(rest_1.RestWalker));\nexports.ResyncFollowsWalker = ResyncFollowsWalker;\nfunction computeAllProdsFollows(topProductions) {\n    var reSyncFollows = {};\n    (0, forEach_1.default)(topProductions, function (topProd) {\n        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n        (0, assign_1.default)(reSyncFollows, currRefsFollow);\n    });\n    return reSyncFollows;\n}\nexports.computeAllProdsFollows = computeAllProdsFollows;\nfunction buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n    return inner.name + occurenceInParent + constants_1.IN;\n}\nexports.buildBetweenProdsFollowPrefix = buildBetweenProdsFollowPrefix;\nfunction buildInProdFollowPrefix(terminal) {\n    var terminalName = terminal.terminalType.name;\n    return terminalName + terminal.idx + constants_1.IN;\n}\nexports.buildInProdFollowPrefix = buildInProdFollowPrefix;\n//# sourceMappingURL=follow.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvZm9sbG93LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCLEdBQUcscUNBQXFDLEdBQUcsOEJBQThCLEdBQUcsMkJBQTJCO0FBQ3RJLGFBQWEsbUJBQU8sQ0FBQyw2RUFBUTtBQUM3QixjQUFjLG1CQUFPLENBQUMsK0VBQVM7QUFDL0IsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELCtCQUErQixtQkFBTyxDQUFDLDREQUFlO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLGdGQUFjO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHNCQUFzQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvZm9sbG93LmpzPzk1NmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZEluUHJvZEZvbGxvd1ByZWZpeCA9IGV4cG9ydHMuYnVpbGRCZXR3ZWVuUHJvZHNGb2xsb3dQcmVmaXggPSBleHBvcnRzLmNvbXB1dGVBbGxQcm9kc0ZvbGxvd3MgPSBleHBvcnRzLlJlc3luY0ZvbGxvd3NXYWxrZXIgPSB2b2lkIDA7XG52YXIgcmVzdF8xID0gcmVxdWlyZShcIi4vcmVzdFwiKTtcbnZhciBmaXJzdF8xID0gcmVxdWlyZShcIi4vZmlyc3RcIik7XG52YXIgZm9yRWFjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZm9yRWFjaFwiKSk7XG52YXIgYXNzaWduXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9hc3NpZ25cIikpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBnYXN0XzEgPSByZXF1aXJlKFwiQGNoZXZyb3RhaW4vZ2FzdFwiKTtcbi8vIFRoaXMgUmVzeW5jRm9sbG93c1dhbGtlciBjb21wdXRlcyBhbGwgb2YgdGhlIGZvbGxvd3MgcmVxdWlyZWQgZm9yIFJFU1lOQ1xuLy8gKHNraXBwaW5nIHJlZmVyZW5jZSBwcm9kdWN0aW9uKS5cbnZhciBSZXN5bmNGb2xsb3dzV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXN5bmNGb2xsb3dzV2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc3luY0ZvbGxvd3NXYWxrZXIodG9wUHJvZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b3BQcm9kID0gdG9wUHJvZDtcbiAgICAgICAgX3RoaXMuZm9sbG93cyA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlc3luY0ZvbGxvd3NXYWxrZXIucHJvdG90eXBlLnN0YXJ0V2Fsa2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy53YWxrKHRoaXMudG9wUHJvZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbGxvd3M7XG4gICAgfTtcbiAgICBSZXN5bmNGb2xsb3dzV2Fsa2VyLnByb3RvdHlwZS53YWxrVGVybWluYWwgPSBmdW5jdGlvbiAodGVybWluYWwsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nISBqdXN0IGxpa2UgaW4gdGhlIHB1YmxpYyBzZWN0b3IgYWZ0ZXIgMTM6MDBcbiAgICB9O1xuICAgIFJlc3luY0ZvbGxvd3NXYWxrZXIucHJvdG90eXBlLndhbGtQcm9kUmVmID0gZnVuY3Rpb24gKHJlZlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICB2YXIgZm9sbG93TmFtZSA9IGJ1aWxkQmV0d2VlblByb2RzRm9sbG93UHJlZml4KHJlZlByb2QucmVmZXJlbmNlZFJ1bGUsIHJlZlByb2QuaWR4KSArXG4gICAgICAgICAgICB0aGlzLnRvcFByb2QubmFtZTtcbiAgICAgICAgdmFyIGZ1bGxSZXN0ID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgdmFyIHJlc3RQcm9kID0gbmV3IGdhc3RfMS5BbHRlcm5hdGl2ZSh7IGRlZmluaXRpb246IGZ1bGxSZXN0IH0pO1xuICAgICAgICB2YXIgdF9pbl90b3BQcm9kX2ZvbGxvd3MgPSAoMCwgZmlyc3RfMS5maXJzdCkocmVzdFByb2QpO1xuICAgICAgICB0aGlzLmZvbGxvd3NbZm9sbG93TmFtZV0gPSB0X2luX3RvcFByb2RfZm9sbG93cztcbiAgICB9O1xuICAgIHJldHVybiBSZXN5bmNGb2xsb3dzV2Fsa2VyO1xufShyZXN0XzEuUmVzdFdhbGtlcikpO1xuZXhwb3J0cy5SZXN5bmNGb2xsb3dzV2Fsa2VyID0gUmVzeW5jRm9sbG93c1dhbGtlcjtcbmZ1bmN0aW9uIGNvbXB1dGVBbGxQcm9kc0ZvbGxvd3ModG9wUHJvZHVjdGlvbnMpIHtcbiAgICB2YXIgcmVTeW5jRm9sbG93cyA9IHt9O1xuICAgICgwLCBmb3JFYWNoXzEuZGVmYXVsdCkodG9wUHJvZHVjdGlvbnMsIGZ1bmN0aW9uICh0b3BQcm9kKSB7XG4gICAgICAgIHZhciBjdXJyUmVmc0ZvbGxvdyA9IG5ldyBSZXN5bmNGb2xsb3dzV2Fsa2VyKHRvcFByb2QpLnN0YXJ0V2Fsa2luZygpO1xuICAgICAgICAoMCwgYXNzaWduXzEuZGVmYXVsdCkocmVTeW5jRm9sbG93cywgY3VyclJlZnNGb2xsb3cpO1xuICAgIH0pO1xuICAgIHJldHVybiByZVN5bmNGb2xsb3dzO1xufVxuZXhwb3J0cy5jb21wdXRlQWxsUHJvZHNGb2xsb3dzID0gY29tcHV0ZUFsbFByb2RzRm9sbG93cztcbmZ1bmN0aW9uIGJ1aWxkQmV0d2VlblByb2RzRm9sbG93UHJlZml4KGlubmVyLCBvY2N1cmVuY2VJblBhcmVudCkge1xuICAgIHJldHVybiBpbm5lci5uYW1lICsgb2NjdXJlbmNlSW5QYXJlbnQgKyBjb25zdGFudHNfMS5JTjtcbn1cbmV4cG9ydHMuYnVpbGRCZXR3ZWVuUHJvZHNGb2xsb3dQcmVmaXggPSBidWlsZEJldHdlZW5Qcm9kc0ZvbGxvd1ByZWZpeDtcbmZ1bmN0aW9uIGJ1aWxkSW5Qcm9kRm9sbG93UHJlZml4KHRlcm1pbmFsKSB7XG4gICAgdmFyIHRlcm1pbmFsTmFtZSA9IHRlcm1pbmFsLnRlcm1pbmFsVHlwZS5uYW1lO1xuICAgIHJldHVybiB0ZXJtaW5hbE5hbWUgKyB0ZXJtaW5hbC5pZHggKyBjb25zdGFudHNfMS5JTjtcbn1cbmV4cG9ydHMuYnVpbGRJblByb2RGb2xsb3dQcmVmaXggPSBidWlsZEluUHJvZEZvbGxvd1ByZWZpeDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvbGxvdy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/follow.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js":
/*!************************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateGrammar = exports.resolveGrammar = void 0;\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar defaults_1 = __importDefault(__webpack_require__(/*! lodash/defaults */ \"(ssr)/./node_modules/lodash/defaults.js\"));\nvar resolver_1 = __webpack_require__(/*! ../resolver */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/resolver.js\");\nvar checks_1 = __webpack_require__(/*! ../checks */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/checks.js\");\nvar errors_public_1 = __webpack_require__(/*! ../../errors_public */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/errors_public.js\");\nfunction resolveGrammar(options) {\n    var actualOptions = (0, defaults_1.default)(options, {\n        errMsgProvider: errors_public_1.defaultGrammarResolverErrorProvider\n    });\n    var topRulesTable = {};\n    (0, forEach_1.default)(options.rules, function (rule) {\n        topRulesTable[rule.name] = rule;\n    });\n    return (0, resolver_1.resolveGrammar)(topRulesTable, actualOptions.errMsgProvider);\n}\nexports.resolveGrammar = resolveGrammar;\nfunction validateGrammar(options) {\n    options = (0, defaults_1.default)(options, {\n        errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider\n    });\n    return (0, checks_1.validateGrammar)(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);\n}\nexports.validateGrammar = validateGrammar;\n//# sourceMappingURL=gast_resolver_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0X3Jlc29sdmVyX3B1YmxpYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLHNCQUFzQjtBQUNoRCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsaUNBQWlDLG1CQUFPLENBQUMsZ0VBQWlCO0FBQzFELGlCQUFpQixtQkFBTyxDQUFDLHNGQUFhO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyxrRkFBVztBQUNsQyxzQkFBc0IsbUJBQU8sQ0FBQywyRkFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZ3JhbW1hci9nYXN0L2dhc3RfcmVzb2x2ZXJfcHVibGljLmpzPzk0NzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlR3JhbW1hciA9IGV4cG9ydHMucmVzb2x2ZUdyYW1tYXIgPSB2b2lkIDA7XG52YXIgZm9yRWFjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZm9yRWFjaFwiKSk7XG52YXIgZGVmYXVsdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2RlZmF1bHRzXCIpKTtcbnZhciByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmVyXCIpO1xudmFyIGNoZWNrc18xID0gcmVxdWlyZShcIi4uL2NoZWNrc1wiKTtcbnZhciBlcnJvcnNfcHVibGljXzEgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzX3B1YmxpY1wiKTtcbmZ1bmN0aW9uIHJlc29sdmVHcmFtbWFyKG9wdGlvbnMpIHtcbiAgICB2YXIgYWN0dWFsT3B0aW9ucyA9ICgwLCBkZWZhdWx0c18xLmRlZmF1bHQpKG9wdGlvbnMsIHtcbiAgICAgICAgZXJyTXNnUHJvdmlkZXI6IGVycm9yc19wdWJsaWNfMS5kZWZhdWx0R3JhbW1hclJlc29sdmVyRXJyb3JQcm92aWRlclxuICAgIH0pO1xuICAgIHZhciB0b3BSdWxlc1RhYmxlID0ge307XG4gICAgKDAsIGZvckVhY2hfMS5kZWZhdWx0KShvcHRpb25zLnJ1bGVzLCBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICB0b3BSdWxlc1RhYmxlW3J1bGUubmFtZV0gPSBydWxlO1xuICAgIH0pO1xuICAgIHJldHVybiAoMCwgcmVzb2x2ZXJfMS5yZXNvbHZlR3JhbW1hcikodG9wUnVsZXNUYWJsZSwgYWN0dWFsT3B0aW9ucy5lcnJNc2dQcm92aWRlcik7XG59XG5leHBvcnRzLnJlc29sdmVHcmFtbWFyID0gcmVzb2x2ZUdyYW1tYXI7XG5mdW5jdGlvbiB2YWxpZGF0ZUdyYW1tYXIob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSAoMCwgZGVmYXVsdHNfMS5kZWZhdWx0KShvcHRpb25zLCB7XG4gICAgICAgIGVyck1zZ1Byb3ZpZGVyOiBlcnJvcnNfcHVibGljXzEuZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyXG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCBjaGVja3NfMS52YWxpZGF0ZUdyYW1tYXIpKG9wdGlvbnMucnVsZXMsIG9wdGlvbnMudG9rZW5UeXBlcywgb3B0aW9ucy5lcnJNc2dQcm92aWRlciwgb3B0aW9ucy5ncmFtbWFyTmFtZSk7XG59XG5leHBvcnRzLnZhbGlkYXRlR3JhbW1hciA9IHZhbGlkYXRlR3JhbW1hcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdhc3RfcmVzb2x2ZXJfcHVibGljLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.nextPossibleTokensAfter = exports.possiblePathsFrom = exports.NextTerminalAfterAtLeastOneSepWalker = exports.NextTerminalAfterAtLeastOneWalker = exports.NextTerminalAfterManySepWalker = exports.NextTerminalAfterManyWalker = exports.AbstractNextTerminalAfterProductionWalker = exports.NextAfterTokenWalker = exports.AbstractNextPossibleTokensWalker = void 0;\nvar rest_1 = __webpack_require__(/*! ./rest */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/rest.js\");\nvar first_1 = __importDefault(__webpack_require__(/*! lodash/first */ \"(ssr)/./node_modules/lodash/first.js\"));\nvar isEmpty_1 = __importDefault(__webpack_require__(/*! lodash/isEmpty */ \"(ssr)/./node_modules/lodash/isEmpty.js\"));\nvar dropRight_1 = __importDefault(__webpack_require__(/*! lodash/dropRight */ \"(ssr)/./node_modules/lodash/dropRight.js\"));\nvar drop_1 = __importDefault(__webpack_require__(/*! lodash/drop */ \"(ssr)/./node_modules/lodash/drop.js\"));\nvar last_1 = __importDefault(__webpack_require__(/*! lodash/last */ \"(ssr)/./node_modules/lodash/last.js\"));\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar clone_1 = __importDefault(__webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"));\nvar first_2 = __webpack_require__(/*! ./first */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/first.js\");\nvar gast_1 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nvar AbstractNextPossibleTokensWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextPossibleTokensWalker, _super);\n    function AbstractNextPossibleTokensWalker(topProd, path) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.path = path;\n        _this.possibleTokTypes = [];\n        _this.nextProductionName = \"\";\n        _this.nextProductionOccurrence = 0;\n        _this.found = false;\n        _this.isAtEndOfPath = false;\n        return _this;\n    }\n    AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n        this.found = false;\n        if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error(\"The path does not start with the walker's top Rule!\");\n        }\n        // immutable for the win\n        this.ruleStack = (0, clone_1.default)(this.path.ruleStack).reverse(); // intelij bug requires assertion\n        this.occurrenceStack = (0, clone_1.default)(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n        // already verified that the first production is valid, we now seek the 2nd production\n        this.ruleStack.pop();\n        this.occurrenceStack.pop();\n        this.updateExpectedNext();\n        this.walk(this.topProd);\n        return this.possibleTokTypes;\n    };\n    AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n        if (prevRest === void 0) { prevRest = []; }\n        // stop scanning once we found the path\n        if (!this.found) {\n            _super.prototype.walk.call(this, prod, prevRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n        // found the next production, need to keep walking in it\n        if (refProd.referencedRule.name === this.nextProductionName &&\n            refProd.idx === this.nextProductionOccurrence) {\n            var fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n        // need to consume the Terminal\n        if ((0, isEmpty_1.default)(this.ruleStack)) {\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n            // really seeking is the last Terminal...\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n        }\n        else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n        }\n    };\n    return AbstractNextPossibleTokensWalker;\n}(rest_1.RestWalker));\nexports.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;\nvar NextAfterTokenWalker = /** @class */ (function (_super) {\n    __extends(NextAfterTokenWalker, _super);\n    function NextAfterTokenWalker(topProd, path) {\n        var _this = _super.call(this, topProd, path) || this;\n        _this.path = path;\n        _this.nextTerminalName = \"\";\n        _this.nextTerminalOccurrence = 0;\n        _this.nextTerminalName = _this.path.lastTok.name;\n        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n        return _this;\n    }\n    NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n        if (this.isAtEndOfPath &&\n            terminal.terminalType.name === this.nextTerminalName &&\n            terminal.idx === this.nextTerminalOccurrence &&\n            !this.found) {\n            var fullRest = currRest.concat(prevRest);\n            var restProd = new gast_1.Alternative({ definition: fullRest });\n            this.possibleTokTypes = (0, first_2.first)(restProd);\n            this.found = true;\n        }\n    };\n    return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker));\nexports.NextAfterTokenWalker = NextAfterTokenWalker;\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nvar AbstractNextTerminalAfterProductionWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextTerminalAfterProductionWalker, _super);\n    function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n        var _this = _super.call(this) || this;\n        _this.topRule = topRule;\n        _this.occurrence = occurrence;\n        _this.result = {\n            token: undefined,\n            occurrence: undefined,\n            isEndOfRule: undefined\n        };\n        return _this;\n    }\n    AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n        this.walk(this.topRule);\n        return this.result;\n    };\n    return AbstractNextTerminalAfterProductionWalker;\n}(rest_1.RestWalker));\nexports.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;\nvar NextTerminalAfterManyWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManyWalker, _super);\n    function NextTerminalAfterManyWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (manyProd.idx === this.occurrence) {\n            var firstAfterMany = (0, first_1.default)(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === undefined;\n            if (firstAfterMany instanceof gast_1.Terminal) {\n                this.result.token = firstAfterMany.terminalType;\n                this.result.occurrence = firstAfterMany.idx;\n            }\n        }\n        else {\n            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexports.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;\nvar NextTerminalAfterManySepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManySepWalker, _super);\n    function NextTerminalAfterManySepWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (manySepProd.idx === this.occurrence) {\n            var firstAfterManySep = (0, first_1.default)(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === undefined;\n            if (firstAfterManySep instanceof gast_1.Terminal) {\n                this.result.token = firstAfterManySep.terminalType;\n                this.result.occurrence = firstAfterManySep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexports.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;\nvar NextTerminalAfterAtLeastOneWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneWalker, _super);\n    function NextTerminalAfterAtLeastOneWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (atLeastOneProd.idx === this.occurrence) {\n            var firstAfterAtLeastOne = (0, first_1.default)(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n            if (firstAfterAtLeastOne instanceof gast_1.Terminal) {\n                this.result.token = firstAfterAtLeastOne.terminalType;\n                this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexports.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker;\n// TODO: reduce code duplication in the AfterWalkers\nvar NextTerminalAfterAtLeastOneSepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n    function NextTerminalAfterAtLeastOneSepWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n        if (atleastOneSepProd.idx === this.occurrence) {\n            var firstAfterfirstAfterAtLeastOneSep = (0, first_1.default)(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof gast_1.Terminal) {\n                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexports.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;\nfunction possiblePathsFrom(targetDef, maxLength, currPath) {\n    if (currPath === void 0) { currPath = []; }\n    // avoid side effects\n    currPath = (0, clone_1.default)(currPath);\n    var result = [];\n    var i = 0;\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n        return nextDef.concat((0, drop_1.default)(targetDef, i + 1));\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n        var prod = targetDef[i];\n        /* istanbul ignore else */\n        if (prod instanceof gast_1.Alternative) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof gast_1.NonTerminal) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof gast_1.Option) {\n            result = getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof gast_1.RepetitionMandatory) {\n            var newDef = prod.definition.concat([\n                new gast_1.Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {\n            var newDef = [\n                new gast_1.Alternative({ definition: prod.definition }),\n                new gast_1.Repetition({\n                    definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)\n                })\n            ];\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof gast_1.RepetitionWithSeparator) {\n            var newDef = prod.definition.concat([\n                new gast_1.Repetition({\n                    definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof gast_1.Repetition) {\n            var newDef = prod.definition.concat([\n                new gast_1.Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof gast_1.Alternation) {\n            (0, forEach_1.default)(prod.definition, function (currAlt) {\n                // TODO: this is a limited check for empty alternatives\n                //   It would prevent a common case of infinite loops during parser initialization.\n                //   However **in-directly** empty alternatives may still cause issues.\n                if ((0, isEmpty_1.default)(currAlt.definition) === false) {\n                    result = getAlternativesForProd(currAlt.definition);\n                }\n            });\n            return result;\n        }\n        else if (prod instanceof gast_1.Terminal) {\n            currPath.push(prod.terminalType);\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n        i++;\n    }\n    result.push({\n        partialPath: currPath,\n        suffixDef: (0, drop_1.default)(targetDef, i)\n    });\n    return result;\n}\nexports.possiblePathsFrom = possiblePathsFrom;\nfunction nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n    // to avoid creating a new Array each time.\n    var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n    var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n    var foundCompletePath = false;\n    var tokenVectorLength = tokenVector.length;\n    var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n    var result = [];\n    var possiblePaths = [];\n    possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: []\n    });\n    while (!(0, isEmpty_1.default)(possiblePaths)) {\n        var currPath = possiblePaths.pop();\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n        if (currPath === EXIT_ALTERNATIVE) {\n            if (foundCompletePath &&\n                (0, last_1.default)(possiblePaths).idx <= minimalAlternativesIndex) {\n                // remove irrelevant alternative\n                possiblePaths.pop();\n            }\n            continue;\n        }\n        var currDef = currPath.def;\n        var currIdx = currPath.idx;\n        var currRuleStack = currPath.ruleStack;\n        var currOccurrenceStack = currPath.occurrenceStack;\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n        if ((0, isEmpty_1.default)(currDef)) {\n            continue;\n        }\n        var prod = currDef[0];\n        /* istanbul ignore else */\n        if (prod === EXIT_NON_TERMINAL) {\n            var nextPath = {\n                idx: currIdx,\n                def: (0, drop_1.default)(currDef),\n                ruleStack: (0, dropRight_1.default)(currRuleStack),\n                occurrenceStack: (0, dropRight_1.default)(currOccurrenceStack)\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof gast_1.Terminal) {\n            /* istanbul ignore else */\n            if (currIdx < tokenVectorLength - 1) {\n                var nextIdx = currIdx + 1;\n                var actualToken = tokenVector[nextIdx];\n                if (tokMatcher(actualToken, prod.terminalType)) {\n                    var nextPath = {\n                        idx: nextIdx,\n                        def: (0, drop_1.default)(currDef),\n                        ruleStack: currRuleStack,\n                        occurrenceStack: currOccurrenceStack\n                    };\n                    possiblePaths.push(nextPath);\n                }\n                // end of the line\n            }\n            else if (currIdx === tokenVectorLength - 1) {\n                // IGNORE ABOVE ELSE\n                result.push({\n                    nextTokenType: prod.terminalType,\n                    nextTokenOccurrence: prod.idx,\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                });\n                foundCompletePath = true;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        }\n        else if (prod instanceof gast_1.NonTerminal) {\n            var newRuleStack = (0, clone_1.default)(currRuleStack);\n            newRuleStack.push(prod.nonTerminalName);\n            var newOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);\n            newOccurrenceStack.push(prod.idx);\n            var nextPath = {\n                idx: currIdx,\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0, drop_1.default)(currDef)),\n                ruleStack: newRuleStack,\n                occurrenceStack: newOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof gast_1.Option) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: (0, drop_1.default)(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var nextPathWith = {\n                idx: currIdx,\n                def: prod.definition.concat((0, drop_1.default)(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof gast_1.RepetitionMandatory) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var secondIteration = new gast_1.Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var separatorGast = new gast_1.Terminal({\n                terminalType: prod.separator\n            });\n            var secondIteration = new gast_1.Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof gast_1.RepetitionWithSeparator) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: (0, drop_1.default)(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var separatorGast = new gast_1.Terminal({\n                terminalType: prod.separator\n            });\n            var nthRepetition = new gast_1.Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof gast_1.Repetition) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: (0, drop_1.default)(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n            var nthRepetition = new gast_1.Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof gast_1.Alternation) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            for (var i = prod.definition.length - 1; i >= 0; i--) {\n                var currAlt = prod.definition[i];\n                var currAltPath = {\n                    idx: currIdx,\n                    def: currAlt.definition.concat((0, drop_1.default)(currDef)),\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                };\n                possiblePaths.push(currAltPath);\n                possiblePaths.push(EXIT_ALTERNATIVE);\n            }\n        }\n        else if (prod instanceof gast_1.Alternative) {\n            possiblePaths.push({\n                idx: currIdx,\n                def: prod.definition.concat((0, drop_1.default)(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            });\n        }\n        else if (prod instanceof gast_1.Rule) {\n            // last because we should only encounter at most a single one of these per invocation.\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n    return result;\n}\nexports.nextPossibleTokensAfter = nextPossibleTokensAfter;\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    var newRuleStack = (0, clone_1.default)(currRuleStack);\n    newRuleStack.push(topRule.name);\n    var newCurrOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1);\n    return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack\n    };\n}\n//# sourceMappingURL=interpreter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvaW50ZXJwcmV0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0IsR0FBRyx5QkFBeUIsR0FBRyw0Q0FBNEMsR0FBRyx5Q0FBeUMsR0FBRyxzQ0FBc0MsR0FBRyxtQ0FBbUMsR0FBRyxpREFBaUQsR0FBRyw0QkFBNEIsR0FBRyx3Q0FBd0M7QUFDblcsYUFBYSxtQkFBTyxDQUFDLDZFQUFRO0FBQzdCLDhCQUE4QixtQkFBTyxDQUFDLDBEQUFjO0FBQ3BELGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCxrQ0FBa0MsbUJBQU8sQ0FBQyxrRUFBa0I7QUFDNUQsNkJBQTZCLG1CQUFPLENBQUMsd0RBQWE7QUFDbEQsNkJBQTZCLG1CQUFPLENBQUMsd0RBQWE7QUFDbEQsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELDhCQUE4QixtQkFBTyxDQUFDLDBEQUFjO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQywrRUFBUztBQUMvQixhQUFhLG1CQUFPLENBQUMsOEVBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsc0JBQXNCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDRDQUE0QztBQUM1QztBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw2QkFBNkI7QUFDdEU7QUFDQSx1REFBdUQsOEJBQThCO0FBQ3JGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsOEJBQThCO0FBQ3JGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZ3JhbW1hci9pbnRlcnByZXRlci5qcz85YjhmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXIgPSBleHBvcnRzLnBvc3NpYmxlUGF0aHNGcm9tID0gZXhwb3J0cy5OZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIgPSBleHBvcnRzLk5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlciA9IGV4cG9ydHMuTmV4dFRlcm1pbmFsQWZ0ZXJNYW55U2VwV2Fsa2VyID0gZXhwb3J0cy5OZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXIgPSBleHBvcnRzLkFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyID0gZXhwb3J0cy5OZXh0QWZ0ZXJUb2tlbldhbGtlciA9IGV4cG9ydHMuQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIgPSB2b2lkIDA7XG52YXIgcmVzdF8xID0gcmVxdWlyZShcIi4vcmVzdFwiKTtcbnZhciBmaXJzdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZmlyc3RcIikpO1xudmFyIGlzRW1wdHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRW1wdHlcIikpO1xudmFyIGRyb3BSaWdodF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZHJvcFJpZ2h0XCIpKTtcbnZhciBkcm9wXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9kcm9wXCIpKTtcbnZhciBsYXN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9sYXN0XCIpKTtcbnZhciBmb3JFYWNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9mb3JFYWNoXCIpKTtcbnZhciBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIikpO1xudmFyIGZpcnN0XzIgPSByZXF1aXJlKFwiLi9maXJzdFwiKTtcbnZhciBnYXN0XzEgPSByZXF1aXJlKFwiQGNoZXZyb3RhaW4vZ2FzdFwiKTtcbnZhciBBYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIodG9wUHJvZCwgcGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b3BQcm9kID0gdG9wUHJvZDtcbiAgICAgICAgX3RoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIF90aGlzLnBvc3NpYmxlVG9rVHlwZXMgPSBbXTtcbiAgICAgICAgX3RoaXMubmV4dFByb2R1Y3Rpb25OYW1lID0gXCJcIjtcbiAgICAgICAgX3RoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlID0gMDtcbiAgICAgICAgX3RoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaXNBdEVuZE9mUGF0aCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyLnByb3RvdHlwZS5zdGFydFdhbGtpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5ydWxlU3RhY2tbMF0gIT09IHRoaXMudG9wUHJvZC5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBwYXRoIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHdhbGtlcidzIHRvcCBSdWxlIVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbW11dGFibGUgZm9yIHRoZSB3aW5cbiAgICAgICAgdGhpcy5ydWxlU3RhY2sgPSAoMCwgY2xvbmVfMS5kZWZhdWx0KSh0aGlzLnBhdGgucnVsZVN0YWNrKS5yZXZlcnNlKCk7IC8vIGludGVsaWogYnVnIHJlcXVpcmVzIGFzc2VydGlvblxuICAgICAgICB0aGlzLm9jY3VycmVuY2VTdGFjayA9ICgwLCBjbG9uZV8xLmRlZmF1bHQpKHRoaXMucGF0aC5vY2N1cnJlbmNlU3RhY2spLnJldmVyc2UoKTsgLy8gaW50ZWxpaiBidWcgcmVxdWlyZXMgYXNzZXJ0aW9uXG4gICAgICAgIC8vIGFscmVhZHkgdmVyaWZpZWQgdGhhdCB0aGUgZmlyc3QgcHJvZHVjdGlvbiBpcyB2YWxpZCwgd2Ugbm93IHNlZWsgdGhlIDJuZCBwcm9kdWN0aW9uXG4gICAgICAgIHRoaXMucnVsZVN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLm9jY3VycmVuY2VTdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy51cGRhdGVFeHBlY3RlZE5leHQoKTtcbiAgICAgICAgdGhpcy53YWxrKHRoaXMudG9wUHJvZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc3NpYmxlVG9rVHlwZXM7XG4gICAgfTtcbiAgICBBYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIChwcm9kLCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAocHJldlJlc3QgPT09IHZvaWQgMCkgeyBwcmV2UmVzdCA9IFtdOyB9XG4gICAgICAgIC8vIHN0b3Agc2Nhbm5pbmcgb25jZSB3ZSBmb3VuZCB0aGUgcGF0aFxuICAgICAgICBpZiAoIXRoaXMuZm91bmQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsay5jYWxsKHRoaXMsIHByb2QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIucHJvdG90eXBlLndhbGtQcm9kUmVmID0gZnVuY3Rpb24gKHJlZlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBmb3VuZCB0aGUgbmV4dCBwcm9kdWN0aW9uLCBuZWVkIHRvIGtlZXAgd2Fsa2luZyBpbiBpdFxuICAgICAgICBpZiAocmVmUHJvZC5yZWZlcmVuY2VkUnVsZS5uYW1lID09PSB0aGlzLm5leHRQcm9kdWN0aW9uTmFtZSAmJlxuICAgICAgICAgICAgcmVmUHJvZC5pZHggPT09IHRoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICB2YXIgZnVsbFJlc3QgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFeHBlY3RlZE5leHQoKTtcbiAgICAgICAgICAgIHRoaXMud2FsayhyZWZQcm9kLnJlZmVyZW5jZWRSdWxlLCBmdWxsUmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyLnByb3RvdHlwZS51cGRhdGVFeHBlY3RlZE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5lZWQgdG8gY29uc3VtZSB0aGUgVGVybWluYWxcbiAgICAgICAgaWYgKCgwLCBpc0VtcHR5XzEuZGVmYXVsdCkodGhpcy5ydWxlU3RhY2spKSB7XG4gICAgICAgICAgICAvLyBtdXN0IHJlc2V0IG5leHRQcm9kdWN0aW9uWFhYIHRvIGF2b2lkIHdhbGtpbmcgZG93biBhbm90aGVyIFRvcCBMZXZlbCBwcm9kdWN0aW9uIHdoaWxlIHdoYXQgd2UgYXJlXG4gICAgICAgICAgICAvLyByZWFsbHkgc2Vla2luZyBpcyB0aGUgbGFzdCBUZXJtaW5hbC4uLlxuICAgICAgICAgICAgdGhpcy5uZXh0UHJvZHVjdGlvbk5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5uZXh0UHJvZHVjdGlvbk9jY3VycmVuY2UgPSAwO1xuICAgICAgICAgICAgdGhpcy5pc0F0RW5kT2ZQYXRoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFByb2R1Y3Rpb25OYW1lID0gdGhpcy5ydWxlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZSA9IHRoaXMub2NjdXJyZW5jZVN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXI7XG59KHJlc3RfMS5SZXN0V2Fsa2VyKSk7XG5leHBvcnRzLkFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyID0gQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXI7XG52YXIgTmV4dEFmdGVyVG9rZW5XYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5leHRBZnRlclRva2VuV2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5leHRBZnRlclRva2VuV2Fsa2VyKHRvcFByb2QsIHBhdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdG9wUHJvZCwgcGF0aCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIF90aGlzLm5leHRUZXJtaW5hbE5hbWUgPSBcIlwiO1xuICAgICAgICBfdGhpcy5uZXh0VGVybWluYWxPY2N1cnJlbmNlID0gMDtcbiAgICAgICAgX3RoaXMubmV4dFRlcm1pbmFsTmFtZSA9IF90aGlzLnBhdGgubGFzdFRvay5uYW1lO1xuICAgICAgICBfdGhpcy5uZXh0VGVybWluYWxPY2N1cnJlbmNlID0gX3RoaXMucGF0aC5sYXN0VG9rT2NjdXJyZW5jZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOZXh0QWZ0ZXJUb2tlbldhbGtlci5wcm90b3R5cGUud2Fsa1Rlcm1pbmFsID0gZnVuY3Rpb24gKHRlcm1pbmFsLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBdEVuZE9mUGF0aCAmJlxuICAgICAgICAgICAgdGVybWluYWwudGVybWluYWxUeXBlLm5hbWUgPT09IHRoaXMubmV4dFRlcm1pbmFsTmFtZSAmJlxuICAgICAgICAgICAgdGVybWluYWwuaWR4ID09PSB0aGlzLm5leHRUZXJtaW5hbE9jY3VycmVuY2UgJiZcbiAgICAgICAgICAgICF0aGlzLmZvdW5kKSB7XG4gICAgICAgICAgICB2YXIgZnVsbFJlc3QgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICAgICAgdmFyIHJlc3RQcm9kID0gbmV3IGdhc3RfMS5BbHRlcm5hdGl2ZSh7IGRlZmluaXRpb246IGZ1bGxSZXN0IH0pO1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJsZVRva1R5cGVzID0gKDAsIGZpcnN0XzIuZmlyc3QpKHJlc3RQcm9kKTtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTmV4dEFmdGVyVG9rZW5XYWxrZXI7XG59KEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyKSk7XG5leHBvcnRzLk5leHRBZnRlclRva2VuV2Fsa2VyID0gTmV4dEFmdGVyVG9rZW5XYWxrZXI7XG4vKipcbiAqIFRoaXMgd2Fsa2VyIG9ubHkgXCJ3YWxrc1wiIGEgc2luZ2xlIFwiVE9QXCIgbGV2ZWwgaW4gdGhlIEdyYW1tYXIgQXN0LCB0aGlzIG1lYW5zXG4gKiBpdCBuZXZlciBcImZvbGxvd3NcIiBwcm9kdWN0aW9uIHJlZnNcbiAqL1xudmFyIEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlcih0b3BSdWxlLCBvY2N1cnJlbmNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvcFJ1bGUgPSB0b3BSdWxlO1xuICAgICAgICBfdGhpcy5vY2N1cnJlbmNlID0gb2NjdXJyZW5jZTtcbiAgICAgICAgX3RoaXMucmVzdWx0ID0ge1xuICAgICAgICAgICAgdG9rZW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9jY3VycmVuY2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzRW5kT2ZSdWxlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlci5wcm90b3R5cGUuc3RhcnRXYWxraW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLndhbGsodGhpcy50b3BSdWxlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyO1xufShyZXN0XzEuUmVzdFdhbGtlcikpO1xuZXhwb3J0cy5BYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlciA9IEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyO1xudmFyIE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV4dFRlcm1pbmFsQWZ0ZXJNYW55V2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXIucHJvdG90eXBlLndhbGtNYW55ID0gZnVuY3Rpb24gKG1hbnlQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKG1hbnlQcm9kLmlkeCA9PT0gdGhpcy5vY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RBZnRlck1hbnkgPSAoMCwgZmlyc3RfMS5kZWZhdWx0KShjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LmlzRW5kT2ZSdWxlID0gZmlyc3RBZnRlck1hbnkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChmaXJzdEFmdGVyTWFueSBpbnN0YW5jZW9mIGdhc3RfMS5UZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnRva2VuID0gZmlyc3RBZnRlck1hbnkudGVybWluYWxUeXBlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0Lm9jY3VycmVuY2UgPSBmaXJzdEFmdGVyTWFueS5pZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLndhbGtNYW55LmNhbGwodGhpcywgbWFueVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXI7XG59KEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyKSk7XG5leHBvcnRzLk5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlciA9IE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlcjtcbnZhciBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTmV4dFRlcm1pbmFsQWZ0ZXJNYW55U2VwV2Fsa2VyLnByb3RvdHlwZS53YWxrTWFueVNlcCA9IGZ1bmN0aW9uIChtYW55U2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmIChtYW55U2VwUHJvZC5pZHggPT09IHRoaXMub2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0QWZ0ZXJNYW55U2VwID0gKDAsIGZpcnN0XzEuZGVmYXVsdCkoY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KSk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZSA9IGZpcnN0QWZ0ZXJNYW55U2VwID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZmlyc3RBZnRlck1hbnlTZXAgaW5zdGFuY2VvZiBnYXN0XzEuVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC50b2tlbiA9IGZpcnN0QWZ0ZXJNYW55U2VwLnRlcm1pbmFsVHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5vY2N1cnJlbmNlID0gZmlyc3RBZnRlck1hbnlTZXAuaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53YWxrTWFueVNlcC5jYWxsKHRoaXMsIG1hbnlTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTmV4dFRlcm1pbmFsQWZ0ZXJNYW55U2VwV2Fsa2VyO1xufShBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlcikpO1xuZXhwb3J0cy5OZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIgPSBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXI7XG52YXIgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVXYWxrZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlci5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmUgPSBmdW5jdGlvbiAoYXRMZWFzdE9uZVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoYXRMZWFzdE9uZVByb2QuaWR4ID09PSB0aGlzLm9jY3VycmVuY2UpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdEFmdGVyQXRMZWFzdE9uZSA9ICgwLCBmaXJzdF8xLmRlZmF1bHQpKGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCkpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGUgPSBmaXJzdEFmdGVyQXRMZWFzdE9uZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGZpcnN0QWZ0ZXJBdExlYXN0T25lIGluc3RhbmNlb2YgZ2FzdF8xLlRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQudG9rZW4gPSBmaXJzdEFmdGVyQXRMZWFzdE9uZS50ZXJtaW5hbFR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQub2NjdXJyZW5jZSA9IGZpcnN0QWZ0ZXJBdExlYXN0T25lLmlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmUuY2FsbCh0aGlzLCBhdExlYXN0T25lUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlcjtcbn0oQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIpKTtcbmV4cG9ydHMuTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyID0gTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyO1xuLy8gVE9ETzogcmVkdWNlIGNvZGUgZHVwbGljYXRpb24gaW4gdGhlIEFmdGVyV2Fsa2Vyc1xudmFyIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIucHJvdG90eXBlLndhbGtBdExlYXN0T25lU2VwID0gZnVuY3Rpb24gKGF0bGVhc3RPbmVTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKGF0bGVhc3RPbmVTZXBQcm9kLmlkeCA9PT0gdGhpcy5vY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RBZnRlcmZpcnN0QWZ0ZXJBdExlYXN0T25lU2VwID0gKDAsIGZpcnN0XzEuZGVmYXVsdCkoY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KSk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZSA9IGZpcnN0QWZ0ZXJmaXJzdEFmdGVyQXRMZWFzdE9uZVNlcCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGZpcnN0QWZ0ZXJmaXJzdEFmdGVyQXRMZWFzdE9uZVNlcCBpbnN0YW5jZW9mIGdhc3RfMS5UZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnRva2VuID0gZmlyc3RBZnRlcmZpcnN0QWZ0ZXJBdExlYXN0T25lU2VwLnRlcm1pbmFsVHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5vY2N1cnJlbmNlID0gZmlyc3RBZnRlcmZpcnN0QWZ0ZXJBdExlYXN0T25lU2VwLmlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmVTZXAuY2FsbCh0aGlzLCBhdGxlYXN0T25lU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlcjtcbn0oQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIpKTtcbmV4cG9ydHMuTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyID0gTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyO1xuZnVuY3Rpb24gcG9zc2libGVQYXRoc0Zyb20odGFyZ2V0RGVmLCBtYXhMZW5ndGgsIGN1cnJQYXRoKSB7XG4gICAgaWYgKGN1cnJQYXRoID09PSB2b2lkIDApIHsgY3VyclBhdGggPSBbXTsgfVxuICAgIC8vIGF2b2lkIHNpZGUgZWZmZWN0c1xuICAgIGN1cnJQYXRoID0gKDAsIGNsb25lXzEuZGVmYXVsdCkoY3VyclBhdGgpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgLy8gVE9ETzogYXZvaWQgaW5uZXIgZnVuY3NcbiAgICBmdW5jdGlvbiByZW1haW5pbmdQYXRoV2l0aChuZXh0RGVmKSB7XG4gICAgICAgIHJldHVybiBuZXh0RGVmLmNvbmNhdCgoMCwgZHJvcF8xLmRlZmF1bHQpKHRhcmdldERlZiwgaSArIDEpKTtcbiAgICB9XG4gICAgLy8gVE9ETzogYXZvaWQgaW5uZXIgZnVuY3NcbiAgICBmdW5jdGlvbiBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKGRlZmluaXRpb24pIHtcbiAgICAgICAgdmFyIGFsdGVybmF0aXZlcyA9IHBvc3NpYmxlUGF0aHNGcm9tKHJlbWFpbmluZ1BhdGhXaXRoKGRlZmluaXRpb24pLCBtYXhMZW5ndGgsIGN1cnJQYXRoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoYWx0ZXJuYXRpdmVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFuZGF0b3J5IHByb2R1Y3Rpb25zIHdpbGwgaGFsdCB0aGUgbG9vcCBhcyB0aGUgcGF0aHMgY29tcHV0ZWQgZnJvbSB0aGVpciByZWN1cnNpdmUgY2FsbHMgd2lsbCBhbHJlYWR5IGNvbnRhaW4gdGhlXG4gICAgICogZm9sbG93aW5nIChyZXN0KSBvZiB0aGUgdGFyZ2V0RGVmLlxuICAgICAqXG4gICAgICogRm9yIG9wdGlvbmFsIHByb2R1Y3Rpb25zIChPcHRpb24vUmVwZXRpdGlvbi8uLi4pIHRoZSBsb29wIHdpbGwgY29udGludWUgdG8gcmVwcmVzZW50IHRoZSBwYXRocyB0aGF0IGRvIG5vdCBpbmNsdWRlIHRoZVxuICAgICAqIHRoZSBvcHRpb25hbCBwcm9kdWN0aW9uLlxuICAgICAqL1xuICAgIHdoaWxlIChjdXJyUGF0aC5sZW5ndGggPCBtYXhMZW5ndGggJiYgaSA8IHRhcmdldERlZi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHByb2QgPSB0YXJnZXREZWZbaV07XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChwcm9kIGluc3RhbmNlb2YgZ2FzdF8xLkFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChwcm9kLmRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBnYXN0XzEuTm9uVGVybWluYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKHByb2QuZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIGdhc3RfMS5PcHRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGdldEFsdGVybmF0aXZlc0ZvclByb2QocHJvZC5kZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgZ2FzdF8xLlJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgICAgIHZhciBuZXdEZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtcbiAgICAgICAgICAgICAgICBuZXcgZ2FzdF8xLlJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBwcm9kLmRlZmluaXRpb25cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChuZXdEZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBnYXN0XzEuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBuZXdEZWYgPSBbXG4gICAgICAgICAgICAgICAgbmV3IGdhc3RfMS5BbHRlcm5hdGl2ZSh7IGRlZmluaXRpb246IHByb2QuZGVmaW5pdGlvbiB9KSxcbiAgICAgICAgICAgICAgICBuZXcgZ2FzdF8xLlJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBbbmV3IGdhc3RfMS5UZXJtaW5hbCh7IHRlcm1pbmFsVHlwZTogcHJvZC5zZXBhcmF0b3IgfSldLmNvbmNhdChwcm9kLmRlZmluaXRpb24pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChuZXdEZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBnYXN0XzEuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBuZXdEZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtcbiAgICAgICAgICAgICAgICBuZXcgZ2FzdF8xLlJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBbbmV3IGdhc3RfMS5UZXJtaW5hbCh7IHRlcm1pbmFsVHlwZTogcHJvZC5zZXBhcmF0b3IgfSldLmNvbmNhdChwcm9kLmRlZmluaXRpb24pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChuZXdEZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBnYXN0XzEuUmVwZXRpdGlvbikge1xuICAgICAgICAgICAgdmFyIG5ld0RlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW1xuICAgICAgICAgICAgICAgIG5ldyBnYXN0XzEuUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb246IHByb2QuZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGdldEFsdGVybmF0aXZlc0ZvclByb2QobmV3RGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgZ2FzdF8xLkFsdGVybmF0aW9uKSB7XG4gICAgICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKHByb2QuZGVmaW5pdGlvbiwgZnVuY3Rpb24gKGN1cnJBbHQpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIGEgbGltaXRlZCBjaGVjayBmb3IgZW1wdHkgYWx0ZXJuYXRpdmVzXG4gICAgICAgICAgICAgICAgLy8gICBJdCB3b3VsZCBwcmV2ZW50IGEgY29tbW9uIGNhc2Ugb2YgaW5maW5pdGUgbG9vcHMgZHVyaW5nIHBhcnNlciBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICAgICAgICAvLyAgIEhvd2V2ZXIgKippbi1kaXJlY3RseSoqIGVtcHR5IGFsdGVybmF0aXZlcyBtYXkgc3RpbGwgY2F1c2UgaXNzdWVzLlxuICAgICAgICAgICAgICAgIGlmICgoMCwgaXNFbXB0eV8xLmRlZmF1bHQpKGN1cnJBbHQuZGVmaW5pdGlvbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdldEFsdGVybmF0aXZlc0ZvclByb2QoY3VyckFsdC5kZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIGdhc3RfMS5UZXJtaW5hbCkge1xuICAgICAgICAgICAgY3VyclBhdGgucHVzaChwcm9kLnRlcm1pbmFsVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBwYXJ0aWFsUGF0aDogY3VyclBhdGgsXG4gICAgICAgIHN1ZmZpeERlZjogKDAsIGRyb3BfMS5kZWZhdWx0KSh0YXJnZXREZWYsIGkpXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucG9zc2libGVQYXRoc0Zyb20gPSBwb3NzaWJsZVBhdGhzRnJvbTtcbmZ1bmN0aW9uIG5leHRQb3NzaWJsZVRva2Vuc0FmdGVyKGluaXRpYWxEZWYsIHRva2VuVmVjdG9yLCB0b2tNYXRjaGVyLCBtYXhMb29rQWhlYWQpIHtcbiAgICB2YXIgRVhJVF9OT05fVEVSTUlOQUwgPSBcIkVYSVRfTk9ORV9URVJNSU5BTFwiO1xuICAgIC8vIHRvIGF2b2lkIGNyZWF0aW5nIGEgbmV3IEFycmF5IGVhY2ggdGltZS5cbiAgICB2YXIgRVhJVF9OT05fVEVSTUlOQUxfQVJSID0gW0VYSVRfTk9OX1RFUk1JTkFMXTtcbiAgICB2YXIgRVhJVF9BTFRFUk5BVElWRSA9IFwiRVhJVF9BTFRFUk5BVElWRVwiO1xuICAgIHZhciBmb3VuZENvbXBsZXRlUGF0aCA9IGZhbHNlO1xuICAgIHZhciB0b2tlblZlY3Rvckxlbmd0aCA9IHRva2VuVmVjdG9yLmxlbmd0aDtcbiAgICB2YXIgbWluaW1hbEFsdGVybmF0aXZlc0luZGV4ID0gdG9rZW5WZWN0b3JMZW5ndGggLSBtYXhMb29rQWhlYWQgLSAxO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgcG9zc2libGVQYXRocyA9IFtdO1xuICAgIHBvc3NpYmxlUGF0aHMucHVzaCh7XG4gICAgICAgIGlkeDogLTEsXG4gICAgICAgIGRlZjogaW5pdGlhbERlZixcbiAgICAgICAgcnVsZVN0YWNrOiBbXSxcbiAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBbXVxuICAgIH0pO1xuICAgIHdoaWxlICghKDAsIGlzRW1wdHlfMS5kZWZhdWx0KShwb3NzaWJsZVBhdGhzKSkge1xuICAgICAgICB2YXIgY3VyclBhdGggPSBwb3NzaWJsZVBhdGhzLnBvcCgpO1xuICAgICAgICAvLyBza2lwIGFsdGVybmF0aXZlcyBpZiBubyBtb3JlIHJlc3VsdHMgY2FuIGJlIGZvdW5kIChhc3N1bWluZyBkZXRlcm1pbmlzdGljIGdyYW1tYXIgd2l0aCBmaXhlZCBsb29rYWhlYWQpXG4gICAgICAgIGlmIChjdXJyUGF0aCA9PT0gRVhJVF9BTFRFUk5BVElWRSkge1xuICAgICAgICAgICAgaWYgKGZvdW5kQ29tcGxldGVQYXRoICYmXG4gICAgICAgICAgICAgICAgKDAsIGxhc3RfMS5kZWZhdWx0KShwb3NzaWJsZVBhdGhzKS5pZHggPD0gbWluaW1hbEFsdGVybmF0aXZlc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGlycmVsZXZhbnQgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJEZWYgPSBjdXJyUGF0aC5kZWY7XG4gICAgICAgIHZhciBjdXJySWR4ID0gY3VyclBhdGguaWR4O1xuICAgICAgICB2YXIgY3VyclJ1bGVTdGFjayA9IGN1cnJQYXRoLnJ1bGVTdGFjaztcbiAgICAgICAgdmFyIGN1cnJPY2N1cnJlbmNlU3RhY2sgPSBjdXJyUGF0aC5vY2N1cnJlbmNlU3RhY2s7XG4gICAgICAgIC8vIEZvciBFeGFtcGxlOiBhbiBlbXB0eSBwYXRoIGNvdWxkIGV4aXN0IGluIGEgdmFsaWQgZ3JhbW1hciBpbiB0aGUgY2FzZSBvZiBhbiBFTVBUWV9BTFRcbiAgICAgICAgaWYgKCgwLCBpc0VtcHR5XzEuZGVmYXVsdCkoY3VyckRlZikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9kID0gY3VyckRlZlswXTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHByb2QgPT09IEVYSVRfTk9OX1RFUk1JTkFMKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogKDAsIGRyb3BfMS5kZWZhdWx0KShjdXJyRGVmKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6ICgwLCBkcm9wUmlnaHRfMS5kZWZhdWx0KShjdXJyUnVsZVN0YWNrKSxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6ICgwLCBkcm9wUmlnaHRfMS5kZWZhdWx0KShjdXJyT2NjdXJyZW5jZVN0YWNrKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIGdhc3RfMS5UZXJtaW5hbCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChjdXJySWR4IDwgdG9rZW5WZWN0b3JMZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRJZHggPSBjdXJySWR4ICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgYWN0dWFsVG9rZW4gPSB0b2tlblZlY3RvcltuZXh0SWR4XTtcbiAgICAgICAgICAgICAgICBpZiAodG9rTWF0Y2hlcihhY3R1YWxUb2tlbiwgcHJvZC50ZXJtaW5hbFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0UGF0aCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeDogbmV4dElkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZjogKDAsIGRyb3BfMS5kZWZhdWx0KShjdXJyRGVmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJJZHggPT09IHRva2VuVmVjdG9yTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vIElHTk9SRSBBQk9WRSBFTFNFXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW5UeXBlOiBwcm9kLnRlcm1pbmFsVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuT2NjdXJyZW5jZTogcHJvZC5pZHgsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm91bmRDb21wbGV0ZVBhdGggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgZ2FzdF8xLk5vblRlcm1pbmFsKSB7XG4gICAgICAgICAgICB2YXIgbmV3UnVsZVN0YWNrID0gKDAsIGNsb25lXzEuZGVmYXVsdCkoY3VyclJ1bGVTdGFjayk7XG4gICAgICAgICAgICBuZXdSdWxlU3RhY2sucHVzaChwcm9kLm5vblRlcm1pbmFsTmFtZSk7XG4gICAgICAgICAgICB2YXIgbmV3T2NjdXJyZW5jZVN0YWNrID0gKDAsIGNsb25lXzEuZGVmYXVsdCkoY3Vyck9jY3VycmVuY2VTdGFjayk7XG4gICAgICAgICAgICBuZXdPY2N1cnJlbmNlU3RhY2sucHVzaChwcm9kLmlkeCk7XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogcHJvZC5kZWZpbml0aW9uLmNvbmNhdChFWElUX05PTl9URVJNSU5BTF9BUlIsICgwLCBkcm9wXzEuZGVmYXVsdCkoY3VyckRlZikpLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogbmV3UnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogbmV3T2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgZ2FzdF8xLk9wdGlvbikge1xuICAgICAgICAgICAgLy8gdGhlIG9yZGVyIG9mIGFsdGVybmF0aXZlcyBpcyBtZWFuaW5nZnVsLCBGSUxPIChMYXN0IHBhdGggd2lsbCBiZSB0cmF2ZXJzZWQgZmlyc3QpLlxuICAgICAgICAgICAgdmFyIG5leHRQYXRoV2l0aG91dCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiAoMCwgZHJvcF8xLmRlZmF1bHQpKGN1cnJEZWYpLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGhXaXRob3V0KTtcbiAgICAgICAgICAgIC8vIHJlcXVpcmVkIG1hcmtlciB0byBhdm9pZCBiYWNrdHJhY2tpbmcgcGF0aHMgd2hvc2UgaGlnaGVyIHByaW9yaXR5IGFsdGVybmF0aXZlcyBhbHJlYWR5IG1hdGNoZWRcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChFWElUX0FMVEVSTkFUSVZFKTtcbiAgICAgICAgICAgIHZhciBuZXh0UGF0aFdpdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogcHJvZC5kZWZpbml0aW9uLmNvbmNhdCgoMCwgZHJvcF8xLmRlZmF1bHQpKGN1cnJEZWYpKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoV2l0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIGdhc3RfMS5SZXBldGl0aW9uTWFuZGF0b3J5KSB7XG4gICAgICAgICAgICAvLyBUT0RPOihUSEUgTkVXIG9wZXJhdG9ycyBoZXJlIHRha2UgYSB3aGlsZS4uLikgKGNvbnZlcnQgb25jZT8pXG4gICAgICAgICAgICB2YXIgc2Vjb25kSXRlcmF0aW9uID0gbmV3IGdhc3RfMS5SZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBwcm9kLmRlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgaWR4OiBwcm9kLmlkeFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbmV4dERlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW3NlY29uZEl0ZXJhdGlvbl0sICgwLCBkcm9wXzEuZGVmYXVsdCkoY3VyckRlZikpO1xuICAgICAgICAgICAgdmFyIG5leHRQYXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IG5leHREZWYsXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIGdhc3RfMS5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICAgICAgLy8gVE9ETzooVEhFIE5FVyBvcGVyYXRvcnMgaGVyZSB0YWtlIGEgd2hpbGUuLi4pIChjb252ZXJ0IG9uY2U/KVxuICAgICAgICAgICAgdmFyIHNlcGFyYXRvckdhc3QgPSBuZXcgZ2FzdF8xLlRlcm1pbmFsKHtcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbFR5cGU6IHByb2Quc2VwYXJhdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzZWNvbmRJdGVyYXRpb24gPSBuZXcgZ2FzdF8xLlJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb246IFtzZXBhcmF0b3JHYXN0XS5jb25jYXQocHJvZC5kZWZpbml0aW9uKSxcbiAgICAgICAgICAgICAgICBpZHg6IHByb2QuaWR4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBuZXh0RGVmID0gcHJvZC5kZWZpbml0aW9uLmNvbmNhdChbc2Vjb25kSXRlcmF0aW9uXSwgKDAsIGRyb3BfMS5kZWZhdWx0KShjdXJyRGVmKSk7XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogbmV4dERlZixcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgZ2FzdF8xLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAvLyB0aGUgb3JkZXIgb2YgYWx0ZXJuYXRpdmVzIGlzIG1lYW5pbmdmdWwsIEZJTE8gKExhc3QgcGF0aCB3aWxsIGJlIHRyYXZlcnNlZCBmaXJzdCkuXG4gICAgICAgICAgICB2YXIgbmV4dFBhdGhXaXRob3V0ID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6ICgwLCBkcm9wXzEuZGVmYXVsdCkoY3VyckRlZiksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aFdpdGhvdXQpO1xuICAgICAgICAgICAgLy8gcmVxdWlyZWQgbWFya2VyIHRvIGF2b2lkIGJhY2t0cmFja2luZyBwYXRocyB3aG9zZSBoaWdoZXIgcHJpb3JpdHkgYWx0ZXJuYXRpdmVzIGFscmVhZHkgbWF0Y2hlZFxuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKEVYSVRfQUxURVJOQVRJVkUpO1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvckdhc3QgPSBuZXcgZ2FzdF8xLlRlcm1pbmFsKHtcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbFR5cGU6IHByb2Quc2VwYXJhdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBudGhSZXBldGl0aW9uID0gbmV3IGdhc3RfMS5SZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBbc2VwYXJhdG9yR2FzdF0uY29uY2F0KHByb2QuZGVmaW5pdGlvbiksXG4gICAgICAgICAgICAgICAgaWR4OiBwcm9kLmlkeFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbmV4dERlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW250aFJlcGV0aXRpb25dLCAoMCwgZHJvcF8xLmRlZmF1bHQpKGN1cnJEZWYpKTtcbiAgICAgICAgICAgIHZhciBuZXh0UGF0aFdpdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogbmV4dERlZixcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoV2l0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIGdhc3RfMS5SZXBldGl0aW9uKSB7XG4gICAgICAgICAgICAvLyB0aGUgb3JkZXIgb2YgYWx0ZXJuYXRpdmVzIGlzIG1lYW5pbmdmdWwsIEZJTE8gKExhc3QgcGF0aCB3aWxsIGJlIHRyYXZlcnNlZCBmaXJzdCkuXG4gICAgICAgICAgICB2YXIgbmV4dFBhdGhXaXRob3V0ID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6ICgwLCBkcm9wXzEuZGVmYXVsdCkoY3VyckRlZiksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aFdpdGhvdXQpO1xuICAgICAgICAgICAgLy8gcmVxdWlyZWQgbWFya2VyIHRvIGF2b2lkIGJhY2t0cmFja2luZyBwYXRocyB3aG9zZSBoaWdoZXIgcHJpb3JpdHkgYWx0ZXJuYXRpdmVzIGFscmVhZHkgbWF0Y2hlZFxuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKEVYSVRfQUxURVJOQVRJVkUpO1xuICAgICAgICAgICAgLy8gVE9ETzogYW4gZW1wdHkgcmVwZXRpdGlvbiB3aWxsIGNhdXNlIGluZmluaXRlIGxvb3BzIGhlcmUsIHdpbGwgdGhlIHBhcnNlciBkZXRlY3QgdGhpcyBpbiBzZWxmQW5hbHlzaXM/XG4gICAgICAgICAgICB2YXIgbnRoUmVwZXRpdGlvbiA9IG5ldyBnYXN0XzEuUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogcHJvZC5kZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgIGlkeDogcHJvZC5pZHhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG5leHREZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtudGhSZXBldGl0aW9uXSwgKDAsIGRyb3BfMS5kZWZhdWx0KShjdXJyRGVmKSk7XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGhXaXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IG5leHREZWYsXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aFdpdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBnYXN0XzEuQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgICAgIC8vIHRoZSBvcmRlciBvZiBhbHRlcm5hdGl2ZXMgaXMgbWVhbmluZ2Z1bCwgRklMTyAoTGFzdCBwYXRoIHdpbGwgYmUgdHJhdmVyc2VkIGZpcnN0KS5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBwcm9kLmRlZmluaXRpb24ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyckFsdCA9IHByb2QuZGVmaW5pdGlvbltpXTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyckFsdFBhdGggPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICAgICAgZGVmOiBjdXJyQWx0LmRlZmluaXRpb24uY29uY2F0KCgwLCBkcm9wXzEuZGVmYXVsdCkoY3VyckRlZikpLFxuICAgICAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKGN1cnJBbHRQYXRoKTtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2goRVhJVF9BTFRFUk5BVElWRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIGdhc3RfMS5BbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBwcm9kLmRlZmluaXRpb24uY29uY2F0KCgwLCBkcm9wXzEuZGVmYXVsdCkoY3VyckRlZikpLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBnYXN0XzEuUnVsZSkge1xuICAgICAgICAgICAgLy8gbGFzdCBiZWNhdXNlIHdlIHNob3VsZCBvbmx5IGVuY291bnRlciBhdCBtb3N0IGEgc2luZ2xlIG9uZSBvZiB0aGVzZSBwZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChleHBhbmRUb3BMZXZlbFJ1bGUocHJvZCwgY3VycklkeCwgY3VyclJ1bGVTdGFjaywgY3Vyck9jY3VycmVuY2VTdGFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5uZXh0UG9zc2libGVUb2tlbnNBZnRlciA9IG5leHRQb3NzaWJsZVRva2Vuc0FmdGVyO1xuZnVuY3Rpb24gZXhwYW5kVG9wTGV2ZWxSdWxlKHRvcFJ1bGUsIGN1cnJJZHgsIGN1cnJSdWxlU3RhY2ssIGN1cnJPY2N1cnJlbmNlU3RhY2spIHtcbiAgICB2YXIgbmV3UnVsZVN0YWNrID0gKDAsIGNsb25lXzEuZGVmYXVsdCkoY3VyclJ1bGVTdGFjayk7XG4gICAgbmV3UnVsZVN0YWNrLnB1c2godG9wUnVsZS5uYW1lKTtcbiAgICB2YXIgbmV3Q3Vyck9jY3VycmVuY2VTdGFjayA9ICgwLCBjbG9uZV8xLmRlZmF1bHQpKGN1cnJPY2N1cnJlbmNlU3RhY2spO1xuICAgIC8vIHRvcCBydWxlIGlzIGFsd2F5cyBhc3N1bWVkIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBvY2N1cnJlbmNlIGluZGV4IDFcbiAgICBuZXdDdXJyT2NjdXJyZW5jZVN0YWNrLnB1c2goMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICBkZWY6IHRvcFJ1bGUuZGVmaW5pdGlvbixcbiAgICAgICAgcnVsZVN0YWNrOiBuZXdSdWxlU3RhY2ssXG4gICAgICAgIG9jY3VycmVuY2VTdGFjazogbmV3Q3Vyck9jY3VycmVuY2VTdGFja1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnByZXRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/keys.js":
/*!***************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/keys.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getKeyForAutomaticLookahead = exports.AT_LEAST_ONE_SEP_IDX = exports.MANY_SEP_IDX = exports.AT_LEAST_ONE_IDX = exports.MANY_IDX = exports.OPTION_IDX = exports.OR_IDX = exports.BITS_FOR_ALT_IDX = exports.BITS_FOR_RULE_IDX = exports.BITS_FOR_OCCURRENCE_IDX = exports.BITS_FOR_METHOD_TYPE = void 0;\nexports.BITS_FOR_METHOD_TYPE = 4;\nexports.BITS_FOR_OCCURRENCE_IDX = 8;\nexports.BITS_FOR_RULE_IDX = 12;\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nexports.BITS_FOR_ALT_IDX = 8;\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\nexports.OR_IDX = 1 << exports.BITS_FOR_OCCURRENCE_IDX;\nexports.OPTION_IDX = 2 << exports.BITS_FOR_OCCURRENCE_IDX;\nexports.MANY_IDX = 3 << exports.BITS_FOR_OCCURRENCE_IDX;\nexports.AT_LEAST_ONE_IDX = 4 << exports.BITS_FOR_OCCURRENCE_IDX;\nexports.MANY_SEP_IDX = 5 << exports.BITS_FOR_OCCURRENCE_IDX;\nexports.AT_LEAST_ONE_SEP_IDX = 6 << exports.BITS_FOR_OCCURRENCE_IDX;\n// this actually returns a number, but it is always used as a string (object prop key)\nfunction getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n    return occurrence | dslMethodIdx | ruleIdx;\n}\nexports.getKeyForAutomaticLookahead = getKeyForAutomaticLookahead;\nvar BITS_START_FOR_ALT_IDX = 32 - exports.BITS_FOR_ALT_IDX;\n//# sourceMappingURL=keys.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIva2V5cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUMsR0FBRyw0QkFBNEIsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0IsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsd0JBQXdCLEdBQUcseUJBQXlCLEdBQUcsK0JBQStCLEdBQUcsNEJBQTRCO0FBQ3JTLDRCQUE0QjtBQUM1QiwrQkFBK0I7QUFDL0IseUJBQXlCO0FBQ3pCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLHdCQUF3QjtBQUN4QixvQkFBb0I7QUFDcEIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9ncmFtbWFyL2tleXMuanM/ODZmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIExvb2thaGVhZCBrZXlzIGFyZSAzMkJpdCBpbnRlZ2VycyBpbiB0aGUgZm9ybVxuLy8gVFRUVFRUVFQtWlpaWlpaWlpaWlpaLVlZWVktWFhYWFhYWFhcbi8vIFhYWFggLT4gT2NjdXJyZW5jZSBJbmRleCBiaXRtYXAuXG4vLyBZWVlZIC0+IERTTCBNZXRob2QgVHlwZSBiaXRtYXAuXG4vLyBaWlpaWlpaWlpaWlpaWlogLT4gUnVsZSBzaG9ydCBJbmRleCBiaXRtYXAuXG4vLyBUVFRUVFRUVFQgLT4gYWx0ZXJuYXRpb24gYWx0ZXJuYXRpdmUgaW5kZXggYml0bWFwXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZCA9IGV4cG9ydHMuQVRfTEVBU1RfT05FX1NFUF9JRFggPSBleHBvcnRzLk1BTllfU0VQX0lEWCA9IGV4cG9ydHMuQVRfTEVBU1RfT05FX0lEWCA9IGV4cG9ydHMuTUFOWV9JRFggPSBleHBvcnRzLk9QVElPTl9JRFggPSBleHBvcnRzLk9SX0lEWCA9IGV4cG9ydHMuQklUU19GT1JfQUxUX0lEWCA9IGV4cG9ydHMuQklUU19GT1JfUlVMRV9JRFggPSBleHBvcnRzLkJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYID0gZXhwb3J0cy5CSVRTX0ZPUl9NRVRIT0RfVFlQRSA9IHZvaWQgMDtcbmV4cG9ydHMuQklUU19GT1JfTUVUSE9EX1RZUEUgPSA0O1xuZXhwb3J0cy5CSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWCA9IDg7XG5leHBvcnRzLkJJVFNfRk9SX1JVTEVfSURYID0gMTI7XG4vLyBUT0RPOiB2YWxpZGF0aW9uLCB0aGlzIG1lYW5zIHRoYXQgdGhlcmUgbWF5IGF0IG1vc3QgMl44IC0tPiAyNTYgYWx0ZXJuYXRpdmVzIGZvciBhbiBhbHRlcm5hdGlvbi5cbmV4cG9ydHMuQklUU19GT1JfQUxUX0lEWCA9IDg7XG4vLyBzaG9ydCBzdHJpbmcgdXNlZCBhcyBwYXJ0IG9mIG1hcHBpbmcga2V5cy5cbi8vIGJlaW5nIHNob3J0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSB3aGVuIGNvbXBvc2luZyBLRVlTIGZvciBtYXBzIG91dCBvZiB0aGVzZVxuLy8gVGhlIDUgLSA4IGJpdHMgKDE2IHBvc3NpYmxlIHZhbHVlcywgYXJlIHJlc2VydmVkIGZvciB0aGUgRFNMIG1ldGhvZCBpbmRpY2VzKVxuZXhwb3J0cy5PUl9JRFggPSAxIDw8IGV4cG9ydHMuQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnRzLk9QVElPTl9JRFggPSAyIDw8IGV4cG9ydHMuQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnRzLk1BTllfSURYID0gMyA8PCBleHBvcnRzLkJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1xuZXhwb3J0cy5BVF9MRUFTVF9PTkVfSURYID0gNCA8PCBleHBvcnRzLkJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1xuZXhwb3J0cy5NQU5ZX1NFUF9JRFggPSA1IDw8IGV4cG9ydHMuQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnRzLkFUX0xFQVNUX09ORV9TRVBfSURYID0gNiA8PCBleHBvcnRzLkJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1xuLy8gdGhpcyBhY3R1YWxseSByZXR1cm5zIGEgbnVtYmVyLCBidXQgaXQgaXMgYWx3YXlzIHVzZWQgYXMgYSBzdHJpbmcgKG9iamVjdCBwcm9wIGtleSlcbmZ1bmN0aW9uIGdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChydWxlSWR4LCBkc2xNZXRob2RJZHgsIG9jY3VycmVuY2UpIHtcbiAgICByZXR1cm4gb2NjdXJyZW5jZSB8IGRzbE1ldGhvZElkeCB8IHJ1bGVJZHg7XG59XG5leHBvcnRzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZCA9IGdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZDtcbnZhciBCSVRTX1NUQVJUX0ZPUl9BTFRfSURYID0gMzIgLSBleHBvcnRzLkJJVFNfRk9SX0FMVF9JRFg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXlzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/keys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js":
/*!************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LLkLookaheadStrategy = void 0;\nvar flatMap_1 = __importDefault(__webpack_require__(/*! lodash/flatMap */ \"(ssr)/./node_modules/lodash/flatMap.js\"));\nvar isEmpty_1 = __importDefault(__webpack_require__(/*! lodash/isEmpty */ \"(ssr)/./node_modules/lodash/isEmpty.js\"));\nvar errors_public_1 = __webpack_require__(/*! ../errors_public */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/errors_public.js\");\nvar parser_1 = __webpack_require__(/*! ../parser/parser */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\");\nvar checks_1 = __webpack_require__(/*! ./checks */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/checks.js\");\nvar lookahead_1 = __webpack_require__(/*! ./lookahead */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js\");\nvar LLkLookaheadStrategy = /** @class */ (function () {\n    function LLkLookaheadStrategy(options) {\n        var _a;\n        this.maxLookahead =\n            (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n    }\n    LLkLookaheadStrategy.prototype.validate = function (options) {\n        var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n        if ((0, isEmpty_1.default)(leftRecursionErrors)) {\n            var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n            var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n            var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n            var allErrors = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], leftRecursionErrors, true), emptyAltErrors, true), ambiguousAltsErrors, true), emptyRepetitionErrors, true);\n            return allErrors;\n        }\n        return leftRecursionErrors;\n    };\n    LLkLookaheadStrategy.prototype.validateNoLeftRecursion = function (rules) {\n        return (0, flatMap_1.default)(rules, function (currTopRule) {\n            return (0, checks_1.validateNoLeftRecursion)(currTopRule, currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n        });\n    };\n    LLkLookaheadStrategy.prototype.validateEmptyOrAlternatives = function (rules) {\n        return (0, flatMap_1.default)(rules, function (currTopRule) {\n            return (0, checks_1.validateEmptyOrAlternative)(currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);\n        });\n    };\n    LLkLookaheadStrategy.prototype.validateAmbiguousAlternationAlternatives = function (rules, maxLookahead) {\n        return (0, flatMap_1.default)(rules, function (currTopRule) {\n            return (0, checks_1.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n        });\n    };\n    LLkLookaheadStrategy.prototype.validateSomeNonEmptyLookaheadPath = function (rules, maxLookahead) {\n        return (0, checks_1.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);\n    };\n    LLkLookaheadStrategy.prototype.buildLookaheadForAlternation = function (options) {\n        return (0, lookahead_1.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, lookahead_1.buildAlternativesLookAheadFunc);\n    };\n    LLkLookaheadStrategy.prototype.buildLookaheadForOptional = function (options) {\n        return (0, lookahead_1.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0, lookahead_1.getProdType)(options.prodType), lookahead_1.buildSingleAlternativeLookaheadFunction);\n    };\n    return LLkLookaheadStrategy;\n}());\nexports.LLkLookaheadStrategy = LLkLookaheadStrategy;\n//# sourceMappingURL=llk_lookahead.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvbGxrX2xvb2thaGVhZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEI7QUFDNUIsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCxzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDaEQsZUFBZSxtQkFBTyxDQUFDLHdGQUFrQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMsaUZBQVU7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsdUZBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvbGxrX2xvb2thaGVhZC5qcz83YjNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MTGtMb29rYWhlYWRTdHJhdGVneSA9IHZvaWQgMDtcbnZhciBmbGF0TWFwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9mbGF0TWFwXCIpKTtcbnZhciBpc0VtcHR5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VtcHR5XCIpKTtcbnZhciBlcnJvcnNfcHVibGljXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzX3B1YmxpY1wiKTtcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9wYXJzZXIvcGFyc2VyXCIpO1xudmFyIGNoZWNrc18xID0gcmVxdWlyZShcIi4vY2hlY2tzXCIpO1xudmFyIGxvb2thaGVhZF8xID0gcmVxdWlyZShcIi4vbG9va2FoZWFkXCIpO1xudmFyIExMa0xvb2thaGVhZFN0cmF0ZWd5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExMa0xvb2thaGVhZFN0cmF0ZWd5KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLm1heExvb2thaGVhZCA9XG4gICAgICAgICAgICAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4TG9va2FoZWFkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwYXJzZXJfMS5ERUZBVUxUX1BBUlNFUl9DT05GSUcubWF4TG9va2FoZWFkO1xuICAgIH1cbiAgICBMTGtMb29rYWhlYWRTdHJhdGVneS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgbGVmdFJlY3Vyc2lvbkVycm9ycyA9IHRoaXMudmFsaWRhdGVOb0xlZnRSZWN1cnNpb24ob3B0aW9ucy5ydWxlcyk7XG4gICAgICAgIGlmICgoMCwgaXNFbXB0eV8xLmRlZmF1bHQpKGxlZnRSZWN1cnNpb25FcnJvcnMpKSB7XG4gICAgICAgICAgICB2YXIgZW1wdHlBbHRFcnJvcnMgPSB0aGlzLnZhbGlkYXRlRW1wdHlPckFsdGVybmF0aXZlcyhvcHRpb25zLnJ1bGVzKTtcbiAgICAgICAgICAgIHZhciBhbWJpZ3VvdXNBbHRzRXJyb3JzID0gdGhpcy52YWxpZGF0ZUFtYmlndW91c0FsdGVybmF0aW9uQWx0ZXJuYXRpdmVzKG9wdGlvbnMucnVsZXMsIHRoaXMubWF4TG9va2FoZWFkKTtcbiAgICAgICAgICAgIHZhciBlbXB0eVJlcGV0aXRpb25FcnJvcnMgPSB0aGlzLnZhbGlkYXRlU29tZU5vbkVtcHR5TG9va2FoZWFkUGF0aChvcHRpb25zLnJ1bGVzLCB0aGlzLm1heExvb2thaGVhZCk7XG4gICAgICAgICAgICB2YXIgYWxsRXJyb3JzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgbGVmdFJlY3Vyc2lvbkVycm9ycywgdHJ1ZSksIGVtcHR5QWx0RXJyb3JzLCB0cnVlKSwgYW1iaWd1b3VzQWx0c0Vycm9ycywgdHJ1ZSksIGVtcHR5UmVwZXRpdGlvbkVycm9ycywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWxsRXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0UmVjdXJzaW9uRXJyb3JzO1xuICAgIH07XG4gICAgTExrTG9va2FoZWFkU3RyYXRlZ3kucHJvdG90eXBlLnZhbGlkYXRlTm9MZWZ0UmVjdXJzaW9uID0gZnVuY3Rpb24gKHJ1bGVzKSB7XG4gICAgICAgIHJldHVybiAoMCwgZmxhdE1hcF8xLmRlZmF1bHQpKHJ1bGVzLCBmdW5jdGlvbiAoY3VyclRvcFJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2hlY2tzXzEudmFsaWRhdGVOb0xlZnRSZWN1cnNpb24pKGN1cnJUb3BSdWxlLCBjdXJyVG9wUnVsZSwgZXJyb3JzX3B1YmxpY18xLmRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTExrTG9va2FoZWFkU3RyYXRlZ3kucHJvdG90eXBlLnZhbGlkYXRlRW1wdHlPckFsdGVybmF0aXZlcyA9IGZ1bmN0aW9uIChydWxlcykge1xuICAgICAgICByZXR1cm4gKDAsIGZsYXRNYXBfMS5kZWZhdWx0KShydWxlcywgZnVuY3Rpb24gKGN1cnJUb3BSdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNoZWNrc18xLnZhbGlkYXRlRW1wdHlPckFsdGVybmF0aXZlKShjdXJyVG9wUnVsZSwgZXJyb3JzX3B1YmxpY18xLmRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTExrTG9va2FoZWFkU3RyYXRlZ3kucHJvdG90eXBlLnZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXMgPSBmdW5jdGlvbiAocnVsZXMsIG1heExvb2thaGVhZCkge1xuICAgICAgICByZXR1cm4gKDAsIGZsYXRNYXBfMS5kZWZhdWx0KShydWxlcywgZnVuY3Rpb24gKGN1cnJUb3BSdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNoZWNrc18xLnZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXMpKGN1cnJUb3BSdWxlLCBtYXhMb29rYWhlYWQsIGVycm9yc19wdWJsaWNfMS5kZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExMa0xvb2thaGVhZFN0cmF0ZWd5LnByb3RvdHlwZS52YWxpZGF0ZVNvbWVOb25FbXB0eUxvb2thaGVhZFBhdGggPSBmdW5jdGlvbiAocnVsZXMsIG1heExvb2thaGVhZCkge1xuICAgICAgICByZXR1cm4gKDAsIGNoZWNrc18xLnZhbGlkYXRlU29tZU5vbkVtcHR5TG9va2FoZWFkUGF0aCkocnVsZXMsIG1heExvb2thaGVhZCwgZXJyb3JzX3B1YmxpY18xLmRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlcik7XG4gICAgfTtcbiAgICBMTGtMb29rYWhlYWRTdHJhdGVneS5wcm90b3R5cGUuYnVpbGRMb29rYWhlYWRGb3JBbHRlcm5hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgbG9va2FoZWFkXzEuYnVpbGRMb29rYWhlYWRGdW5jRm9yT3IpKG9wdGlvbnMucHJvZE9jY3VycmVuY2UsIG9wdGlvbnMucnVsZSwgb3B0aW9ucy5tYXhMb29rYWhlYWQsIG9wdGlvbnMuaGFzUHJlZGljYXRlcywgb3B0aW9ucy5keW5hbWljVG9rZW5zRW5hYmxlZCwgbG9va2FoZWFkXzEuYnVpbGRBbHRlcm5hdGl2ZXNMb29rQWhlYWRGdW5jKTtcbiAgICB9O1xuICAgIExMa0xvb2thaGVhZFN0cmF0ZWd5LnByb3RvdHlwZS5idWlsZExvb2thaGVhZEZvck9wdGlvbmFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBsb29rYWhlYWRfMS5idWlsZExvb2thaGVhZEZ1bmNGb3JPcHRpb25hbFByb2QpKG9wdGlvbnMucHJvZE9jY3VycmVuY2UsIG9wdGlvbnMucnVsZSwgb3B0aW9ucy5tYXhMb29rYWhlYWQsIG9wdGlvbnMuZHluYW1pY1Rva2Vuc0VuYWJsZWQsICgwLCBsb29rYWhlYWRfMS5nZXRQcm9kVHlwZSkob3B0aW9ucy5wcm9kVHlwZSksIGxvb2thaGVhZF8xLmJ1aWxkU2luZ2xlQWx0ZXJuYXRpdmVMb29rYWhlYWRGdW5jdGlvbik7XG4gICAgfTtcbiAgICByZXR1cm4gTExrTG9va2FoZWFkU3RyYXRlZ3k7XG59KCkpO1xuZXhwb3J0cy5MTGtMb29rYWhlYWRTdHJhdGVneSA9IExMa0xvb2thaGVhZFN0cmF0ZWd5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGxrX2xvb2thaGVhZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js":
/*!********************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.areTokenCategoriesNotUsed = exports.isStrictPrefixOfPath = exports.containsPath = exports.getLookaheadPathsForOptionalProd = exports.getLookaheadPathsForOr = exports.lookAheadSequenceFromAlternatives = exports.buildSingleAlternativeLookaheadFunction = exports.buildAlternativesLookAheadFunc = exports.buildLookaheadFuncForOptionalProd = exports.buildLookaheadFuncForOr = exports.getLookaheadPaths = exports.getProdType = exports.PROD_TYPE = void 0;\nvar isEmpty_1 = __importDefault(__webpack_require__(/*! lodash/isEmpty */ \"(ssr)/./node_modules/lodash/isEmpty.js\"));\nvar flatten_1 = __importDefault(__webpack_require__(/*! lodash/flatten */ \"(ssr)/./node_modules/lodash/flatten.js\"));\nvar every_1 = __importDefault(__webpack_require__(/*! lodash/every */ \"(ssr)/./node_modules/lodash/every.js\"));\nvar map_1 = __importDefault(__webpack_require__(/*! lodash/map */ \"(ssr)/./node_modules/lodash/map.js\"));\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar has_1 = __importDefault(__webpack_require__(/*! lodash/has */ \"(ssr)/./node_modules/lodash/has.js\"));\nvar reduce_1 = __importDefault(__webpack_require__(/*! lodash/reduce */ \"(ssr)/./node_modules/lodash/reduce.js\"));\nvar interpreter_1 = __webpack_require__(/*! ./interpreter */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js\");\nvar rest_1 = __webpack_require__(/*! ./rest */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/rest.js\");\nvar tokens_1 = __webpack_require__(/*! ../../scan/tokens */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/tokens.js\");\nvar gast_1 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nvar gast_2 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nvar PROD_TYPE;\n(function (PROD_TYPE) {\n    PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE = exports.PROD_TYPE || (exports.PROD_TYPE = {}));\nfunction getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof gast_1.Option || prod === \"Option\") {\n        return PROD_TYPE.OPTION;\n    }\n    else if (prod instanceof gast_1.Repetition || prod === \"Repetition\") {\n        return PROD_TYPE.REPETITION;\n    }\n    else if (prod instanceof gast_1.RepetitionMandatory ||\n        prod === \"RepetitionMandatory\") {\n        return PROD_TYPE.REPETITION_MANDATORY;\n    }\n    else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator ||\n        prod === \"RepetitionMandatoryWithSeparator\") {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    }\n    else if (prod instanceof gast_1.RepetitionWithSeparator ||\n        prod === \"RepetitionWithSeparator\") {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    }\n    else if (prod instanceof gast_1.Alternation || prod === \"Alternation\") {\n        return PROD_TYPE.ALTERNATION;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexports.getProdType = getProdType;\nfunction getLookaheadPaths(options) {\n    var occurrence = options.occurrence, rule = options.rule, prodType = options.prodType, maxLookahead = options.maxLookahead;\n    var type = getProdType(prodType);\n    if (type === PROD_TYPE.ALTERNATION) {\n        return getLookaheadPathsForOr(occurrence, rule, maxLookahead);\n    }\n    else {\n        return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);\n    }\n}\nexports.getLookaheadPaths = getLookaheadPaths;\nfunction buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokens_1.tokenStructuredMatcherNoCategories\n        : tokens_1.tokenStructuredMatcher;\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\nexports.buildLookaheadFuncForOr = buildLookaheadFuncForOr;\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nfunction buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokens_1.tokenStructuredMatcherNoCategories\n        : tokens_1.tokenStructuredMatcher;\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexports.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;\nfunction buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    var numOfAlts = alts.length;\n    var areAllOneTokenLookahead = (0, every_1.default)(alts, function (currAlt) {\n        return (0, every_1.default)(currAlt, function (currPath) {\n            return currPath.length === 1;\n        });\n    });\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function (orAlts) {\n            // unfortunately the predicates must be extracted every single time\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n            var predicates = (0, map_1.default)(orAlts, function (currAlt) { return currAlt.GATE; });\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                var currPredicate = predicates[t];\n                if (currPredicate !== undefined && currPredicate.call(this) === false) {\n                    // if the predicate does not match there is no point in checking the paths\n                    continue;\n                }\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        // optimized (common) case of all the lookaheads paths requiring only\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n        var singleTokenAlts = (0, map_1.default)(alts, function (currAlt) {\n            return (0, flatten_1.default)(currAlt);\n        });\n        var choiceToAlt_1 = (0, reduce_1.default)(singleTokenAlts, function (result, currAlt, idx) {\n            (0, forEach_1.default)(currAlt, function (currTokType) {\n                if (!(0, has_1.default)(result, currTokType.tokenTypeIdx)) {\n                    result[currTokType.tokenTypeIdx] = idx;\n                }\n                (0, forEach_1.default)(currTokType.categoryMatches, function (currExtendingType) {\n                    if (!(0, has_1.default)(result, currExtendingType)) {\n                        result[currExtendingType] = idx;\n                    }\n                });\n            });\n            return result;\n        }, {});\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            var nextToken = this.LA(1);\n            return choiceToAlt_1[nextToken.tokenTypeIdx];\n        };\n    }\n    else {\n        // optimized lookahead without needing to check the predicates at all.\n        // this causes code duplication which is intentional to improve performance.\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n}\nexports.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;\nfunction buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    var areAllOneTokenLookahead = (0, every_1.default)(alt, function (currPath) {\n        return currPath.length === 1;\n    });\n    var numOfPaths = alt.length;\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        var singleTokensTypes = (0, flatten_1.default)(alt);\n        if (singleTokensTypes.length === 1 &&\n            (0, isEmpty_1.default)(singleTokensTypes[0].categoryMatches)) {\n            var expectedTokenType = singleTokensTypes[0];\n            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n            return function () {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n            };\n        }\n        else {\n            var choiceToAlt_2 = (0, reduce_1.default)(singleTokensTypes, function (result, currTokType, idx) {\n                result[currTokType.tokenTypeIdx] = true;\n                (0, forEach_1.default)(currTokType.categoryMatches, function (currExtendingType) {\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function () {\n                var nextToken = this.LA(1);\n                return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    }\n    else {\n        return function () {\n            nextPath: for (var j = 0; j < numOfPaths; j++) {\n                var currPath = alt[j];\n                var currPathLength = currPath.length;\n                for (var i = 0; i < currPathLength; i++) {\n                    var nextToken = this.LA(i + 1);\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\n                        // mismatch in current path\n                        // try the next pth\n                        continue nextPath;\n                    }\n                }\n                // found a full path that matches.\n                return true;\n            }\n            // none of the paths matched\n            return false;\n        };\n    }\n}\nexports.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;\nvar RestDefinitionFinderWalker = /** @class */ (function (_super) {\n    __extends(RestDefinitionFinderWalker, _super);\n    function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        return _this;\n    }\n    RestDefinitionFinderWalker.prototype.startWalking = function () {\n        this.walk(this.topProd);\n        return this.restDef;\n    };\n    RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n        return false;\n    };\n    RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return RestDefinitionFinderWalker;\n}(rest_1.RestWalker));\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nvar InsideDefinitionFinderVisitor = /** @class */ (function (_super) {\n    __extends(InsideDefinitionFinderVisitor, _super);\n    function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n        var _this = _super.call(this) || this;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        _this.targetRef = targetRef;\n        _this.result = [];\n        return _this;\n    }\n    InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdName &&\n            (this.targetRef === undefined || node === this.targetRef)) {\n            this.result = node.definition;\n        }\n    };\n    InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n    };\n    return InsideDefinitionFinderVisitor;\n}(gast_2.GAstVisitor));\nfunction initializeArrayOfArrays(size) {\n    var result = new Array(size);\n    for (var i = 0; i < size; i++) {\n        result[i] = [];\n    }\n    return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n    var keys = [\"\"];\n    for (var i = 0; i < path.length; i++) {\n        var tokType = path[i];\n        var longerKeys = [];\n        for (var j = 0; j < keys.length; j++) {\n            var currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n            for (var t = 0; t < tokType.categoryMatches.length; t++) {\n                var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        // We only want to test vs the other alternatives\n        if (currAltIdx === idx) {\n            continue;\n        }\n        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n            var searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) {\n                return false;\n            }\n        }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true;\n}\nfunction lookAheadSequenceFromAlternatives(altsDefs, k) {\n    var partialAlts = (0, map_1.default)(altsDefs, function (currAlt) {\n        return (0, interpreter_1.possiblePathsFrom)([currAlt], 1);\n    });\n    var finalResult = initializeArrayOfArrays(partialAlts.length);\n    var altsHashes = (0, map_1.default)(partialAlts, function (currAltPaths) {\n        var dict = {};\n        (0, forEach_1.default)(currAltPaths, function (item) {\n            var keys = pathToHashKeys(item.partialPath);\n            (0, forEach_1.default)(keys, function (currKey) {\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    var newData = partialAlts;\n    // maxLookahead loop\n    for (var pathLength = 1; pathLength <= k; pathLength++) {\n        var currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        var _loop_1 = function (altIdx) {\n            var currAltPathsAndSuffixes = currDataset[altIdx];\n            // paths in current alternative loop\n            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n                var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                var prefixKeys = pathToHashKeys(currPathPrefix);\n                var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                // End of the line for this path.\n                if (isUnique || (0, isEmpty_1.default)(suffixDef) || currPathPrefix.length === k) {\n                    var currAltResult = finalResult[altIdx];\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        // Update all new  keys for the current path.\n                        for (var j = 0; j < prefixKeys.length; j++) {\n                            var currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                }\n                // Expand longer paths\n                else {\n                    var newPartialPathsAndSuffixes = (0, interpreter_1.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    // Update keys for new known paths\n                    (0, forEach_1.default)(newPartialPathsAndSuffixes, function (item) {\n                        var prefixKeys = pathToHashKeys(item.partialPath);\n                        (0, forEach_1.default)(prefixKeys, function (key) {\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        };\n        // alternatives loop\n        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n            _loop_1(altIdx);\n        }\n    }\n    return finalResult;\n}\nexports.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;\nfunction getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor);\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexports.getLookaheadPathsForOr = getLookaheadPathsForOr;\nfunction getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    var insideDef = insideDefVisitor.result;\n    var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    var afterDef = afterDefWalker.startWalking();\n    var insideFlat = new gast_1.Alternative({ definition: insideDef });\n    var afterFlat = new gast_1.Alternative({ definition: afterDef });\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexports.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;\nfunction containsPath(alternative, searchPath) {\n    compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n        var otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) {\n            continue;\n        }\n        for (var j = 0; j < otherPath.length; j++) {\n            var searchTok = searchPath[j];\n            var otherTok = otherPath[j];\n            var matchingTokens = searchTok === otherTok ||\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n            if (matchingTokens === false) {\n                continue compareOtherPath;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nexports.containsPath = containsPath;\nfunction isStrictPrefixOfPath(prefix, other) {\n    return (prefix.length < other.length &&\n        (0, every_1.default)(prefix, function (tokType, idx) {\n            var otherTokType = other[idx];\n            return (tokType === otherTokType ||\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\n        }));\n}\nexports.isStrictPrefixOfPath = isStrictPrefixOfPath;\nfunction areTokenCategoriesNotUsed(lookAheadPaths) {\n    return (0, every_1.default)(lookAheadPaths, function (singleAltPaths) {\n        return (0, every_1.default)(singleAltPaths, function (singlePath) {\n            return (0, every_1.default)(singlePath, function (token) { return (0, isEmpty_1.default)(token.categoryMatches); });\n        });\n    });\n}\nexports.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;\n//# sourceMappingURL=lookahead.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvbG9va2FoZWFkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLEdBQUcsNEJBQTRCLEdBQUcsb0JBQW9CLEdBQUcsd0NBQXdDLEdBQUcsOEJBQThCLEdBQUcseUNBQXlDLEdBQUcsK0NBQStDLEdBQUcsc0NBQXNDLEdBQUcseUNBQXlDLEdBQUcsK0JBQStCLEdBQUcseUJBQXlCLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCO0FBQzliLGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsOEJBQThCLG1CQUFPLENBQUMsMERBQWM7QUFDcEQsNEJBQTRCLG1CQUFPLENBQUMsc0RBQVk7QUFDaEQsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELDRCQUE0QixtQkFBTyxDQUFDLHNEQUFZO0FBQ2hELCtCQUErQixtQkFBTyxDQUFDLDREQUFlO0FBQ3RELG9CQUFvQixtQkFBTyxDQUFDLDJGQUFlO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyw2RUFBUTtBQUM3QixlQUFlLG1CQUFPLENBQUMsaUZBQW1CO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLDhFQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0MsaUJBQWlCLEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsc0JBQXNCO0FBQ25HLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RDtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBLGdDQUFnQyxvQkFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSw0QkFBNEIsb0NBQW9DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1Q0FBdUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQ0FBbUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhDQUE4QztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2QkFBNkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1QkFBdUI7QUFDckUsNkNBQTZDLHNCQUFzQjtBQUNuRTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esc0NBQXNDLHdCQUF3QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsdURBQXVEO0FBQzlILFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9ncmFtbWFyL2xvb2thaGVhZC5qcz9kMzk5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZCA9IGV4cG9ydHMuaXNTdHJpY3RQcmVmaXhPZlBhdGggPSBleHBvcnRzLmNvbnRhaW5zUGF0aCA9IGV4cG9ydHMuZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2QgPSBleHBvcnRzLmdldExvb2thaGVhZFBhdGhzRm9yT3IgPSBleHBvcnRzLmxvb2tBaGVhZFNlcXVlbmNlRnJvbUFsdGVybmF0aXZlcyA9IGV4cG9ydHMuYnVpbGRTaW5nbGVBbHRlcm5hdGl2ZUxvb2thaGVhZEZ1bmN0aW9uID0gZXhwb3J0cy5idWlsZEFsdGVybmF0aXZlc0xvb2tBaGVhZEZ1bmMgPSBleHBvcnRzLmJ1aWxkTG9va2FoZWFkRnVuY0Zvck9wdGlvbmFsUHJvZCA9IGV4cG9ydHMuYnVpbGRMb29rYWhlYWRGdW5jRm9yT3IgPSBleHBvcnRzLmdldExvb2thaGVhZFBhdGhzID0gZXhwb3J0cy5nZXRQcm9kVHlwZSA9IGV4cG9ydHMuUFJPRF9UWVBFID0gdm9pZCAwO1xudmFyIGlzRW1wdHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRW1wdHlcIikpO1xudmFyIGZsYXR0ZW5fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZsYXR0ZW5cIikpO1xudmFyIGV2ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9ldmVyeVwiKSk7XG52YXIgbWFwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9tYXBcIikpO1xudmFyIGZvckVhY2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZvckVhY2hcIikpO1xudmFyIGhhc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaGFzXCIpKTtcbnZhciByZWR1Y2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3JlZHVjZVwiKSk7XG52YXIgaW50ZXJwcmV0ZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVycHJldGVyXCIpO1xudmFyIHJlc3RfMSA9IHJlcXVpcmUoXCIuL3Jlc3RcIik7XG52YXIgdG9rZW5zXzEgPSByZXF1aXJlKFwiLi4vLi4vc2Nhbi90b2tlbnNcIik7XG52YXIgZ2FzdF8xID0gcmVxdWlyZShcIkBjaGV2cm90YWluL2dhc3RcIik7XG52YXIgZ2FzdF8yID0gcmVxdWlyZShcIkBjaGV2cm90YWluL2dhc3RcIik7XG52YXIgUFJPRF9UWVBFO1xuKGZ1bmN0aW9uIChQUk9EX1RZUEUpIHtcbiAgICBQUk9EX1RZUEVbUFJPRF9UWVBFW1wiT1BUSU9OXCJdID0gMF0gPSBcIk9QVElPTlwiO1xuICAgIFBST0RfVFlQRVtQUk9EX1RZUEVbXCJSRVBFVElUSU9OXCJdID0gMV0gPSBcIlJFUEVUSVRJT05cIjtcbiAgICBQUk9EX1RZUEVbUFJPRF9UWVBFW1wiUkVQRVRJVElPTl9NQU5EQVRPUllcIl0gPSAyXSA9IFwiUkVQRVRJVElPTl9NQU5EQVRPUllcIjtcbiAgICBQUk9EX1RZUEVbUFJPRF9UWVBFW1wiUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1JcIl0gPSAzXSA9IFwiUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1JcIjtcbiAgICBQUk9EX1RZUEVbUFJPRF9UWVBFW1wiUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUlwiXSA9IDRdID0gXCJSRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SXCI7XG4gICAgUFJPRF9UWVBFW1BST0RfVFlQRVtcIkFMVEVSTkFUSU9OXCJdID0gNV0gPSBcIkFMVEVSTkFUSU9OXCI7XG59KShQUk9EX1RZUEUgPSBleHBvcnRzLlBST0RfVFlQRSB8fCAoZXhwb3J0cy5QUk9EX1RZUEUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0UHJvZFR5cGUocHJvZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2QgaW5zdGFuY2VvZiBnYXN0XzEuT3B0aW9uIHx8IHByb2QgPT09IFwiT3B0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIFBST0RfVFlQRS5PUFRJT047XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBnYXN0XzEuUmVwZXRpdGlvbiB8fCBwcm9kID09PSBcIlJlcGV0aXRpb25cIikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLlJFUEVUSVRJT047XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBnYXN0XzEuUmVwZXRpdGlvbk1hbmRhdG9yeSB8fFxuICAgICAgICBwcm9kID09PSBcIlJlcGV0aXRpb25NYW5kYXRvcnlcIikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgZ2FzdF8xLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yIHx8XG4gICAgICAgIHByb2QgPT09IFwiUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3JcIikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgZ2FzdF8xLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yIHx8XG4gICAgICAgIHByb2QgPT09IFwiUmVwZXRpdGlvbldpdGhTZXBhcmF0b3JcIikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1I7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBnYXN0XzEuQWx0ZXJuYXRpb24gfHwgcHJvZCA9PT0gXCJBbHRlcm5hdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBQUk9EX1RZUEUuQUxURVJOQVRJT047XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0UHJvZFR5cGUgPSBnZXRQcm9kVHlwZTtcbmZ1bmN0aW9uIGdldExvb2thaGVhZFBhdGhzKG9wdGlvbnMpIHtcbiAgICB2YXIgb2NjdXJyZW5jZSA9IG9wdGlvbnMub2NjdXJyZW5jZSwgcnVsZSA9IG9wdGlvbnMucnVsZSwgcHJvZFR5cGUgPSBvcHRpb25zLnByb2RUeXBlLCBtYXhMb29rYWhlYWQgPSBvcHRpb25zLm1heExvb2thaGVhZDtcbiAgICB2YXIgdHlwZSA9IGdldFByb2RUeXBlKHByb2RUeXBlKTtcbiAgICBpZiAodHlwZSA9PT0gUFJPRF9UWVBFLkFMVEVSTkFUSU9OKSB7XG4gICAgICAgIHJldHVybiBnZXRMb29rYWhlYWRQYXRoc0Zvck9yKG9jY3VycmVuY2UsIHJ1bGUsIG1heExvb2thaGVhZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2Qob2NjdXJyZW5jZSwgcnVsZSwgdHlwZSwgbWF4TG9va2FoZWFkKTtcbiAgICB9XG59XG5leHBvcnRzLmdldExvb2thaGVhZFBhdGhzID0gZ2V0TG9va2FoZWFkUGF0aHM7XG5mdW5jdGlvbiBidWlsZExvb2thaGVhZEZ1bmNGb3JPcihvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgbWF4TG9va2FoZWFkLCBoYXNQcmVkaWNhdGVzLCBkeW5hbWljVG9rZW5zRW5hYmxlZCwgbGFGdW5jQnVpbGRlcikge1xuICAgIHZhciBsb29rQWhlYWRQYXRocyA9IGdldExvb2thaGVhZFBhdGhzRm9yT3Iob2NjdXJyZW5jZSwgcnVsZUdyYW1tYXIsIG1heExvb2thaGVhZCk7XG4gICAgdmFyIHRva2VuTWF0Y2hlciA9IGFyZVRva2VuQ2F0ZWdvcmllc05vdFVzZWQobG9va0FoZWFkUGF0aHMpXG4gICAgICAgID8gdG9rZW5zXzEudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllc1xuICAgICAgICA6IHRva2Vuc18xLnRva2VuU3RydWN0dXJlZE1hdGNoZXI7XG4gICAgcmV0dXJuIGxhRnVuY0J1aWxkZXIobG9va0FoZWFkUGF0aHMsIGhhc1ByZWRpY2F0ZXMsIHRva2VuTWF0Y2hlciwgZHluYW1pY1Rva2Vuc0VuYWJsZWQpO1xufVxuZXhwb3J0cy5idWlsZExvb2thaGVhZEZ1bmNGb3JPciA9IGJ1aWxkTG9va2FoZWFkRnVuY0Zvck9yO1xuLyoqXG4gKiAgV2hlbiBkZWFsaW5nIHdpdGggYW4gT3B0aW9uYWwgcHJvZHVjdGlvbiAoT1BUSU9OL01BTlkvMm5kIGl0ZXJhdGlvbiBvZiBBVF9MRUFTVF9PTkUvLi4uKSB3ZSBuZWVkIHRvIGNvbXBhcmVcbiAqICB0aGUgbG9va2FoZWFkIFwiaW5zaWRlXCIgdGhlIHByb2R1Y3Rpb24gYW5kIHRoZSBsb29rYWhlYWQgaW1tZWRpYXRlbHkgXCJhZnRlclwiIGl0IGluIHRoZSBzYW1lIHRvcCBsZXZlbCBydWxlIChjb250ZXh0IGZyZWUpLlxuICpcbiAqICBFeGFtcGxlOiBnaXZlbiBhIHByb2R1Y3Rpb246XG4gKiAgQUJDKERFKT9ERlxuICpcbiAqICBUaGUgb3B0aW9uYWwgJyhERSk/JyBzaG91bGQgb25seSBiZSBlbnRlcmVkIGlmIHdlIHNlZSAnREUnLiBhIHNpbmdsZSBUb2tlbiAnRCcgaXMgbm90IHN1ZmZpY2llbnQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgdHdvXG4gKiAgYWx0ZXJuYXRpdmVzLlxuICpcbiAqICBAcmV0dXJucyBBIExvb2thaGVhZCBmdW5jdGlvbiB3aGljaCB3aWxsIHJldHVybiB0cnVlIElGRiB0aGUgcGFyc2VyIHNob3VsZCBwYXJzZSB0aGUgT3B0aW9uYWwgcHJvZHVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMb29rYWhlYWRGdW5jRm9yT3B0aW9uYWxQcm9kKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBrLCBkeW5hbWljVG9rZW5zRW5hYmxlZCwgcHJvZFR5cGUsIGxvb2thaGVhZEJ1aWxkZXIpIHtcbiAgICB2YXIgbG9va0FoZWFkUGF0aHMgPSBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZChvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgcHJvZFR5cGUsIGspO1xuICAgIHZhciB0b2tlbk1hdGNoZXIgPSBhcmVUb2tlbkNhdGVnb3JpZXNOb3RVc2VkKGxvb2tBaGVhZFBhdGhzKVxuICAgICAgICA/IHRva2Vuc18xLnRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXNcbiAgICAgICAgOiB0b2tlbnNfMS50b2tlblN0cnVjdHVyZWRNYXRjaGVyO1xuICAgIHJldHVybiBsb29rYWhlYWRCdWlsZGVyKGxvb2tBaGVhZFBhdGhzWzBdLCB0b2tlbk1hdGNoZXIsIGR5bmFtaWNUb2tlbnNFbmFibGVkKTtcbn1cbmV4cG9ydHMuYnVpbGRMb29rYWhlYWRGdW5jRm9yT3B0aW9uYWxQcm9kID0gYnVpbGRMb29rYWhlYWRGdW5jRm9yT3B0aW9uYWxQcm9kO1xuZnVuY3Rpb24gYnVpbGRBbHRlcm5hdGl2ZXNMb29rQWhlYWRGdW5jKGFsdHMsIGhhc1ByZWRpY2F0ZXMsIHRva2VuTWF0Y2hlciwgZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICB2YXIgbnVtT2ZBbHRzID0gYWx0cy5sZW5ndGg7XG4gICAgdmFyIGFyZUFsbE9uZVRva2VuTG9va2FoZWFkID0gKDAsIGV2ZXJ5XzEuZGVmYXVsdCkoYWx0cywgZnVuY3Rpb24gKGN1cnJBbHQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBldmVyeV8xLmRlZmF1bHQpKGN1cnJBbHQsIGZ1bmN0aW9uIChjdXJyUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJQYXRoLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gVGhpcyB2ZXJzaW9uIHRha2VzIGludG8gYWNjb3VudCB0aGUgcHJlZGljYXRlcyBhcyB3ZWxsLlxuICAgIGlmIChoYXNQcmVkaWNhdGVzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBjaG9zZW4gYWx0ZXJuYXRpdmUgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob3JBbHRzKSB7XG4gICAgICAgICAgICAvLyB1bmZvcnR1bmF0ZWx5IHRoZSBwcmVkaWNhdGVzIG11c3QgYmUgZXh0cmFjdGVkIGV2ZXJ5IHNpbmdsZSB0aW1lXG4gICAgICAgICAgICAvLyBhcyB0aGV5IGNhbm5vdCBiZSBjYWNoZWQgZHVlIHRvIHJlZmVyZW5jZXMgdG8gcGFyYW1ldGVycyh2YXJzKSB3aGljaCBhcmUgbm8gbG9uZ2VyIHZhbGlkLlxuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IGluIHRoZSBjb21tb24gY2FzZSBvZiBubyBwcmVkaWNhdGVzLCBubyBjcHUgdGltZSB3aWxsIGJlIHdhc3RlZCBvbiB0aGlzIChzZWUgZWxzZSBibG9jaylcbiAgICAgICAgICAgIHZhciBwcmVkaWNhdGVzID0gKDAsIG1hcF8xLmRlZmF1bHQpKG9yQWx0cywgZnVuY3Rpb24gKGN1cnJBbHQpIHsgcmV0dXJuIGN1cnJBbHQuR0FURTsgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bU9mQWx0czsgdCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJBbHQgPSBhbHRzW3RdO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyTnVtT2ZQYXRocyA9IGN1cnJBbHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyUHJlZGljYXRlID0gcHJlZGljYXRlc1t0XTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyclByZWRpY2F0ZSAhPT0gdW5kZWZpbmVkICYmIGN1cnJQcmVkaWNhdGUuY2FsbCh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHByZWRpY2F0ZSBkb2VzIG5vdCBtYXRjaCB0aGVyZSBpcyBubyBwb2ludCBpbiBjaGVja2luZyB0aGUgcGF0aHNcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRQYXRoOiBmb3IgKHZhciBqID0gMDsgaiA8IGN1cnJOdW1PZlBhdGhzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJQYXRoID0gY3VyckFsdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJQYXRoTGVuZ3RoID0gY3VyclBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJQYXRoTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLkxBKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbk1hdGNoZXIobmV4dFRva2VuLCBjdXJyUGF0aFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlzbWF0Y2ggaW4gY3VycmVudCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBuZXh0IHB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG5leHRQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgZnVsbCBwYXRoIHRoYXQgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGFsc28gd29yayBmb3IgYW4gZW1wdHkgQUxUIGFzIHRoZSBsb29wIHdpbGwgYmUgc2tpcHBlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm9uZSBvZiB0aGUgcGF0aHMgZm9yIHRoZSBjdXJyZW50IGFsdGVybmF0aXZlIG1hdGNoZWRcbiAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIG5leHQgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vbmUgb2YgdGhlIGFsdGVybmF0aXZlcyBjb3VsZCBiZSBtYXRjaGVkXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmVBbGxPbmVUb2tlbkxvb2thaGVhZCAmJiAhZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICAgICAgLy8gb3B0aW1pemVkIChjb21tb24pIGNhc2Ugb2YgYWxsIHRoZSBsb29rYWhlYWRzIHBhdGhzIHJlcXVpcmluZyBvbmx5XG4gICAgICAgIC8vIGEgc2luZ2xlIHRva2VuIGxvb2thaGVhZC4gVGhlc2UgT3B0aW1pemF0aW9ucyBjYW5ub3Qgd29yayBpZiBkeW5hbWljYWxseSBkZWZpbmVkIFRva2VucyBhcmUgdXNlZC5cbiAgICAgICAgdmFyIHNpbmdsZVRva2VuQWx0cyA9ICgwLCBtYXBfMS5kZWZhdWx0KShhbHRzLCBmdW5jdGlvbiAoY3VyckFsdCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBmbGF0dGVuXzEuZGVmYXVsdCkoY3VyckFsdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2hvaWNlVG9BbHRfMSA9ICgwLCByZWR1Y2VfMS5kZWZhdWx0KShzaW5nbGVUb2tlbkFsdHMsIGZ1bmN0aW9uIChyZXN1bHQsIGN1cnJBbHQsIGlkeCkge1xuICAgICAgICAgICAgKDAsIGZvckVhY2hfMS5kZWZhdWx0KShjdXJyQWx0LCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoISgwLCBoYXNfMS5kZWZhdWx0KShyZXN1bHQsIGN1cnJUb2tUeXBlLnRva2VuVHlwZUlkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJUb2tUeXBlLnRva2VuVHlwZUlkeF0gPSBpZHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICgwLCBmb3JFYWNoXzEuZGVmYXVsdCkoY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzLCBmdW5jdGlvbiAoY3VyckV4dGVuZGluZ1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgaGFzXzEuZGVmYXVsdCkocmVzdWx0LCBjdXJyRXh0ZW5kaW5nVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyRXh0ZW5kaW5nVHlwZV0gPSBpZHg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwge30pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gLSBUaGUgY2hvc2VuIGFsdGVybmF0aXZlIGluZGV4XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5leHRUb2tlbiA9IHRoaXMuTEEoMSk7XG4gICAgICAgICAgICByZXR1cm4gY2hvaWNlVG9BbHRfMVtuZXh0VG9rZW4udG9rZW5UeXBlSWR4XTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG9wdGltaXplZCBsb29rYWhlYWQgd2l0aG91dCBuZWVkaW5nIHRvIGNoZWNrIHRoZSBwcmVkaWNhdGVzIGF0IGFsbC5cbiAgICAgICAgLy8gdGhpcyBjYXVzZXMgY29kZSBkdXBsaWNhdGlvbiB3aGljaCBpcyBpbnRlbnRpb25hbCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gLSBUaGUgY2hvc2VuIGFsdGVybmF0aXZlIGluZGV4XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1PZkFsdHM7IHQrKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyQWx0ID0gYWx0c1t0XTtcbiAgICAgICAgICAgICAgICB2YXIgY3Vyck51bU9mUGF0aHMgPSBjdXJyQWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBuZXh0UGF0aDogZm9yICh2YXIgaiA9IDA7IGogPCBjdXJyTnVtT2ZQYXRoczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyUGF0aCA9IGN1cnJBbHRbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyUGF0aExlbmd0aCA9IGN1cnJQYXRoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyUGF0aExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5MQShpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgY3VyclBhdGhbaV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pc21hdGNoIGluIGN1cnJlbnQgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgbmV4dCBwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBuZXh0UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIGZ1bGwgcGF0aCB0aGF0IG1hdGNoZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIHdvcmsgZm9yIGFuIGVtcHR5IEFMVCBhcyB0aGUgbG9vcCB3aWxsIGJlIHNraXBwZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5vbmUgb2YgdGhlIHBhdGhzIGZvciB0aGUgY3VycmVudCBhbHRlcm5hdGl2ZSBtYXRjaGVkXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBuZXh0IGFsdGVybmF0aXZlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub25lIG9mIHRoZSBhbHRlcm5hdGl2ZXMgY291bGQgYmUgbWF0Y2hlZFxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLmJ1aWxkQWx0ZXJuYXRpdmVzTG9va0FoZWFkRnVuYyA9IGJ1aWxkQWx0ZXJuYXRpdmVzTG9va0FoZWFkRnVuYztcbmZ1bmN0aW9uIGJ1aWxkU2luZ2xlQWx0ZXJuYXRpdmVMb29rYWhlYWRGdW5jdGlvbihhbHQsIHRva2VuTWF0Y2hlciwgZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICB2YXIgYXJlQWxsT25lVG9rZW5Mb29rYWhlYWQgPSAoMCwgZXZlcnlfMS5kZWZhdWx0KShhbHQsIGZ1bmN0aW9uIChjdXJyUGF0aCkge1xuICAgICAgICByZXR1cm4gY3VyclBhdGgubGVuZ3RoID09PSAxO1xuICAgIH0pO1xuICAgIHZhciBudW1PZlBhdGhzID0gYWx0Lmxlbmd0aDtcbiAgICAvLyBvcHRpbWl6ZWQgKGNvbW1vbikgY2FzZSBvZiBhbGwgdGhlIGxvb2thaGVhZHMgcGF0aHMgcmVxdWlyaW5nIG9ubHlcbiAgICAvLyBhIHNpbmdsZSB0b2tlbiBsb29rYWhlYWQuXG4gICAgaWYgKGFyZUFsbE9uZVRva2VuTG9va2FoZWFkICYmICFkeW5hbWljVG9rZW5zRW5hYmxlZCkge1xuICAgICAgICB2YXIgc2luZ2xlVG9rZW5zVHlwZXMgPSAoMCwgZmxhdHRlbl8xLmRlZmF1bHQpKGFsdCk7XG4gICAgICAgIGlmIChzaW5nbGVUb2tlbnNUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICgwLCBpc0VtcHR5XzEuZGVmYXVsdCkoc2luZ2xlVG9rZW5zVHlwZXNbMF0uY2F0ZWdvcnlNYXRjaGVzKSkge1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkVG9rZW5UeXBlID0gc2luZ2xlVG9rZW5zVHlwZXNbMF07XG4gICAgICAgICAgICB2YXIgZXhwZWN0ZWRUb2tlblVuaXF1ZUtleV8xID0gZXhwZWN0ZWRUb2tlblR5cGUudG9rZW5UeXBlSWR4O1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5MQSgxKS50b2tlblR5cGVJZHggPT09IGV4cGVjdGVkVG9rZW5VbmlxdWVLZXlfMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2hvaWNlVG9BbHRfMiA9ICgwLCByZWR1Y2VfMS5kZWZhdWx0KShzaW5nbGVUb2tlbnNUeXBlcywgZnVuY3Rpb24gKHJlc3VsdCwgY3VyclRva1R5cGUsIGlkeCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyVG9rVHlwZS50b2tlblR5cGVJZHhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlcywgZnVuY3Rpb24gKGN1cnJFeHRlbmRpbmdUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyRXh0ZW5kaW5nVHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaG9pY2VUb0FsdF8yW25leHRUb2tlbi50b2tlblR5cGVJZHhdID09PSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG5leHRQYXRoOiBmb3IgKHZhciBqID0gMDsgaiA8IG51bU9mUGF0aHM7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyUGF0aCA9IGFsdFtqXTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclBhdGhMZW5ndGggPSBjdXJyUGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyUGF0aExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLkxBKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuTWF0Y2hlcihuZXh0VG9rZW4sIGN1cnJQYXRoW2ldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pc21hdGNoIGluIGN1cnJlbnQgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBuZXh0IHB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbmV4dFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZm91bmQgYSBmdWxsIHBhdGggdGhhdCBtYXRjaGVzLlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm9uZSBvZiB0aGUgcGF0aHMgbWF0Y2hlZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuYnVpbGRTaW5nbGVBbHRlcm5hdGl2ZUxvb2thaGVhZEZ1bmN0aW9uID0gYnVpbGRTaW5nbGVBbHRlcm5hdGl2ZUxvb2thaGVhZEZ1bmN0aW9uO1xudmFyIFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlcih0b3BQcm9kLCB0YXJnZXRPY2N1cnJlbmNlLCB0YXJnZXRQcm9kVHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b3BQcm9kID0gdG9wUHJvZDtcbiAgICAgICAgX3RoaXMudGFyZ2V0T2NjdXJyZW5jZSA9IHRhcmdldE9jY3VycmVuY2U7XG4gICAgICAgIF90aGlzLnRhcmdldFByb2RUeXBlID0gdGFyZ2V0UHJvZFR5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIucHJvdG90eXBlLnN0YXJ0V2Fsa2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy53YWxrKHRoaXMudG9wUHJvZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3REZWY7XG4gICAgfTtcbiAgICBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlci5wcm90b3R5cGUuY2hlY2tJc1RhcmdldCA9IGZ1bmN0aW9uIChub2RlLCBleHBlY3RlZFByb2RUeXBlLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKG5vZGUuaWR4ID09PSB0aGlzLnRhcmdldE9jY3VycmVuY2UgJiZcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0UHJvZFR5cGUgPT09IGV4cGVjdGVkUHJvZFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdERlZiA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24sIGRvIG5vdCBpdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBHcmFtbWFyIGFzdCBhZnRlciB3ZSBoYXZlIGZvdW5kIHRoZSB0YXJnZXRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIucHJvdG90eXBlLndhbGtPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0lzVGFyZ2V0KG9wdGlvblByb2QsIFBST0RfVFlQRS5PUFRJT04sIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMsIG9wdGlvblByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZSA9IGZ1bmN0aW9uIChhdExlYXN0T25lUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0lzVGFyZ2V0KGF0TGVhc3RPbmVQcm9kLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlksIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMsIGF0TGVhc3RPbmVQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlci5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmVTZXAgPSBmdW5jdGlvbiAoYXRMZWFzdE9uZVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tJc1RhcmdldChhdExlYXN0T25lU2VwUHJvZCwgUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SLCBjdXJyUmVzdCwgcHJldlJlc3QpKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLndhbGtPcHRpb24uY2FsbCh0aGlzLCBhdExlYXN0T25lU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIucHJvdG90eXBlLndhbGtNYW55ID0gZnVuY3Rpb24gKG1hbnlQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrSXNUYXJnZXQobWFueVByb2QsIFBST0RfVFlQRS5SRVBFVElUSU9OLCBjdXJyUmVzdCwgcHJldlJlc3QpKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLndhbGtPcHRpb24uY2FsbCh0aGlzLCBtYW55UHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIucHJvdG90eXBlLndhbGtNYW55U2VwID0gZnVuY3Rpb24gKG1hbnlTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrSXNUYXJnZXQobWFueVNlcFByb2QsIFBST0RfVFlQRS5SRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SLCBjdXJyUmVzdCwgcHJldlJlc3QpKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLndhbGtPcHRpb24uY2FsbCh0aGlzLCBtYW55U2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyO1xufShyZXN0XzEuUmVzdFdhbGtlcikpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZpbml0aW9uIG9mIGEgdGFyZ2V0IHByb2R1Y3Rpb24gaW4gYSB0b3AgbGV2ZWwgbGV2ZWwgcnVsZS5cbiAqL1xudmFyIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvcih0YXJnZXRPY2N1cnJlbmNlLCB0YXJnZXRQcm9kVHlwZSwgdGFyZ2V0UmVmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRhcmdldE9jY3VycmVuY2UgPSB0YXJnZXRPY2N1cnJlbmNlO1xuICAgICAgICBfdGhpcy50YXJnZXRQcm9kVHlwZSA9IHRhcmdldFByb2RUeXBlO1xuICAgICAgICBfdGhpcy50YXJnZXRSZWYgPSB0YXJnZXRSZWY7XG4gICAgICAgIF90aGlzLnJlc3VsdCA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS5jaGVja0lzVGFyZ2V0ID0gZnVuY3Rpb24gKG5vZGUsIGV4cGVjdGVkUHJvZE5hbWUpIHtcbiAgICAgICAgaWYgKG5vZGUuaWR4ID09PSB0aGlzLnRhcmdldE9jY3VycmVuY2UgJiZcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0UHJvZFR5cGUgPT09IGV4cGVjdGVkUHJvZE5hbWUgJiZcbiAgICAgICAgICAgICh0aGlzLnRhcmdldFJlZiA9PT0gdW5kZWZpbmVkIHx8IG5vZGUgPT09IHRoaXMudGFyZ2V0UmVmKSkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBub2RlLmRlZmluaXRpb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE9wdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJc1RhcmdldChub2RlLCBQUk9EX1RZUEUuT1BUSU9OKTtcbiAgICB9O1xuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmNoZWNrSXNUYXJnZXQobm9kZSwgUFJPRF9UWVBFLlJFUEVUSVRJT04pO1xuICAgIH07XG4gICAgSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJc1RhcmdldChub2RlLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlkpO1xuICAgIH07XG4gICAgSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmNoZWNrSXNUYXJnZXQobm9kZSwgUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SKTtcbiAgICB9O1xuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lzVGFyZ2V0KG5vZGUsIFBST0RfVFlQRS5SRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SKTtcbiAgICB9O1xuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lzVGFyZ2V0KG5vZGUsIFBST0RfVFlQRS5BTFRFUk5BVElPTik7XG4gICAgfTtcbiAgICByZXR1cm4gSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3I7XG59KGdhc3RfMi5HQXN0VmlzaXRvcikpO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUFycmF5T2ZBcnJheXMoc2l6ZSkge1xuICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2ldID0gW107XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEEgc29ydCBvZiBoYXNoIGZ1bmN0aW9uIGJldHdlZW4gYSBQYXRoIGluIHRoZSBncmFtbWFyIGFuZCBhIHN0cmluZy5cbiAqIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgbXVsdGlwbGUgXCJoYXNoZXNcIiB0byBzdXBwb3J0IHRoZSBzY2VuYXJpbyBvZiB0b2tlbiBjYXRlZ29yaWVzLlxuICogLSAgQSBzaW5nbGUgcGF0aCB3aXRoIGNhdGVnb3JpZXMgbWF5IG1hdGNoIG11bHRpcGxlICoqYWN0dWFsKiogcGF0aHMuXG4gKi9cbmZ1bmN0aW9uIHBhdGhUb0hhc2hLZXlzKHBhdGgpIHtcbiAgICB2YXIga2V5cyA9IFtcIlwiXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva1R5cGUgPSBwYXRoW2ldO1xuICAgICAgICB2YXIgbG9uZ2VyS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyU2hvcnRlcktleSA9IGtleXNbal07XG4gICAgICAgICAgICBsb25nZXJLZXlzLnB1c2goY3VyclNob3J0ZXJLZXkgKyBcIl9cIiArIHRva1R5cGUudG9rZW5UeXBlSWR4KTtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcmllc0tleVN1ZmZpeCA9IFwiX1wiICsgdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXNbdF07XG4gICAgICAgICAgICAgICAgbG9uZ2VyS2V5cy5wdXNoKGN1cnJTaG9ydGVyS2V5ICsgY2F0ZWdvcmllc0tleVN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5cyA9IGxvbmdlcktleXM7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuLyoqXG4gKiBJbXBlcmF0aXZlIHN0eWxlIGR1ZSB0byBiZWluZyBjYWxsZWQgZnJvbSBhIGhvdCBzcG90XG4gKi9cbmZ1bmN0aW9uIGlzVW5pcXVlUHJlZml4SGFzaChhbHRLbm93blBhdGhzS2V5cywgc2VhcmNoUGF0aEtleXMsIGlkeCkge1xuICAgIGZvciAodmFyIGN1cnJBbHRJZHggPSAwOyBjdXJyQWx0SWR4IDwgYWx0S25vd25QYXRoc0tleXMubGVuZ3RoOyBjdXJyQWx0SWR4KyspIHtcbiAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHRlc3QgdnMgdGhlIG90aGVyIGFsdGVybmF0aXZlc1xuICAgICAgICBpZiAoY3VyckFsdElkeCA9PT0gaWR4KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXJBbHRLbm93blBhdGhzS2V5cyA9IGFsdEtub3duUGF0aHNLZXlzW2N1cnJBbHRJZHhdO1xuICAgICAgICBmb3IgKHZhciBzZWFyY2hJZHggPSAwOyBzZWFyY2hJZHggPCBzZWFyY2hQYXRoS2V5cy5sZW5ndGg7IHNlYXJjaElkeCsrKSB7XG4gICAgICAgICAgICB2YXIgc2VhcmNoS2V5ID0gc2VhcmNoUGF0aEtleXNbc2VhcmNoSWR4XTtcbiAgICAgICAgICAgIGlmIChvdGhlckFsdEtub3duUGF0aHNLZXlzW3NlYXJjaEtleV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm9uZSBvZiB0aGUgU2VhcmNoUGF0aEtleXMgd2VyZSBmb3VuZCBpbiBhbnkgb2YgdGhlIG90aGVyIGFsdGVybmF0aXZlc1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbG9va0FoZWFkU2VxdWVuY2VGcm9tQWx0ZXJuYXRpdmVzKGFsdHNEZWZzLCBrKSB7XG4gICAgdmFyIHBhcnRpYWxBbHRzID0gKDAsIG1hcF8xLmRlZmF1bHQpKGFsdHNEZWZzLCBmdW5jdGlvbiAoY3VyckFsdCkge1xuICAgICAgICByZXR1cm4gKDAsIGludGVycHJldGVyXzEucG9zc2libGVQYXRoc0Zyb20pKFtjdXJyQWx0XSwgMSk7XG4gICAgfSk7XG4gICAgdmFyIGZpbmFsUmVzdWx0ID0gaW5pdGlhbGl6ZUFycmF5T2ZBcnJheXMocGFydGlhbEFsdHMubGVuZ3RoKTtcbiAgICB2YXIgYWx0c0hhc2hlcyA9ICgwLCBtYXBfMS5kZWZhdWx0KShwYXJ0aWFsQWx0cywgZnVuY3Rpb24gKGN1cnJBbHRQYXRocykge1xuICAgICAgICB2YXIgZGljdCA9IHt9O1xuICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKGN1cnJBbHRQYXRocywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gcGF0aFRvSGFzaEtleXMoaXRlbS5wYXJ0aWFsUGF0aCk7XG4gICAgICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKGtleXMsIGZ1bmN0aW9uIChjdXJyS2V5KSB7XG4gICAgICAgICAgICAgICAgZGljdFtjdXJyS2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkaWN0O1xuICAgIH0pO1xuICAgIHZhciBuZXdEYXRhID0gcGFydGlhbEFsdHM7XG4gICAgLy8gbWF4TG9va2FoZWFkIGxvb3BcbiAgICBmb3IgKHZhciBwYXRoTGVuZ3RoID0gMTsgcGF0aExlbmd0aCA8PSBrOyBwYXRoTGVuZ3RoKyspIHtcbiAgICAgICAgdmFyIGN1cnJEYXRhc2V0ID0gbmV3RGF0YTtcbiAgICAgICAgbmV3RGF0YSA9IGluaXRpYWxpemVBcnJheU9mQXJyYXlzKGN1cnJEYXRhc2V0Lmxlbmd0aCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGFsdElkeCkge1xuICAgICAgICAgICAgdmFyIGN1cnJBbHRQYXRoc0FuZFN1ZmZpeGVzID0gY3VyckRhdGFzZXRbYWx0SWR4XTtcbiAgICAgICAgICAgIC8vIHBhdGhzIGluIGN1cnJlbnQgYWx0ZXJuYXRpdmUgbG9vcFxuICAgICAgICAgICAgZm9yICh2YXIgY3VyclBhdGhJZHggPSAwOyBjdXJyUGF0aElkeCA8IGN1cnJBbHRQYXRoc0FuZFN1ZmZpeGVzLmxlbmd0aDsgY3VyclBhdGhJZHgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyUGF0aFByZWZpeCA9IGN1cnJBbHRQYXRoc0FuZFN1ZmZpeGVzW2N1cnJQYXRoSWR4XS5wYXJ0aWFsUGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgc3VmZml4RGVmID0gY3VyckFsdFBhdGhzQW5kU3VmZml4ZXNbY3VyclBhdGhJZHhdLnN1ZmZpeERlZjtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4S2V5cyA9IHBhdGhUb0hhc2hLZXlzKGN1cnJQYXRoUHJlZml4KTtcbiAgICAgICAgICAgICAgICB2YXIgaXNVbmlxdWUgPSBpc1VuaXF1ZVByZWZpeEhhc2goYWx0c0hhc2hlcywgcHJlZml4S2V5cywgYWx0SWR4KTtcbiAgICAgICAgICAgICAgICAvLyBFbmQgb2YgdGhlIGxpbmUgZm9yIHRoaXMgcGF0aC5cbiAgICAgICAgICAgICAgICBpZiAoaXNVbmlxdWUgfHwgKDAsIGlzRW1wdHlfMS5kZWZhdWx0KShzdWZmaXhEZWYpIHx8IGN1cnJQYXRoUHJlZml4Lmxlbmd0aCA9PT0gaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyckFsdFJlc3VsdCA9IGZpbmFsUmVzdWx0W2FsdElkeF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IENhbiB3ZSBpbXBsZW1lbnQgYSBjb250YWluc1BhdGggdXNpbmcgTWFwcy9EaWN0aW9uYXJpZXM/XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluc1BhdGgoY3VyckFsdFJlc3VsdCwgY3VyclBhdGhQcmVmaXgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyckFsdFJlc3VsdC5wdXNoKGN1cnJQYXRoUHJlZml4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgbmV3ICBrZXlzIGZvciB0aGUgY3VycmVudCBwYXRoLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcmVmaXhLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJLZXkgPSBwcmVmaXhLZXlzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdHNIYXNoZXNbYWx0SWR4XVtjdXJyS2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRXhwYW5kIGxvbmdlciBwYXRoc1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UGFydGlhbFBhdGhzQW5kU3VmZml4ZXMgPSAoMCwgaW50ZXJwcmV0ZXJfMS5wb3NzaWJsZVBhdGhzRnJvbSkoc3VmZml4RGVmLCBwYXRoTGVuZ3RoICsgMSwgY3VyclBhdGhQcmVmaXgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW2FsdElkeF0gPSBuZXdEYXRhW2FsdElkeF0uY29uY2F0KG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGtleXMgZm9yIG5ldyBrbm93biBwYXRoc1xuICAgICAgICAgICAgICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeEtleXMgPSBwYXRoVG9IYXNoS2V5cyhpdGVtLnBhcnRpYWxQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBmb3JFYWNoXzEuZGVmYXVsdCkocHJlZml4S2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdHNIYXNoZXNbYWx0SWR4XVtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGFsdGVybmF0aXZlcyBsb29wXG4gICAgICAgIGZvciAodmFyIGFsdElkeCA9IDA7IGFsdElkeCA8IGN1cnJEYXRhc2V0Lmxlbmd0aDsgYWx0SWR4KyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoYWx0SWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmluYWxSZXN1bHQ7XG59XG5leHBvcnRzLmxvb2tBaGVhZFNlcXVlbmNlRnJvbUFsdGVybmF0aXZlcyA9IGxvb2tBaGVhZFNlcXVlbmNlRnJvbUFsdGVybmF0aXZlcztcbmZ1bmN0aW9uIGdldExvb2thaGVhZFBhdGhzRm9yT3Iob2NjdXJyZW5jZSwgcnVsZUdyYW1tYXIsIGssIG9yUHJvZCkge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yKG9jY3VycmVuY2UsIFBST0RfVFlQRS5BTFRFUk5BVElPTiwgb3JQcm9kKTtcbiAgICBydWxlR3JhbW1hci5hY2NlcHQodmlzaXRvcik7XG4gICAgcmV0dXJuIGxvb2tBaGVhZFNlcXVlbmNlRnJvbUFsdGVybmF0aXZlcyh2aXNpdG9yLnJlc3VsdCwgayk7XG59XG5leHBvcnRzLmdldExvb2thaGVhZFBhdGhzRm9yT3IgPSBnZXRMb29rYWhlYWRQYXRoc0Zvck9yO1xuZnVuY3Rpb24gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2Qob2NjdXJyZW5jZSwgcnVsZUdyYW1tYXIsIHByb2RUeXBlLCBrKSB7XG4gICAgdmFyIGluc2lkZURlZlZpc2l0b3IgPSBuZXcgSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3Iob2NjdXJyZW5jZSwgcHJvZFR5cGUpO1xuICAgIHJ1bGVHcmFtbWFyLmFjY2VwdChpbnNpZGVEZWZWaXNpdG9yKTtcbiAgICB2YXIgaW5zaWRlRGVmID0gaW5zaWRlRGVmVmlzaXRvci5yZXN1bHQ7XG4gICAgdmFyIGFmdGVyRGVmV2Fsa2VyID0gbmV3IFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyKHJ1bGVHcmFtbWFyLCBvY2N1cnJlbmNlLCBwcm9kVHlwZSk7XG4gICAgdmFyIGFmdGVyRGVmID0gYWZ0ZXJEZWZXYWxrZXIuc3RhcnRXYWxraW5nKCk7XG4gICAgdmFyIGluc2lkZUZsYXQgPSBuZXcgZ2FzdF8xLkFsdGVybmF0aXZlKHsgZGVmaW5pdGlvbjogaW5zaWRlRGVmIH0pO1xuICAgIHZhciBhZnRlckZsYXQgPSBuZXcgZ2FzdF8xLkFsdGVybmF0aXZlKHsgZGVmaW5pdGlvbjogYWZ0ZXJEZWYgfSk7XG4gICAgcmV0dXJuIGxvb2tBaGVhZFNlcXVlbmNlRnJvbUFsdGVybmF0aXZlcyhbaW5zaWRlRmxhdCwgYWZ0ZXJGbGF0XSwgayk7XG59XG5leHBvcnRzLmdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kID0gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2Q7XG5mdW5jdGlvbiBjb250YWluc1BhdGgoYWx0ZXJuYXRpdmUsIHNlYXJjaFBhdGgpIHtcbiAgICBjb21wYXJlT3RoZXJQYXRoOiBmb3IgKHZhciBpID0gMDsgaSA8IGFsdGVybmF0aXZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvdGhlclBhdGggPSBhbHRlcm5hdGl2ZVtpXTtcbiAgICAgICAgaWYgKG90aGVyUGF0aC5sZW5ndGggIT09IHNlYXJjaFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG90aGVyUGF0aC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHNlYXJjaFRvayA9IHNlYXJjaFBhdGhbal07XG4gICAgICAgICAgICB2YXIgb3RoZXJUb2sgPSBvdGhlclBhdGhbal07XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdUb2tlbnMgPSBzZWFyY2hUb2sgPT09IG90aGVyVG9rIHx8XG4gICAgICAgICAgICAgICAgb3RoZXJUb2suY2F0ZWdvcnlNYXRjaGVzTWFwW3NlYXJjaFRvay50b2tlblR5cGVJZHhdICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdUb2tlbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWUgY29tcGFyZU90aGVyUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5jb250YWluc1BhdGggPSBjb250YWluc1BhdGg7XG5mdW5jdGlvbiBpc1N0cmljdFByZWZpeE9mUGF0aChwcmVmaXgsIG90aGVyKSB7XG4gICAgcmV0dXJuIChwcmVmaXgubGVuZ3RoIDwgb3RoZXIubGVuZ3RoICYmXG4gICAgICAgICgwLCBldmVyeV8xLmRlZmF1bHQpKHByZWZpeCwgZnVuY3Rpb24gKHRva1R5cGUsIGlkeCkge1xuICAgICAgICAgICAgdmFyIG90aGVyVG9rVHlwZSA9IG90aGVyW2lkeF07XG4gICAgICAgICAgICByZXR1cm4gKHRva1R5cGUgPT09IG90aGVyVG9rVHlwZSB8fFxuICAgICAgICAgICAgICAgIG90aGVyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXNNYXBbdG9rVHlwZS50b2tlblR5cGVJZHhdKTtcbiAgICAgICAgfSkpO1xufVxuZXhwb3J0cy5pc1N0cmljdFByZWZpeE9mUGF0aCA9IGlzU3RyaWN0UHJlZml4T2ZQYXRoO1xuZnVuY3Rpb24gYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZChsb29rQWhlYWRQYXRocykge1xuICAgIHJldHVybiAoMCwgZXZlcnlfMS5kZWZhdWx0KShsb29rQWhlYWRQYXRocywgZnVuY3Rpb24gKHNpbmdsZUFsdFBhdGhzKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXZlcnlfMS5kZWZhdWx0KShzaW5nbGVBbHRQYXRocywgZnVuY3Rpb24gKHNpbmdsZVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZXZlcnlfMS5kZWZhdWx0KShzaW5nbGVQYXRoLCBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuICgwLCBpc0VtcHR5XzEuZGVmYXVsdCkodG9rZW4uY2F0ZWdvcnlNYXRjaGVzKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5hcmVUb2tlbkNhdGVnb3JpZXNOb3RVc2VkID0gYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvb2thaGVhZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/resolver.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/resolver.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GastRefResolverVisitor = exports.resolveGrammar = void 0;\nvar parser_1 = __webpack_require__(/*! ../parser/parser */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\");\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar values_1 = __importDefault(__webpack_require__(/*! lodash/values */ \"(ssr)/./node_modules/lodash/values.js\"));\nvar gast_1 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nfunction resolveGrammar(topLevels, errMsgProvider) {\n    var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n    refResolver.resolveRefs();\n    return refResolver.errors;\n}\nexports.resolveGrammar = resolveGrammar;\nvar GastRefResolverVisitor = /** @class */ (function (_super) {\n    __extends(GastRefResolverVisitor, _super);\n    function GastRefResolverVisitor(nameToTopRule, errMsgProvider) {\n        var _this = _super.call(this) || this;\n        _this.nameToTopRule = nameToTopRule;\n        _this.errMsgProvider = errMsgProvider;\n        _this.errors = [];\n        return _this;\n    }\n    GastRefResolverVisitor.prototype.resolveRefs = function () {\n        var _this = this;\n        (0, forEach_1.default)((0, values_1.default)(this.nameToTopRule), function (prod) {\n            _this.currTopLevel = prod;\n            prod.accept(_this);\n        });\n    };\n    GastRefResolverVisitor.prototype.visitNonTerminal = function (node) {\n        var ref = this.nameToTopRule[node.nonTerminalName];\n        if (!ref) {\n            var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n            this.errors.push({\n                message: msg,\n                type: parser_1.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n                ruleName: this.currTopLevel.name,\n                unresolvedRefName: node.nonTerminalName\n            });\n        }\n        else {\n            node.referencedRule = ref;\n        }\n    };\n    return GastRefResolverVisitor;\n}(gast_1.GAstVisitor));\nexports.GastRefResolverVisitor = GastRefResolverVisitor;\n//# sourceMappingURL=resolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvcmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyxzQkFBc0I7QUFDdkQsZUFBZSxtQkFBTyxDQUFDLHdGQUFrQjtBQUN6QyxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsK0JBQStCLG1CQUFPLENBQUMsNERBQWU7QUFDdEQsYUFBYSxtQkFBTyxDQUFDLDhFQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvcmVzb2x2ZXIuanM/ZWY1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdhc3RSZWZSZXNvbHZlclZpc2l0b3IgPSBleHBvcnRzLnJlc29sdmVHcmFtbWFyID0gdm9pZCAwO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4uL3BhcnNlci9wYXJzZXJcIik7XG52YXIgZm9yRWFjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZm9yRWFjaFwiKSk7XG52YXIgdmFsdWVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC92YWx1ZXNcIikpO1xudmFyIGdhc3RfMSA9IHJlcXVpcmUoXCJAY2hldnJvdGFpbi9nYXN0XCIpO1xuZnVuY3Rpb24gcmVzb2x2ZUdyYW1tYXIodG9wTGV2ZWxzLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciByZWZSZXNvbHZlciA9IG5ldyBHYXN0UmVmUmVzb2x2ZXJWaXNpdG9yKHRvcExldmVscywgZXJyTXNnUHJvdmlkZXIpO1xuICAgIHJlZlJlc29sdmVyLnJlc29sdmVSZWZzKCk7XG4gICAgcmV0dXJuIHJlZlJlc29sdmVyLmVycm9ycztcbn1cbmV4cG9ydHMucmVzb2x2ZUdyYW1tYXIgPSByZXNvbHZlR3JhbW1hcjtcbnZhciBHYXN0UmVmUmVzb2x2ZXJWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHYXN0UmVmUmVzb2x2ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdhc3RSZWZSZXNvbHZlclZpc2l0b3IobmFtZVRvVG9wUnVsZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZVRvVG9wUnVsZSA9IG5hbWVUb1RvcFJ1bGU7XG4gICAgICAgIF90aGlzLmVyck1zZ1Byb3ZpZGVyID0gZXJyTXNnUHJvdmlkZXI7XG4gICAgICAgIF90aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdhc3RSZWZSZXNvbHZlclZpc2l0b3IucHJvdG90eXBlLnJlc29sdmVSZWZzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKCgwLCB2YWx1ZXNfMS5kZWZhdWx0KSh0aGlzLm5hbWVUb1RvcFJ1bGUpLCBmdW5jdGlvbiAocHJvZCkge1xuICAgICAgICAgICAgX3RoaXMuY3VyclRvcExldmVsID0gcHJvZDtcbiAgICAgICAgICAgIHByb2QuYWNjZXB0KF90aGlzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHYXN0UmVmUmVzb2x2ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vblRlcm1pbmFsID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXMubmFtZVRvVG9wUnVsZVtub2RlLm5vblRlcm1pbmFsTmFtZV07XG4gICAgICAgIGlmICghcmVmKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gdGhpcy5lcnJNc2dQcm92aWRlci5idWlsZFJ1bGVOb3RGb3VuZEVycm9yKHRoaXMuY3VyclRvcExldmVsLCBub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgICAgICAgICB0eXBlOiBwYXJzZXJfMS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLlVOUkVTT0xWRURfU1VCUlVMRV9SRUYsXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuY3VyclRvcExldmVsLm5hbWUsXG4gICAgICAgICAgICAgICAgdW5yZXNvbHZlZFJlZk5hbWU6IG5vZGUubm9uVGVybWluYWxOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUucmVmZXJlbmNlZFJ1bGUgPSByZWY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHYXN0UmVmUmVzb2x2ZXJWaXNpdG9yO1xufShnYXN0XzEuR0FzdFZpc2l0b3IpKTtcbmV4cG9ydHMuR2FzdFJlZlJlc29sdmVyVmlzaXRvciA9IEdhc3RSZWZSZXNvbHZlclZpc2l0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/resolver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/rest.js":
/*!***************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/rest.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RestWalker = void 0;\nvar drop_1 = __importDefault(__webpack_require__(/*! lodash/drop */ \"(ssr)/./node_modules/lodash/drop.js\"));\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar gast_1 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nvar RestWalker = /** @class */ (function () {\n    function RestWalker() {\n    }\n    RestWalker.prototype.walk = function (prod, prevRest) {\n        var _this = this;\n        if (prevRest === void 0) { prevRest = []; }\n        (0, forEach_1.default)(prod.definition, function (subProd, index) {\n            var currRest = (0, drop_1.default)(prod.definition, index + 1);\n            /* istanbul ignore else */\n            if (subProd instanceof gast_1.NonTerminal) {\n                _this.walkProdRef(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.Terminal) {\n                _this.walkTerminal(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.Alternative) {\n                _this.walkFlat(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.Option) {\n                _this.walkOption(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.RepetitionMandatory) {\n                _this.walkAtLeastOne(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.RepetitionMandatoryWithSeparator) {\n                _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.RepetitionWithSeparator) {\n                _this.walkManySep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.Repetition) {\n                _this.walkMany(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof gast_1.Alternation) {\n                _this.walkOr(subProd, currRest, prevRest);\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    };\n    RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) { };\n    RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) { };\n    RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n        // ABCDEF => after the D the rest is EF\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    };\n    RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        // ABC(DE)?F => after the (DE)? the rest is F\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    };\n    RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n        var fullAtLeastOneRest = [\n            new gast_1.Option({ definition: atLeastOneProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    };\n    RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n        var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    };\n    RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n        var fullManyRest = [\n            new gast_1.Option({ definition: manyProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    };\n    RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n        var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    };\n    RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n        var _this = this;\n        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n        var fullOrRest = currRest.concat(prevRest);\n        // walk all different alternatives\n        (0, forEach_1.default)(orProd.definition, function (alt) {\n            // wrapping each alternative in a single definition wrapper\n            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n            var prodWrapper = new gast_1.Alternative({ definition: [alt] });\n            _this.walk(prodWrapper, fullOrRest);\n        });\n    };\n    return RestWalker;\n}());\nexports.RestWalker = RestWalker;\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    var repSepRest = [\n        new gast_1.Option({\n            definition: [\n                new gast_1.Terminal({ terminalType: repSepProd.separator })\n            ].concat(repSepProd.definition)\n        })\n    ];\n    var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n//# sourceMappingURL=rest.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvcmVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQiw2QkFBNkIsbUJBQU8sQ0FBQyx3REFBYTtBQUNsRCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsYUFBYSxtQkFBTyxDQUFDLDhFQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1Q0FBdUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxtQkFBbUI7QUFDMUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9ncmFtbWFyL3Jlc3QuanM/MDkxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzdFdhbGtlciA9IHZvaWQgMDtcbnZhciBkcm9wXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9kcm9wXCIpKTtcbnZhciBmb3JFYWNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9mb3JFYWNoXCIpKTtcbnZhciBnYXN0XzEgPSByZXF1aXJlKFwiQGNoZXZyb3RhaW4vZ2FzdFwiKTtcbi8qKlxuICogIEEgR3JhbW1hciBXYWxrZXIgdGhhdCBjb21wdXRlcyB0aGUgXCJyZW1haW5pbmdcIiBncmFtbWFyIFwiYWZ0ZXJcIiBhIHByb2R1Y3Rpb25zIGluIHRoZSBncmFtbWFyLlxuICovXG52YXIgUmVzdFdhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXN0V2Fsa2VyKCkge1xuICAgIH1cbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gKHByb2QsIHByZXZSZXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChwcmV2UmVzdCA9PT0gdm9pZCAwKSB7IHByZXZSZXN0ID0gW107IH1cbiAgICAgICAgKDAsIGZvckVhY2hfMS5kZWZhdWx0KShwcm9kLmRlZmluaXRpb24sIGZ1bmN0aW9uIChzdWJQcm9kLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGN1cnJSZXN0ID0gKDAsIGRyb3BfMS5kZWZhdWx0KShwcm9kLmRlZmluaXRpb24sIGluZGV4ICsgMSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBnYXN0XzEuTm9uVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53YWxrUHJvZFJlZihzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIGdhc3RfMS5UZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLndhbGtUZXJtaW5hbChzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIGdhc3RfMS5BbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLndhbGtGbGF0KHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgZ2FzdF8xLk9wdGlvbikge1xuICAgICAgICAgICAgICAgIF90aGlzLndhbGtPcHRpb24oc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBnYXN0XzEuUmVwZXRpdGlvbk1hbmRhdG9yeSkge1xuICAgICAgICAgICAgICAgIF90aGlzLndhbGtBdExlYXN0T25lKHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgZ2FzdF8xLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2Fsa0F0TGVhc3RPbmVTZXAoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBnYXN0XzEuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53YWxrTWFueVNlcChzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIGdhc3RfMS5SZXBldGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2Fsa01hbnkoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBnYXN0XzEuQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53YWxrT3Ioc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzdFdhbGtlci5wcm90b3R5cGUud2Fsa1Rlcm1pbmFsID0gZnVuY3Rpb24gKHRlcm1pbmFsLCBjdXJyUmVzdCwgcHJldlJlc3QpIHsgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrUHJvZFJlZiA9IGZ1bmN0aW9uIChyZWZQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHsgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrRmxhdCA9IGZ1bmN0aW9uIChmbGF0UHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIEFCQ0RFRiA9PiBhZnRlciB0aGUgRCB0aGUgcmVzdCBpcyBFRlxuICAgICAgICB2YXIgZnVsbE9yUmVzdCA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhmbGF0UHJvZCwgZnVsbE9yUmVzdCk7XG4gICAgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrT3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvblByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBBQkMoREUpP0YgPT4gYWZ0ZXIgdGhlIChERSk/IHRoZSByZXN0IGlzIEZcbiAgICAgICAgdmFyIGZ1bGxPclJlc3QgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICB0aGlzLndhbGsob3B0aW9uUHJvZCwgZnVsbE9yUmVzdCk7XG4gICAgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZSA9IGZ1bmN0aW9uIChhdExlYXN0T25lUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIEFCQyhERSkrRiA9PiBhZnRlciB0aGUgKERFKSsgdGhlIHJlc3QgaXMgKERFKT9GXG4gICAgICAgIHZhciBmdWxsQXRMZWFzdE9uZVJlc3QgPSBbXG4gICAgICAgICAgICBuZXcgZ2FzdF8xLk9wdGlvbih7IGRlZmluaXRpb246IGF0TGVhc3RPbmVQcm9kLmRlZmluaXRpb24gfSlcbiAgICAgICAgXS5jb25jYXQoY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgdGhpcy53YWxrKGF0TGVhc3RPbmVQcm9kLCBmdWxsQXRMZWFzdE9uZVJlc3QpO1xuICAgIH07XG4gICAgUmVzdFdhbGtlci5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmVTZXAgPSBmdW5jdGlvbiAoYXRMZWFzdE9uZVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBBQkMgREUoLERFKSogRiA9PiBhZnRlciB0aGUgKCxERSkrIHRoZSByZXN0IGlzICgsREUpP0ZcbiAgICAgICAgdmFyIGZ1bGxBdExlYXN0T25lU2VwUmVzdCA9IHJlc3RGb3JSZXBldGl0aW9uV2l0aFNlcGFyYXRvcihhdExlYXN0T25lU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgdGhpcy53YWxrKGF0TGVhc3RPbmVTZXBQcm9kLCBmdWxsQXRMZWFzdE9uZVNlcFJlc3QpO1xuICAgIH07XG4gICAgUmVzdFdhbGtlci5wcm90b3R5cGUud2Fsa01hbnkgPSBmdW5jdGlvbiAobWFueVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBBQkMoREUpKkYgPT4gYWZ0ZXIgdGhlIChERSkqIHRoZSByZXN0IGlzIChERSk/RlxuICAgICAgICB2YXIgZnVsbE1hbnlSZXN0ID0gW1xuICAgICAgICAgICAgbmV3IGdhc3RfMS5PcHRpb24oeyBkZWZpbml0aW9uOiBtYW55UHJvZC5kZWZpbml0aW9uIH0pXG4gICAgICAgIF0uY29uY2F0KGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhtYW55UHJvZCwgZnVsbE1hbnlSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtNYW55U2VwID0gZnVuY3Rpb24gKG1hbnlTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDIChERSgsREUpKik/IEYgPT4gYWZ0ZXIgdGhlICgsREUpKiB0aGUgcmVzdCBpcyAoLERFKT9GXG4gICAgICAgIHZhciBmdWxsTWFueVNlcFJlc3QgPSByZXN0Rm9yUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IobWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhtYW55U2VwUHJvZCwgZnVsbE1hbnlTZXBSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtPciA9IGZ1bmN0aW9uIChvclByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBBQkMoRHxFfEYpRyA9PiB3aGVuIGZpbmRpbmcgdGhlIChEfEV8RikgdGhlIHJlc3QgaXMgR1xuICAgICAgICB2YXIgZnVsbE9yUmVzdCA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgIC8vIHdhbGsgYWxsIGRpZmZlcmVudCBhbHRlcm5hdGl2ZXNcbiAgICAgICAgKDAsIGZvckVhY2hfMS5kZWZhdWx0KShvclByb2QuZGVmaW5pdGlvbiwgZnVuY3Rpb24gKGFsdCkge1xuICAgICAgICAgICAgLy8gd3JhcHBpbmcgZWFjaCBhbHRlcm5hdGl2ZSBpbiBhIHNpbmdsZSBkZWZpbml0aW9uIHdyYXBwZXJcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIGVycm9ycyBpbiBjb21wdXRpbmcgdGhlIHJlc3Qgb2YgdGhhdCBhbHRlcm5hdGl2ZSBpbiB0aGUgaW52b2NhdGlvbiB0byBjb21wdXRlSW5Qcm9kRm9sbG93c1xuICAgICAgICAgICAgLy8gKG90aGVyd2lzZSBmb3IgT1IoW2FsdDEsYWx0Ml0pIGFsdDIgd2lsbCBiZSBjb25zaWRlcmVkIGluICdyZXN0JyBvZiBhbHQxXG4gICAgICAgICAgICB2YXIgcHJvZFdyYXBwZXIgPSBuZXcgZ2FzdF8xLkFsdGVybmF0aXZlKHsgZGVmaW5pdGlvbjogW2FsdF0gfSk7XG4gICAgICAgICAgICBfdGhpcy53YWxrKHByb2RXcmFwcGVyLCBmdWxsT3JSZXN0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzdFdhbGtlcjtcbn0oKSk7XG5leHBvcnRzLlJlc3RXYWxrZXIgPSBSZXN0V2Fsa2VyO1xuZnVuY3Rpb24gcmVzdEZvclJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKHJlcFNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgIHZhciByZXBTZXBSZXN0ID0gW1xuICAgICAgICBuZXcgZ2FzdF8xLk9wdGlvbih7XG4gICAgICAgICAgICBkZWZpbml0aW9uOiBbXG4gICAgICAgICAgICAgICAgbmV3IGdhc3RfMS5UZXJtaW5hbCh7IHRlcm1pbmFsVHlwZTogcmVwU2VwUHJvZC5zZXBhcmF0b3IgfSlcbiAgICAgICAgICAgIF0uY29uY2F0KHJlcFNlcFByb2QuZGVmaW5pdGlvbilcbiAgICAgICAgfSlcbiAgICBdO1xuICAgIHZhciBmdWxsUmVwU2VwUmVzdCA9IHJlcFNlcFJlc3QuY29uY2F0KGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgcmV0dXJuIGZ1bGxSZXBTZXBSZXN0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/rest.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js":
/*!****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/parser.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EmbeddedActionsParser = exports.CstParser = exports.Parser = exports.EMPTY_ALT = exports.ParserDefinitionErrorType = exports.DEFAULT_RULE_CONFIG = exports.DEFAULT_PARSER_CONFIG = exports.END_OF_FILE = void 0;\nvar isEmpty_1 = __importDefault(__webpack_require__(/*! lodash/isEmpty */ \"(ssr)/./node_modules/lodash/isEmpty.js\"));\nvar map_1 = __importDefault(__webpack_require__(/*! lodash/map */ \"(ssr)/./node_modules/lodash/map.js\"));\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar values_1 = __importDefault(__webpack_require__(/*! lodash/values */ \"(ssr)/./node_modules/lodash/values.js\"));\nvar has_1 = __importDefault(__webpack_require__(/*! lodash/has */ \"(ssr)/./node_modules/lodash/has.js\"));\nvar clone_1 = __importDefault(__webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"));\nvar utils_1 = __webpack_require__(/*! @chevrotain/utils */ \"(ssr)/./node_modules/@chevrotain/utils/lib/src/api.js\");\nvar follow_1 = __webpack_require__(/*! ../grammar/follow */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/follow.js\");\nvar tokens_public_1 = __webpack_require__(/*! ../../scan/tokens_public */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/tokens_public.js\");\nvar errors_public_1 = __webpack_require__(/*! ../errors_public */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/errors_public.js\");\nvar gast_resolver_public_1 = __webpack_require__(/*! ../grammar/gast/gast_resolver_public */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js\");\nvar recoverable_1 = __webpack_require__(/*! ./traits/recoverable */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js\");\nvar looksahead_1 = __webpack_require__(/*! ./traits/looksahead */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js\");\nvar tree_builder_1 = __webpack_require__(/*! ./traits/tree_builder */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js\");\nvar lexer_adapter_1 = __webpack_require__(/*! ./traits/lexer_adapter */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js\");\nvar recognizer_api_1 = __webpack_require__(/*! ./traits/recognizer_api */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js\");\nvar recognizer_engine_1 = __webpack_require__(/*! ./traits/recognizer_engine */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js\");\nvar error_handler_1 = __webpack_require__(/*! ./traits/error_handler */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js\");\nvar context_assist_1 = __webpack_require__(/*! ./traits/context_assist */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js\");\nvar gast_recorder_1 = __webpack_require__(/*! ./traits/gast_recorder */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js\");\nvar perf_tracer_1 = __webpack_require__(/*! ./traits/perf_tracer */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js\");\nvar apply_mixins_1 = __webpack_require__(/*! ./utils/apply_mixins */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js\");\nvar checks_1 = __webpack_require__(/*! ../grammar/checks */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/checks.js\");\nexports.END_OF_FILE = (0, tokens_public_1.createTokenInstance)(tokens_public_1.EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(exports.END_OF_FILE);\nexports.DEFAULT_PARSER_CONFIG = Object.freeze({\n    recoveryEnabled: false,\n    maxLookahead: 3,\n    dynamicTokensEnabled: false,\n    outputCst: true,\n    errorMessageProvider: errors_public_1.defaultParserErrorProvider,\n    nodeLocationTracking: \"none\",\n    traceInitPerf: false,\n    skipValidations: false\n});\nexports.DEFAULT_RULE_CONFIG = Object.freeze({\n    recoveryValueFunc: function () { return undefined; },\n    resyncEnabled: true\n});\nvar ParserDefinitionErrorType;\n(function (ParserDefinitionErrorType) {\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"CUSTOM_LOOKAHEAD_VALIDATION\"] = 13] = \"CUSTOM_LOOKAHEAD_VALIDATION\";\n})(ParserDefinitionErrorType = exports.ParserDefinitionErrorType || (exports.ParserDefinitionErrorType = {}));\nfunction EMPTY_ALT(value) {\n    if (value === void 0) { value = undefined; }\n    return function () {\n        return value;\n    };\n}\nexports.EMPTY_ALT = EMPTY_ALT;\nvar Parser = /** @class */ (function () {\n    function Parser(tokenVocabulary, config) {\n        this.definitionErrors = [];\n        this.selfAnalysisDone = false;\n        var that = this;\n        that.initErrorHandler(config);\n        that.initLexerAdapter();\n        that.initLooksAhead(config);\n        that.initRecognizerEngine(tokenVocabulary, config);\n        that.initRecoverable(config);\n        that.initTreeBuilder(config);\n        that.initContentAssist();\n        that.initGastRecorder(config);\n        that.initPerformanceTracer(config);\n        if ((0, has_1.default)(config, \"ignoredIssues\")) {\n            throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\n                \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\n                \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\n                \"For further details.\");\n        }\n        this.skipValidations = (0, has_1.default)(config, \"skipValidations\")\n            ? config.skipValidations // casting assumes the end user passing the correct type\n            : exports.DEFAULT_PARSER_CONFIG.skipValidations;\n    }\n    /**\n     *  @deprecated use the **instance** method with the same name instead\n     */\n    Parser.performSelfAnalysis = function (parserInstance) {\n        throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\" +\n            \"\\t\\nUse the **instance** method with the same name instead.\");\n    };\n    Parser.prototype.performSelfAnalysis = function () {\n        var _this = this;\n        this.TRACE_INIT(\"performSelfAnalysis\", function () {\n            var defErrorsMsgs;\n            _this.selfAnalysisDone = true;\n            var className = _this.className;\n            _this.TRACE_INIT(\"toFastProps\", function () {\n                // Without this voodoo magic the parser would be x3-x4 slower\n                // It seems it is better to invoke `toFastProperties` **before**\n                // Any manipulations of the `this` object done during the recording phase.\n                (0, utils_1.toFastProperties)(_this);\n            });\n            _this.TRACE_INIT(\"Grammar Recording\", function () {\n                try {\n                    _this.enableRecording();\n                    // Building the GAST\n                    (0, forEach_1.default)(_this.definedRulesNames, function (currRuleName) {\n                        var wrappedRule = _this[currRuleName];\n                        var originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n                        var recordedRuleGast;\n                        _this.TRACE_INIT(\"\".concat(currRuleName, \" Rule\"), function () {\n                            recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n                        });\n                        _this.gastProductionsCache[currRuleName] = recordedRuleGast;\n                    });\n                }\n                finally {\n                    _this.disableRecording();\n                }\n            });\n            var resolverErrors = [];\n            _this.TRACE_INIT(\"Grammar Resolving\", function () {\n                resolverErrors = (0, gast_resolver_public_1.resolveGrammar)({\n                    rules: (0, values_1.default)(_this.gastProductionsCache)\n                });\n                _this.definitionErrors = _this.definitionErrors.concat(resolverErrors);\n            });\n            _this.TRACE_INIT(\"Grammar Validations\", function () {\n                // only perform additional grammar validations IFF no resolving errors have occurred.\n                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n                if ((0, isEmpty_1.default)(resolverErrors) && _this.skipValidations === false) {\n                    var validationErrors = (0, gast_resolver_public_1.validateGrammar)({\n                        rules: (0, values_1.default)(_this.gastProductionsCache),\n                        tokenTypes: (0, values_1.default)(_this.tokensMap),\n                        errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider,\n                        grammarName: className\n                    });\n                    var lookaheadValidationErrors = (0, checks_1.validateLookahead)({\n                        lookaheadStrategy: _this.lookaheadStrategy,\n                        rules: (0, values_1.default)(_this.gastProductionsCache),\n                        tokenTypes: (0, values_1.default)(_this.tokensMap),\n                        grammarName: className\n                    });\n                    _this.definitionErrors = _this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);\n                }\n            });\n            // this analysis may fail if the grammar is not perfectly valid\n            if ((0, isEmpty_1.default)(_this.definitionErrors)) {\n                // The results of these computations are not needed unless error recovery is enabled.\n                if (_this.recoveryEnabled) {\n                    _this.TRACE_INIT(\"computeAllProdsFollows\", function () {\n                        var allFollows = (0, follow_1.computeAllProdsFollows)((0, values_1.default)(_this.gastProductionsCache));\n                        _this.resyncFollows = allFollows;\n                    });\n                }\n                _this.TRACE_INIT(\"ComputeLookaheadFunctions\", function () {\n                    var _a, _b;\n                    (_b = (_a = _this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {\n                        rules: (0, values_1.default)(_this.gastProductionsCache)\n                    });\n                    _this.preComputeLookaheadFunctions((0, values_1.default)(_this.gastProductionsCache));\n                });\n            }\n            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n                !(0, isEmpty_1.default)(_this.definitionErrors)) {\n                defErrorsMsgs = (0, map_1.default)(_this.definitionErrors, function (defError) { return defError.message; });\n                throw new Error(\"Parser Definition Errors detected:\\n \".concat(defErrorsMsgs.join(\"\\n-------------------------------\\n\")));\n            }\n        });\n    };\n    // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n    // (normally during the parser's constructor).\n    // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n    // for example: duplicate rule names, referencing an unresolved subrule, ect...\n    // This flag should not be enabled during normal usage, it is used in special situations, for example when\n    // needing to display the parser definition errors in some GUI(online playground).\n    Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;\n    return Parser;\n}());\nexports.Parser = Parser;\n(0, apply_mixins_1.applyMixins)(Parser, [\n    recoverable_1.Recoverable,\n    looksahead_1.LooksAhead,\n    tree_builder_1.TreeBuilder,\n    lexer_adapter_1.LexerAdapter,\n    recognizer_engine_1.RecognizerEngine,\n    recognizer_api_1.RecognizerApi,\n    error_handler_1.ErrorHandler,\n    context_assist_1.ContentAssist,\n    gast_recorder_1.GastRecorder,\n    perf_tracer_1.PerformanceTracer\n]);\nvar CstParser = /** @class */ (function (_super) {\n    __extends(CstParser, _super);\n    function CstParser(tokenVocabulary, config) {\n        if (config === void 0) { config = exports.DEFAULT_PARSER_CONFIG; }\n        var configClone = (0, clone_1.default)(config);\n        configClone.outputCst = true;\n        return _super.call(this, tokenVocabulary, configClone) || this;\n    }\n    return CstParser;\n}(Parser));\nexports.CstParser = CstParser;\nvar EmbeddedActionsParser = /** @class */ (function (_super) {\n    __extends(EmbeddedActionsParser, _super);\n    function EmbeddedActionsParser(tokenVocabulary, config) {\n        if (config === void 0) { config = exports.DEFAULT_PARSER_CONFIG; }\n        var configClone = (0, clone_1.default)(config);\n        configClone.outputCst = false;\n        return _super.call(this, tokenVocabulary, configClone) || this;\n    }\n    return EmbeddedActionsParser;\n}(Parser));\nexports.EmbeddedActionsParser = EmbeddedActionsParser;\n//# sourceMappingURL=parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsaUJBQWlCLEdBQUcsaUNBQWlDLEdBQUcsMkJBQTJCLEdBQUcsNkJBQTZCLEdBQUcsbUJBQW1CO0FBQzlNLGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCw0QkFBNEIsbUJBQU8sQ0FBQyxzREFBWTtBQUNoRCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsK0JBQStCLG1CQUFPLENBQUMsNERBQWU7QUFDdEQsNEJBQTRCLG1CQUFPLENBQUMsc0RBQVk7QUFDaEQsOEJBQThCLG1CQUFPLENBQUMsMERBQWM7QUFDcEQsY0FBYyxtQkFBTyxDQUFDLGdGQUFtQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMsMEZBQW1CO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLCtGQUEwQjtBQUN4RCxzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDaEQsNkJBQTZCLG1CQUFPLENBQUMsZ0lBQXNDO0FBQzNFLG9CQUFvQixtQkFBTyxDQUFDLHdHQUFzQjtBQUNsRCxtQkFBbUIsbUJBQU8sQ0FBQyxzR0FBcUI7QUFDaEQscUJBQXFCLG1CQUFPLENBQUMsMEdBQXVCO0FBQ3BELHNCQUFzQixtQkFBTyxDQUFDLDRHQUF3QjtBQUN0RCx1QkFBdUIsbUJBQU8sQ0FBQyw4R0FBeUI7QUFDeEQsMEJBQTBCLG1CQUFPLENBQUMsb0hBQTRCO0FBQzlELHNCQUFzQixtQkFBTyxDQUFDLDRHQUF3QjtBQUN0RCx1QkFBdUIsbUJBQU8sQ0FBQyw4R0FBeUI7QUFDeEQsc0JBQXNCLG1CQUFPLENBQUMsNEdBQXdCO0FBQ3RELG9CQUFvQixtQkFBTyxDQUFDLHdHQUFzQjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyx3R0FBc0I7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLDBGQUFtQjtBQUMxQyxtQkFBbUI7QUFDbkI7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkI7QUFDM0IscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0VBQW9FLGlDQUFpQyxLQUFLO0FBQzNHO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLDBCQUEwQjtBQUMzSDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci9wYXJzZXIuanM/ZGMyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVtYmVkZGVkQWN0aW9uc1BhcnNlciA9IGV4cG9ydHMuQ3N0UGFyc2VyID0gZXhwb3J0cy5QYXJzZXIgPSBleHBvcnRzLkVNUFRZX0FMVCA9IGV4cG9ydHMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZSA9IGV4cG9ydHMuREVGQVVMVF9SVUxFX0NPTkZJRyA9IGV4cG9ydHMuREVGQVVMVF9QQVJTRVJfQ09ORklHID0gZXhwb3J0cy5FTkRfT0ZfRklMRSA9IHZvaWQgMDtcbnZhciBpc0VtcHR5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VtcHR5XCIpKTtcbnZhciBtYXBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL21hcFwiKSk7XG52YXIgZm9yRWFjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZm9yRWFjaFwiKSk7XG52YXIgdmFsdWVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC92YWx1ZXNcIikpO1xudmFyIGhhc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaGFzXCIpKTtcbnZhciBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIikpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiQGNoZXZyb3RhaW4vdXRpbHNcIik7XG52YXIgZm9sbG93XzEgPSByZXF1aXJlKFwiLi4vZ3JhbW1hci9mb2xsb3dcIik7XG52YXIgdG9rZW5zX3B1YmxpY18xID0gcmVxdWlyZShcIi4uLy4uL3NjYW4vdG9rZW5zX3B1YmxpY1wiKTtcbnZhciBlcnJvcnNfcHVibGljXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzX3B1YmxpY1wiKTtcbnZhciBnYXN0X3Jlc29sdmVyX3B1YmxpY18xID0gcmVxdWlyZShcIi4uL2dyYW1tYXIvZ2FzdC9nYXN0X3Jlc29sdmVyX3B1YmxpY1wiKTtcbnZhciByZWNvdmVyYWJsZV8xID0gcmVxdWlyZShcIi4vdHJhaXRzL3JlY292ZXJhYmxlXCIpO1xudmFyIGxvb2tzYWhlYWRfMSA9IHJlcXVpcmUoXCIuL3RyYWl0cy9sb29rc2FoZWFkXCIpO1xudmFyIHRyZWVfYnVpbGRlcl8xID0gcmVxdWlyZShcIi4vdHJhaXRzL3RyZWVfYnVpbGRlclwiKTtcbnZhciBsZXhlcl9hZGFwdGVyXzEgPSByZXF1aXJlKFwiLi90cmFpdHMvbGV4ZXJfYWRhcHRlclwiKTtcbnZhciByZWNvZ25pemVyX2FwaV8xID0gcmVxdWlyZShcIi4vdHJhaXRzL3JlY29nbml6ZXJfYXBpXCIpO1xudmFyIHJlY29nbml6ZXJfZW5naW5lXzEgPSByZXF1aXJlKFwiLi90cmFpdHMvcmVjb2duaXplcl9lbmdpbmVcIik7XG52YXIgZXJyb3JfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vdHJhaXRzL2Vycm9yX2hhbmRsZXJcIik7XG52YXIgY29udGV4dF9hc3Npc3RfMSA9IHJlcXVpcmUoXCIuL3RyYWl0cy9jb250ZXh0X2Fzc2lzdFwiKTtcbnZhciBnYXN0X3JlY29yZGVyXzEgPSByZXF1aXJlKFwiLi90cmFpdHMvZ2FzdF9yZWNvcmRlclwiKTtcbnZhciBwZXJmX3RyYWNlcl8xID0gcmVxdWlyZShcIi4vdHJhaXRzL3BlcmZfdHJhY2VyXCIpO1xudmFyIGFwcGx5X21peGluc18xID0gcmVxdWlyZShcIi4vdXRpbHMvYXBwbHlfbWl4aW5zXCIpO1xudmFyIGNoZWNrc18xID0gcmVxdWlyZShcIi4uL2dyYW1tYXIvY2hlY2tzXCIpO1xuZXhwb3J0cy5FTkRfT0ZfRklMRSA9ICgwLCB0b2tlbnNfcHVibGljXzEuY3JlYXRlVG9rZW5JbnN0YW5jZSkodG9rZW5zX3B1YmxpY18xLkVPRiwgXCJcIiwgTmFOLCBOYU4sIE5hTiwgTmFOLCBOYU4sIE5hTik7XG5PYmplY3QuZnJlZXplKGV4cG9ydHMuRU5EX09GX0ZJTEUpO1xuZXhwb3J0cy5ERUZBVUxUX1BBUlNFUl9DT05GSUcgPSBPYmplY3QuZnJlZXplKHtcbiAgICByZWNvdmVyeUVuYWJsZWQ6IGZhbHNlLFxuICAgIG1heExvb2thaGVhZDogMyxcbiAgICBkeW5hbWljVG9rZW5zRW5hYmxlZDogZmFsc2UsXG4gICAgb3V0cHV0Q3N0OiB0cnVlLFxuICAgIGVycm9yTWVzc2FnZVByb3ZpZGVyOiBlcnJvcnNfcHVibGljXzEuZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIsXG4gICAgbm9kZUxvY2F0aW9uVHJhY2tpbmc6IFwibm9uZVwiLFxuICAgIHRyYWNlSW5pdFBlcmY6IGZhbHNlLFxuICAgIHNraXBWYWxpZGF0aW9uczogZmFsc2Vcbn0pO1xuZXhwb3J0cy5ERUZBVUxUX1JVTEVfQ09ORklHID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgcmVjb3ZlcnlWYWx1ZUZ1bmM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcbiAgICByZXN5bmNFbmFibGVkOiB0cnVlXG59KTtcbnZhciBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlO1xuKGZ1bmN0aW9uIChQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlKSB7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSU5WQUxJRF9SVUxFX05BTUVcIl0gPSAwXSA9IFwiSU5WQUxJRF9SVUxFX05BTUVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJEVVBMSUNBVEVfUlVMRV9OQU1FXCJdID0gMV0gPSBcIkRVUExJQ0FURV9SVUxFX05BTUVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJJTlZBTElEX1JVTEVfT1ZFUlJJREVcIl0gPSAyXSA9IFwiSU5WQUxJRF9SVUxFX09WRVJSSURFXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiRFVQTElDQVRFX1BST0RVQ1RJT05TXCJdID0gM10gPSBcIkRVUExJQ0FURV9QUk9EVUNUSU9OU1wiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlVOUkVTT0xWRURfU1VCUlVMRV9SRUZcIl0gPSA0XSA9IFwiVU5SRVNPTFZFRF9TVUJSVUxFX1JFRlwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkxFRlRfUkVDVVJTSU9OXCJdID0gNV0gPSBcIkxFRlRfUkVDVVJTSU9OXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTk9ORV9MQVNUX0VNUFRZX0FMVFwiXSA9IDZdID0gXCJOT05FX0xBU1RfRU1QVFlfQUxUXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiQU1CSUdVT1VTX0FMVFNcIl0gPSA3XSA9IFwiQU1CSUdVT1VTX0FMVFNcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJDT05GTElDVF9UT0tFTlNfUlVMRVNfTkFNRVNQQUNFXCJdID0gOF0gPSBcIkNPTkZMSUNUX1RPS0VOU19SVUxFU19OQU1FU1BBQ0VcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJJTlZBTElEX1RPS0VOX05BTUVcIl0gPSA5XSA9IFwiSU5WQUxJRF9UT0tFTl9OQU1FXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTk9fTk9OX0VNUFRZX0xPT0tBSEVBRFwiXSA9IDEwXSA9IFwiTk9fTk9OX0VNUFRZX0xPT0tBSEVBRFwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkFNQklHVU9VU19QUkVGSVhfQUxUU1wiXSA9IDExXSA9IFwiQU1CSUdVT1VTX1BSRUZJWF9BTFRTXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiVE9PX01BTllfQUxUU1wiXSA9IDEyXSA9IFwiVE9PX01BTllfQUxUU1wiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkNVU1RPTV9MT09LQUhFQURfVkFMSURBVElPTlwiXSA9IDEzXSA9IFwiQ1VTVE9NX0xPT0tBSEVBRF9WQUxJREFUSU9OXCI7XG59KShQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlID0gZXhwb3J0cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlIHx8IChleHBvcnRzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gRU1QVFlfQUxUKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSB1bmRlZmluZWQ7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn1cbmV4cG9ydHMuRU1QVFlfQUxUID0gRU1QVFlfQUxUO1xudmFyIFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uRXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuc2VsZkFuYWx5c2lzRG9uZSA9IGZhbHNlO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoYXQuaW5pdEVycm9ySGFuZGxlcihjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRMZXhlckFkYXB0ZXIoKTtcbiAgICAgICAgdGhhdC5pbml0TG9va3NBaGVhZChjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRSZWNvZ25pemVyRW5naW5lKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0UmVjb3ZlcmFibGUoY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0VHJlZUJ1aWxkZXIoY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0Q29udGVudEFzc2lzdCgpO1xuICAgICAgICB0aGF0LmluaXRHYXN0UmVjb3JkZXIoY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0UGVyZm9ybWFuY2VUcmFjZXIoY29uZmlnKTtcbiAgICAgICAgaWYgKCgwLCBoYXNfMS5kZWZhdWx0KShjb25maWcsIFwiaWdub3JlZElzc3Vlc1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIDxpZ25vcmVkSXNzdWVzPiBJUGFyc2VyQ29uZmlnIHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuXFxuXFx0XCIgK1xuICAgICAgICAgICAgICAgIFwiUGxlYXNlIHVzZSB0aGUgPElHTk9SRV9BTUJJR1VJVElFUz4gZmxhZyBvbiB0aGUgcmVsZXZhbnQgRFNMIG1ldGhvZCBpbnN0ZWFkLlxcblxcdFwiICtcbiAgICAgICAgICAgICAgICBcIlNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2dyYW1tYXJfZXJyb3JzLmh0bWwjSUdOT1JJTkdfQU1CSUdVSVRJRVNcXG5cXHRcIiArXG4gICAgICAgICAgICAgICAgXCJGb3IgZnVydGhlciBkZXRhaWxzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNraXBWYWxpZGF0aW9ucyA9ICgwLCBoYXNfMS5kZWZhdWx0KShjb25maWcsIFwic2tpcFZhbGlkYXRpb25zXCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5za2lwVmFsaWRhdGlvbnMgLy8gY2FzdGluZyBhc3N1bWVzIHRoZSBlbmQgdXNlciBwYXNzaW5nIHRoZSBjb3JyZWN0IHR5cGVcbiAgICAgICAgICAgIDogZXhwb3J0cy5ERUZBVUxUX1BBUlNFUl9DT05GSUcuc2tpcFZhbGlkYXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQGRlcHJlY2F0ZWQgdXNlIHRoZSAqKmluc3RhbmNlKiogbWV0aG9kIHdpdGggdGhlIHNhbWUgbmFtZSBpbnN0ZWFkXG4gICAgICovXG4gICAgUGFyc2VyLnBlcmZvcm1TZWxmQW5hbHlzaXMgPSBmdW5jdGlvbiAocGFyc2VySW5zdGFuY2UpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgKipzdGF0aWMqKiBgcGVyZm9ybVNlbGZBbmFseXNpc2AgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQuXCIgK1xuICAgICAgICAgICAgXCJcXHRcXG5Vc2UgdGhlICoqaW5zdGFuY2UqKiBtZXRob2Qgd2l0aCB0aGUgc2FtZSBuYW1lIGluc3RlYWQuXCIpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wZXJmb3JtU2VsZkFuYWx5c2lzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJwZXJmb3JtU2VsZkFuYWx5c2lzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkZWZFcnJvcnNNc2dzO1xuICAgICAgICAgICAgX3RoaXMuc2VsZkFuYWx5c2lzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gX3RoaXMuY2xhc3NOYW1lO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcInRvRmFzdFByb3BzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBXaXRob3V0IHRoaXMgdm9vZG9vIG1hZ2ljIHRoZSBwYXJzZXIgd291bGQgYmUgeDMteDQgc2xvd2VyXG4gICAgICAgICAgICAgICAgLy8gSXQgc2VlbXMgaXQgaXMgYmV0dGVyIHRvIGludm9rZSBgdG9GYXN0UHJvcGVydGllc2AgKipiZWZvcmUqKlxuICAgICAgICAgICAgICAgIC8vIEFueSBtYW5pcHVsYXRpb25zIG9mIHRoZSBgdGhpc2Agb2JqZWN0IGRvbmUgZHVyaW5nIHRoZSByZWNvcmRpbmcgcGhhc2UuXG4gICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEudG9GYXN0UHJvcGVydGllcykoX3RoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiR3JhbW1hciBSZWNvcmRpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVuYWJsZVJlY29yZGluZygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBCdWlsZGluZyB0aGUgR0FTVFxuICAgICAgICAgICAgICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKF90aGlzLmRlZmluZWRSdWxlc05hbWVzLCBmdW5jdGlvbiAoY3VyclJ1bGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZFJ1bGUgPSBfdGhpc1tjdXJyUnVsZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsR3JhbW1hckFjdGlvbiA9IHdyYXBwZWRSdWxlW1wib3JpZ2luYWxHcmFtbWFyQWN0aW9uXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZGVkUnVsZUdhc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiXCIuY29uY2F0KGN1cnJSdWxlTmFtZSwgXCIgUnVsZVwiKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZGVkUnVsZUdhc3QgPSBfdGhpcy50b3BMZXZlbFJ1bGVSZWNvcmQoY3VyclJ1bGVOYW1lLCBvcmlnaW5hbEdyYW1tYXJBY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZVtjdXJyUnVsZU5hbWVdID0gcmVjb3JkZWRSdWxlR2FzdDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNhYmxlUmVjb3JkaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZXJFcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJHcmFtbWFyIFJlc29sdmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZXJFcnJvcnMgPSAoMCwgZ2FzdF9yZXNvbHZlcl9wdWJsaWNfMS5yZXNvbHZlR3JhbW1hcikoe1xuICAgICAgICAgICAgICAgICAgICBydWxlczogKDAsIHZhbHVlc18xLmRlZmF1bHQpKF90aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLmRlZmluaXRpb25FcnJvcnMgPSBfdGhpcy5kZWZpbml0aW9uRXJyb3JzLmNvbmNhdChyZXNvbHZlckVycm9ycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJHcmFtbWFyIFZhbGlkYXRpb25zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHBlcmZvcm0gYWRkaXRpb25hbCBncmFtbWFyIHZhbGlkYXRpb25zIElGRiBubyByZXNvbHZpbmcgZXJyb3JzIGhhdmUgb2NjdXJyZWQuXG4gICAgICAgICAgICAgICAgLy8gYXMgdW5yZXNvbHZlZCBncmFtbWFyIG1heSBsZWFkIHRvIHVuaGFuZGxlZCBydW50aW1lIGV4Y2VwdGlvbnMgaW4gdGhlIGZvbGxvdyB1cCB2YWxpZGF0aW9ucy5cbiAgICAgICAgICAgICAgICBpZiAoKDAsIGlzRW1wdHlfMS5kZWZhdWx0KShyZXNvbHZlckVycm9ycykgJiYgX3RoaXMuc2tpcFZhbGlkYXRpb25zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGlvbkVycm9ycyA9ICgwLCBnYXN0X3Jlc29sdmVyX3B1YmxpY18xLnZhbGlkYXRlR3JhbW1hcikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXM6ICgwLCB2YWx1ZXNfMS5kZWZhdWx0KShfdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblR5cGVzOiAoMCwgdmFsdWVzXzEuZGVmYXVsdCkoX3RoaXMudG9rZW5zTWFwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyck1zZ1Byb3ZpZGVyOiBlcnJvcnNfcHVibGljXzEuZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbW1hck5hbWU6IGNsYXNzTmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvb2thaGVhZFZhbGlkYXRpb25FcnJvcnMgPSAoMCwgY2hlY2tzXzEudmFsaWRhdGVMb29rYWhlYWQpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZFN0cmF0ZWd5OiBfdGhpcy5sb29rYWhlYWRTdHJhdGVneSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzOiAoMCwgdmFsdWVzXzEuZGVmYXVsdCkoX3RoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5UeXBlczogKDAsIHZhbHVlc18xLmRlZmF1bHQpKF90aGlzLnRva2Vuc01hcCksXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFtbWFyTmFtZTogY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZWZpbml0aW9uRXJyb3JzID0gX3RoaXMuZGVmaW5pdGlvbkVycm9ycy5jb25jYXQodmFsaWRhdGlvbkVycm9ycywgbG9va2FoZWFkVmFsaWRhdGlvbkVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB0aGlzIGFuYWx5c2lzIG1heSBmYWlsIGlmIHRoZSBncmFtbWFyIGlzIG5vdCBwZXJmZWN0bHkgdmFsaWRcbiAgICAgICAgICAgIGlmICgoMCwgaXNFbXB0eV8xLmRlZmF1bHQpKF90aGlzLmRlZmluaXRpb25FcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlc3VsdHMgb2YgdGhlc2UgY29tcHV0YXRpb25zIGFyZSBub3QgbmVlZGVkIHVubGVzcyBlcnJvciByZWNvdmVyeSBpcyBlbmFibGVkLlxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZWNvdmVyeUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcImNvbXB1dGVBbGxQcm9kc0ZvbGxvd3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsbEZvbGxvd3MgPSAoMCwgZm9sbG93XzEuY29tcHV0ZUFsbFByb2RzRm9sbG93cykoKDAsIHZhbHVlc18xLmRlZmF1bHQpKF90aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXN5bmNGb2xsb3dzID0gYWxsRm9sbG93cztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJDb21wdXRlTG9va2FoZWFkRnVuY3Rpb25zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMubG9va2FoZWFkU3RyYXRlZ3kpLmluaXRpYWxpemUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlczogKDAsIHZhbHVlc18xLmRlZmF1bHQpKF90aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJlQ29tcHV0ZUxvb2thaGVhZEZ1bmN0aW9ucygoMCwgdmFsdWVzXzEuZGVmYXVsdCkoX3RoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghUGFyc2VyLkRFRkVSX0RFRklOSVRJT05fRVJST1JTX0hBTkRMSU5HICYmXG4gICAgICAgICAgICAgICAgISgwLCBpc0VtcHR5XzEuZGVmYXVsdCkoX3RoaXMuZGVmaW5pdGlvbkVycm9ycykpIHtcbiAgICAgICAgICAgICAgICBkZWZFcnJvcnNNc2dzID0gKDAsIG1hcF8xLmRlZmF1bHQpKF90aGlzLmRlZmluaXRpb25FcnJvcnMsIGZ1bmN0aW9uIChkZWZFcnJvcikgeyByZXR1cm4gZGVmRXJyb3IubWVzc2FnZTsgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2VyIERlZmluaXRpb24gRXJyb3JzIGRldGVjdGVkOlxcbiBcIi5jb25jYXQoZGVmRXJyb3JzTXNncy5qb2luKFwiXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFNldCB0aGlzIGZsYWcgdG8gdHJ1ZSBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgUGFyc2VyIHRvIHRocm93IGVycm9yIHdoZW4gcHJvYmxlbXMgaW4gaXQncyBkZWZpbml0aW9uIGFyZSBkZXRlY3RlZC5cbiAgICAvLyAobm9ybWFsbHkgZHVyaW5nIHRoZSBwYXJzZXIncyBjb25zdHJ1Y3RvcikuXG4gICAgLy8gVGhpcyBpcyBhIGRlc2lnbiB0aW1lIGZsYWcsIGl0IHdpbGwgbm90IGFmZmVjdCB0aGUgcnVudGltZSBlcnJvciBoYW5kbGluZyBvZiB0aGUgcGFyc2VyLCBqdXN0IGRlc2lnbiB0aW1lIGVycm9ycyxcbiAgICAvLyBmb3IgZXhhbXBsZTogZHVwbGljYXRlIHJ1bGUgbmFtZXMsIHJlZmVyZW5jaW5nIGFuIHVucmVzb2x2ZWQgc3VicnVsZSwgZWN0Li4uXG4gICAgLy8gVGhpcyBmbGFnIHNob3VsZCBub3QgYmUgZW5hYmxlZCBkdXJpbmcgbm9ybWFsIHVzYWdlLCBpdCBpcyB1c2VkIGluIHNwZWNpYWwgc2l0dWF0aW9ucywgZm9yIGV4YW1wbGUgd2hlblxuICAgIC8vIG5lZWRpbmcgdG8gZGlzcGxheSB0aGUgcGFyc2VyIGRlZmluaXRpb24gZXJyb3JzIGluIHNvbWUgR1VJKG9ubGluZSBwbGF5Z3JvdW5kKS5cbiAgICBQYXJzZXIuREVGRVJfREVGSU5JVElPTl9FUlJPUlNfSEFORExJTkcgPSBmYWxzZTtcbiAgICByZXR1cm4gUGFyc2VyO1xufSgpKTtcbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuKDAsIGFwcGx5X21peGluc18xLmFwcGx5TWl4aW5zKShQYXJzZXIsIFtcbiAgICByZWNvdmVyYWJsZV8xLlJlY292ZXJhYmxlLFxuICAgIGxvb2tzYWhlYWRfMS5Mb29rc0FoZWFkLFxuICAgIHRyZWVfYnVpbGRlcl8xLlRyZWVCdWlsZGVyLFxuICAgIGxleGVyX2FkYXB0ZXJfMS5MZXhlckFkYXB0ZXIsXG4gICAgcmVjb2duaXplcl9lbmdpbmVfMS5SZWNvZ25pemVyRW5naW5lLFxuICAgIHJlY29nbml6ZXJfYXBpXzEuUmVjb2duaXplckFwaSxcbiAgICBlcnJvcl9oYW5kbGVyXzEuRXJyb3JIYW5kbGVyLFxuICAgIGNvbnRleHRfYXNzaXN0XzEuQ29udGVudEFzc2lzdCxcbiAgICBnYXN0X3JlY29yZGVyXzEuR2FzdFJlY29yZGVyLFxuICAgIHBlcmZfdHJhY2VyXzEuUGVyZm9ybWFuY2VUcmFjZXJcbl0pO1xudmFyIENzdFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ3N0UGFyc2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENzdFBhcnNlcih0b2tlblZvY2FidWxhcnksIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0gZXhwb3J0cy5ERUZBVUxUX1BBUlNFUl9DT05GSUc7IH1cbiAgICAgICAgdmFyIGNvbmZpZ0Nsb25lID0gKDAsIGNsb25lXzEuZGVmYXVsdCkoY29uZmlnKTtcbiAgICAgICAgY29uZmlnQ2xvbmUub3V0cHV0Q3N0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnQ2xvbmUpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDc3RQYXJzZXI7XG59KFBhcnNlcikpO1xuZXhwb3J0cy5Dc3RQYXJzZXIgPSBDc3RQYXJzZXI7XG52YXIgRW1iZWRkZWRBY3Rpb25zUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbWJlZGRlZEFjdGlvbnNQYXJzZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1iZWRkZWRBY3Rpb25zUGFyc2VyKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSBleHBvcnRzLkRFRkFVTFRfUEFSU0VSX0NPTkZJRzsgfVxuICAgICAgICB2YXIgY29uZmlnQ2xvbmUgPSAoMCwgY2xvbmVfMS5kZWZhdWx0KShjb25maWcpO1xuICAgICAgICBjb25maWdDbG9uZS5vdXRwdXRDc3QgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnQ2xvbmUpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBFbWJlZGRlZEFjdGlvbnNQYXJzZXI7XG59KFBhcnNlcikpO1xuZXhwb3J0cy5FbWJlZGRlZEFjdGlvbnNQYXJzZXIgPSBFbWJlZGRlZEFjdGlvbnNQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContentAssist = void 0;\nvar interpreter_1 = __webpack_require__(/*! ../../grammar/interpreter */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js\");\nvar first_1 = __importDefault(__webpack_require__(/*! lodash/first */ \"(ssr)/./node_modules/lodash/first.js\"));\nvar isUndefined_1 = __importDefault(__webpack_require__(/*! lodash/isUndefined */ \"(ssr)/./node_modules/lodash/isUndefined.js\"));\nvar ContentAssist = /** @class */ (function () {\n    function ContentAssist() {\n    }\n    ContentAssist.prototype.initContentAssist = function () { };\n    ContentAssist.prototype.computeContentAssist = function (startRuleName, precedingInput) {\n        var startRuleGast = this.gastProductionsCache[startRuleName];\n        if ((0, isUndefined_1.default)(startRuleGast)) {\n            throw Error(\"Rule ->\".concat(startRuleName, \"<- does not exist in this grammar.\"));\n        }\n        return (0, interpreter_1.nextPossibleTokensAfter)([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n    };\n    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n    // TODO: should this be more explicitly part of the public API?\n    ContentAssist.prototype.getNextPossibleTokenTypes = function (grammarPath) {\n        var topRuleName = (0, first_1.default)(grammarPath.ruleStack);\n        var gastProductions = this.getGAstProductions();\n        var topProduction = gastProductions[topRuleName];\n        var nextPossibleTokenTypes = new interpreter_1.NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n        return nextPossibleTokenTypes;\n    };\n    return ContentAssist;\n}());\nexports.ContentAssist = ContentAssist;\n//# sourceMappingURL=context_assist.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvY29udGV4dF9hc3Npc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsb0JBQW9CLG1CQUFPLENBQUMsdUdBQTJCO0FBQ3ZELDhCQUE4QixtQkFBTyxDQUFDLDBEQUFjO0FBQ3BELG9DQUFvQyxtQkFBTyxDQUFDLHNFQUFvQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9jb250ZXh0X2Fzc2lzdC5qcz8zNmYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250ZW50QXNzaXN0ID0gdm9pZCAwO1xudmFyIGludGVycHJldGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZ3JhbW1hci9pbnRlcnByZXRlclwiKTtcbnZhciBmaXJzdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZmlyc3RcIikpO1xudmFyIGlzVW5kZWZpbmVkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc1VuZGVmaW5lZFwiKSk7XG52YXIgQ29udGVudEFzc2lzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250ZW50QXNzaXN0KCkge1xuICAgIH1cbiAgICBDb250ZW50QXNzaXN0LnByb3RvdHlwZS5pbml0Q29udGVudEFzc2lzdCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBDb250ZW50QXNzaXN0LnByb3RvdHlwZS5jb21wdXRlQ29udGVudEFzc2lzdCA9IGZ1bmN0aW9uIChzdGFydFJ1bGVOYW1lLCBwcmVjZWRpbmdJbnB1dCkge1xuICAgICAgICB2YXIgc3RhcnRSdWxlR2FzdCA9IHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGVbc3RhcnRSdWxlTmFtZV07XG4gICAgICAgIGlmICgoMCwgaXNVbmRlZmluZWRfMS5kZWZhdWx0KShzdGFydFJ1bGVHYXN0KSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJSdWxlIC0+XCIuY29uY2F0KHN0YXJ0UnVsZU5hbWUsIFwiPC0gZG9lcyBub3QgZXhpc3QgaW4gdGhpcyBncmFtbWFyLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBpbnRlcnByZXRlcl8xLm5leHRQb3NzaWJsZVRva2Vuc0FmdGVyKShbc3RhcnRSdWxlR2FzdF0sIHByZWNlZGluZ0lucHV0LCB0aGlzLnRva2VuTWF0Y2hlciwgdGhpcy5tYXhMb29rYWhlYWQpO1xuICAgIH07XG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgYSBtZW1iZXIgbWV0aG9kIG9yIGEgdXRpbGl0eT8gaXQgZG9lcyBub3QgaGF2ZSBhbnkgc3RhdGUgb3IgdXNhZ2Ugb2YgJ3RoaXMnLi4uXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgbW9yZSBleHBsaWNpdGx5IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEk/XG4gICAgQ29udGVudEFzc2lzdC5wcm90b3R5cGUuZ2V0TmV4dFBvc3NpYmxlVG9rZW5UeXBlcyA9IGZ1bmN0aW9uIChncmFtbWFyUGF0aCkge1xuICAgICAgICB2YXIgdG9wUnVsZU5hbWUgPSAoMCwgZmlyc3RfMS5kZWZhdWx0KShncmFtbWFyUGF0aC5ydWxlU3RhY2spO1xuICAgICAgICB2YXIgZ2FzdFByb2R1Y3Rpb25zID0gdGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKTtcbiAgICAgICAgdmFyIHRvcFByb2R1Y3Rpb24gPSBnYXN0UHJvZHVjdGlvbnNbdG9wUnVsZU5hbWVdO1xuICAgICAgICB2YXIgbmV4dFBvc3NpYmxlVG9rZW5UeXBlcyA9IG5ldyBpbnRlcnByZXRlcl8xLk5leHRBZnRlclRva2VuV2Fsa2VyKHRvcFByb2R1Y3Rpb24sIGdyYW1tYXJQYXRoKS5zdGFydFdhbGtpbmcoKTtcbiAgICAgICAgcmV0dXJuIG5leHRQb3NzaWJsZVRva2VuVHlwZXM7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udGVudEFzc2lzdDtcbn0oKSk7XG5leHBvcnRzLkNvbnRlbnRBc3Npc3QgPSBDb250ZW50QXNzaXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dF9hc3Npc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js":
/*!******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ErrorHandler = void 0;\nvar exceptions_public_1 = __webpack_require__(/*! ../../exceptions_public */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/exceptions_public.js\");\nvar has_1 = __importDefault(__webpack_require__(/*! lodash/has */ \"(ssr)/./node_modules/lodash/has.js\"));\nvar clone_1 = __importDefault(__webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"));\nvar lookahead_1 = __webpack_require__(/*! ../../grammar/lookahead */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js\");\nvar parser_1 = __webpack_require__(/*! ../parser */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\");\n/**\n * Trait responsible for runtime parsing errors.\n */\nvar ErrorHandler = /** @class */ (function () {\n    function ErrorHandler() {\n    }\n    ErrorHandler.prototype.initErrorHandler = function (config) {\n        this._errors = [];\n        this.errorMessageProvider = (0, has_1.default)(config, \"errorMessageProvider\")\n            ? config.errorMessageProvider // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;\n    };\n    ErrorHandler.prototype.SAVE_ERROR = function (error) {\n        if ((0, exceptions_public_1.isRecognitionException)(error)) {\n            error.context = {\n                ruleStack: this.getHumanReadableRuleStack(),\n                ruleOccurrenceStack: (0, clone_1.default)(this.RULE_OCCURRENCE_STACK)\n            };\n            this._errors.push(error);\n            return error;\n        }\n        else {\n            throw Error(\"Trying to save an Error which is not a RecognitionException\");\n        }\n    };\n    Object.defineProperty(ErrorHandler.prototype, \"errors\", {\n        get: function () {\n            return (0, clone_1.default)(this._errors);\n        },\n        set: function (newErrors) {\n            this._errors = newErrors;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // TODO: consider caching the error message computed information\n    ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {\n        var ruleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[ruleName];\n        var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);\n        var insideProdPaths = lookAheadPathsPerAlternative[0];\n        var actualTokens = [];\n        for (var i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        var msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName\n        });\n        throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));\n    };\n    // TODO: consider caching the error message computed information\n    ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {\n        var ruleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[ruleName];\n        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n        var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);\n        var actualTokens = [];\n        for (var i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        var previousToken = this.LA(0);\n        var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName()\n        });\n        throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));\n    };\n    return ErrorHandler;\n}());\nexports.ErrorHandler = ErrorHandler;\n//# sourceMappingURL=error_handler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvZXJyb3JfaGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQiwwQkFBMEIsbUJBQU8sQ0FBQyxtR0FBeUI7QUFDM0QsNEJBQTRCLG1CQUFPLENBQUMsc0RBQVk7QUFDaEQsOEJBQThCLG1CQUFPLENBQUMsMERBQWM7QUFDcEQsa0JBQWtCLG1CQUFPLENBQUMsbUdBQXlCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxpRkFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvZXJyb3JfaGFuZGxlci5qcz8wYWI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FcnJvckhhbmRsZXIgPSB2b2lkIDA7XG52YXIgZXhjZXB0aW9uc19wdWJsaWNfMSA9IHJlcXVpcmUoXCIuLi8uLi9leGNlcHRpb25zX3B1YmxpY1wiKTtcbnZhciBoYXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2hhc1wiKSk7XG52YXIgY2xvbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpKTtcbnZhciBsb29rYWhlYWRfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmFtbWFyL2xvb2thaGVhZFwiKTtcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJcIik7XG4vKipcbiAqIFRyYWl0IHJlc3BvbnNpYmxlIGZvciBydW50aW1lIHBhcnNpbmcgZXJyb3JzLlxuICovXG52YXIgRXJyb3JIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVycm9ySGFuZGxlcigpIHtcbiAgICB9XG4gICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5pbml0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlciA9ICgwLCBoYXNfMS5kZWZhdWx0KShjb25maWcsIFwiZXJyb3JNZXNzYWdlUHJvdmlkZXJcIilcbiAgICAgICAgICAgID8gY29uZmlnLmVycm9yTWVzc2FnZVByb3ZpZGVyIC8vIGFzc3VtZXMgZW5kIHVzZXIgcHJvdmlkZXMgdGhlIGNvcnJlY3QgY29uZmlnIHZhbHVlL3R5cGVcbiAgICAgICAgICAgIDogcGFyc2VyXzEuREVGQVVMVF9QQVJTRVJfQ09ORklHLmVycm9yTWVzc2FnZVByb3ZpZGVyO1xuICAgIH07XG4gICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5TQVZFX0VSUk9SID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICgoMCwgZXhjZXB0aW9uc19wdWJsaWNfMS5pc1JlY29nbml0aW9uRXhjZXB0aW9uKShlcnJvcikpIHtcbiAgICAgICAgICAgIGVycm9yLmNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiB0aGlzLmdldEh1bWFuUmVhZGFibGVSdWxlU3RhY2soKSxcbiAgICAgICAgICAgICAgICBydWxlT2NjdXJyZW5jZVN0YWNrOiAoMCwgY2xvbmVfMS5kZWZhdWx0KSh0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRyeWluZyB0byBzYXZlIGFuIEVycm9yIHdoaWNoIGlzIG5vdCBhIFJlY29nbml0aW9uRXhjZXB0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JIYW5kbGVyLnByb3RvdHlwZSwgXCJlcnJvcnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY2xvbmVfMS5kZWZhdWx0KSh0aGlzLl9lcnJvcnMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdFcnJvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IG5ld0Vycm9ycztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIFRPRE86IGNvbnNpZGVyIGNhY2hpbmcgdGhlIGVycm9yIG1lc3NhZ2UgY29tcHV0ZWQgaW5mb3JtYXRpb25cbiAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnJhaXNlRWFybHlFeGl0RXhjZXB0aW9uID0gZnVuY3Rpb24gKG9jY3VycmVuY2UsIHByb2RUeXBlLCB1c2VyRGVmaW5lZEVyck1zZykge1xuICAgICAgICB2YXIgcnVsZU5hbWUgPSB0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKTtcbiAgICAgICAgdmFyIHJ1bGVHcmFtbWFyID0gdGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKVtydWxlTmFtZV07XG4gICAgICAgIHZhciBsb29rQWhlYWRQYXRoc1BlckFsdGVybmF0aXZlID0gKDAsIGxvb2thaGVhZF8xLmdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kKShvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgcHJvZFR5cGUsIHRoaXMubWF4TG9va2FoZWFkKTtcbiAgICAgICAgdmFyIGluc2lkZVByb2RQYXRocyA9IGxvb2tBaGVhZFBhdGhzUGVyQWx0ZXJuYXRpdmVbMF07XG4gICAgICAgIHZhciBhY3R1YWxUb2tlbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gdGhpcy5tYXhMb29rYWhlYWQ7IGkrKykge1xuICAgICAgICAgICAgYWN0dWFsVG9rZW5zLnB1c2godGhpcy5MQShpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRFYXJseUV4aXRNZXNzYWdlKHtcbiAgICAgICAgICAgIGV4cGVjdGVkSXRlcmF0aW9uUGF0aHM6IGluc2lkZVByb2RQYXRocyxcbiAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsVG9rZW5zLFxuICAgICAgICAgICAgcHJldmlvdXM6IHRoaXMuTEEoMCksXG4gICAgICAgICAgICBjdXN0b21Vc2VyRGVzY3JpcHRpb246IHVzZXJEZWZpbmVkRXJyTXNnLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGVOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyB0aGlzLlNBVkVfRVJST1IobmV3IGV4Y2VwdGlvbnNfcHVibGljXzEuRWFybHlFeGl0RXhjZXB0aW9uKG1zZywgdGhpcy5MQSgxKSwgdGhpcy5MQSgwKSkpO1xuICAgIH07XG4gICAgLy8gVE9ETzogY29uc2lkZXIgY2FjaGluZyB0aGUgZXJyb3IgbWVzc2FnZSBjb21wdXRlZCBpbmZvcm1hdGlvblxuICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUucmFpc2VOb0FsdEV4Y2VwdGlvbiA9IGZ1bmN0aW9uIChvY2N1cnJlbmNlLCBlcnJNc2dUeXBlcykge1xuICAgICAgICB2YXIgcnVsZU5hbWUgPSB0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKTtcbiAgICAgICAgdmFyIHJ1bGVHcmFtbWFyID0gdGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKVtydWxlTmFtZV07XG4gICAgICAgIC8vIFRPRE86IGdldExvb2thaGVhZFBhdGhzRm9yT3IgY2FuIGJlIHNsb3cgZm9yIGxhcmdlIGVub3VnaCBtYXhMb29rYWhlYWQgYW5kIGNlcnRhaW4gZ3JhbW1hcnMsIGNvbnNpZGVyIGNhY2hpbmcgP1xuICAgICAgICB2YXIgbG9va0FoZWFkUGF0aHNQZXJBbHRlcm5hdGl2ZSA9ICgwLCBsb29rYWhlYWRfMS5nZXRMb29rYWhlYWRQYXRoc0Zvck9yKShvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgdGhpcy5tYXhMb29rYWhlYWQpO1xuICAgICAgICB2YXIgYWN0dWFsVG9rZW5zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHRoaXMubWF4TG9va2FoZWFkOyBpKyspIHtcbiAgICAgICAgICAgIGFjdHVhbFRva2Vucy5wdXNoKHRoaXMuTEEoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91c1Rva2VuID0gdGhpcy5MQSgwKTtcbiAgICAgICAgdmFyIGVyck1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGROb1ZpYWJsZUFsdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgZXhwZWN0ZWRQYXRoc1BlckFsdDogbG9va0FoZWFkUGF0aHNQZXJBbHRlcm5hdGl2ZSxcbiAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsVG9rZW5zLFxuICAgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzVG9rZW4sXG4gICAgICAgICAgICBjdXN0b21Vc2VyRGVzY3JpcHRpb246IGVyck1zZ1R5cGVzLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyB0aGlzLlNBVkVfRVJST1IobmV3IGV4Y2VwdGlvbnNfcHVibGljXzEuTm9WaWFibGVBbHRFeGNlcHRpb24oZXJyTXNnLCB0aGlzLkxBKDEpLCBwcmV2aW91c1Rva2VuKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRXJyb3JIYW5kbGVyO1xufSgpKTtcbmV4cG9ydHMuRXJyb3JIYW5kbGVyID0gRXJyb3JIYW5kbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JfaGFuZGxlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js":
/*!******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GastRecorder = void 0;\nvar last_1 = __importDefault(__webpack_require__(/*! lodash/last */ \"(ssr)/./node_modules/lodash/last.js\"));\nvar isArray_1 = __importDefault(__webpack_require__(/*! lodash/isArray */ \"(ssr)/./node_modules/lodash/isArray.js\"));\nvar some_1 = __importDefault(__webpack_require__(/*! lodash/some */ \"(ssr)/./node_modules/lodash/some.js\"));\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar isFunction_1 = __importDefault(__webpack_require__(/*! lodash/isFunction */ \"(ssr)/./node_modules/lodash/isFunction.js\"));\nvar has_1 = __importDefault(__webpack_require__(/*! lodash/has */ \"(ssr)/./node_modules/lodash/has.js\"));\nvar gast_1 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nvar lexer_public_1 = __webpack_require__(/*! ../../../scan/lexer_public */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/lexer_public.js\");\nvar tokens_1 = __webpack_require__(/*! ../../../scan/tokens */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/tokens.js\");\nvar tokens_public_1 = __webpack_require__(/*! ../../../scan/tokens_public */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/tokens_public.js\");\nvar parser_1 = __webpack_require__(/*! ../parser */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\");\nvar keys_1 = __webpack_require__(/*! ../../grammar/keys */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/keys.js\");\nvar RECORDING_NULL_OBJECT = {\n    description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = (0, tokens_public_1.createToken)({ name: \"RECORDING_PHASE_TOKEN\", pattern: lexer_public_1.Lexer.NA });\n(0, tokens_1.augmentTokenTypes)([RFT]);\nvar RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\", \n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n    name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n        \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n    children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nvar GastRecorder = /** @class */ (function () {\n    function GastRecorder() {\n    }\n    GastRecorder.prototype.initGastRecorder = function (config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    };\n    GastRecorder.prototype.enableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT(\"Enable Recording\", function () {\n            var _loop_1 = function (i) {\n                var idx = i > 0 ? i : \"\";\n                _this[\"CONSUME\".concat(idx)] = function (arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                _this[\"SUBRULE\".concat(idx)] = function (arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                _this[\"OPTION\".concat(idx)] = function (arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                _this[\"OR\".concat(idx)] = function (arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                _this[\"MANY\".concat(idx)] = function (arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                _this[\"MANY_SEP\".concat(idx)] = function (arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE\".concat(idx)] = function (arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE_SEP\".concat(idx)] = function (arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            };\n            /**\n             * Warning Dark Voodoo Magic upcoming!\n             * We are \"replacing\" the public parsing DSL methods API\n             * With **new** alternative implementations on the Parser **instance**\n             *\n             * So far this is the only way I've found to avoid performance regressions during parsing time.\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n             *   implementations directly instead.\n             */\n            for (var i = 0; i < 10; i++) {\n                _loop_1(i);\n            }\n            // DSL methods with the idx(suffix) as an argument\n            _this[\"consume\"] = function (idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"subrule\"] = function (idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"option\"] = function (idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            _this[\"or\"] = function (idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            _this[\"many\"] = function (idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            _this[\"atLeastOne\"] = function (idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            _this.ACTION = _this.ACTION_RECORD;\n            _this.BACKTRACK = _this.BACKTRACK_RECORD;\n            _this.LA = _this.LA_RECORD;\n        });\n    };\n    GastRecorder.prototype.disableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = false;\n        // By deleting these **instance** properties, any future invocation\n        // will be deferred to the original methods on the **prototype** object\n        // This seems to get rid of any incorrect optimizations that V8 may\n        // do during the recording phase.\n        this.TRACE_INIT(\"Deleting Recording methods\", function () {\n            var that = _this;\n            for (var i = 0; i < 10; i++) {\n                var idx = i > 0 ? i : \"\";\n                delete that[\"CONSUME\".concat(idx)];\n                delete that[\"SUBRULE\".concat(idx)];\n                delete that[\"OPTION\".concat(idx)];\n                delete that[\"OR\".concat(idx)];\n                delete that[\"MANY\".concat(idx)];\n                delete that[\"MANY_SEP\".concat(idx)];\n                delete that[\"AT_LEAST_ONE\".concat(idx)];\n                delete that[\"AT_LEAST_ONE_SEP\".concat(idx)];\n            }\n            delete that[\"consume\"];\n            delete that[\"subrule\"];\n            delete that[\"option\"];\n            delete that[\"or\"];\n            delete that[\"many\"];\n            delete that[\"atLeastOne\"];\n            delete that.ACTION;\n            delete that.BACKTRACK;\n            delete that.LA;\n        });\n    };\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    // @ts-expect-error -- noop place holder\n    GastRecorder.prototype.ACTION_RECORD = function (impl) {\n        // NO-OP during recording\n    };\n    // Executing backtracking logic will break our recording logic assumptions\n    GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n        return function () { return true; };\n    };\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    GastRecorder.prototype.LA_RECORD = function (howMuch) {\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n        // On LA return EOF at the end of the input so an infinite loop may occur.\n        return parser_1.END_OF_FILE;\n    };\n    GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n        try {\n            var newTopLevelRule = new gast_1.Rule({ definition: [], name: name });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        }\n        catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n                try {\n                    originalError.message =\n                        originalError.message +\n                            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n                            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n                }\n                catch (mutabilityError) {\n                    // We may not be able to modify the original error object\n                    throw originalError;\n                }\n            }\n            throw originalError;\n        }\n    };\n    // Implementation of parsing DSL\n    GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n        return recordProd.call(this, gast_1.Option, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, gast_1.RepetitionMandatory, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, gast_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, gast_1.Repetition, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, gast_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n        return recordOrProd.call(this, altsOrOpts, occurrence);\n    };\n    GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || (0, has_1.default)(ruleToCall, \"ruleName\") === false) {\n            var error = new Error(\"<SUBRULE\".concat(getIdxSuffix(occurrence), \"> argument is invalid\") +\n                \" expecting a Parser method reference but got: <\".concat(JSON.stringify(ruleToCall), \">\") +\n                \"\\n inside top level rule: <\".concat(this.recordingProdStack[0].name, \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = (0, last_1.default)(this.recordingProdStack);\n        var ruleName = ruleToCall.ruleName;\n        var newNoneTerminal = new gast_1.NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: undefined\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n    };\n    GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {\n            var error = new Error(\"<CONSUME\".concat(getIdxSuffix(occurrence), \"> argument is invalid\") +\n                \" expecting a TokenType reference but got: <\".concat(JSON.stringify(tokType), \">\") +\n                \"\\n inside top level rule: <\".concat(this.recordingProdStack[0].name, \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = (0, last_1.default)(this.recordingProdStack);\n        var newNoneTerminal = new gast_1.Terminal({\n            idx: occurrence,\n            terminalType: tokType,\n            label: options === null || options === void 0 ? void 0 : options.LABEL\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return RECORDING_PHASE_TOKEN;\n    };\n    return GastRecorder;\n}());\nexports.GastRecorder = GastRecorder;\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n    if (handleSep === void 0) { handleSep = false; }\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = (0, last_1.default)(this.recordingProdStack);\n    var grammarAction = (0, isFunction_1.default)(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n    var newProd = new prodConstructor({ definition: [], idx: occurrence });\n    if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n    }\n    if ((0, has_1.default)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n    var _this = this;\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = (0, last_1.default)(this.recordingProdStack);\n    // Only an array of alternatives\n    var hasOptions = (0, isArray_1.default)(mainProdArg) === false;\n    var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    var newOrProd = new gast_1.Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n    });\n    if ((0, has_1.default)(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    var hasPredicates = (0, some_1.default)(alts, function (currAlt) { return (0, isFunction_1.default)(currAlt.GATE); });\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    (0, forEach_1.default)(alts, function (currAlt) {\n        var currAltFlat = new gast_1.Alternative({ definition: [] });\n        newOrProd.definition.push(currAltFlat);\n        if ((0, has_1.default)(currAlt, \"IGNORE_AMBIGUITIES\")) {\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES; // assumes end user provides the correct config value/type\n        }\n        // **implicit** ignoreAmbiguities due to usage of gate\n        else if ((0, has_1.default)(currAlt, \"GATE\")) {\n            currAltFlat.ignoreAmbiguities = true;\n        }\n        _this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(_this);\n        _this.recordingProdStack.pop();\n    });\n    return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n    return idx === 0 ? \"\" : \"\".concat(idx);\n}\nfunction assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n        var error = new Error(\n        // The stack trace will contain all the needed details\n        \"Invalid DSL Method idx value: <\".concat(idx, \">\\n\\t\") +\n            \"Idx value must be a none negative value smaller than \".concat(MAX_METHOD_IDX + 1));\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n//# sourceMappingURL=gast_recorder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvZ2FzdF9yZWNvcmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQiw2QkFBNkIsbUJBQU8sQ0FBQyx3REFBYTtBQUNsRCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsNkJBQTZCLG1CQUFPLENBQUMsd0RBQWE7QUFDbEQsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELG1DQUFtQyxtQkFBTyxDQUFDLG9FQUFtQjtBQUM5RCw0QkFBNEIsbUJBQU8sQ0FBQyxzREFBWTtBQUNoRCxhQUFhLG1CQUFPLENBQUMsOEVBQWtCO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLGdHQUE0QjtBQUN6RCxlQUFlLG1CQUFPLENBQUMsb0ZBQXNCO0FBQzdDLHNCQUFzQixtQkFBTyxDQUFDLGtHQUE2QjtBQUMzRCxlQUFlLG1CQUFPLENBQUMsaUZBQVc7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLHlGQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUVBQWlFO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw0QkFBNEI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0I7QUFDcEI7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlDQUFpQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxpREFBaUQ7QUFDeEg7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2dhc3RfcmVjb3JkZXIuanM/NmNlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2FzdFJlY29yZGVyID0gdm9pZCAwO1xudmFyIGxhc3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2xhc3RcIikpO1xudmFyIGlzQXJyYXlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIikpO1xudmFyIHNvbWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3NvbWVcIikpO1xudmFyIGZvckVhY2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZvckVhY2hcIikpO1xudmFyIGlzRnVuY3Rpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIikpO1xudmFyIGhhc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaGFzXCIpKTtcbnZhciBnYXN0XzEgPSByZXF1aXJlKFwiQGNoZXZyb3RhaW4vZ2FzdFwiKTtcbnZhciBsZXhlcl9wdWJsaWNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zY2FuL2xleGVyX3B1YmxpY1wiKTtcbnZhciB0b2tlbnNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zY2FuL3Rva2Vuc1wiKTtcbnZhciB0b2tlbnNfcHVibGljXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vc2Nhbi90b2tlbnNfcHVibGljXCIpO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4uL3BhcnNlclwiKTtcbnZhciBrZXlzXzEgPSByZXF1aXJlKFwiLi4vLi4vZ3JhbW1hci9rZXlzXCIpO1xudmFyIFJFQ09SRElOR19OVUxMX09CSkVDVCA9IHtcbiAgICBkZXNjcmlwdGlvbjogXCJUaGlzIE9iamVjdCBpbmRpY2F0ZXMgdGhlIFBhcnNlciBpcyBkdXJpbmcgUmVjb3JkaW5nIFBoYXNlXCJcbn07XG5PYmplY3QuZnJlZXplKFJFQ09SRElOR19OVUxMX09CSkVDVCk7XG52YXIgSEFORExFX1NFUEFSQVRPUiA9IHRydWU7XG52YXIgTUFYX01FVEhPRF9JRFggPSBNYXRoLnBvdygyLCBrZXlzXzEuQklUU19GT1JfT0NDVVJSRU5DRV9JRFgpIC0gMTtcbnZhciBSRlQgPSAoMCwgdG9rZW5zX3B1YmxpY18xLmNyZWF0ZVRva2VuKSh7IG5hbWU6IFwiUkVDT1JESU5HX1BIQVNFX1RPS0VOXCIsIHBhdHRlcm46IGxleGVyX3B1YmxpY18xLkxleGVyLk5BIH0pO1xuKDAsIHRva2Vuc18xLmF1Z21lbnRUb2tlblR5cGVzKShbUkZUXSk7XG52YXIgUkVDT1JESU5HX1BIQVNFX1RPS0VOID0gKDAsIHRva2Vuc19wdWJsaWNfMS5jcmVhdGVUb2tlbkluc3RhbmNlKShSRlQsIFwiVGhpcyBJVG9rZW4gaW5kaWNhdGVzIHRoZSBQYXJzZXIgaXMgaW4gUmVjb3JkaW5nIFBoYXNlXFxuXFx0XCIgK1xuICAgIFwiXCIgK1xuICAgIFwiU2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9pbnRlcm5hbHMuaHRtbCNncmFtbWFyLXJlY29yZGluZyBmb3IgZGV0YWlsc1wiLCBcbi8vIFVzaW5nIFwiLTFcIiBpbnN0ZWFkIG9mIE5hTiAoYXMgaW4gRU9GKSBiZWNhdXNlIGFuIGFjdHVhbCBudW1iZXIgaXMgbGVzcyBsaWtlbHkgdG9cbi8vIGNhdXNlIGVycm9ycyBpZiB0aGUgb3V0cHV0IG9mIExBIG9yIENPTlNVTUUgd291bGQgYmUgKGluY29ycmVjdGx5KSB1c2VkIGR1cmluZyB0aGUgcmVjb3JkaW5nIHBoYXNlLlxuLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSk7XG5PYmplY3QuZnJlZXplKFJFQ09SRElOR19QSEFTRV9UT0tFTik7XG52YXIgUkVDT1JESU5HX1BIQVNFX0NTVE5PREUgPSB7XG4gICAgbmFtZTogXCJUaGlzIENTVE5vZGUgaW5kaWNhdGVzIHRoZSBQYXJzZXIgaXMgaW4gUmVjb3JkaW5nIFBoYXNlXFxuXFx0XCIgK1xuICAgICAgICBcIlNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvaW50ZXJuYWxzLmh0bWwjZ3JhbW1hci1yZWNvcmRpbmcgZm9yIGRldGFpbHNcIixcbiAgICBjaGlsZHJlbjoge31cbn07XG4vKipcbiAqIFRoaXMgdHJhaXQgaGFuZGxlcyB0aGUgY3JlYXRpb24gb2YgdGhlIEdBU1Qgc3RydWN0dXJlIGZvciBDaGV2cm90YWluIEdyYW1tYXJzXG4gKi9cbnZhciBHYXN0UmVjb3JkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR2FzdFJlY29yZGVyKCkge1xuICAgIH1cbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLmluaXRHYXN0UmVjb3JkZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrID0gW107XG4gICAgICAgIHRoaXMuUkVDT1JESU5HX1BIQVNFID0gZmFsc2U7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLmVuYWJsZVJlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5SRUNPUkRJTkdfUEhBU0UgPSB0cnVlO1xuICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJFbmFibGUgUmVjb3JkaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gaSA+IDAgPyBpIDogXCJcIjtcbiAgICAgICAgICAgICAgICBfdGhpc1tcIkNPTlNVTUVcIi5jb25jYXQoaWR4KV0gPSBmdW5jdGlvbiAoYXJnMSwgYXJnMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWxSZWNvcmQoYXJnMSwgaSwgYXJnMik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpc1tcIlNVQlJVTEVcIi5jb25jYXQoaWR4KV0gPSBmdW5jdGlvbiAoYXJnMSwgYXJnMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWxSZWNvcmQoYXJnMSwgaSwgYXJnMik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpc1tcIk9QVElPTlwiLmNvbmNhdChpZHgpXSA9IGZ1bmN0aW9uIChhcmcxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsUmVjb3JkKGFyZzEsIGkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXNbXCJPUlwiLmNvbmNhdChpZHgpXSA9IGZ1bmN0aW9uIChhcmcxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWxSZWNvcmQoYXJnMSwgaSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpc1tcIk1BTllcIi5jb25jYXQoaWR4KV0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbFJlY29yZChpLCBhcmcxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzW1wiTUFOWV9TRVBcIi5jb25jYXQoaWR4KV0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsUmVjb3JkKGksIGFyZzEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXNbXCJBVF9MRUFTVF9PTkVcIi5jb25jYXQoaWR4KV0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbFJlY29yZChpLCBhcmcxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzW1wiQVRfTEVBU1RfT05FX1NFUFwiLmNvbmNhdChpZHgpXSA9IGZ1bmN0aW9uIChhcmcxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxSZWNvcmQoaSwgYXJnMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdhcm5pbmcgRGFyayBWb29kb28gTWFnaWMgdXBjb21pbmchXG4gICAgICAgICAgICAgKiBXZSBhcmUgXCJyZXBsYWNpbmdcIiB0aGUgcHVibGljIHBhcnNpbmcgRFNMIG1ldGhvZHMgQVBJXG4gICAgICAgICAgICAgKiBXaXRoICoqbmV3KiogYWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb25zIG9uIHRoZSBQYXJzZXIgKippbnN0YW5jZSoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU28gZmFyIHRoaXMgaXMgdGhlIG9ubHkgd2F5IEkndmUgZm91bmQgdG8gYXZvaWQgcGVyZm9ybWFuY2UgcmVncmVzc2lvbnMgZHVyaW5nIHBhcnNpbmcgdGltZS5cbiAgICAgICAgICAgICAqIC0gQXBwcm94IDMwJSBwZXJmb3JtYW5jZSByZWdyZXNzaW9uIHdhcyBtZWFzdXJlZCBvbiBDaHJvbWUgNzUgQ2FuYXJ5IHdoZW4gYXR0ZW1wdGluZyB0byByZXBsYWNlIHRoZSBcImludGVybmFsXCJcbiAgICAgICAgICAgICAqICAgaW1wbGVtZW50YXRpb25zIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEU0wgbWV0aG9kcyB3aXRoIHRoZSBpZHgoc3VmZml4KSBhcyBhbiBhcmd1bWVudFxuICAgICAgICAgICAgX3RoaXNbXCJjb25zdW1lXCJdID0gZnVuY3Rpb24gKGlkeCwgYXJnMSwgYXJnMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbFJlY29yZChhcmcxLCBpZHgsIGFyZzIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzW1wic3VicnVsZVwiXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWxSZWNvcmQoYXJnMSwgaWR4LCBhcmcyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpc1tcIm9wdGlvblwiXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbFJlY29yZChhcmcxLCBpZHgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzW1wib3JcIl0gPSBmdW5jdGlvbiAoaWR4LCBhcmcxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbFJlY29yZChhcmcxLCBpZHgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzW1wibWFueVwiXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbFJlY29yZChpZHgsIGFyZzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzW1wiYXRMZWFzdE9uZVwiXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbFJlY29yZChpZHgsIGFyZzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLkFDVElPTiA9IF90aGlzLkFDVElPTl9SRUNPUkQ7XG4gICAgICAgICAgICBfdGhpcy5CQUNLVFJBQ0sgPSBfdGhpcy5CQUNLVFJBQ0tfUkVDT1JEO1xuICAgICAgICAgICAgX3RoaXMuTEEgPSBfdGhpcy5MQV9SRUNPUkQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5kaXNhYmxlUmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLlJFQ09SRElOR19QSEFTRSA9IGZhbHNlO1xuICAgICAgICAvLyBCeSBkZWxldGluZyB0aGVzZSAqKmluc3RhbmNlKiogcHJvcGVydGllcywgYW55IGZ1dHVyZSBpbnZvY2F0aW9uXG4gICAgICAgIC8vIHdpbGwgYmUgZGVmZXJyZWQgdG8gdGhlIG9yaWdpbmFsIG1ldGhvZHMgb24gdGhlICoqcHJvdG90eXBlKiogb2JqZWN0XG4gICAgICAgIC8vIFRoaXMgc2VlbXMgdG8gZ2V0IHJpZCBvZiBhbnkgaW5jb3JyZWN0IG9wdGltaXphdGlvbnMgdGhhdCBWOCBtYXlcbiAgICAgICAgLy8gZG8gZHVyaW5nIHRoZSByZWNvcmRpbmcgcGhhc2UuXG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcIkRlbGV0aW5nIFJlY29yZGluZyBtZXRob2RzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gX3RoaXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gaSA+IDAgPyBpIDogXCJcIjtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhhdFtcIkNPTlNVTUVcIi5jb25jYXQoaWR4KV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoYXRbXCJTVUJSVUxFXCIuY29uY2F0KGlkeCldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0W1wiT1BUSU9OXCIuY29uY2F0KGlkeCldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0W1wiT1JcIi5jb25jYXQoaWR4KV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoYXRbXCJNQU5ZXCIuY29uY2F0KGlkeCldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0W1wiTUFOWV9TRVBcIi5jb25jYXQoaWR4KV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoYXRbXCJBVF9MRUFTVF9PTkVcIi5jb25jYXQoaWR4KV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoYXRbXCJBVF9MRUFTVF9PTkVfU0VQXCIuY29uY2F0KGlkeCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoYXRbXCJjb25zdW1lXCJdO1xuICAgICAgICAgICAgZGVsZXRlIHRoYXRbXCJzdWJydWxlXCJdO1xuICAgICAgICAgICAgZGVsZXRlIHRoYXRbXCJvcHRpb25cIl07XG4gICAgICAgICAgICBkZWxldGUgdGhhdFtcIm9yXCJdO1xuICAgICAgICAgICAgZGVsZXRlIHRoYXRbXCJtYW55XCJdO1xuICAgICAgICAgICAgZGVsZXRlIHRoYXRbXCJhdExlYXN0T25lXCJdO1xuICAgICAgICAgICAgZGVsZXRlIHRoYXQuQUNUSU9OO1xuICAgICAgICAgICAgZGVsZXRlIHRoYXQuQkFDS1RSQUNLO1xuICAgICAgICAgICAgZGVsZXRlIHRoYXQuTEE7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gICBQYXJzZXIgbWV0aG9kcyBhcmUgY2FsbGVkIGluc2lkZSBhbiBBQ1RJT04/XG4gICAgLy8gICBNYXliZSB0cnkvY2F0Y2gvZmluYWxseSBvbiBBQ1RJT05TIHdoaWxlIGRpc2FibGluZyB0aGUgcmVjb3JkZXJzIHN0YXRlIGNoYW5nZXM/XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBub29wIHBsYWNlIGhvbGRlclxuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUuQUNUSU9OX1JFQ09SRCA9IGZ1bmN0aW9uIChpbXBsKSB7XG4gICAgICAgIC8vIE5PLU9QIGR1cmluZyByZWNvcmRpbmdcbiAgICB9O1xuICAgIC8vIEV4ZWN1dGluZyBiYWNrdHJhY2tpbmcgbG9naWMgd2lsbCBicmVhayBvdXIgcmVjb3JkaW5nIGxvZ2ljIGFzc3VtcHRpb25zXG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5CQUNLVFJBQ0tfUkVDT1JEID0gZnVuY3Rpb24gKGdyYW1tYXJSdWxlLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIH07XG4gICAgLy8gTEEgaXMgcGFydCBvZiB0aGUgb2ZmaWNpYWwgQVBJIGFuZCBtYXkgYmUgdXNlZCBmb3IgY3VzdG9tIGxvb2thaGVhZCBsb2dpY1xuICAgIC8vIGJ5IGVuZCB1c2VycyB3aG8gbWF5IGZvcmdldCB0byB3cmFwIGl0IGluIEFDVElPTiBvciBpbnNpZGUgYSBHQVRFXG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5MQV9SRUNPUkQgPSBmdW5jdGlvbiAoaG93TXVjaCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIHRoZSBSRUNPUkRfUEhBU0VfVE9LRU4gaGVyZSBiZWNhdXNlIHNvbWVvbmUgbWF5IGRlcGVuZFxuICAgICAgICAvLyBPbiBMQSByZXR1cm4gRU9GIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IHNvIGFuIGluZmluaXRlIGxvb3AgbWF5IG9jY3VyLlxuICAgICAgICByZXR1cm4gcGFyc2VyXzEuRU5EX09GX0ZJTEU7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLnRvcExldmVsUnVsZVJlY29yZCA9IGZ1bmN0aW9uIChuYW1lLCBkZWYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBuZXdUb3BMZXZlbFJ1bGUgPSBuZXcgZ2FzdF8xLlJ1bGUoeyBkZWZpbml0aW9uOiBbXSwgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgICAgIG5ld1RvcExldmVsUnVsZS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrLnB1c2gobmV3VG9wTGV2ZWxSdWxlKTtcbiAgICAgICAgICAgIGRlZi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3VG9wTGV2ZWxSdWxlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFcnJvci5LTk9XTl9SRUNPUkRFUl9FUlJPUiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3IubWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yLm1lc3NhZ2UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG5cXHQgVGhpcyBlcnJvciB3YXMgdGhyb3duIGR1cmluZyB0aGUgXCJncmFtbWFyIHJlY29yZGluZyBwaGFzZVwiIEZvciBtb3JlIGluZm8gc2VlOlxcblxcdCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvaW50ZXJuYWxzLmh0bWwjZ3JhbW1hci1yZWNvcmRpbmdcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKG11dGFiaWxpdHlFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXkgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSBvcmlnaW5hbCBlcnJvciBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBvZiBwYXJzaW5nIERTTFxuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUub3B0aW9uSW50ZXJuYWxSZWNvcmQgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZFByb2QuY2FsbCh0aGlzLCBnYXN0XzEuT3B0aW9uLCBhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSk7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLmF0TGVhc3RPbmVJbnRlcm5hbFJlY29yZCA9IGZ1bmN0aW9uIChvY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZWNvcmRQcm9kLmNhbGwodGhpcywgZ2FzdF8xLlJlcGV0aXRpb25NYW5kYXRvcnksIGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlKTtcbiAgICB9O1xuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxSZWNvcmQgPSBmdW5jdGlvbiAob2NjdXJyZW5jZSwgb3B0aW9ucykge1xuICAgICAgICByZWNvcmRQcm9kLmNhbGwodGhpcywgZ2FzdF8xLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBvcHRpb25zLCBvY2N1cnJlbmNlLCBIQU5ETEVfU0VQQVJBVE9SKTtcbiAgICB9O1xuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUubWFueUludGVybmFsUmVjb3JkID0gZnVuY3Rpb24gKG9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJlY29yZFByb2QuY2FsbCh0aGlzLCBnYXN0XzEuUmVwZXRpdGlvbiwgYWN0aW9uT1JNZXRob2REZWYsIG9jY3VycmVuY2UpO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5tYW55U2VwRmlyc3RJbnRlcm5hbFJlY29yZCA9IGZ1bmN0aW9uIChvY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJlY29yZFByb2QuY2FsbCh0aGlzLCBnYXN0XzEuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIG9wdGlvbnMsIG9jY3VycmVuY2UsIEhBTkRMRV9TRVBBUkFUT1IpO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5vckludGVybmFsUmVjb3JkID0gZnVuY3Rpb24gKGFsdHNPck9wdHMsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZE9yUHJvZC5jYWxsKHRoaXMsIGFsdHNPck9wdHMsIG9jY3VycmVuY2UpO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5zdWJydWxlSW50ZXJuYWxSZWNvcmQgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb2NjdXJyZW5jZSwgb3B0aW9ucykge1xuICAgICAgICBhc3NlcnRNZXRob2RJZHhJc1ZhbGlkKG9jY3VycmVuY2UpO1xuICAgICAgICBpZiAoIXJ1bGVUb0NhbGwgfHwgKDAsIGhhc18xLmRlZmF1bHQpKHJ1bGVUb0NhbGwsIFwicnVsZU5hbWVcIikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCI8U1VCUlVMRVwiLmNvbmNhdChnZXRJZHhTdWZmaXgob2NjdXJyZW5jZSksIFwiPiBhcmd1bWVudCBpcyBpbnZhbGlkXCIpICtcbiAgICAgICAgICAgICAgICBcIiBleHBlY3RpbmcgYSBQYXJzZXIgbWV0aG9kIHJlZmVyZW5jZSBidXQgZ290OiA8XCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHJ1bGVUb0NhbGwpLCBcIj5cIikgK1xuICAgICAgICAgICAgICAgIFwiXFxuIGluc2lkZSB0b3AgbGV2ZWwgcnVsZTogPFwiLmNvbmNhdCh0aGlzLnJlY29yZGluZ1Byb2RTdGFja1swXS5uYW1lLCBcIj5cIikpO1xuICAgICAgICAgICAgZXJyb3IuS05PV05fUkVDT1JERVJfRVJST1IgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZQcm9kID0gKDAsIGxhc3RfMS5kZWZhdWx0KSh0aGlzLnJlY29yZGluZ1Byb2RTdGFjayk7XG4gICAgICAgIHZhciBydWxlTmFtZSA9IHJ1bGVUb0NhbGwucnVsZU5hbWU7XG4gICAgICAgIHZhciBuZXdOb25lVGVybWluYWwgPSBuZXcgZ2FzdF8xLk5vblRlcm1pbmFsKHtcbiAgICAgICAgICAgIGlkeDogb2NjdXJyZW5jZSxcbiAgICAgICAgICAgIG5vblRlcm1pbmFsTmFtZTogcnVsZU5hbWUsXG4gICAgICAgICAgICBsYWJlbDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLkxBQkVMLFxuICAgICAgICAgICAgLy8gVGhlIHJlc29sdmluZyBvZiB0aGUgYHJlZmVyZW5jZWRSdWxlYCBwcm9wZXJ0eSB3aWxsIGJlIGRvbmUgb25jZSBhbGwgdGhlIFJ1bGUncyBHQVNUcyBoYXZlIGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgcmVmZXJlbmNlZFJ1bGU6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcHJldlByb2QuZGVmaW5pdGlvbi5wdXNoKG5ld05vbmVUZXJtaW5hbCk7XG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dENzdCA/IFJFQ09SRElOR19QSEFTRV9DU1ROT0RFIDogUkVDT1JESU5HX05VTExfT0JKRUNUO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5jb25zdW1lSW50ZXJuYWxSZWNvcmQgPSBmdW5jdGlvbiAodG9rVHlwZSwgb2NjdXJyZW5jZSwgb3B0aW9ucykge1xuICAgICAgICBhc3NlcnRNZXRob2RJZHhJc1ZhbGlkKG9jY3VycmVuY2UpO1xuICAgICAgICBpZiAoISgwLCB0b2tlbnNfMS5oYXNTaG9ydEtleVByb3BlcnR5KSh0b2tUeXBlKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiPENPTlNVTUVcIi5jb25jYXQoZ2V0SWR4U3VmZml4KG9jY3VycmVuY2UpLCBcIj4gYXJndW1lbnQgaXMgaW52YWxpZFwiKSArXG4gICAgICAgICAgICAgICAgXCIgZXhwZWN0aW5nIGEgVG9rZW5UeXBlIHJlZmVyZW5jZSBidXQgZ290OiA8XCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHRva1R5cGUpLCBcIj5cIikgK1xuICAgICAgICAgICAgICAgIFwiXFxuIGluc2lkZSB0b3AgbGV2ZWwgcnVsZTogPFwiLmNvbmNhdCh0aGlzLnJlY29yZGluZ1Byb2RTdGFja1swXS5uYW1lLCBcIj5cIikpO1xuICAgICAgICAgICAgZXJyb3IuS05PV05fUkVDT1JERVJfRVJST1IgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZQcm9kID0gKDAsIGxhc3RfMS5kZWZhdWx0KSh0aGlzLnJlY29yZGluZ1Byb2RTdGFjayk7XG4gICAgICAgIHZhciBuZXdOb25lVGVybWluYWwgPSBuZXcgZ2FzdF8xLlRlcm1pbmFsKHtcbiAgICAgICAgICAgIGlkeDogb2NjdXJyZW5jZSxcbiAgICAgICAgICAgIHRlcm1pbmFsVHlwZTogdG9rVHlwZSxcbiAgICAgICAgICAgIGxhYmVsOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuTEFCRUxcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZQcm9kLmRlZmluaXRpb24ucHVzaChuZXdOb25lVGVybWluYWwpO1xuICAgICAgICByZXR1cm4gUkVDT1JESU5HX1BIQVNFX1RPS0VOO1xuICAgIH07XG4gICAgcmV0dXJuIEdhc3RSZWNvcmRlcjtcbn0oKSk7XG5leHBvcnRzLkdhc3RSZWNvcmRlciA9IEdhc3RSZWNvcmRlcjtcbmZ1bmN0aW9uIHJlY29yZFByb2QocHJvZENvbnN0cnVjdG9yLCBtYWluUHJvZEFyZywgb2NjdXJyZW5jZSwgaGFuZGxlU2VwKSB7XG4gICAgaWYgKGhhbmRsZVNlcCA9PT0gdm9pZCAwKSB7IGhhbmRsZVNlcCA9IGZhbHNlOyB9XG4gICAgYXNzZXJ0TWV0aG9kSWR4SXNWYWxpZChvY2N1cnJlbmNlKTtcbiAgICB2YXIgcHJldlByb2QgPSAoMCwgbGFzdF8xLmRlZmF1bHQpKHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrKTtcbiAgICB2YXIgZ3JhbW1hckFjdGlvbiA9ICgwLCBpc0Z1bmN0aW9uXzEuZGVmYXVsdCkobWFpblByb2RBcmcpID8gbWFpblByb2RBcmcgOiBtYWluUHJvZEFyZy5ERUY7XG4gICAgdmFyIG5ld1Byb2QgPSBuZXcgcHJvZENvbnN0cnVjdG9yKHsgZGVmaW5pdGlvbjogW10sIGlkeDogb2NjdXJyZW5jZSB9KTtcbiAgICBpZiAoaGFuZGxlU2VwKSB7XG4gICAgICAgIG5ld1Byb2Quc2VwYXJhdG9yID0gbWFpblByb2RBcmcuU0VQO1xuICAgIH1cbiAgICBpZiAoKDAsIGhhc18xLmRlZmF1bHQpKG1haW5Qcm9kQXJnLCBcIk1BWF9MT09LQUhFQURcIikpIHtcbiAgICAgICAgbmV3UHJvZC5tYXhMb29rYWhlYWQgPSBtYWluUHJvZEFyZy5NQVhfTE9PS0FIRUFEO1xuICAgIH1cbiAgICB0aGlzLnJlY29yZGluZ1Byb2RTdGFjay5wdXNoKG5ld1Byb2QpO1xuICAgIGdyYW1tYXJBY3Rpb24uY2FsbCh0aGlzKTtcbiAgICBwcmV2UHJvZC5kZWZpbml0aW9uLnB1c2gobmV3UHJvZCk7XG4gICAgdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIFJFQ09SRElOR19OVUxMX09CSkVDVDtcbn1cbmZ1bmN0aW9uIHJlY29yZE9yUHJvZChtYWluUHJvZEFyZywgb2NjdXJyZW5jZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgYXNzZXJ0TWV0aG9kSWR4SXNWYWxpZChvY2N1cnJlbmNlKTtcbiAgICB2YXIgcHJldlByb2QgPSAoMCwgbGFzdF8xLmRlZmF1bHQpKHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrKTtcbiAgICAvLyBPbmx5IGFuIGFycmF5IG9mIGFsdGVybmF0aXZlc1xuICAgIHZhciBoYXNPcHRpb25zID0gKDAsIGlzQXJyYXlfMS5kZWZhdWx0KShtYWluUHJvZEFyZykgPT09IGZhbHNlO1xuICAgIHZhciBhbHRzID0gaGFzT3B0aW9ucyA9PT0gZmFsc2UgPyBtYWluUHJvZEFyZyA6IG1haW5Qcm9kQXJnLkRFRjtcbiAgICB2YXIgbmV3T3JQcm9kID0gbmV3IGdhc3RfMS5BbHRlcm5hdGlvbih7XG4gICAgICAgIGRlZmluaXRpb246IFtdLFxuICAgICAgICBpZHg6IG9jY3VycmVuY2UsXG4gICAgICAgIGlnbm9yZUFtYmlndWl0aWVzOiBoYXNPcHRpb25zICYmIG1haW5Qcm9kQXJnLklHTk9SRV9BTUJJR1VJVElFUyA9PT0gdHJ1ZVxuICAgIH0pO1xuICAgIGlmICgoMCwgaGFzXzEuZGVmYXVsdCkobWFpblByb2RBcmcsIFwiTUFYX0xPT0tBSEVBRFwiKSkge1xuICAgICAgICBuZXdPclByb2QubWF4TG9va2FoZWFkID0gbWFpblByb2RBcmcuTUFYX0xPT0tBSEVBRDtcbiAgICB9XG4gICAgdmFyIGhhc1ByZWRpY2F0ZXMgPSAoMCwgc29tZV8xLmRlZmF1bHQpKGFsdHMsIGZ1bmN0aW9uIChjdXJyQWx0KSB7IHJldHVybiAoMCwgaXNGdW5jdGlvbl8xLmRlZmF1bHQpKGN1cnJBbHQuR0FURSk7IH0pO1xuICAgIG5ld09yUHJvZC5oYXNQcmVkaWNhdGVzID0gaGFzUHJlZGljYXRlcztcbiAgICBwcmV2UHJvZC5kZWZpbml0aW9uLnB1c2gobmV3T3JQcm9kKTtcbiAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKGFsdHMsIGZ1bmN0aW9uIChjdXJyQWx0KSB7XG4gICAgICAgIHZhciBjdXJyQWx0RmxhdCA9IG5ldyBnYXN0XzEuQWx0ZXJuYXRpdmUoeyBkZWZpbml0aW9uOiBbXSB9KTtcbiAgICAgICAgbmV3T3JQcm9kLmRlZmluaXRpb24ucHVzaChjdXJyQWx0RmxhdCk7XG4gICAgICAgIGlmICgoMCwgaGFzXzEuZGVmYXVsdCkoY3VyckFsdCwgXCJJR05PUkVfQU1CSUdVSVRJRVNcIikpIHtcbiAgICAgICAgICAgIGN1cnJBbHRGbGF0Lmlnbm9yZUFtYmlndWl0aWVzID0gY3VyckFsdC5JR05PUkVfQU1CSUdVSVRJRVM7IC8vIGFzc3VtZXMgZW5kIHVzZXIgcHJvdmlkZXMgdGhlIGNvcnJlY3QgY29uZmlnIHZhbHVlL3R5cGVcbiAgICAgICAgfVxuICAgICAgICAvLyAqKmltcGxpY2l0KiogaWdub3JlQW1iaWd1aXRpZXMgZHVlIHRvIHVzYWdlIG9mIGdhdGVcbiAgICAgICAgZWxzZSBpZiAoKDAsIGhhc18xLmRlZmF1bHQpKGN1cnJBbHQsIFwiR0FURVwiKSkge1xuICAgICAgICAgICAgY3VyckFsdEZsYXQuaWdub3JlQW1iaWd1aXRpZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnJlY29yZGluZ1Byb2RTdGFjay5wdXNoKGN1cnJBbHRGbGF0KTtcbiAgICAgICAgY3VyckFsdC5BTFQuY2FsbChfdGhpcyk7XG4gICAgICAgIF90aGlzLnJlY29yZGluZ1Byb2RTdGFjay5wb3AoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUkVDT1JESU5HX05VTExfT0JKRUNUO1xufVxuZnVuY3Rpb24gZ2V0SWR4U3VmZml4KGlkeCkge1xuICAgIHJldHVybiBpZHggPT09IDAgPyBcIlwiIDogXCJcIi5jb25jYXQoaWR4KTtcbn1cbmZ1bmN0aW9uIGFzc2VydE1ldGhvZElkeElzVmFsaWQoaWR4KSB7XG4gICAgaWYgKGlkeCA8IDAgfHwgaWR4ID4gTUFYX01FVEhPRF9JRFgpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAvLyBUaGUgc3RhY2sgdHJhY2Ugd2lsbCBjb250YWluIGFsbCB0aGUgbmVlZGVkIGRldGFpbHNcbiAgICAgICAgXCJJbnZhbGlkIERTTCBNZXRob2QgaWR4IHZhbHVlOiA8XCIuY29uY2F0KGlkeCwgXCI+XFxuXFx0XCIpICtcbiAgICAgICAgICAgIFwiSWR4IHZhbHVlIG11c3QgYmUgYSBub25lIG5lZ2F0aXZlIHZhbHVlIHNtYWxsZXIgdGhhbiBcIi5jb25jYXQoTUFYX01FVEhPRF9JRFggKyAxKSk7XG4gICAgICAgIGVycm9yLktOT1dOX1JFQ09SREVSX0VSUk9SID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2FzdF9yZWNvcmRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js":
/*!******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LexerAdapter = void 0;\nvar parser_1 = __webpack_require__(/*! ../parser */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\");\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nvar LexerAdapter = /** @class */ (function () {\n    function LexerAdapter() {\n    }\n    LexerAdapter.prototype.initLexerAdapter = function () {\n        this.tokVector = [];\n        this.tokVectorLength = 0;\n        this.currIdx = -1;\n    };\n    Object.defineProperty(LexerAdapter.prototype, \"input\", {\n        get: function () {\n            return this.tokVector;\n        },\n        set: function (newInput) {\n            // @ts-ignore - `this parameter` not supported in setters/getters\n            //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n            if (this.selfAnalysisDone !== true) {\n                throw Error(\"Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.\");\n            }\n            // @ts-ignore - `this parameter` not supported in setters/getters\n            //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n            this.reset();\n            this.tokVector = newInput;\n            this.tokVectorLength = newInput.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // skips a token and returns the next token\n    LexerAdapter.prototype.SKIP_TOKEN = function () {\n        if (this.currIdx <= this.tokVector.length - 2) {\n            this.consumeToken();\n            return this.LA(1);\n        }\n        else {\n            return parser_1.END_OF_FILE;\n        }\n    };\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LexerAdapter.prototype.LA = function (howMuch) {\n        var soughtIdx = this.currIdx + howMuch;\n        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n            return parser_1.END_OF_FILE;\n        }\n        else {\n            return this.tokVector[soughtIdx];\n        }\n    };\n    LexerAdapter.prototype.consumeToken = function () {\n        this.currIdx++;\n    };\n    LexerAdapter.prototype.exportLexerState = function () {\n        return this.currIdx;\n    };\n    LexerAdapter.prototype.importLexerState = function (newState) {\n        this.currIdx = newState;\n    };\n    LexerAdapter.prototype.resetLexerState = function () {\n        this.currIdx = -1;\n    };\n    LexerAdapter.prototype.moveToTerminatedState = function () {\n        this.currIdx = this.tokVector.length - 1;\n    };\n    LexerAdapter.prototype.getLexerPosition = function () {\n        return this.exportLexerState();\n    };\n    return LexerAdapter;\n}());\nexports.LexerAdapter = LexerAdapter;\n//# sourceMappingURL=lexer_adapter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvbGV4ZXJfYWRhcHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsZUFBZSxtQkFBTyxDQUFDLGlGQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9sZXhlcl9hZGFwdGVyLmpzPzNjMDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxleGVyQWRhcHRlciA9IHZvaWQgMDtcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJcIik7XG4vKipcbiAqIFRyYWl0IHJlc3BvbnNpYmxlIGFic3RyYWN0aW5nIG92ZXIgdGhlIGludGVyYWN0aW9uIHdpdGggTGV4ZXIgb3V0cHV0IChUb2tlbiB2ZWN0b3IpLlxuICpcbiAqIFRoaXMgY291bGQgYmUgZ2VuZXJhbGl6ZWQgdG8gc3VwcG9ydCBvdGhlciBraW5kcyBvZiBsZXhlcnMsIGUuZy5cbiAqIC0gSnVzdCBpbiBUaW1lIExleGluZyAvIExleGVyLUxlc3MgcGFyc2luZy5cbiAqIC0gU3RyZWFtaW5nIExleGVyLlxuICovXG52YXIgTGV4ZXJBZGFwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExleGVyQWRhcHRlcigpIHtcbiAgICB9XG4gICAgTGV4ZXJBZGFwdGVyLnByb3RvdHlwZS5pbml0TGV4ZXJBZGFwdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRva1ZlY3RvciA9IFtdO1xuICAgICAgICB0aGlzLnRva1ZlY3Rvckxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY3VycklkeCA9IC0xO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExleGVyQWRhcHRlci5wcm90b3R5cGUsIFwiaW5wdXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRva1ZlY3RvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3SW5wdXQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBgdGhpcyBwYXJhbWV0ZXJgIG5vdCBzdXBwb3J0ZWQgaW4gc2V0dGVycy9nZXR0ZXJzXG4gICAgICAgICAgICAvLyAgIC0gaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svZnVuY3Rpb25zLmh0bWwjdGhpcy1wYXJhbWV0ZXJzXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxmQW5hbHlzaXNEb25lICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJNaXNzaW5nIDxwZXJmb3JtU2VsZkFuYWx5c2lzPiBpbnZvY2F0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIFBhcnNlcidzIGNvbnN0cnVjdG9yLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBgdGhpcyBwYXJhbWV0ZXJgIG5vdCBzdXBwb3J0ZWQgaW4gc2V0dGVycy9nZXR0ZXJzXG4gICAgICAgICAgICAvLyAgIC0gaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svZnVuY3Rpb25zLmh0bWwjdGhpcy1wYXJhbWV0ZXJzXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnRva1ZlY3RvciA9IG5ld0lucHV0O1xuICAgICAgICAgICAgdGhpcy50b2tWZWN0b3JMZW5ndGggPSBuZXdJbnB1dC5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyBza2lwcyBhIHRva2VuIGFuZCByZXR1cm5zIHRoZSBuZXh0IHRva2VuXG4gICAgTGV4ZXJBZGFwdGVyLnByb3RvdHlwZS5TS0lQX1RPS0VOID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJySWR4IDw9IHRoaXMudG9rVmVjdG9yLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZVRva2VuKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5MQSgxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXJfMS5FTkRfT0ZfRklMRTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gTGV4ZXIgKGFjY2Vzc2luZyBUb2tlbiB2ZWN0b3IpIHJlbGF0ZWQgbWV0aG9kcyB3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbiB0byBpbXBsZW1lbnQgbGF6eSBsZXhlcnNcbiAgICAvLyBvciBsZXhlcnMgZGVwZW5kZW50IG9uIHBhcnNlciBjb250ZXh0LlxuICAgIExleGVyQWRhcHRlci5wcm90b3R5cGUuTEEgPSBmdW5jdGlvbiAoaG93TXVjaCkge1xuICAgICAgICB2YXIgc291Z2h0SWR4ID0gdGhpcy5jdXJySWR4ICsgaG93TXVjaDtcbiAgICAgICAgaWYgKHNvdWdodElkeCA8IDAgfHwgdGhpcy50b2tWZWN0b3JMZW5ndGggPD0gc291Z2h0SWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyXzEuRU5EX09GX0ZJTEU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2tWZWN0b3Jbc291Z2h0SWR4XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGV4ZXJBZGFwdGVyLnByb3RvdHlwZS5jb25zdW1lVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY3VycklkeCsrO1xuICAgIH07XG4gICAgTGV4ZXJBZGFwdGVyLnByb3RvdHlwZS5leHBvcnRMZXhlclN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJySWR4O1xuICAgIH07XG4gICAgTGV4ZXJBZGFwdGVyLnByb3RvdHlwZS5pbXBvcnRMZXhlclN0YXRlID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuY3VycklkeCA9IG5ld1N0YXRlO1xuICAgIH07XG4gICAgTGV4ZXJBZGFwdGVyLnByb3RvdHlwZS5yZXNldExleGVyU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY3VycklkeCA9IC0xO1xuICAgIH07XG4gICAgTGV4ZXJBZGFwdGVyLnByb3RvdHlwZS5tb3ZlVG9UZXJtaW5hdGVkU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY3VycklkeCA9IHRoaXMudG9rVmVjdG9yLmxlbmd0aCAtIDE7XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLmdldExleGVyUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cG9ydExleGVyU3RhdGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBMZXhlckFkYXB0ZXI7XG59KCkpO1xuZXhwb3J0cy5MZXhlckFkYXB0ZXIgPSBMZXhlckFkYXB0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXhlcl9hZGFwdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js":
/*!***************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.collectMethods = exports.LooksAhead = void 0;\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar has_1 = __importDefault(__webpack_require__(/*! lodash/has */ \"(ssr)/./node_modules/lodash/has.js\"));\nvar parser_1 = __webpack_require__(/*! ../parser */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\");\nvar keys_1 = __webpack_require__(/*! ../../grammar/keys */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/keys.js\");\nvar gast_1 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nvar gast_2 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\nvar llk_lookahead_1 = __webpack_require__(/*! ../../grammar/llk_lookahead */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js\");\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nvar LooksAhead = /** @class */ (function () {\n    function LooksAhead() {\n    }\n    LooksAhead.prototype.initLooksAhead = function (config) {\n        this.dynamicTokensEnabled = (0, has_1.default)(config, \"dynamicTokensEnabled\")\n            ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n        this.maxLookahead = (0, has_1.default)(config, \"maxLookahead\")\n            ? config.maxLookahead // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;\n        this.lookaheadStrategy = (0, has_1.default)(config, \"lookaheadStrategy\")\n            ? config.lookaheadStrategy // assumes end user provides the correct config value/type\n            : new llk_lookahead_1.LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });\n        this.lookAheadFuncsCache = new Map();\n    };\n    LooksAhead.prototype.preComputeLookaheadFunctions = function (rules) {\n        var _this = this;\n        (0, forEach_1.default)(rules, function (currRule) {\n            _this.TRACE_INIT(\"\".concat(currRule.name, \" Rule Lookahead\"), function () {\n                var _a = collectMethods(currRule), alternation = _a.alternation, repetition = _a.repetition, option = _a.option, repetitionMandatory = _a.repetitionMandatory, repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a.repetitionWithSeparator;\n                (0, forEach_1.default)(alternation, function (currProd) {\n                    var prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n                    _this.TRACE_INIT(\"\".concat((0, gast_2.getProductionDslName)(currProd)).concat(prodIdx), function () {\n                        var laFunc = _this.lookaheadStrategy.buildLookaheadForAlternation({\n                            prodOccurrence: currProd.idx,\n                            rule: currRule,\n                            maxLookahead: currProd.maxLookahead || _this.maxLookahead,\n                            hasPredicates: currProd.hasPredicates,\n                            dynamicTokensEnabled: _this.dynamicTokensEnabled\n                        });\n                        var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);\n                        _this.setLaFuncCache(key, laFunc);\n                    });\n                });\n                (0, forEach_1.default)(repetition, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, \"Repetition\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n                });\n                (0, forEach_1.default)(option, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, \"Option\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n                });\n                (0, forEach_1.default)(repetitionMandatory, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, \"RepetitionMandatory\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n                });\n                (0, forEach_1.default)(repetitionMandatoryWithSeparator, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, \"RepetitionMandatoryWithSeparator\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n                });\n                (0, forEach_1.default)(repetitionWithSeparator, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, \"RepetitionWithSeparator\", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));\n                });\n            });\n        });\n    };\n    LooksAhead.prototype.computeLookaheadFunc = function (rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n        var _this = this;\n        this.TRACE_INIT(\"\".concat(dslMethodName).concat(prodOccurrence === 0 ? \"\" : prodOccurrence), function () {\n            var laFunc = _this.lookaheadStrategy.buildLookaheadForOptional({\n                prodOccurrence: prodOccurrence,\n                rule: rule,\n                maxLookahead: prodMaxLookahead || _this.maxLookahead,\n                dynamicTokensEnabled: _this.dynamicTokensEnabled,\n                prodType: prodType\n            });\n            var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n            _this.setLaFuncCache(key, laFunc);\n        });\n    };\n    // this actually returns a number, but it is always used as a string (object prop key)\n    LooksAhead.prototype.getKeyForAutomaticLookahead = function (dslMethodIdx, occurrence) {\n        var currRuleShortName = this.getLastExplicitRuleShortName();\n        return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);\n    };\n    LooksAhead.prototype.getLaFuncFromCache = function (key) {\n        return this.lookAheadFuncsCache.get(key);\n    };\n    /* istanbul ignore next */\n    LooksAhead.prototype.setLaFuncCache = function (key, value) {\n        this.lookAheadFuncsCache.set(key, value);\n    };\n    return LooksAhead;\n}());\nexports.LooksAhead = LooksAhead;\nvar DslMethodsCollectorVisitor = /** @class */ (function (_super) {\n    __extends(DslMethodsCollectorVisitor, _super);\n    function DslMethodsCollectorVisitor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: []\n        };\n        return _this;\n    }\n    DslMethodsCollectorVisitor.prototype.reset = function () {\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: []\n        };\n    };\n    DslMethodsCollectorVisitor.prototype.visitOption = function (option) {\n        this.dslMethods.option.push(option);\n    };\n    DslMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.dslMethods.repetitionWithSeparator.push(manySep);\n    };\n    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.dslMethods.repetitionMandatory.push(atLeastOne);\n    };\n    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n    };\n    DslMethodsCollectorVisitor.prototype.visitRepetition = function (many) {\n        this.dslMethods.repetition.push(many);\n    };\n    DslMethodsCollectorVisitor.prototype.visitAlternation = function (or) {\n        this.dslMethods.alternation.push(or);\n    };\n    return DslMethodsCollectorVisitor;\n}(gast_1.GAstVisitor));\nvar collectorVisitor = new DslMethodsCollectorVisitor();\nfunction collectMethods(rule) {\n    collectorVisitor.reset();\n    rule.accept(collectorVisitor);\n    var dslMethods = collectorVisitor.dslMethods;\n    // avoid uncleaned references\n    collectorVisitor.reset();\n    return dslMethods;\n}\nexports.collectMethods = collectMethods;\n//# sourceMappingURL=looksahead.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvbG9va3NhaGVhZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLGtCQUFrQjtBQUMzQyxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsNEJBQTRCLG1CQUFPLENBQUMsc0RBQVk7QUFDaEQsZUFBZSxtQkFBTyxDQUFDLGlGQUFXO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyx5RkFBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLDhFQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsOEVBQWtCO0FBQ3ZDLHNCQUFzQixtQkFBTyxDQUFDLDJHQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUNBQWlDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9sb29rc2FoZWFkLmpzP2VkMDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb2xsZWN0TWV0aG9kcyA9IGV4cG9ydHMuTG9va3NBaGVhZCA9IHZvaWQgMDtcbnZhciBmb3JFYWNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9mb3JFYWNoXCIpKTtcbnZhciBoYXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2hhc1wiKSk7XG52YXIgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vcGFyc2VyXCIpO1xudmFyIGtleXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmFtbWFyL2tleXNcIik7XG52YXIgZ2FzdF8xID0gcmVxdWlyZShcIkBjaGV2cm90YWluL2dhc3RcIik7XG52YXIgZ2FzdF8yID0gcmVxdWlyZShcIkBjaGV2cm90YWluL2dhc3RcIik7XG52YXIgbGxrX2xvb2thaGVhZF8xID0gcmVxdWlyZShcIi4uLy4uL2dyYW1tYXIvbGxrX2xvb2thaGVhZFwiKTtcbi8qKlxuICogVHJhaXQgcmVzcG9uc2libGUgZm9yIHRoZSBsb29rYWhlYWQgcmVsYXRlZCB1dGlsaXRpZXMgYW5kIG9wdGltaXphdGlvbnMuXG4gKi9cbnZhciBMb29rc0FoZWFkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvb2tzQWhlYWQoKSB7XG4gICAgfVxuICAgIExvb2tzQWhlYWQucHJvdG90eXBlLmluaXRMb29rc0FoZWFkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkID0gKDAsIGhhc18xLmRlZmF1bHQpKGNvbmZpZywgXCJkeW5hbWljVG9rZW5zRW5hYmxlZFwiKVxuICAgICAgICAgICAgPyBjb25maWcuZHluYW1pY1Rva2Vuc0VuYWJsZWQgLy8gYXNzdW1lcyBlbmQgdXNlciBwcm92aWRlcyB0aGUgY29ycmVjdCBjb25maWcgdmFsdWUvdHlwZVxuICAgICAgICAgICAgOiBwYXJzZXJfMS5ERUZBVUxUX1BBUlNFUl9DT05GSUcuZHluYW1pY1Rva2Vuc0VuYWJsZWQ7XG4gICAgICAgIHRoaXMubWF4TG9va2FoZWFkID0gKDAsIGhhc18xLmRlZmF1bHQpKGNvbmZpZywgXCJtYXhMb29rYWhlYWRcIilcbiAgICAgICAgICAgID8gY29uZmlnLm1heExvb2thaGVhZCAvLyBhc3N1bWVzIGVuZCB1c2VyIHByb3ZpZGVzIHRoZSBjb3JyZWN0IGNvbmZpZyB2YWx1ZS90eXBlXG4gICAgICAgICAgICA6IHBhcnNlcl8xLkRFRkFVTFRfUEFSU0VSX0NPTkZJRy5tYXhMb29rYWhlYWQ7XG4gICAgICAgIHRoaXMubG9va2FoZWFkU3RyYXRlZ3kgPSAoMCwgaGFzXzEuZGVmYXVsdCkoY29uZmlnLCBcImxvb2thaGVhZFN0cmF0ZWd5XCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5sb29rYWhlYWRTdHJhdGVneSAvLyBhc3N1bWVzIGVuZCB1c2VyIHByb3ZpZGVzIHRoZSBjb3JyZWN0IGNvbmZpZyB2YWx1ZS90eXBlXG4gICAgICAgICAgICA6IG5ldyBsbGtfbG9va2FoZWFkXzEuTExrTG9va2FoZWFkU3RyYXRlZ3koeyBtYXhMb29rYWhlYWQ6IHRoaXMubWF4TG9va2FoZWFkIH0pO1xuICAgICAgICB0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfTtcbiAgICBMb29rc0FoZWFkLnByb3RvdHlwZS5wcmVDb21wdXRlTG9va2FoZWFkRnVuY3Rpb25zID0gZnVuY3Rpb24gKHJ1bGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICgwLCBmb3JFYWNoXzEuZGVmYXVsdCkocnVsZXMsIGZ1bmN0aW9uIChjdXJyUnVsZSkge1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIlwiLmNvbmNhdChjdXJyUnVsZS5uYW1lLCBcIiBSdWxlIExvb2thaGVhZFwiKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGNvbGxlY3RNZXRob2RzKGN1cnJSdWxlKSwgYWx0ZXJuYXRpb24gPSBfYS5hbHRlcm5hdGlvbiwgcmVwZXRpdGlvbiA9IF9hLnJlcGV0aXRpb24sIG9wdGlvbiA9IF9hLm9wdGlvbiwgcmVwZXRpdGlvbk1hbmRhdG9yeSA9IF9hLnJlcGV0aXRpb25NYW5kYXRvcnksIHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yID0gX2EucmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yID0gX2EucmVwZXRpdGlvbldpdGhTZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgKDAsIGZvckVhY2hfMS5kZWZhdWx0KShhbHRlcm5hdGlvbiwgZnVuY3Rpb24gKGN1cnJQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9kSWR4ID0gY3VyclByb2QuaWR4ID09PSAwID8gXCJcIiA6IGN1cnJQcm9kLmlkeDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIlwiLmNvbmNhdCgoMCwgZ2FzdF8yLmdldFByb2R1Y3Rpb25Ec2xOYW1lKShjdXJyUHJvZCkpLmNvbmNhdChwcm9kSWR4KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhRnVuYyA9IF90aGlzLmxvb2thaGVhZFN0cmF0ZWd5LmJ1aWxkTG9va2FoZWFkRm9yQWx0ZXJuYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2RPY2N1cnJlbmNlOiBjdXJyUHJvZC5pZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogY3VyclJ1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4TG9va2FoZWFkOiBjdXJyUHJvZC5tYXhMb29rYWhlYWQgfHwgX3RoaXMubWF4TG9va2FoZWFkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1ByZWRpY2F0ZXM6IGN1cnJQcm9kLmhhc1ByZWRpY2F0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY1Rva2Vuc0VuYWJsZWQ6IF90aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSAoMCwga2V5c18xLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZCkoX3RoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydFtjdXJyUnVsZS5uYW1lXSwga2V5c18xLk9SX0lEWCwgY3VyclByb2QuaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldExhRnVuY0NhY2hlKGtleSwgbGFGdW5jKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgKDAsIGZvckVhY2hfMS5kZWZhdWx0KShyZXBldGl0aW9uLCBmdW5jdGlvbiAoY3VyclByb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcHV0ZUxvb2thaGVhZEZ1bmMoY3VyclJ1bGUsIGN1cnJQcm9kLmlkeCwga2V5c18xLk1BTllfSURYLCBcIlJlcGV0aXRpb25cIiwgY3VyclByb2QubWF4TG9va2FoZWFkLCAoMCwgZ2FzdF8yLmdldFByb2R1Y3Rpb25Ec2xOYW1lKShjdXJyUHJvZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICgwLCBmb3JFYWNoXzEuZGVmYXVsdCkob3B0aW9uLCBmdW5jdGlvbiAoY3VyclByb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcHV0ZUxvb2thaGVhZEZ1bmMoY3VyclJ1bGUsIGN1cnJQcm9kLmlkeCwga2V5c18xLk9QVElPTl9JRFgsIFwiT3B0aW9uXCIsIGN1cnJQcm9kLm1heExvb2thaGVhZCwgKDAsIGdhc3RfMi5nZXRQcm9kdWN0aW9uRHNsTmFtZSkoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKHJlcGV0aXRpb25NYW5kYXRvcnksIGZ1bmN0aW9uIChjdXJyUHJvZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlTG9va2FoZWFkRnVuYyhjdXJyUnVsZSwgY3VyclByb2QuaWR4LCBrZXlzXzEuQVRfTEVBU1RfT05FX0lEWCwgXCJSZXBldGl0aW9uTWFuZGF0b3J5XCIsIGN1cnJQcm9kLm1heExvb2thaGVhZCwgKDAsIGdhc3RfMi5nZXRQcm9kdWN0aW9uRHNsTmFtZSkoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBmdW5jdGlvbiAoY3VyclByb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcHV0ZUxvb2thaGVhZEZ1bmMoY3VyclJ1bGUsIGN1cnJQcm9kLmlkeCwga2V5c18xLkFUX0xFQVNUX09ORV9TRVBfSURYLCBcIlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yXCIsIGN1cnJQcm9kLm1heExvb2thaGVhZCwgKDAsIGdhc3RfMi5nZXRQcm9kdWN0aW9uRHNsTmFtZSkoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBmdW5jdGlvbiAoY3VyclByb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcHV0ZUxvb2thaGVhZEZ1bmMoY3VyclJ1bGUsIGN1cnJQcm9kLmlkeCwga2V5c18xLk1BTllfU0VQX0lEWCwgXCJSZXBldGl0aW9uV2l0aFNlcGFyYXRvclwiLCBjdXJyUHJvZC5tYXhMb29rYWhlYWQsICgwLCBnYXN0XzIuZ2V0UHJvZHVjdGlvbkRzbE5hbWUpKGN1cnJQcm9kKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb29rc0FoZWFkLnByb3RvdHlwZS5jb21wdXRlTG9va2FoZWFkRnVuYyA9IGZ1bmN0aW9uIChydWxlLCBwcm9kT2NjdXJyZW5jZSwgcHJvZEtleSwgcHJvZFR5cGUsIHByb2RNYXhMb29rYWhlYWQsIGRzbE1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiXCIuY29uY2F0KGRzbE1ldGhvZE5hbWUpLmNvbmNhdChwcm9kT2NjdXJyZW5jZSA9PT0gMCA/IFwiXCIgOiBwcm9kT2NjdXJyZW5jZSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYUZ1bmMgPSBfdGhpcy5sb29rYWhlYWRTdHJhdGVneS5idWlsZExvb2thaGVhZEZvck9wdGlvbmFsKHtcbiAgICAgICAgICAgICAgICBwcm9kT2NjdXJyZW5jZTogcHJvZE9jY3VycmVuY2UsXG4gICAgICAgICAgICAgICAgcnVsZTogcnVsZSxcbiAgICAgICAgICAgICAgICBtYXhMb29rYWhlYWQ6IHByb2RNYXhMb29rYWhlYWQgfHwgX3RoaXMubWF4TG9va2FoZWFkLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNUb2tlbnNFbmFibGVkOiBfdGhpcy5keW5hbWljVG9rZW5zRW5hYmxlZCxcbiAgICAgICAgICAgICAgICBwcm9kVHlwZTogcHJvZFR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGtleSA9ICgwLCBrZXlzXzEuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKShfdGhpcy5mdWxsUnVsZU5hbWVUb1Nob3J0W3J1bGUubmFtZV0sIHByb2RLZXksIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgICAgIF90aGlzLnNldExhRnVuY0NhY2hlKGtleSwgbGFGdW5jKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB0aGlzIGFjdHVhbGx5IHJldHVybnMgYSBudW1iZXIsIGJ1dCBpdCBpcyBhbHdheXMgdXNlZCBhcyBhIHN0cmluZyAob2JqZWN0IHByb3Aga2V5KVxuICAgIExvb2tzQWhlYWQucHJvdG90eXBlLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZCA9IGZ1bmN0aW9uIChkc2xNZXRob2RJZHgsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgdmFyIGN1cnJSdWxlU2hvcnROYW1lID0gdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lKCk7XG4gICAgICAgIHJldHVybiAoMCwga2V5c18xLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZCkoY3VyclJ1bGVTaG9ydE5hbWUsIGRzbE1ldGhvZElkeCwgb2NjdXJyZW5jZSk7XG4gICAgfTtcbiAgICBMb29rc0FoZWFkLnByb3RvdHlwZS5nZXRMYUZ1bmNGcm9tQ2FjaGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGUuZ2V0KGtleSk7XG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIExvb2tzQWhlYWQucHJvdG90eXBlLnNldExhRnVuY0NhY2hlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5sb29rQWhlYWRGdW5jc0NhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBMb29rc0FoZWFkO1xufSgpKTtcbmV4cG9ydHMuTG9va3NBaGVhZCA9IExvb2tzQWhlYWQ7XG52YXIgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZHNsTWV0aG9kcyA9IHtcbiAgICAgICAgICAgIG9wdGlvbjogW10sXG4gICAgICAgICAgICBhbHRlcm5hdGlvbjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uOiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yOiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25NYW5kYXRvcnk6IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRzbE1ldGhvZHMgPSB7XG4gICAgICAgICAgICBvcHRpb246IFtdLFxuICAgICAgICAgICAgYWx0ZXJuYXRpb246IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uV2l0aFNlcGFyYXRvcjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uTWFuZGF0b3J5OiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0T3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB0aGlzLmRzbE1ldGhvZHMub3B0aW9uLnB1c2gob3B0aW9uKTtcbiAgICB9O1xuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKG1hbnlTZXApIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLnB1c2gobWFueVNlcCk7XG4gICAgfTtcbiAgICBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5ID0gZnVuY3Rpb24gKGF0TGVhc3RPbmUpIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25NYW5kYXRvcnkucHVzaChhdExlYXN0T25lKTtcbiAgICB9O1xuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKGF0TGVhc3RPbmVTZXApIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLnB1c2goYXRMZWFzdE9uZVNlcCk7XG4gICAgfTtcbiAgICBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uID0gZnVuY3Rpb24gKG1hbnkpIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb24ucHVzaChtYW55KTtcbiAgICB9O1xuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uID0gZnVuY3Rpb24gKG9yKSB7XG4gICAgICAgIHRoaXMuZHNsTWV0aG9kcy5hbHRlcm5hdGlvbi5wdXNoKG9yKTtcbiAgICB9O1xuICAgIHJldHVybiBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcjtcbn0oZ2FzdF8xLkdBc3RWaXNpdG9yKSk7XG52YXIgY29sbGVjdG9yVmlzaXRvciA9IG5ldyBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcigpO1xuZnVuY3Rpb24gY29sbGVjdE1ldGhvZHMocnVsZSkge1xuICAgIGNvbGxlY3RvclZpc2l0b3IucmVzZXQoKTtcbiAgICBydWxlLmFjY2VwdChjb2xsZWN0b3JWaXNpdG9yKTtcbiAgICB2YXIgZHNsTWV0aG9kcyA9IGNvbGxlY3RvclZpc2l0b3IuZHNsTWV0aG9kcztcbiAgICAvLyBhdm9pZCB1bmNsZWFuZWQgcmVmZXJlbmNlc1xuICAgIGNvbGxlY3RvclZpc2l0b3IucmVzZXQoKTtcbiAgICByZXR1cm4gZHNsTWV0aG9kcztcbn1cbmV4cG9ydHMuY29sbGVjdE1ldGhvZHMgPSBjb2xsZWN0TWV0aG9kcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvb2tzYWhlYWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PerformanceTracer = void 0;\nvar has_1 = __importDefault(__webpack_require__(/*! lodash/has */ \"(ssr)/./node_modules/lodash/has.js\"));\nvar utils_1 = __webpack_require__(/*! @chevrotain/utils */ \"(ssr)/./node_modules/@chevrotain/utils/lib/src/api.js\");\nvar parser_1 = __webpack_require__(/*! ../parser */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\");\n/**\n * Trait responsible for runtime parsing errors.\n */\nvar PerformanceTracer = /** @class */ (function () {\n    function PerformanceTracer() {\n    }\n    PerformanceTracer.prototype.initPerformanceTracer = function (config) {\n        if ((0, has_1.default)(config, \"traceInitPerf\")) {\n            var userTraceInitPerf = config.traceInitPerf;\n            var traceIsNumber = typeof userTraceInitPerf === \"number\";\n            this.traceInitMaxIdent = traceIsNumber\n                ? userTraceInitPerf\n                : Infinity;\n            this.traceInitPerf = traceIsNumber\n                ? userTraceInitPerf > 0\n                : userTraceInitPerf; // assumes end user provides the correct config value/type\n        }\n        else {\n            this.traceInitMaxIdent = 0;\n            this.traceInitPerf = parser_1.DEFAULT_PARSER_CONFIG.traceInitPerf;\n        }\n        this.traceInitIndent = -1;\n    };\n    PerformanceTracer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            var indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                console.log(\"\".concat(indent, \"--> <\").concat(phaseDesc, \">\"));\n            }\n            var _a = (0, utils_1.timer)(phaseImpl), time = _a.time, value = _a.value;\n            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n            var traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                traceMethod(\"\".concat(indent, \"<-- <\").concat(phaseDesc, \"> time: \").concat(time, \"ms\"));\n            }\n            this.traceInitIndent--;\n            return value;\n        }\n        else {\n            return phaseImpl();\n        }\n    };\n    return PerformanceTracer;\n}());\nexports.PerformanceTracer = PerformanceTracer;\n//# sourceMappingURL=perf_tracer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvcGVyZl90cmFjZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsNEJBQTRCLG1CQUFPLENBQUMsc0RBQVk7QUFDaEQsY0FBYyxtQkFBTyxDQUFDLGdGQUFtQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMsaUZBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3BlcmZfdHJhY2VyLmpzP2VmMTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBlcmZvcm1hbmNlVHJhY2VyID0gdm9pZCAwO1xudmFyIGhhc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaGFzXCIpKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIkBjaGV2cm90YWluL3V0aWxzXCIpO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4uL3BhcnNlclwiKTtcbi8qKlxuICogVHJhaXQgcmVzcG9uc2libGUgZm9yIHJ1bnRpbWUgcGFyc2luZyBlcnJvcnMuXG4gKi9cbnZhciBQZXJmb3JtYW5jZVRyYWNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQZXJmb3JtYW5jZVRyYWNlcigpIHtcbiAgICB9XG4gICAgUGVyZm9ybWFuY2VUcmFjZXIucHJvdG90eXBlLmluaXRQZXJmb3JtYW5jZVRyYWNlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgaWYgKCgwLCBoYXNfMS5kZWZhdWx0KShjb25maWcsIFwidHJhY2VJbml0UGVyZlwiKSkge1xuICAgICAgICAgICAgdmFyIHVzZXJUcmFjZUluaXRQZXJmID0gY29uZmlnLnRyYWNlSW5pdFBlcmY7XG4gICAgICAgICAgICB2YXIgdHJhY2VJc051bWJlciA9IHR5cGVvZiB1c2VyVHJhY2VJbml0UGVyZiA9PT0gXCJudW1iZXJcIjtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0TWF4SWRlbnQgPSB0cmFjZUlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyB1c2VyVHJhY2VJbml0UGVyZlxuICAgICAgICAgICAgICAgIDogSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdFBlcmYgPSB0cmFjZUlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyB1c2VyVHJhY2VJbml0UGVyZiA+IDBcbiAgICAgICAgICAgICAgICA6IHVzZXJUcmFjZUluaXRQZXJmOyAvLyBhc3N1bWVzIGVuZCB1c2VyIHByb3ZpZGVzIHRoZSBjb3JyZWN0IGNvbmZpZyB2YWx1ZS90eXBlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdE1heElkZW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0UGVyZiA9IHBhcnNlcl8xLkRFRkFVTFRfUEFSU0VSX0NPTkZJRy50cmFjZUluaXRQZXJmO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2VJbml0SW5kZW50ID0gLTE7XG4gICAgfTtcbiAgICBQZXJmb3JtYW5jZVRyYWNlci5wcm90b3R5cGUuVFJBQ0VfSU5JVCA9IGZ1bmN0aW9uIChwaGFzZURlc2MsIHBoYXNlSW1wbCkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIG9wdGltaXplIHRoaXMgdXNpbmcgTk9PUCBwYXR0ZXJuIGJlY2F1c2VcbiAgICAgICAgLy8gSXQgaXMgbm90IGNhbGxlZCBpbiBhIGhvdCBzcG90Li4uXG4gICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdFBlcmYgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0SW5kZW50Kys7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gbmV3IEFycmF5KHRoaXMudHJhY2VJbml0SW5kZW50ICsgMSkuam9pbihcIlxcdFwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdEluZGVudCA8IHRoaXMudHJhY2VJbml0TWF4SWRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlwiLmNvbmNhdChpbmRlbnQsIFwiLS0+IDxcIikuY29uY2F0KHBoYXNlRGVzYywgXCI+XCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYSA9ICgwLCB1dGlsc18xLnRpbWVyKShwaGFzZUltcGwpLCB0aW1lID0gX2EudGltZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gRGlmZmljdWx0IHRvIHJlcHJvZHVjZSBzcGVjaWZpYyBwZXJmb3JtYW5jZSBiZWhhdmlvciAoPjEwbXMpIGluIHRlc3RzICovXG4gICAgICAgICAgICB2YXIgdHJhY2VNZXRob2QgPSB0aW1lID4gMTAgPyBjb25zb2xlLndhcm4gOiBjb25zb2xlLmxvZztcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdEluZGVudCA8IHRoaXMudHJhY2VJbml0TWF4SWRlbnQpIHtcbiAgICAgICAgICAgICAgICB0cmFjZU1ldGhvZChcIlwiLmNvbmNhdChpbmRlbnQsIFwiPC0tIDxcIikuY29uY2F0KHBoYXNlRGVzYywgXCI+IHRpbWU6IFwiKS5jb25jYXQodGltZSwgXCJtc1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdEluZGVudC0tO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBoYXNlSW1wbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUGVyZm9ybWFuY2VUcmFjZXI7XG59KCkpO1xuZXhwb3J0cy5QZXJmb3JtYW5jZVRyYWNlciA9IFBlcmZvcm1hbmNlVHJhY2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyZl90cmFjZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RecognizerApi = void 0;\nvar values_1 = __importDefault(__webpack_require__(/*! lodash/values */ \"(ssr)/./node_modules/lodash/values.js\"));\nvar includes_1 = __importDefault(__webpack_require__(/*! lodash/includes */ \"(ssr)/./node_modules/lodash/includes.js\"));\nvar exceptions_public_1 = __webpack_require__(/*! ../../exceptions_public */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/exceptions_public.js\");\nvar parser_1 = __webpack_require__(/*! ../parser */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\");\nvar errors_public_1 = __webpack_require__(/*! ../../errors_public */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/errors_public.js\");\nvar checks_1 = __webpack_require__(/*! ../../grammar/checks */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/checks.js\");\nvar gast_1 = __webpack_require__(/*! @chevrotain/gast */ \"(ssr)/./node_modules/@chevrotain/gast/lib/src/api.js\");\n/**\n * This trait is responsible for implementing the public API\n * for defining Chevrotain parsers, i.e:\n * - CONSUME\n * - RULE\n * - OPTION\n * - ...\n */\nvar RecognizerApi = /** @class */ (function () {\n    function RecognizerApi() {\n    }\n    RecognizerApi.prototype.ACTION = function (impl) {\n        return impl.call(this);\n    };\n    RecognizerApi.prototype.consume = function (idx, tokType, options) {\n        return this.consumeInternal(tokType, idx, options);\n    };\n    RecognizerApi.prototype.subrule = function (idx, ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, idx, options);\n    };\n    RecognizerApi.prototype.option = function (idx, actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, idx);\n    };\n    RecognizerApi.prototype.or = function (idx, altsOrOpts) {\n        return this.orInternal(altsOrOpts, idx);\n    };\n    RecognizerApi.prototype.many = function (idx, actionORMethodDef) {\n        return this.manyInternal(idx, actionORMethodDef);\n    };\n    RecognizerApi.prototype.atLeastOne = function (idx, actionORMethodDef) {\n        return this.atLeastOneInternal(idx, actionORMethodDef);\n    };\n    RecognizerApi.prototype.CONSUME = function (tokType, options) {\n        return this.consumeInternal(tokType, 0, options);\n    };\n    RecognizerApi.prototype.CONSUME1 = function (tokType, options) {\n        return this.consumeInternal(tokType, 1, options);\n    };\n    RecognizerApi.prototype.CONSUME2 = function (tokType, options) {\n        return this.consumeInternal(tokType, 2, options);\n    };\n    RecognizerApi.prototype.CONSUME3 = function (tokType, options) {\n        return this.consumeInternal(tokType, 3, options);\n    };\n    RecognizerApi.prototype.CONSUME4 = function (tokType, options) {\n        return this.consumeInternal(tokType, 4, options);\n    };\n    RecognizerApi.prototype.CONSUME5 = function (tokType, options) {\n        return this.consumeInternal(tokType, 5, options);\n    };\n    RecognizerApi.prototype.CONSUME6 = function (tokType, options) {\n        return this.consumeInternal(tokType, 6, options);\n    };\n    RecognizerApi.prototype.CONSUME7 = function (tokType, options) {\n        return this.consumeInternal(tokType, 7, options);\n    };\n    RecognizerApi.prototype.CONSUME8 = function (tokType, options) {\n        return this.consumeInternal(tokType, 8, options);\n    };\n    RecognizerApi.prototype.CONSUME9 = function (tokType, options) {\n        return this.consumeInternal(tokType, 9, options);\n    };\n    RecognizerApi.prototype.SUBRULE = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 0, options);\n    };\n    RecognizerApi.prototype.SUBRULE1 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 1, options);\n    };\n    RecognizerApi.prototype.SUBRULE2 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 2, options);\n    };\n    RecognizerApi.prototype.SUBRULE3 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 3, options);\n    };\n    RecognizerApi.prototype.SUBRULE4 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 4, options);\n    };\n    RecognizerApi.prototype.SUBRULE5 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 5, options);\n    };\n    RecognizerApi.prototype.SUBRULE6 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 6, options);\n    };\n    RecognizerApi.prototype.SUBRULE7 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 7, options);\n    };\n    RecognizerApi.prototype.SUBRULE8 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 8, options);\n    };\n    RecognizerApi.prototype.SUBRULE9 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 9, options);\n    };\n    RecognizerApi.prototype.OPTION = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 0);\n    };\n    RecognizerApi.prototype.OPTION1 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 1);\n    };\n    RecognizerApi.prototype.OPTION2 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 2);\n    };\n    RecognizerApi.prototype.OPTION3 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 3);\n    };\n    RecognizerApi.prototype.OPTION4 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 4);\n    };\n    RecognizerApi.prototype.OPTION5 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 5);\n    };\n    RecognizerApi.prototype.OPTION6 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 6);\n    };\n    RecognizerApi.prototype.OPTION7 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 7);\n    };\n    RecognizerApi.prototype.OPTION8 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 8);\n    };\n    RecognizerApi.prototype.OPTION9 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 9);\n    };\n    RecognizerApi.prototype.OR = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 0);\n    };\n    RecognizerApi.prototype.OR1 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 1);\n    };\n    RecognizerApi.prototype.OR2 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 2);\n    };\n    RecognizerApi.prototype.OR3 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 3);\n    };\n    RecognizerApi.prototype.OR4 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 4);\n    };\n    RecognizerApi.prototype.OR5 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 5);\n    };\n    RecognizerApi.prototype.OR6 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 6);\n    };\n    RecognizerApi.prototype.OR7 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 7);\n    };\n    RecognizerApi.prototype.OR8 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 8);\n    };\n    RecognizerApi.prototype.OR9 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 9);\n    };\n    RecognizerApi.prototype.MANY = function (actionORMethodDef) {\n        this.manyInternal(0, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY1 = function (actionORMethodDef) {\n        this.manyInternal(1, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY2 = function (actionORMethodDef) {\n        this.manyInternal(2, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY3 = function (actionORMethodDef) {\n        this.manyInternal(3, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY4 = function (actionORMethodDef) {\n        this.manyInternal(4, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY5 = function (actionORMethodDef) {\n        this.manyInternal(5, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY6 = function (actionORMethodDef) {\n        this.manyInternal(6, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY7 = function (actionORMethodDef) {\n        this.manyInternal(7, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY8 = function (actionORMethodDef) {\n        this.manyInternal(8, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY9 = function (actionORMethodDef) {\n        this.manyInternal(9, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY_SEP = function (options) {\n        this.manySepFirstInternal(0, options);\n    };\n    RecognizerApi.prototype.MANY_SEP1 = function (options) {\n        this.manySepFirstInternal(1, options);\n    };\n    RecognizerApi.prototype.MANY_SEP2 = function (options) {\n        this.manySepFirstInternal(2, options);\n    };\n    RecognizerApi.prototype.MANY_SEP3 = function (options) {\n        this.manySepFirstInternal(3, options);\n    };\n    RecognizerApi.prototype.MANY_SEP4 = function (options) {\n        this.manySepFirstInternal(4, options);\n    };\n    RecognizerApi.prototype.MANY_SEP5 = function (options) {\n        this.manySepFirstInternal(5, options);\n    };\n    RecognizerApi.prototype.MANY_SEP6 = function (options) {\n        this.manySepFirstInternal(6, options);\n    };\n    RecognizerApi.prototype.MANY_SEP7 = function (options) {\n        this.manySepFirstInternal(7, options);\n    };\n    RecognizerApi.prototype.MANY_SEP8 = function (options) {\n        this.manySepFirstInternal(8, options);\n    };\n    RecognizerApi.prototype.MANY_SEP9 = function (options) {\n        this.manySepFirstInternal(9, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE = function (actionORMethodDef) {\n        this.atLeastOneInternal(0, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE1 = function (actionORMethodDef) {\n        return this.atLeastOneInternal(1, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE2 = function (actionORMethodDef) {\n        this.atLeastOneInternal(2, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE3 = function (actionORMethodDef) {\n        this.atLeastOneInternal(3, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE4 = function (actionORMethodDef) {\n        this.atLeastOneInternal(4, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE5 = function (actionORMethodDef) {\n        this.atLeastOneInternal(5, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE6 = function (actionORMethodDef) {\n        this.atLeastOneInternal(6, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE7 = function (actionORMethodDef) {\n        this.atLeastOneInternal(7, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE8 = function (actionORMethodDef) {\n        this.atLeastOneInternal(8, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE9 = function (actionORMethodDef) {\n        this.atLeastOneInternal(9, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP = function (options) {\n        this.atLeastOneSepFirstInternal(0, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP1 = function (options) {\n        this.atLeastOneSepFirstInternal(1, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP2 = function (options) {\n        this.atLeastOneSepFirstInternal(2, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP3 = function (options) {\n        this.atLeastOneSepFirstInternal(3, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP4 = function (options) {\n        this.atLeastOneSepFirstInternal(4, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP5 = function (options) {\n        this.atLeastOneSepFirstInternal(5, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP6 = function (options) {\n        this.atLeastOneSepFirstInternal(6, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP7 = function (options) {\n        this.atLeastOneSepFirstInternal(7, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP8 = function (options) {\n        this.atLeastOneSepFirstInternal(8, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP9 = function (options) {\n        this.atLeastOneSepFirstInternal(9, options);\n    };\n    RecognizerApi.prototype.RULE = function (name, implementation, config) {\n        if (config === void 0) { config = parser_1.DEFAULT_RULE_CONFIG; }\n        if ((0, includes_1.default)(this.definedRulesNames, name)) {\n            var errMsg = errors_public_1.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n                topLevelRule: name,\n                grammarName: this.className\n            });\n            var error = {\n                message: errMsg,\n                type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n                ruleName: name\n            };\n            this.definitionErrors.push(error);\n        }\n        this.definedRulesNames.push(name);\n        var ruleImplementation = this.defineRule(name, implementation, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    };\n    RecognizerApi.prototype.OVERRIDE_RULE = function (name, impl, config) {\n        if (config === void 0) { config = parser_1.DEFAULT_RULE_CONFIG; }\n        var ruleErrors = (0, checks_1.validateRuleIsOverridden)(name, this.definedRulesNames, this.className);\n        this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n        var ruleImplementation = this.defineRule(name, impl, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    };\n    RecognizerApi.prototype.BACKTRACK = function (grammarRule, args) {\n        return function () {\n            // save org state\n            this.isBackTrackingStack.push(1);\n            var orgState = this.saveRecogState();\n            try {\n                grammarRule.apply(this, args);\n                // if no exception was thrown we have succeed parsing the rule.\n                return true;\n            }\n            catch (e) {\n                if ((0, exceptions_public_1.isRecognitionException)(e)) {\n                    return false;\n                }\n                else {\n                    throw e;\n                }\n            }\n            finally {\n                this.reloadRecogState(orgState);\n                this.isBackTrackingStack.pop();\n            }\n        };\n    };\n    // GAST export APIs\n    RecognizerApi.prototype.getGAstProductions = function () {\n        return this.gastProductionsCache;\n    };\n    RecognizerApi.prototype.getSerializedGastProductions = function () {\n        return (0, gast_1.serializeGrammar)((0, values_1.default)(this.gastProductionsCache));\n    };\n    return RecognizerApi;\n}());\nexports.RecognizerApi = RecognizerApi;\n//# sourceMappingURL=recognizer_api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvcmVjb2duaXplcl9hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsK0JBQStCLG1CQUFPLENBQUMsNERBQWU7QUFDdEQsaUNBQWlDLG1CQUFPLENBQUMsZ0VBQWlCO0FBQzFELDBCQUEwQixtQkFBTyxDQUFDLG1HQUF5QjtBQUMzRCxlQUFlLG1CQUFPLENBQUMsaUZBQVc7QUFDbEMsc0JBQXNCLG1CQUFPLENBQUMsMkZBQXFCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyw2RkFBc0I7QUFDN0MsYUFBYSxtQkFBTyxDQUFDLDhFQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3JlY29nbml6ZXJfYXBpLmpzPzY5NTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlY29nbml6ZXJBcGkgPSB2b2lkIDA7XG52YXIgdmFsdWVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC92YWx1ZXNcIikpO1xudmFyIGluY2x1ZGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pbmNsdWRlc1wiKSk7XG52YXIgZXhjZXB0aW9uc19wdWJsaWNfMSA9IHJlcXVpcmUoXCIuLi8uLi9leGNlcHRpb25zX3B1YmxpY1wiKTtcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJcIik7XG52YXIgZXJyb3JzX3B1YmxpY18xID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc19wdWJsaWNcIik7XG52YXIgY2hlY2tzXzEgPSByZXF1aXJlKFwiLi4vLi4vZ3JhbW1hci9jaGVja3NcIik7XG52YXIgZ2FzdF8xID0gcmVxdWlyZShcIkBjaGV2cm90YWluL2dhc3RcIik7XG4vKipcbiAqIFRoaXMgdHJhaXQgaXMgcmVzcG9uc2libGUgZm9yIGltcGxlbWVudGluZyB0aGUgcHVibGljIEFQSVxuICogZm9yIGRlZmluaW5nIENoZXZyb3RhaW4gcGFyc2VycywgaS5lOlxuICogLSBDT05TVU1FXG4gKiAtIFJVTEVcbiAqIC0gT1BUSU9OXG4gKiAtIC4uLlxuICovXG52YXIgUmVjb2duaXplckFwaSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWNvZ25pemVyQXBpKCkge1xuICAgIH1cbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BQ1RJT04gPSBmdW5jdGlvbiAoaW1wbCkge1xuICAgICAgICByZXR1cm4gaW1wbC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIChpZHgsIHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIGlkeCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5zdWJydWxlID0gZnVuY3Rpb24gKGlkeCwgcnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgaWR4LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLm9wdGlvbiA9IGZ1bmN0aW9uIChpZHgsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCBpZHgpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAoaWR4LCBhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgaWR4KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLm1hbnkgPSBmdW5jdGlvbiAoaWR4LCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5tYW55SW50ZXJuYWwoaWR4LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5hdExlYXN0T25lID0gZnVuY3Rpb24gKGlkeCwgYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKGlkeCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRSA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCAwLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkNPTlNVTUUxID0gZnVuY3Rpb24gKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDEsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRTIgPSBmdW5jdGlvbiAodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgMiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5DT05TVU1FMyA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCAzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkNPTlNVTUU0ID0gZnVuY3Rpb24gKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRTUgPSBmdW5jdGlvbiAodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgNSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5DT05TVU1FNiA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCA2LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkNPTlNVTUU3ID0gZnVuY3Rpb24gKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDcsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRTggPSBmdW5jdGlvbiAodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgOCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5DT05TVU1FOSA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCA5LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEUgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgMCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5TVUJSVUxFMSA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCAxLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEUyID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuU1VCUlVMRTMgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgMywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5TVUJSVUxFNCA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCA0LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEU1ID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuU1VCUlVMRTYgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgNiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5TVUJSVUxFNyA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCA3LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEU4ID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDgsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuU1VCUlVMRTkgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgOSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT04gPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDApO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1BUSU9OMSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgMSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT04yID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCAyKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9QVElPTjMgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1BUSU9ONCA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgNCk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT041ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCA1KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9QVElPTjYgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1BUSU9ONyA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgNyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT044ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCA4KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9QVElPTjkgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1IgPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDApO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1IxID0gZnVuY3Rpb24gKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCAxKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9SMiA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgMik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUjMgPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1I0ID0gZnVuY3Rpb24gKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA0KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9SNSA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgNSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUjYgPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1I3ID0gZnVuY3Rpb24gKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA3KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9SOCA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgOCk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUjkgPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCgwLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZMSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCgxLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZMiA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCgyLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZMyA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCgzLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZNCA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg0LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZNSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg1LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZNiA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg2LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZNyA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg3LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZOCA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg4LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZOSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg5LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoMCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUDEgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDEsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWV9TRVAyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCgyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTllfU0VQMyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoMywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUDQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWV9TRVA1ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg1LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTllfU0VQNiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoNiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUDcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDcsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWV9TRVA4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg4LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTllfU0VQOSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoOSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkUgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FMSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMSwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FMiA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCgyLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkUzID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDMsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORTQgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FNSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg1LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkU2ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDYsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORTcgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNywgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FOCA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg4LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkU5ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDksIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDAsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDEgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDEsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDYgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDYsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDcsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDgsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuUlVMRSA9IGZ1bmN0aW9uIChuYW1lLCBpbXBsZW1lbnRhdGlvbiwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSBwYXJzZXJfMS5ERUZBVUxUX1JVTEVfQ09ORklHOyB9XG4gICAgICAgIGlmICgoMCwgaW5jbHVkZXNfMS5kZWZhdWx0KSh0aGlzLmRlZmluZWRSdWxlc05hbWVzLCBuYW1lKSkge1xuICAgICAgICAgICAgdmFyIGVyck1zZyA9IGVycm9yc19wdWJsaWNfMS5kZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIuYnVpbGREdXBsaWNhdGVSdWxlTmFtZUVycm9yKHtcbiAgICAgICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IG5hbWUsXG4gICAgICAgICAgICAgICAgZ3JhbW1hck5hbWU6IHRoaXMuY2xhc3NOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgdHlwZTogcGFyc2VyXzEuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUlVMRV9OQU1FLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBuYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVmaW5lZFJ1bGVzTmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgdmFyIHJ1bGVJbXBsZW1lbnRhdGlvbiA9IHRoaXMuZGVmaW5lUnVsZShuYW1lLCBpbXBsZW1lbnRhdGlvbiwgY29uZmlnKTtcbiAgICAgICAgdGhpc1tuYW1lXSA9IHJ1bGVJbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgcmV0dXJuIHJ1bGVJbXBsZW1lbnRhdGlvbjtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9WRVJSSURFX1JVTEUgPSBmdW5jdGlvbiAobmFtZSwgaW1wbCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSBwYXJzZXJfMS5ERUZBVUxUX1JVTEVfQ09ORklHOyB9XG4gICAgICAgIHZhciBydWxlRXJyb3JzID0gKDAsIGNoZWNrc18xLnZhbGlkYXRlUnVsZUlzT3ZlcnJpZGRlbikobmFtZSwgdGhpcy5kZWZpbmVkUnVsZXNOYW1lcywgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25FcnJvcnMgPSB0aGlzLmRlZmluaXRpb25FcnJvcnMuY29uY2F0KHJ1bGVFcnJvcnMpO1xuICAgICAgICB2YXIgcnVsZUltcGxlbWVudGF0aW9uID0gdGhpcy5kZWZpbmVSdWxlKG5hbWUsIGltcGwsIGNvbmZpZyk7XG4gICAgICAgIHRoaXNbbmFtZV0gPSBydWxlSW1wbGVtZW50YXRpb247XG4gICAgICAgIHJldHVybiBydWxlSW1wbGVtZW50YXRpb247XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5CQUNLVFJBQ0sgPSBmdW5jdGlvbiAoZ3JhbW1hclJ1bGUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgb3JnIHN0YXRlXG4gICAgICAgICAgICB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sucHVzaCgxKTtcbiAgICAgICAgICAgIHZhciBvcmdTdGF0ZSA9IHRoaXMuc2F2ZVJlY29nU3RhdGUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZ3JhbW1hclJ1bGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gZXhjZXB0aW9uIHdhcyB0aHJvd24gd2UgaGF2ZSBzdWNjZWVkIHBhcnNpbmcgdGhlIHJ1bGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgZXhjZXB0aW9uc19wdWJsaWNfMS5pc1JlY29nbml0aW9uRXhjZXB0aW9uKShlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVsb2FkUmVjb2dTdGF0ZShvcmdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gR0FTVCBleHBvcnQgQVBJc1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLmdldEdBc3RQcm9kdWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGU7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5nZXRTZXJpYWxpemVkR2FzdFByb2R1Y3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKDAsIGdhc3RfMS5zZXJpYWxpemVHcmFtbWFyKSgoMCwgdmFsdWVzXzEuZGVmYXVsdCkodGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY29nbml6ZXJBcGk7XG59KCkpO1xuZXhwb3J0cy5SZWNvZ25pemVyQXBpID0gUmVjb2duaXplckFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY29nbml6ZXJfYXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RecognizerEngine = void 0;\nvar isEmpty_1 = __importDefault(__webpack_require__(/*! lodash/isEmpty */ \"(ssr)/./node_modules/lodash/isEmpty.js\"));\nvar isArray_1 = __importDefault(__webpack_require__(/*! lodash/isArray */ \"(ssr)/./node_modules/lodash/isArray.js\"));\nvar flatten_1 = __importDefault(__webpack_require__(/*! lodash/flatten */ \"(ssr)/./node_modules/lodash/flatten.js\"));\nvar every_1 = __importDefault(__webpack_require__(/*! lodash/every */ \"(ssr)/./node_modules/lodash/every.js\"));\nvar uniq_1 = __importDefault(__webpack_require__(/*! lodash/uniq */ \"(ssr)/./node_modules/lodash/uniq.js\"));\nvar isObject_1 = __importDefault(__webpack_require__(/*! lodash/isObject */ \"(ssr)/./node_modules/lodash/isObject.js\"));\nvar has_1 = __importDefault(__webpack_require__(/*! lodash/has */ \"(ssr)/./node_modules/lodash/has.js\"));\nvar values_1 = __importDefault(__webpack_require__(/*! lodash/values */ \"(ssr)/./node_modules/lodash/values.js\"));\nvar reduce_1 = __importDefault(__webpack_require__(/*! lodash/reduce */ \"(ssr)/./node_modules/lodash/reduce.js\"));\nvar clone_1 = __importDefault(__webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"));\nvar keys_1 = __webpack_require__(/*! ../../grammar/keys */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/keys.js\");\nvar exceptions_public_1 = __webpack_require__(/*! ../../exceptions_public */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/exceptions_public.js\");\nvar lookahead_1 = __webpack_require__(/*! ../../grammar/lookahead */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js\");\nvar interpreter_1 = __webpack_require__(/*! ../../grammar/interpreter */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js\");\nvar parser_1 = __webpack_require__(/*! ../parser */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\");\nvar recoverable_1 = __webpack_require__(/*! ./recoverable */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js\");\nvar tokens_public_1 = __webpack_require__(/*! ../../../scan/tokens_public */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/tokens_public.js\");\nvar tokens_1 = __webpack_require__(/*! ../../../scan/tokens */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/tokens.js\");\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nvar RecognizerEngine = /** @class */ (function () {\n    function RecognizerEngine() {\n    }\n    RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n        this.className = this.constructor.name;\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;\n        this.subruleIdx = 0;\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if ((0, has_1.default)(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n                \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n                \"\\tFor Further details.\");\n        }\n        if ((0, isArray_1.default)(tokenVocabulary)) {\n            // This only checks for Token vocabularies provided as arrays.\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n            // rather than all edge cases of empty Token vocabularies.\n            if ((0, isEmpty_1.default)(tokenVocabulary)) {\n                throw Error(\"A Token Vocabulary cannot be empty.\\n\" +\n                    \"\\tNote that the first argument for the parser constructor\\n\" +\n                    \"\\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n                throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n                    \"\\tFor Further details.\");\n            }\n        }\n        if ((0, isArray_1.default)(tokenVocabulary)) {\n            this.tokensMap = (0, reduce_1.default)(tokenVocabulary, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if ((0, has_1.default)(tokenVocabulary, \"modes\") &&\n            (0, every_1.default)((0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)), tokens_1.isTokenType)) {\n            var allTokenTypes_1 = (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes));\n            var uniqueTokens = (0, uniq_1.default)(allTokenTypes_1);\n            this.tokensMap = (0, reduce_1.default)(uniqueTokens, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if ((0, isObject_1.default)(tokenVocabulary)) {\n            this.tokensMap = (0, clone_1.default)(tokenVocabulary);\n        }\n        else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" +\n                \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n        }\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n        // parsed with a clear error message (\"expecting EOF but found ...\")\n        this.tokensMap[\"EOF\"] = tokens_public_1.EOF;\n        var allTokenTypes = (0, has_1.default)(tokenVocabulary, \"modes\")\n            ? (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes))\n            : (0, values_1.default)(tokenVocabulary);\n        var noTokenCategoriesUsed = (0, every_1.default)(allTokenTypes, function (tokenConstructor) {\n            return (0, isEmpty_1.default)(tokenConstructor.categoryMatches);\n        });\n        this.tokenMatcher = noTokenCategoriesUsed\n            ? tokens_1.tokenStructuredMatcherNoCategories\n            : tokens_1.tokenStructuredMatcher;\n        // Because ES2015+ syntax should be supported for creating Token classes\n        // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n        (0, tokens_1.augmentTokenTypes)((0, values_1.default)(this.tokensMap));\n    };\n    RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n        if (this.selfAnalysisDone) {\n            throw Error(\"Grammar rule <\".concat(ruleName, \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\") +\n                \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n        }\n        var resyncEnabled = (0, has_1.default)(config, \"resyncEnabled\")\n            ? config.resyncEnabled // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;\n        var recoveryValueFunc = (0, has_1.default)(config, \"recoveryValueFunc\")\n            ? config.recoveryValueFunc // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;\n        // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n        var shortName = this.ruleShortNameIdx << (keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX);\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        var invokeRuleWithTry;\n        // Micro optimization, only check the condition **once** on rule definition\n        // instead of **every single** rule invocation.\n        if (this.outputCst === true) {\n            invokeRuleWithTry = function invokeRuleWithTry() {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    impl.apply(this, args);\n                    var cst = this.CST_STACK[this.CST_STACK.length - 1];\n                    this.cstPostRule(cst);\n                    return cst;\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        else {\n            invokeRuleWithTry = function invokeRuleWithTryCst() {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    return impl.apply(this, args);\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        var wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName: ruleName, originalGrammarAction: impl });\n        return wrappedGrammarRule;\n    };\n    RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n        var isFirstInvokedRule = this.RULE_STACK.length === 1;\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\n        // reSync with EOF and just output some INVALID ParseTree\n        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n        // path is really the most valid one\n        var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n        if ((0, exceptions_public_1.isRecognitionException)(e)) {\n            var recogError = e;\n            if (reSyncEnabled) {\n                var reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    }\n                    else {\n                        return recoveryValueFunc(e);\n                    }\n                }\n                else {\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    // to be handled Further up the call stack\n                    throw recogError;\n                }\n            }\n            else if (isFirstInvokedRule) {\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n                this.moveToTerminatedState();\n                // the parser should never throw one of its own errors outside its flow.\n                // even if error recovery is disabled\n                return recoveryValueFunc(e);\n            }\n            else {\n                // to be recovered Further up the call stack\n                throw recogError;\n            }\n        }\n        else {\n            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n            throw e;\n        }\n    };\n    // Implementation of parsing DSL\n    RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n        var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    };\n    RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            var predicate_1 = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate_1 !== undefined) {\n                var orgLookaheadFunction_1 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return predicate_1.call(_this) && orgLookaheadFunction_1.call(_this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n        }\n        return undefined;\n    };\n    RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);\n        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    };\n    RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            var predicate_2 = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate_2 !== undefined) {\n                var orgLookaheadFunction_2 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return predicate_2.call(_this) && orgLookaheadFunction_2.call(_this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            var notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true &&\n                notStuck === true) {\n                notStuck = this.doSingleRepetition(action);\n            }\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        }\n        // note that while it may seem that this can cause an error because by using a recursive call to\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            ;\n            action.call(this);\n            //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n            //  because it is only needed in error recovery scenarios.\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                interpreter_1.NextTerminalAfterAtLeastOneSepWalker\n            ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n        }\n    };\n    RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    };\n    RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookaheadFunction = this.getLaFuncFromCache(key);\n        var action;\n        if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            var predicate_3 = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate_3 !== undefined) {\n                var orgLookaheadFunction_3 = lookaheadFunction;\n                lookaheadFunction = function () {\n                    return predicate_3.call(_this) && orgLookaheadFunction_3.call(_this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        var notStuck = true;\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, keys_1.MANY_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManyWalker, \n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    };\n    RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLaFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                interpreter_1.NextTerminalAfterManySepWalker\n            ], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);\n        }\n    };\n    RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while (separatorLookAheadFunc()) {\n            // note that this CONSUME will never enter recovery because\n            // the separatorLookAheadFunc checks that the separator really does exist.\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        // we can only arrive to this function after an error\n        // has occurred (hence the name 'second') so the following\n        // IF will always be entered, its possible to remove it...\n        // however it is kept to avoid confusion and be consistent.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        /* istanbul ignore else */\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker\n        ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n    };\n    RecognizerEngine.prototype.doSingleRepetition = function (action) {\n        var beforeIteration = this.getLexerPosition();\n        action.call(this);\n        var afterIteration = this.getLexerPosition();\n        // This boolean will indicate if this repetition progressed\n        // or if we are \"stuck\" (potential infinite loop in the repetition).\n        return afterIteration > beforeIteration;\n    };\n    RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);\n        var alts = (0, isArray_1.default)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n        var laFunc = this.getLaFuncFromCache(laKey);\n        var altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== undefined) {\n            var chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    };\n    RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            var firstRedundantTok = this.LA(1);\n            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName()\n            });\n            this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));\n        }\n    };\n    RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n        var ruleResult;\n        try {\n            var args = options !== undefined ? options.ARGS : undefined;\n            this.subruleIdx = idx;\n            ruleResult = ruleToCall.apply(this, args);\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleToCall.ruleName);\n            return ruleResult;\n        }\n        catch (e) {\n            throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    };\n    RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n        if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== undefined) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    };\n    RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n        var consumedToken;\n        try {\n            var nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            }\n            else {\n                this.consumeInternalError(tokType, nextToken, options);\n            }\n        }\n        catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\n            ? options.LABEL\n            : tokType.name, consumedToken);\n        return consumedToken;\n    };\n    RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n        var msg;\n        var previousToken = this.LA(0);\n        if (options !== undefined && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n        }\n        else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: tokType,\n                actual: nextToken,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName()\n            });\n        }\n        throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));\n    };\n    RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\n        if (this.recoveryEnabled &&\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n            eFromConsumption.name === \"MismatchedTokenException\" &&\n            !this.isBackTracking()) {\n            var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            }\n            catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {\n                    // failed in RuleRecovery.\n                    // throw the original error in order to trigger reSync error recovery\n                    throw eFromConsumption;\n                }\n                else {\n                    throw eFromInRuleRecovery;\n                }\n            }\n        }\n        else {\n            throw eFromConsumption;\n        }\n    };\n    RecognizerEngine.prototype.saveRecogState = function () {\n        // errors is a getter which will clone the errors array\n        var savedErrors = this.errors;\n        var savedRuleStack = (0, clone_1.default)(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK\n        };\n    };\n    RecognizerEngine.prototype.reloadRecogState = function (newState) {\n        this.errors = newState.errors;\n        this.importLexerState(newState.lexerState);\n        this.RULE_STACK = newState.RULE_STACK;\n    };\n    RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        // NOOP when cst is disabled\n        this.cstInvocationStateUpdate(fullName);\n    };\n    RecognizerEngine.prototype.isBackTracking = function () {\n        return this.isBackTrackingStack.length !== 0;\n    };\n    RecognizerEngine.prototype.getCurrRuleFullName = function () {\n        var shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.isAtEndOfInput = function () {\n        return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);\n    };\n    RecognizerEngine.prototype.reset = function () {\n        this.resetLexerState();\n        this.subruleIdx = 0;\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        // TODO: extract a specific reset for TreeBuilder trait\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    };\n    return RecognizerEngine;\n}());\nexports.RecognizerEngine = RecognizerEngine;\n//# sourceMappingURL=recognizer_engine.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvcmVjb2duaXplcl9lbmdpbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsOEJBQThCLG1CQUFPLENBQUMsMERBQWM7QUFDcEQsNkJBQTZCLG1CQUFPLENBQUMsd0RBQWE7QUFDbEQsaUNBQWlDLG1CQUFPLENBQUMsZ0VBQWlCO0FBQzFELDRCQUE0QixtQkFBTyxDQUFDLHNEQUFZO0FBQ2hELCtCQUErQixtQkFBTyxDQUFDLDREQUFlO0FBQ3RELCtCQUErQixtQkFBTyxDQUFDLDREQUFlO0FBQ3RELDhCQUE4QixtQkFBTyxDQUFDLDBEQUFjO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQyx5RkFBb0I7QUFDekMsMEJBQTBCLG1CQUFPLENBQUMsbUdBQXlCO0FBQzNELGtCQUFrQixtQkFBTyxDQUFDLG1HQUF5QjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyx1R0FBMkI7QUFDdkQsZUFBZSxtQkFBTyxDQUFDLGlGQUFXO0FBQ2xDLG9CQUFvQixtQkFBTyxDQUFDLGlHQUFlO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLGtHQUE2QjtBQUMzRCxlQUFlLG1CQUFPLENBQUMsb0ZBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGlEQUFpRDtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9yZWNvZ25pemVyX2VuZ2luZS5qcz9jYmY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWNvZ25pemVyRW5naW5lID0gdm9pZCAwO1xudmFyIGlzRW1wdHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRW1wdHlcIikpO1xudmFyIGlzQXJyYXlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIikpO1xudmFyIGZsYXR0ZW5fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZsYXR0ZW5cIikpO1xudmFyIGV2ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9ldmVyeVwiKSk7XG52YXIgdW5pcV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvdW5pcVwiKSk7XG52YXIgaXNPYmplY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzT2JqZWN0XCIpKTtcbnZhciBoYXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2hhc1wiKSk7XG52YXIgdmFsdWVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC92YWx1ZXNcIikpO1xudmFyIHJlZHVjZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvcmVkdWNlXCIpKTtcbnZhciBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIikpO1xudmFyIGtleXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmFtbWFyL2tleXNcIik7XG52YXIgZXhjZXB0aW9uc19wdWJsaWNfMSA9IHJlcXVpcmUoXCIuLi8uLi9leGNlcHRpb25zX3B1YmxpY1wiKTtcbnZhciBsb29rYWhlYWRfMSA9IHJlcXVpcmUoXCIuLi8uLi9ncmFtbWFyL2xvb2thaGVhZFwiKTtcbnZhciBpbnRlcnByZXRlcl8xID0gcmVxdWlyZShcIi4uLy4uL2dyYW1tYXIvaW50ZXJwcmV0ZXJcIik7XG52YXIgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vcGFyc2VyXCIpO1xudmFyIHJlY292ZXJhYmxlXzEgPSByZXF1aXJlKFwiLi9yZWNvdmVyYWJsZVwiKTtcbnZhciB0b2tlbnNfcHVibGljXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vc2Nhbi90b2tlbnNfcHVibGljXCIpO1xudmFyIHRva2Vuc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3NjYW4vdG9rZW5zXCIpO1xuLyoqXG4gKiBUaGlzIHRyYWl0IGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgcnVudGltZSBwYXJzaW5nIGVuZ2luZVxuICogVXNlZCBieSB0aGUgb2ZmaWNpYWwgQVBJIChyZWNvZ25pemVyX2FwaS50cylcbiAqL1xudmFyIFJlY29nbml6ZXJFbmdpbmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjb2duaXplckVuZ2luZSgpIHtcbiAgICB9XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuaW5pdFJlY29nbml6ZXJFbmdpbmUgPSBmdW5jdGlvbiAodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIC8vIFRPRE86IHdvdWxkIHVzaW5nIGFuIEVTNiBNYXAgb3IgcGxhaW4gb2JqZWN0IGJlIGZhc3RlciAoQ1NUIGJ1aWxkaW5nIHNjZW5hcmlvKVxuICAgICAgICB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGwgPSB7fTtcbiAgICAgICAgdGhpcy5mdWxsUnVsZU5hbWVUb1Nob3J0ID0ge307XG4gICAgICAgIHRoaXMucnVsZVNob3J0TmFtZUlkeCA9IDI1NjtcbiAgICAgICAgdGhpcy50b2tlbk1hdGNoZXIgPSB0b2tlbnNfMS50b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzO1xuICAgICAgICB0aGlzLnN1YnJ1bGVJZHggPSAwO1xuICAgICAgICB0aGlzLmRlZmluZWRSdWxlc05hbWVzID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zTWFwID0ge307XG4gICAgICAgIHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLlJVTEVfU1RBQ0sgPSBbXTtcbiAgICAgICAgdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sgPSBbXTtcbiAgICAgICAgdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSA9IHt9O1xuICAgICAgICBpZiAoKDAsIGhhc18xLmRlZmF1bHQpKGNvbmZpZywgXCJzZXJpYWxpemVkR3JhbW1hclwiKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgUGFyc2VyJ3MgY29uZmlndXJhdGlvbiBjYW4gbm8gbG9uZ2VyIGNvbnRhaW4gYSA8c2VyaWFsaXplZEdyYW1tYXI+IHByb3BlcnR5LlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvY2hhbmdlcy9CUkVBS0lOR19DSEFOR0VTLmh0bWwjXzYtMC0wXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0Rm9yIEZ1cnRoZXIgZGV0YWlscy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpc0FycmF5XzEuZGVmYXVsdCkodG9rZW5Wb2NhYnVsYXJ5KSkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmx5IGNoZWNrcyBmb3IgVG9rZW4gdm9jYWJ1bGFyaWVzIHByb3ZpZGVkIGFzIGFycmF5cy5cbiAgICAgICAgICAgIC8vIFRoYXQgaXMgZ29vZCBlbm91Z2ggYmVjYXVzZSB0aGUgbWFpbiBvYmplY3RpdmUgaXMgdG8gZGV0ZWN0IHVzZXJzIG9mIHByZS1WNC4wIEFQSXNcbiAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIGFsbCBlZGdlIGNhc2VzIG9mIGVtcHR5IFRva2VuIHZvY2FidWxhcmllcy5cbiAgICAgICAgICAgIGlmICgoMCwgaXNFbXB0eV8xLmRlZmF1bHQpKHRva2VuVm9jYWJ1bGFyeSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkEgVG9rZW4gVm9jYWJ1bGFyeSBjYW5ub3QgYmUgZW1wdHkuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdE5vdGUgdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQgZm9yIHRoZSBwYXJzZXIgY29uc3RydWN0b3JcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0aXMgbm8gbG9uZ2VyIGEgVG9rZW4gdmVjdG9yIChzaW5jZSB2NC4wKS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuVm9jYWJ1bGFyeVswXS5zdGFydE9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIFBhcnNlciBjb25zdHJ1Y3RvciBubyBsb25nZXIgYWNjZXB0cyBhIHRva2VuIHZlY3RvciBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvY2hhbmdlcy9CUkVBS0lOR19DSEFOR0VTLmh0bWwjXzQtMC0wXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdEZvciBGdXJ0aGVyIGRldGFpbHMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaXNBcnJheV8xLmRlZmF1bHQpKHRva2VuVm9jYWJ1bGFyeSkpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5zTWFwID0gKDAsIHJlZHVjZV8xLmRlZmF1bHQpKHRva2VuVm9jYWJ1bGFyeSwgZnVuY3Rpb24gKGFjYywgdG9rVHlwZSkge1xuICAgICAgICAgICAgICAgIGFjY1t0b2tUeXBlLm5hbWVdID0gdG9rVHlwZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBoYXNfMS5kZWZhdWx0KSh0b2tlblZvY2FidWxhcnksIFwibW9kZXNcIikgJiZcbiAgICAgICAgICAgICgwLCBldmVyeV8xLmRlZmF1bHQpKCgwLCBmbGF0dGVuXzEuZGVmYXVsdCkoKDAsIHZhbHVlc18xLmRlZmF1bHQpKHRva2VuVm9jYWJ1bGFyeS5tb2RlcykpLCB0b2tlbnNfMS5pc1Rva2VuVHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBhbGxUb2tlblR5cGVzXzEgPSAoMCwgZmxhdHRlbl8xLmRlZmF1bHQpKCgwLCB2YWx1ZXNfMS5kZWZhdWx0KSh0b2tlblZvY2FidWxhcnkubW9kZXMpKTtcbiAgICAgICAgICAgIHZhciB1bmlxdWVUb2tlbnMgPSAoMCwgdW5pcV8xLmRlZmF1bHQpKGFsbFRva2VuVHlwZXNfMSk7XG4gICAgICAgICAgICB0aGlzLnRva2Vuc01hcCA9ICgwLCByZWR1Y2VfMS5kZWZhdWx0KSh1bmlxdWVUb2tlbnMsIGZ1bmN0aW9uIChhY2MsIHRva1R5cGUpIHtcbiAgICAgICAgICAgICAgICBhY2NbdG9rVHlwZS5uYW1lXSA9IHRva1R5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgaXNPYmplY3RfMS5kZWZhdWx0KSh0b2tlblZvY2FidWxhcnkpKSB7XG4gICAgICAgICAgICB0aGlzLnRva2Vuc01hcCA9ICgwLCBjbG9uZV8xLmRlZmF1bHQpKHRva2VuVm9jYWJ1bGFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCI8dG9rZW5zRGljdGlvbmFyeT4gYXJndW1lbnQgbXVzdCBiZSBBbiBBcnJheSBvZiBUb2tlbiBjb25zdHJ1Y3RvcnMsXCIgK1xuICAgICAgICAgICAgICAgIFwiIEEgZGljdGlvbmFyeSBvZiBUb2tlbiBjb25zdHJ1Y3RvcnMgb3IgYW4gSU11bHRpTW9kZUxleGVyRGVmaW5pdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbHdheXMgYWRkIEVPRiB0byB0aGUgdG9rZW5OYW1lcyAtPiBjb25zdHJ1Y3RvcnMgbWFwLiBpdCBpcyB1c2VmdWwgdG8gYXNzdXJlIGFsbCB0aGUgaW5wdXQgaGFzIGJlZW5cbiAgICAgICAgLy8gcGFyc2VkIHdpdGggYSBjbGVhciBlcnJvciBtZXNzYWdlIChcImV4cGVjdGluZyBFT0YgYnV0IGZvdW5kIC4uLlwiKVxuICAgICAgICB0aGlzLnRva2Vuc01hcFtcIkVPRlwiXSA9IHRva2Vuc19wdWJsaWNfMS5FT0Y7XG4gICAgICAgIHZhciBhbGxUb2tlblR5cGVzID0gKDAsIGhhc18xLmRlZmF1bHQpKHRva2VuVm9jYWJ1bGFyeSwgXCJtb2Rlc1wiKVxuICAgICAgICAgICAgPyAoMCwgZmxhdHRlbl8xLmRlZmF1bHQpKCgwLCB2YWx1ZXNfMS5kZWZhdWx0KSh0b2tlblZvY2FidWxhcnkubW9kZXMpKVxuICAgICAgICAgICAgOiAoMCwgdmFsdWVzXzEuZGVmYXVsdCkodG9rZW5Wb2NhYnVsYXJ5KTtcbiAgICAgICAgdmFyIG5vVG9rZW5DYXRlZ29yaWVzVXNlZCA9ICgwLCBldmVyeV8xLmRlZmF1bHQpKGFsbFRva2VuVHlwZXMsIGZ1bmN0aW9uICh0b2tlbkNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGlzRW1wdHlfMS5kZWZhdWx0KSh0b2tlbkNvbnN0cnVjdG9yLmNhdGVnb3J5TWF0Y2hlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRva2VuTWF0Y2hlciA9IG5vVG9rZW5DYXRlZ29yaWVzVXNlZFxuICAgICAgICAgICAgPyB0b2tlbnNfMS50b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzXG4gICAgICAgICAgICA6IHRva2Vuc18xLnRva2VuU3RydWN0dXJlZE1hdGNoZXI7XG4gICAgICAgIC8vIEJlY2F1c2UgRVMyMDE1KyBzeW50YXggc2hvdWxkIGJlIHN1cHBvcnRlZCBmb3IgY3JlYXRpbmcgVG9rZW4gY2xhc3Nlc1xuICAgICAgICAvLyBXZSBjYW5ub3QgYXNzdW1lIHRoYXQgdGhlIFRva2VuIGNsYXNzZXMgd2VyZSBjcmVhdGVkIHVzaW5nIHRoZSBcImV4dGVuZFRva2VuXCIgdXRpbGl0aWVzXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBtdXN0IGF1Z21lbnQgdGhlIFRva2VuIGNsYXNzZXMgYm90aCBvbiBMZXhlciBpbml0aWFsaXphdGlvbiBhbmQgb24gUGFyc2VyIGluaXRpYWxpemF0aW9uXG4gICAgICAgICgwLCB0b2tlbnNfMS5hdWdtZW50VG9rZW5UeXBlcykoKDAsIHZhbHVlc18xLmRlZmF1bHQpKHRoaXMudG9rZW5zTWFwKSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5kZWZpbmVSdWxlID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBpbXBsLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZkFuYWx5c2lzRG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJHcmFtbWFyIHJ1bGUgPFwiLmNvbmNhdChydWxlTmFtZSwgXCI+IG1heSBub3QgYmUgZGVmaW5lZCBhZnRlciB0aGUgJ3BlcmZvcm1TZWxmQW5hbHlzaXMnIG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQnXFxuXCIpICtcbiAgICAgICAgICAgICAgICBcIk1ha2Ugc3VyZSB0aGF0IGFsbCBncmFtbWFyIHJ1bGUgZGVmaW5pdGlvbnMgYXJlIGRvbmUgYmVmb3JlICdwZXJmb3JtU2VsZkFuYWx5c2lzJyBpcyBjYWxsZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN5bmNFbmFibGVkID0gKDAsIGhhc18xLmRlZmF1bHQpKGNvbmZpZywgXCJyZXN5bmNFbmFibGVkXCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5yZXN5bmNFbmFibGVkIC8vIGFzc3VtZXMgZW5kIHVzZXIgcHJvdmlkZXMgdGhlIGNvcnJlY3QgY29uZmlnIHZhbHVlL3R5cGVcbiAgICAgICAgICAgIDogcGFyc2VyXzEuREVGQVVMVF9SVUxFX0NPTkZJRy5yZXN5bmNFbmFibGVkO1xuICAgICAgICB2YXIgcmVjb3ZlcnlWYWx1ZUZ1bmMgPSAoMCwgaGFzXzEuZGVmYXVsdCkoY29uZmlnLCBcInJlY292ZXJ5VmFsdWVGdW5jXCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5yZWNvdmVyeVZhbHVlRnVuYyAvLyBhc3N1bWVzIGVuZCB1c2VyIHByb3ZpZGVzIHRoZSBjb3JyZWN0IGNvbmZpZyB2YWx1ZS90eXBlXG4gICAgICAgICAgICA6IHBhcnNlcl8xLkRFRkFVTFRfUlVMRV9DT05GSUcucmVjb3ZlcnlWYWx1ZUZ1bmM7XG4gICAgICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogVXNlIHNtYWxsIGludGVnZXJzIGFzIGtleXMgZm9yIHRoZSBsb25nZXIgaHVtYW4gcmVhZGFibGUgXCJmdWxsXCIgcnVsZSBuYW1lcy5cbiAgICAgICAgLy8gdGhpcyBncmVhdGx5IGltcHJvdmVzIE1hcCBhY2Nlc3MgdGltZSAoYXMgbXVjaCBhcyA4JSBmb3Igc29tZSBwZXJmb3JtYW5jZSBiZW5jaG1hcmtzKS5cbiAgICAgICAgdmFyIHNob3J0TmFtZSA9IHRoaXMucnVsZVNob3J0TmFtZUlkeCA8PCAoa2V5c18xLkJJVFNfRk9SX01FVEhPRF9UWVBFICsga2V5c18xLkJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYKTtcbiAgICAgICAgdGhpcy5ydWxlU2hvcnROYW1lSWR4Kys7XG4gICAgICAgIHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbFtzaG9ydE5hbWVdID0gcnVsZU5hbWU7XG4gICAgICAgIHRoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydFtydWxlTmFtZV0gPSBzaG9ydE5hbWU7XG4gICAgICAgIHZhciBpbnZva2VSdWxlV2l0aFRyeTtcbiAgICAgICAgLy8gTWljcm8gb3B0aW1pemF0aW9uLCBvbmx5IGNoZWNrIHRoZSBjb25kaXRpb24gKipvbmNlKiogb24gcnVsZSBkZWZpbml0aW9uXG4gICAgICAgIC8vIGluc3RlYWQgb2YgKipldmVyeSBzaW5nbGUqKiBydWxlIGludm9jYXRpb24uXG4gICAgICAgIGlmICh0aGlzLm91dHB1dENzdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaW52b2tlUnVsZVdpdGhUcnkgPSBmdW5jdGlvbiBpbnZva2VSdWxlV2l0aFRyeSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydWxlSW52b2NhdGlvblN0YXRlVXBkYXRlKHNob3J0TmFtZSwgcnVsZU5hbWUsIHRoaXMuc3VicnVsZUlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGltcGwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjc3QgPSB0aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZShjc3QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnZva2VSdWxlQ2F0Y2goZSwgcmVzeW5jRW5hYmxlZCwgcmVjb3ZlcnlWYWx1ZUZ1bmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydWxlRmluYWxseVN0YXRlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGludm9rZVJ1bGVXaXRoVHJ5ID0gZnVuY3Rpb24gaW52b2tlUnVsZVdpdGhUcnlDc3QoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZShzaG9ydE5hbWUsIHJ1bGVOYW1lLCB0aGlzLnN1YnJ1bGVJZHgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1wbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW52b2tlUnVsZUNhdGNoKGUsIHJlc3luY0VuYWJsZWQsIHJlY292ZXJ5VmFsdWVGdW5jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVsZUZpbmFsbHlTdGF0ZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBwZWRHcmFtbWFyUnVsZSA9IE9iamVjdC5hc3NpZ24oaW52b2tlUnVsZVdpdGhUcnksIHsgcnVsZU5hbWU6IHJ1bGVOYW1lLCBvcmlnaW5hbEdyYW1tYXJBY3Rpb246IGltcGwgfSk7XG4gICAgICAgIHJldHVybiB3cmFwcGVkR3JhbW1hclJ1bGU7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5pbnZva2VSdWxlQ2F0Y2ggPSBmdW5jdGlvbiAoZSwgcmVzeW5jRW5hYmxlZENvbmZpZywgcmVjb3ZlcnlWYWx1ZUZ1bmMpIHtcbiAgICAgICAgdmFyIGlzRmlyc3RJbnZva2VkUnVsZSA9IHRoaXMuUlVMRV9TVEFDSy5sZW5ndGggPT09IDE7XG4gICAgICAgIC8vIG5vdGUgdGhlIHJlU3luYyBpcyBhbHdheXMgZW5hYmxlZCBmb3IgdGhlIGZpcnN0IHJ1bGUgaW52b2NhdGlvbiwgYmVjYXVzZSB3ZSBtdXN0IGFsd2F5cyBiZSBhYmxlIHRvXG4gICAgICAgIC8vIHJlU3luYyB3aXRoIEVPRiBhbmQganVzdCBvdXRwdXQgc29tZSBJTlZBTElEIFBhcnNlVHJlZVxuICAgICAgICAvLyBkdXJpbmcgYmFja3RyYWNraW5nIHJlU3luYyByZWNvdmVyeSBpcyBkaXNhYmxlZCwgb3RoZXJ3aXNlIHdlIGNhbid0IGJlIGNlcnRhaW4gdGhlIGJhY2t0cmFja2luZ1xuICAgICAgICAvLyBwYXRoIGlzIHJlYWxseSB0aGUgbW9zdCB2YWxpZCBvbmVcbiAgICAgICAgdmFyIHJlU3luY0VuYWJsZWQgPSByZXN5bmNFbmFibGVkQ29uZmlnICYmICF0aGlzLmlzQmFja1RyYWNraW5nKCkgJiYgdGhpcy5yZWNvdmVyeUVuYWJsZWQ7XG4gICAgICAgIGlmICgoMCwgZXhjZXB0aW9uc19wdWJsaWNfMS5pc1JlY29nbml0aW9uRXhjZXB0aW9uKShlKSkge1xuICAgICAgICAgICAgdmFyIHJlY29nRXJyb3IgPSBlO1xuICAgICAgICAgICAgaWYgKHJlU3luY0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVTeW5jVG9rVHlwZSA9IHRoaXMuZmluZFJlU3luY1Rva2VuVHlwZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW5DdXJyZW50UnVsZVJlU3luY1NldChyZVN5bmNUb2tUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICByZWNvZ0Vycm9yLnJlc3luY2VkVG9rZW5zID0gdGhpcy5yZVN5bmNUbyhyZVN5bmNUb2tUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0Q3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbENzdFJlc3VsdCA9IHRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbENzdFJlc3VsdC5yZWNvdmVyZWROb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsQ3N0UmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY292ZXJ5VmFsdWVGdW5jKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRDc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsQ3N0UmVzdWx0ID0gdGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsQ3N0UmVzdWx0LnJlY292ZXJlZE5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb2dFcnJvci5wYXJ0aWFsQ3N0UmVzdWx0ID0gcGFydGlhbENzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB0byBiZSBoYW5kbGVkIEZ1cnRoZXIgdXAgdGhlIGNhbGwgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVjb2dFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZpcnN0SW52b2tlZFJ1bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgYSBSZWR1bmRhbnQgaW5wdXQgZXJyb3Igd2lsbCBiZSBjcmVhdGVkIGFzIHdlbGwgYW5kIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGlzIGlzIGluZGVlZCB0aGUgY2FzZVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVRvVGVybWluYXRlZFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhcnNlciBzaG91bGQgbmV2ZXIgdGhyb3cgb25lIG9mIGl0cyBvd24gZXJyb3JzIG91dHNpZGUgaXRzIGZsb3cuXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpZiBlcnJvciByZWNvdmVyeSBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgICAgIHJldHVybiByZWNvdmVyeVZhbHVlRnVuYyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRvIGJlIHJlY292ZXJlZCBGdXJ0aGVyIHVwIHRoZSBjYWxsIHN0YWNrXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVjb2dFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNvbWUgb3RoZXIgRXJyb3IgdHlwZSB3aGljaCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGUgKGZvciBleGFtcGxlIGEgYnVpbHQgaW4gSmF2YVNjcmlwdCBFcnJvcilcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEltcGxlbWVudGF0aW9uIG9mIHBhcnNpbmcgRFNMXG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUub3B0aW9uSW50ZXJuYWwgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGtleXNfMS5PUFRJT05fSURYLCBvY2N1cnJlbmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWxMb2dpYyhhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSwga2V5KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLm9wdGlvbkludGVybmFsTG9naWMgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYsIG9jY3VycmVuY2UsIGtleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbG9va0FoZWFkRnVuYyA9IHRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKGtleSk7XG4gICAgICAgIHZhciBhY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uT1JNZXRob2REZWYgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uT1JNZXRob2REZWYuREVGO1xuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZV8xID0gYWN0aW9uT1JNZXRob2REZWYuR0FURTtcbiAgICAgICAgICAgIC8vIHByZWRpY2F0ZSBwcmVzZW50XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlXzEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBvcmdMb29rYWhlYWRGdW5jdGlvbl8xID0gbG9va0FoZWFkRnVuYztcbiAgICAgICAgICAgICAgICBsb29rQWhlYWRGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlXzEuY2FsbChfdGhpcykgJiYgb3JnTG9va2FoZWFkRnVuY3Rpb25fMS5jYWxsKF90aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uT1JNZXRob2REZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZEZ1bmMuY2FsbCh0aGlzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5hdExlYXN0T25lSW50ZXJuYWwgPSBmdW5jdGlvbiAocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGtleXNfMS5BVF9MRUFTVF9PTkVfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZiwgbGFLZXkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuYXRMZWFzdE9uZUludGVybmFsTG9naWMgPSBmdW5jdGlvbiAocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvb2tBaGVhZEZ1bmMgPSB0aGlzLmdldExhRnVuY0Zyb21DYWNoZShrZXkpO1xuICAgICAgICB2YXIgYWN0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbk9STWV0aG9kRGVmICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbk9STWV0aG9kRGVmLkRFRjtcbiAgICAgICAgICAgIHZhciBwcmVkaWNhdGVfMiA9IGFjdGlvbk9STWV0aG9kRGVmLkdBVEU7XG4gICAgICAgICAgICAvLyBwcmVkaWNhdGUgcHJlc2VudFxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZV8yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JnTG9va2FoZWFkRnVuY3Rpb25fMiA9IGxvb2tBaGVhZEZ1bmM7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZV8yLmNhbGwoX3RoaXMpICYmIG9yZ0xvb2thaGVhZEZ1bmN0aW9uXzIuY2FsbChfdGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbk9STWV0aG9kRGVmO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb29rQWhlYWRGdW5jLmNhbGwodGhpcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBub3RTdHVjayA9IHRoaXMuZG9TaW5nbGVSZXBldGl0aW9uKGFjdGlvbik7XG4gICAgICAgICAgICB3aGlsZSAobG9va0FoZWFkRnVuYy5jYWxsKHRoaXMpID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgbm90U3R1Y2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBub3RTdHVjayA9IHRoaXMuZG9TaW5nbGVSZXBldGl0aW9uKGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlRWFybHlFeGl0RXhjZXB0aW9uKHByb2RPY2N1cnJlbmNlLCBsb29rYWhlYWRfMS5QUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlksIGFjdGlvbk9STWV0aG9kRGVmLkVSUl9NU0cpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdGUgdGhhdCB3aGlsZSBpdCBtYXkgc2VlbSB0aGF0IHRoaXMgY2FuIGNhdXNlIGFuIGVycm9yIGJlY2F1c2UgYnkgdXNpbmcgYSByZWN1cnNpdmUgY2FsbCB0b1xuICAgICAgICAvLyBBVF9MRUFTVF9PTkUgd2UgY2hhbmdlIHRoZSBncmFtbWFyIHRvIEFUX0xFQVNUX1RXTywgQVRfTEVBU1RfVEhSRUUgLi4uICwgdGhlIHBvc3NpYmxlIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgIC8vIGZyb20gdGhlIHRyeUluUmVwZXRpdGlvblJlY292ZXJ5KC4uLikgd2lsbCBvbmx5IGhhcHBlbiBJRkYgdGhlcmUgcmVhbGx5IGFyZSBUV08vVEhSRUUvLi4uLiBpdGVtcy5cbiAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiIHdpbGwgYmUgZGVmaW5lZCBhcyBOT09QIHVubGVzcyByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgIHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMuYXRMZWFzdE9uZUludGVybmFsLCBbcHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmXSwgbG9va0FoZWFkRnVuYywga2V5c18xLkFUX0xFQVNUX09ORV9JRFgsIHByb2RPY2N1cnJlbmNlLCBpbnRlcnByZXRlcl8xLk5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlcik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGFLZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChrZXlzXzEuQVRfTEVBU1RfT05FX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zLCBsYUtleSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbExvZ2ljID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFjdGlvbiA9IG9wdGlvbnMuREVGO1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gb3B0aW9ucy5TRVA7XG4gICAgICAgIHZhciBmaXJzdEl0ZXJhdGlvbkxvb2thaGVhZEZ1bmMgPSB0aGlzLmdldExhRnVuY0Zyb21DYWNoZShrZXkpO1xuICAgICAgICAvLyAxc3QgaXRlcmF0aW9uXG4gICAgICAgIGlmIChmaXJzdEl0ZXJhdGlvbkxvb2thaGVhZEZ1bmMuY2FsbCh0aGlzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvLyAgVE9ETzogT3B0aW1pemF0aW9uIGNhbiBtb3ZlIHRoaXMgZnVuY3Rpb24gY29uc3RydWN0aW9uIGludG8gXCJhdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnlcIlxuICAgICAgICAgICAgLy8gIGJlY2F1c2UgaXQgaXMgb25seSBuZWVkZWQgaW4gZXJyb3IgcmVjb3Zlcnkgc2NlbmFyaW9zLlxuICAgICAgICAgICAgdmFyIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRva2VuTWF0Y2hlcihfdGhpcy5MQSgxKSwgc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyAybmQuLm50aCBpdGVyYXRpb25zXG4gICAgICAgICAgICB3aGlsZSAodGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSwgc2VwYXJhdG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGlzIENPTlNVTUUgd2lsbCBuZXZlciBlbnRlciByZWNvdmVyeSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMgY2hlY2tzIHRoYXQgdGhlIHNlcGFyYXRvciByZWFsbHkgZG9lcyBleGlzdC5cbiAgICAgICAgICAgICAgICB0aGlzLkNPTlNVTUUoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogXCJhdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnlcIiB3aWxsIGJlIGRlZmluZWQgYXMgTk9PUCB1bmxlc3MgcmVjb3ZlcnkgaXMgZW5hYmxlZFxuICAgICAgICAgICAgdGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5yZXBldGl0aW9uU2VwU2Vjb25kSW50ZXJuYWwsIFtcbiAgICAgICAgICAgICAgICBwcm9kT2NjdXJyZW5jZSxcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yTG9va0FoZWFkRnVuYyxcbiAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJfMS5OZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXJcbiAgICAgICAgICAgIF0sIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsIGtleXNfMS5BVF9MRUFTVF9PTkVfU0VQX0lEWCwgcHJvZE9jY3VycmVuY2UsIGludGVycHJldGVyXzEuTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2VFYXJseUV4aXRFeGNlcHRpb24ocHJvZE9jY3VycmVuY2UsIGxvb2thaGVhZF8xLlBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUiwgb3B0aW9ucy5FUlJfTVNHKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUubWFueUludGVybmFsID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB2YXIgbGFLZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChrZXlzXzEuTUFOWV9JRFgsIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFueUludGVybmFsTG9naWMocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmLCBsYUtleSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5tYW55SW50ZXJuYWxMb2dpYyA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWYsIGtleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbG9va2FoZWFkRnVuY3Rpb24gPSB0aGlzLmdldExhRnVuY0Zyb21DYWNoZShrZXkpO1xuICAgICAgICB2YXIgYWN0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbk9STWV0aG9kRGVmICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbk9STWV0aG9kRGVmLkRFRjtcbiAgICAgICAgICAgIHZhciBwcmVkaWNhdGVfMyA9IGFjdGlvbk9STWV0aG9kRGVmLkdBVEU7XG4gICAgICAgICAgICAvLyBwcmVkaWNhdGUgcHJlc2VudFxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZV8zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JnTG9va2FoZWFkRnVuY3Rpb25fMyA9IGxvb2thaGVhZEZ1bmN0aW9uO1xuICAgICAgICAgICAgICAgIGxvb2thaGVhZEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlXzMuY2FsbChfdGhpcykgJiYgb3JnTG9va2FoZWFkRnVuY3Rpb25fMy5jYWxsKF90aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uT1JNZXRob2REZWY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vdFN0dWNrID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKGxvb2thaGVhZEZ1bmN0aW9uLmNhbGwodGhpcykgPT09IHRydWUgJiYgbm90U3R1Y2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG5vdFN0dWNrID0gdGhpcy5kb1NpbmdsZVJlcGV0aXRpb24oYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCIgd2lsbCBiZSBkZWZpbmVkIGFzIE5PT1AgdW5sZXNzIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgdGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5tYW55SW50ZXJuYWwsIFtwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWZdLCBsb29rYWhlYWRGdW5jdGlvbiwga2V5c18xLk1BTllfSURYLCBwcm9kT2NjdXJyZW5jZSwgaW50ZXJwcmV0ZXJfMS5OZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXIsIFxuICAgICAgICAvLyBUaGUgbm90U3R1Y2sgcGFyYW1ldGVyIGlzIG9ubHkgcmVsZXZhbnQgd2hlbiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiXG4gICAgICAgIC8vIGlzIGludm9rZWQgZnJvbSBtYW55SW50ZXJuYWwsIGluIHRoZSBNQU5ZX1NFUCBjYXNlIGFuZCBBVF9MRUFTVF9PTkVbX1NFUF1cbiAgICAgICAgLy8gQW4gaW5maW5pdGUgbG9vcCBjYW5ub3Qgb2NjdXIgYXM6XG4gICAgICAgIC8vIC0gRWl0aGVyIHRoZSBsb29rYWhlYWQgaXMgZ3VhcmFudGVlZCB0byBjb25zdW1lIHNvbWV0aGluZyAoU2luZ2xlIFRva2VuIFNlcGFyYXRvcilcbiAgICAgICAgLy8gLSBBVF9MRUFTVF9PTkUgYnkgZGVmaW5pdGlvbiBpcyBndWFyYW50ZWVkIHRvIGNvbnN1bWUgc29tZXRoaW5nIChvciBlcnJvciBvdXQpLlxuICAgICAgICBub3RTdHVjayk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5tYW55U2VwRmlyc3RJbnRlcm5hbCA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGFLZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChrZXlzXzEuTUFOWV9TRVBfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWxMb2dpYyhwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucywgbGFLZXkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUubWFueVNlcEZpcnN0SW50ZXJuYWxMb2dpYyA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucywga2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhY3Rpb24gPSBvcHRpb25zLkRFRjtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IG9wdGlvbnMuU0VQO1xuICAgICAgICB2YXIgZmlyc3RJdGVyYXRpb25MYUZ1bmMgPSB0aGlzLmdldExhRnVuY0Zyb21DYWNoZShrZXkpO1xuICAgICAgICAvLyAxc3QgaXRlcmF0aW9uXG4gICAgICAgIGlmIChmaXJzdEl0ZXJhdGlvbkxhRnVuYy5jYWxsKHRoaXMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3JMb29rQWhlYWRGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50b2tlbk1hdGNoZXIoX3RoaXMuTEEoMSksIHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gMm5kLi5udGggaXRlcmF0aW9uc1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksIHNlcGFyYXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhpcyBDT05TVU1FIHdpbGwgbmV2ZXIgZW50ZXIgcmVjb3ZlcnkgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBzZXBhcmF0b3JMb29rQWhlYWRGdW5jIGNoZWNrcyB0aGF0IHRoZSBzZXBhcmF0b3IgcmVhbGx5IGRvZXMgZXhpc3QuXG4gICAgICAgICAgICAgICAgdGhpcy5DT05TVU1FKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCBmb3IgY2hlY2tpbmcgaW5maW5pdGUgbG9vcCBoZXJlIGR1ZSB0byBjb25zdW1pbmcgdGhlIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogXCJhdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnlcIiB3aWxsIGJlIGRlZmluZWQgYXMgTk9PUCB1bmxlc3MgcmVjb3ZlcnkgaXMgZW5hYmxlZFxuICAgICAgICAgICAgdGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5yZXBldGl0aW9uU2VwU2Vjb25kSW50ZXJuYWwsIFtcbiAgICAgICAgICAgICAgICBwcm9kT2NjdXJyZW5jZSxcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yTG9va0FoZWFkRnVuYyxcbiAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJfMS5OZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXJcbiAgICAgICAgICAgIF0sIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsIGtleXNfMS5NQU5ZX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlLCBpbnRlcnByZXRlcl8xLk5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLnJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbCA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgc2VwYXJhdG9yLCBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLCBhY3Rpb24sIG5leHRUZXJtaW5hbEFmdGVyV2Fsa2VyKSB7XG4gICAgICAgIHdoaWxlIChzZXBhcmF0b3JMb29rQWhlYWRGdW5jKCkpIHtcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGlzIENPTlNVTUUgd2lsbCBuZXZlciBlbnRlciByZWNvdmVyeSBiZWNhdXNlXG4gICAgICAgICAgICAvLyB0aGUgc2VwYXJhdG9yTG9va0FoZWFkRnVuYyBjaGVja3MgdGhhdCB0aGUgc2VwYXJhdG9yIHJlYWxseSBkb2VzIGV4aXN0LlxuICAgICAgICAgICAgdGhpcy5DT05TVU1FKHNlcGFyYXRvcik7XG4gICAgICAgICAgICBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBjYW4gb25seSBhcnJpdmUgdG8gdGhpcyBmdW5jdGlvbiBhZnRlciBhbiBlcnJvclxuICAgICAgICAvLyBoYXMgb2NjdXJyZWQgKGhlbmNlIHRoZSBuYW1lICdzZWNvbmQnKSBzbyB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIElGIHdpbGwgYWx3YXlzIGJlIGVudGVyZWQsIGl0cyBwb3NzaWJsZSB0byByZW1vdmUgaXQuLi5cbiAgICAgICAgLy8gaG93ZXZlciBpdCBpcyBrZXB0IHRvIGF2b2lkIGNvbmZ1c2lvbiBhbmQgYmUgY29uc2lzdGVudC5cbiAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiIHdpbGwgYmUgZGVmaW5lZCBhcyBOT09QIHVubGVzcyByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLCBbXG4gICAgICAgICAgICBwcm9kT2NjdXJyZW5jZSxcbiAgICAgICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgICAgIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBuZXh0VGVybWluYWxBZnRlcldhbGtlclxuICAgICAgICBdLCBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLCBrZXlzXzEuQVRfTEVBU1RfT05FX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlLCBuZXh0VGVybWluYWxBZnRlcldhbGtlcik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5kb1NpbmdsZVJlcGV0aXRpb24gPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBiZWZvcmVJdGVyYXRpb24gPSB0aGlzLmdldExleGVyUG9zaXRpb24oKTtcbiAgICAgICAgYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgIHZhciBhZnRlckl0ZXJhdGlvbiA9IHRoaXMuZ2V0TGV4ZXJQb3NpdGlvbigpO1xuICAgICAgICAvLyBUaGlzIGJvb2xlYW4gd2lsbCBpbmRpY2F0ZSBpZiB0aGlzIHJlcGV0aXRpb24gcHJvZ3Jlc3NlZFxuICAgICAgICAvLyBvciBpZiB3ZSBhcmUgXCJzdHVja1wiIChwb3RlbnRpYWwgaW5maW5pdGUgbG9vcCBpbiB0aGUgcmVwZXRpdGlvbikuXG4gICAgICAgIHJldHVybiBhZnRlckl0ZXJhdGlvbiA+IGJlZm9yZUl0ZXJhdGlvbjtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLm9ySW50ZXJuYWwgPSBmdW5jdGlvbiAoYWx0c09yT3B0cywgb2NjdXJyZW5jZSkge1xuICAgICAgICB2YXIgbGFLZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChrZXlzXzEuT1JfSURYLCBvY2N1cnJlbmNlKTtcbiAgICAgICAgdmFyIGFsdHMgPSAoMCwgaXNBcnJheV8xLmRlZmF1bHQpKGFsdHNPck9wdHMpID8gYWx0c09yT3B0cyA6IGFsdHNPck9wdHMuREVGO1xuICAgICAgICB2YXIgbGFGdW5jID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUobGFLZXkpO1xuICAgICAgICB2YXIgYWx0SWR4VG9UYWtlID0gbGFGdW5jLmNhbGwodGhpcywgYWx0cyk7XG4gICAgICAgIGlmIChhbHRJZHhUb1Rha2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGNob3NlbkFsdGVybmF0aXZlID0gYWx0c1thbHRJZHhUb1Rha2VdO1xuICAgICAgICAgICAgcmV0dXJuIGNob3NlbkFsdGVybmF0aXZlLkFMVC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmFpc2VOb0FsdEV4Y2VwdGlvbihvY2N1cnJlbmNlLCBhbHRzT3JPcHRzLkVSUl9NU0cpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUucnVsZUZpbmFsbHlTdGF0ZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLLnBvcCgpO1xuICAgICAgICB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSy5wb3AoKTtcbiAgICAgICAgLy8gTk9PUCB3aGVuIGNzdCBpcyBkaXNhYmxlZFxuICAgICAgICB0aGlzLmNzdEZpbmFsbHlTdGF0ZVVwZGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5SVUxFX1NUQUNLLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQXRFbmRPZklucHV0KCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RSZWR1bmRhbnRUb2sgPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgdmFyIGVyck1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGROb3RBbGxJbnB1dFBhcnNlZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGZpcnN0UmVkdW5kYW50OiBmaXJzdFJlZHVuZGFudFRvayxcbiAgICAgICAgICAgICAgICBydWxlTmFtZTogdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5TQVZFX0VSUk9SKG5ldyBleGNlcHRpb25zX3B1YmxpY18xLk5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uKGVyck1zZywgZmlyc3RSZWR1bmRhbnRUb2spKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuc3VicnVsZUludGVybmFsID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIGlkeCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcnVsZVJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5BUkdTIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zdWJydWxlSWR4ID0gaWR4O1xuICAgICAgICAgICAgcnVsZVJlc3VsdCA9IHJ1bGVUb0NhbGwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB0aGlzLmNzdFBvc3ROb25UZXJtaW5hbChydWxlUmVzdWx0LCBvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5MQUJFTCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLkxBQkVMXG4gICAgICAgICAgICAgICAgOiBydWxlVG9DYWxsLnJ1bGVOYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBydWxlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnN1YnJ1bGVJbnRlcm5hbEVycm9yKGUsIG9wdGlvbnMsIHJ1bGVUb0NhbGwucnVsZU5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5zdWJydWxlSW50ZXJuYWxFcnJvciA9IGZ1bmN0aW9uIChlLCBvcHRpb25zLCBydWxlTmFtZSkge1xuICAgICAgICBpZiAoKDAsIGV4Y2VwdGlvbnNfcHVibGljXzEuaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbikoZSkgJiYgZS5wYXJ0aWFsQ3N0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsKGUucGFydGlhbENzdFJlc3VsdCwgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuTEFCRUwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5MQUJFTFxuICAgICAgICAgICAgICAgIDogcnVsZU5hbWUpO1xuICAgICAgICAgICAgZGVsZXRlIGUucGFydGlhbENzdFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuY29uc3VtZUludGVybmFsID0gZnVuY3Rpb24gKHRva1R5cGUsIGlkeCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29uc3VtZWRUb2tlbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgdG9rVHlwZSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVUb2tlbigpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVkVG9rZW4gPSBuZXh0VG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVJbnRlcm5hbEVycm9yKHRva1R5cGUsIG5leHRUb2tlbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVGcm9tQ29uc3VtcHRpb24pIHtcbiAgICAgICAgICAgIGNvbnN1bWVkVG9rZW4gPSB0aGlzLmNvbnN1bWVJbnRlcm5hbFJlY292ZXJ5KHRva1R5cGUsIGlkeCwgZUZyb21Db25zdW1wdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jc3RQb3N0VGVybWluYWwob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuTEFCRUwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBvcHRpb25zLkxBQkVMXG4gICAgICAgICAgICA6IHRva1R5cGUubmFtZSwgY29uc3VtZWRUb2tlbik7XG4gICAgICAgIHJldHVybiBjb25zdW1lZFRva2VuO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuY29uc3VtZUludGVybmFsRXJyb3IgPSBmdW5jdGlvbiAodG9rVHlwZSwgbmV4dFRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtc2c7XG4gICAgICAgIHZhciBwcmV2aW91c1Rva2VuID0gdGhpcy5MQSgwKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLkVSUl9NU0cpIHtcbiAgICAgICAgICAgIG1zZyA9IG9wdGlvbnMuRVJSX01TRztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRva1R5cGUsXG4gICAgICAgICAgICAgICAgYWN0dWFsOiBuZXh0VG9rZW4sXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzVG9rZW4sXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLlNBVkVfRVJST1IobmV3IGV4Y2VwdGlvbnNfcHVibGljXzEuTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uKG1zZywgbmV4dFRva2VuLCBwcmV2aW91c1Rva2VuKSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5jb25zdW1lSW50ZXJuYWxSZWNvdmVyeSA9IGZ1bmN0aW9uICh0b2tUeXBlLCBpZHgsIGVGcm9tQ29uc3VtcHRpb24pIHtcbiAgICAgICAgLy8gbm8gcmVjb3ZlcnkgYWxsb3dlZCBkdXJpbmcgYmFja3RyYWNraW5nLCBvdGhlcndpc2UgYmFja3RyYWNraW5nIG1heSByZWNvdmVyIGludmFsaWQgc3ludGF4IGFuZCBhY2NlcHQgaXRcbiAgICAgICAgLy8gYnV0IHRoZSBvcmlnaW5hbCBzeW50YXggY291bGQgaGF2ZSBiZWVuIHBhcnNlZCBzdWNjZXNzZnVsbHkgd2l0aG91dCBhbnkgYmFja3RyYWNraW5nICsgcmVjb3ZlcnlcbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcnlFbmFibGVkICYmXG4gICAgICAgICAgICAvLyBUT0RPOiBtb3JlIHJvYnVzdCBjaGVja2luZyBvZiB0aGUgZXhjZXB0aW9uIHR5cGUuIFBlcmhhcHMgVHlwZXNjcmlwdCBleHRlbmRpbmcgZXhwcmVzc2lvbnM/XG4gICAgICAgICAgICBlRnJvbUNvbnN1bXB0aW9uLm5hbWUgPT09IFwiTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uXCIgJiZcbiAgICAgICAgICAgICF0aGlzLmlzQmFja1RyYWNraW5nKCkpIHtcbiAgICAgICAgICAgIHZhciBmb2xsb3dzID0gdGhpcy5nZXRGb2xsb3dzRm9ySW5SdWxlUmVjb3ZlcnkodG9rVHlwZSwgaWR4KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJ5SW5SdWxlUmVjb3ZlcnkodG9rVHlwZSwgZm9sbG93cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZUZyb21JblJ1bGVSZWNvdmVyeSkge1xuICAgICAgICAgICAgICAgIGlmIChlRnJvbUluUnVsZVJlY292ZXJ5Lm5hbWUgPT09IHJlY292ZXJhYmxlXzEuSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkIGluIFJ1bGVSZWNvdmVyeS5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgdGhlIG9yaWdpbmFsIGVycm9yIGluIG9yZGVyIHRvIHRyaWdnZXIgcmVTeW5jIGVycm9yIHJlY292ZXJ5XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVGcm9tQ29uc3VtcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlRnJvbUluUnVsZVJlY292ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVGcm9tQ29uc3VtcHRpb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLnNhdmVSZWNvZ1N0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlcnJvcnMgaXMgYSBnZXR0ZXIgd2hpY2ggd2lsbCBjbG9uZSB0aGUgZXJyb3JzIGFycmF5XG4gICAgICAgIHZhciBzYXZlZEVycm9ycyA9IHRoaXMuZXJyb3JzO1xuICAgICAgICB2YXIgc2F2ZWRSdWxlU3RhY2sgPSAoMCwgY2xvbmVfMS5kZWZhdWx0KSh0aGlzLlJVTEVfU1RBQ0spO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzOiBzYXZlZEVycm9ycyxcbiAgICAgICAgICAgIGxleGVyU3RhdGU6IHRoaXMuZXhwb3J0TGV4ZXJTdGF0ZSgpLFxuICAgICAgICAgICAgUlVMRV9TVEFDSzogc2F2ZWRSdWxlU3RhY2ssXG4gICAgICAgICAgICBDU1RfU1RBQ0s6IHRoaXMuQ1NUX1NUQUNLXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5yZWxvYWRSZWNvZ1N0YXRlID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gbmV3U3RhdGUuZXJyb3JzO1xuICAgICAgICB0aGlzLmltcG9ydExleGVyU3RhdGUobmV3U3RhdGUubGV4ZXJTdGF0ZSk7XG4gICAgICAgIHRoaXMuUlVMRV9TVEFDSyA9IG5ld1N0YXRlLlJVTEVfU1RBQ0s7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5ydWxlSW52b2NhdGlvblN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKHNob3J0TmFtZSwgZnVsbE5hbWUsIGlkeEluQ2FsbGluZ1J1bGUpIHtcbiAgICAgICAgdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sucHVzaChpZHhJbkNhbGxpbmdSdWxlKTtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLLnB1c2goc2hvcnROYW1lKTtcbiAgICAgICAgLy8gTk9PUCB3aGVuIGNzdCBpcyBkaXNhYmxlZFxuICAgICAgICB0aGlzLmNzdEludm9jYXRpb25TdGF0ZVVwZGF0ZShmdWxsTmFtZSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5pc0JhY2tUcmFja2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjay5sZW5ndGggIT09IDA7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5nZXRDdXJyUnVsZUZ1bGxOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2hvcnROYW1lID0gdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxbc2hvcnROYW1lXTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lID0gZnVuY3Rpb24gKHNob3J0TmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsW3Nob3J0TmFtZV07XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5pc0F0RW5kT2ZJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksIHRva2Vuc19wdWJsaWNfMS5FT0YpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVzZXRMZXhlclN0YXRlKCk7XG4gICAgICAgIHRoaXMuc3VicnVsZUlkeCA9IDA7XG4gICAgICAgIHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLlJVTEVfU1RBQ0sgPSBbXTtcbiAgICAgICAgLy8gVE9ETzogZXh0cmFjdCBhIHNwZWNpZmljIHJlc2V0IGZvciBUcmVlQnVpbGRlciB0cmFpdFxuICAgICAgICB0aGlzLkNTVF9TVEFDSyA9IFtdO1xuICAgICAgICB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSyA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY29nbml6ZXJFbmdpbmU7XG59KCkpO1xuZXhwb3J0cy5SZWNvZ25pemVyRW5naW5lID0gUmVjb2duaXplckVuZ2luZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY29nbml6ZXJfZW5naW5lLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js":
/*!****************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.attemptInRepetitionRecovery = exports.Recoverable = exports.InRuleRecoveryException = exports.IN_RULE_RECOVERY_EXCEPTION = exports.EOF_FOLLOW_KEY = void 0;\nvar tokens_public_1 = __webpack_require__(/*! ../../../scan/tokens_public */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/tokens_public.js\");\nvar isEmpty_1 = __importDefault(__webpack_require__(/*! lodash/isEmpty */ \"(ssr)/./node_modules/lodash/isEmpty.js\"));\nvar dropRight_1 = __importDefault(__webpack_require__(/*! lodash/dropRight */ \"(ssr)/./node_modules/lodash/dropRight.js\"));\nvar flatten_1 = __importDefault(__webpack_require__(/*! lodash/flatten */ \"(ssr)/./node_modules/lodash/flatten.js\"));\nvar map_1 = __importDefault(__webpack_require__(/*! lodash/map */ \"(ssr)/./node_modules/lodash/map.js\"));\nvar find_1 = __importDefault(__webpack_require__(/*! lodash/find */ \"(ssr)/./node_modules/lodash/find.js\"));\nvar has_1 = __importDefault(__webpack_require__(/*! lodash/has */ \"(ssr)/./node_modules/lodash/has.js\"));\nvar includes_1 = __importDefault(__webpack_require__(/*! lodash/includes */ \"(ssr)/./node_modules/lodash/includes.js\"));\nvar clone_1 = __importDefault(__webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"));\nvar exceptions_public_1 = __webpack_require__(/*! ../../exceptions_public */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/exceptions_public.js\");\nvar constants_1 = __webpack_require__(/*! ../../constants */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/constants.js\");\nvar parser_1 = __webpack_require__(/*! ../parser */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\");\nexports.EOF_FOLLOW_KEY = {};\nexports.IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nvar InRuleRecoveryException = /** @class */ (function (_super) {\n    __extends(InRuleRecoveryException, _super);\n    function InRuleRecoveryException(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = exports.IN_RULE_RECOVERY_EXCEPTION;\n        return _this;\n    }\n    return InRuleRecoveryException;\n}(Error));\nexports.InRuleRecoveryException = InRuleRecoveryException;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nvar Recoverable = /** @class */ (function () {\n    function Recoverable() {\n    }\n    Recoverable.prototype.initRecoverable = function (config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = (0, has_1.default)(config, \"recoveryEnabled\")\n            ? config.recoveryEnabled // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    };\n    Recoverable.prototype.getTokenToInsert = function (tokType) {\n        var tokToInsert = (0, tokens_public_1.createTokenInstance)(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    };\n    Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\n        return true;\n    };\n    Recoverable.prototype.canTokenTypeBeDeletedInRecovery = function (tokType) {\n        return true;\n    };\n    Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        var _this = this;\n        // TODO: can the resyncTokenType be cached?\n        var reSyncTokType = this.findReSyncTokenType();\n        var savedLexerState = this.exportLexerState();\n        var resyncedTokens = [];\n        var passedResyncPoint = false;\n        var nextTokenWithoutResync = this.LA(1);\n        var currToken = this.LA(1);\n        var generateErrorMessage = function () {\n            var previousToken = _this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: _this.getCurrRuleFullName()\n            });\n            var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = (0, dropRight_1.default)(resyncedTokens);\n            _this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // \"between rules\" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    };\n    Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    };\n    // Error Recovery functionality\n    Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\n        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        var follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    };\n    Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            var tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            var nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException(\"sad sad panda\");\n    };\n    Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\n        var _this = this;\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if ((0, isEmpty_1.default)(follows)) {\n            return false;\n        }\n        var mismatchedTok = this.LA(1);\n        var isMisMatchedTokInFollows = (0, find_1.default)(follows, function (possibleFollowsTokType) {\n            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\n        if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n            return false;\n        }\n        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    };\n    Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\n        var followKey = this.getCurrFollowKey();\n        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return (0, includes_1.default)(currentRuleReSyncSet, tokenTypeIdx);\n    };\n    Recoverable.prototype.findReSyncTokenType = function () {\n        var allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        var nextToken = this.LA(1);\n        var k = 2;\n        while (true) {\n            var foundMatch = (0, find_1.default)(allPossibleReSyncTokTypes, function (resyncTokType) {\n                var canMatch = (0, tokens_public_1.tokenMatcher)(nextToken, resyncTokType);\n                return canMatch;\n            });\n            if (foundMatch !== undefined) {\n                return foundMatch;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    };\n    Recoverable.prototype.getCurrFollowKey = function () {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return exports.EOF_FOLLOW_KEY;\n        }\n        var currRuleShortName = this.getLastExplicitRuleShortName();\n        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName)\n        };\n    };\n    Recoverable.prototype.buildFullFollowKeyStack = function () {\n        var _this = this;\n        var explicitRuleStack = this.RULE_STACK;\n        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return (0, map_1.default)(explicitRuleStack, function (ruleName, idx) {\n            if (idx === 0) {\n                return exports.EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: _this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n            };\n        });\n    };\n    Recoverable.prototype.flattenFollowSet = function () {\n        var _this = this;\n        var followStack = (0, map_1.default)(this.buildFullFollowKeyStack(), function (currKey) {\n            return _this.getFollowSetFromFollowKey(currKey);\n        });\n        return (0, flatten_1.default)(followStack);\n    };\n    Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\n        if (followKey === exports.EOF_FOLLOW_KEY) {\n            return [tokens_public_1.EOF];\n        }\n        var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;\n        return this.resyncFollows[followName];\n    };\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\n        if (!this.tokenMatcher(token, tokens_public_1.EOF)) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    };\n    Recoverable.prototype.reSyncTo = function (tokType) {\n        var resyncedTokens = [];\n        var nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return (0, dropRight_1.default)(resyncedTokens);\n    };\n    Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    };\n    Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\n        var pathRuleStack = this.getHumanReadableRuleStack();\n        var pathOccurrenceStack = (0, clone_1.default)(this.RULE_OCCURRENCE_STACK);\n        var grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule\n        };\n        return grammarPath;\n    };\n    Recoverable.prototype.getHumanReadableRuleStack = function () {\n        var _this = this;\n        return (0, map_1.default)(this.RULE_STACK, function (currShortName) {\n            return _this.shortRuleNameToFullName(currShortName);\n        });\n    };\n    return Recoverable;\n}());\nexports.Recoverable = Recoverable;\nfunction attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    var firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        var currRuleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[currRuleName];\n        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    var expectTokAfterLastMatch = firstAfterRepInfo.token;\n    var nextTokIdx = firstAfterRepInfo.occurrence;\n    var isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = tokens_public_1.EOF;\n        nextTokIdx = 1;\n    }\n    // We don't have anything to re-sync to...\n    // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n        return;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\nexports.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n//# sourceMappingURL=recoverable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvcmVjb3ZlcmFibGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUMsR0FBRyxtQkFBbUIsR0FBRywrQkFBK0IsR0FBRyxrQ0FBa0MsR0FBRyxzQkFBc0I7QUFDekosc0JBQXNCLG1CQUFPLENBQUMsa0dBQTZCO0FBQzNELGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCxrQ0FBa0MsbUJBQU8sQ0FBQyxrRUFBa0I7QUFDNUQsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELDRCQUE0QixtQkFBTyxDQUFDLHNEQUFZO0FBQ2hELDZCQUE2QixtQkFBTyxDQUFDLHdEQUFhO0FBQ2xELDRCQUE0QixtQkFBTyxDQUFDLHNEQUFZO0FBQ2hELGlDQUFpQyxtQkFBTyxDQUFDLGdFQUFpQjtBQUMxRCw4QkFBOEIsbUJBQU8sQ0FBQywwREFBYztBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyxtR0FBeUI7QUFDM0Qsa0JBQWtCLG1CQUFPLENBQUMsbUZBQWlCO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxpRkFBVztBQUNsQyxzQkFBc0I7QUFDdEIsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvcmVjb3ZlcmFibGUuanM/ZjU1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSA9IGV4cG9ydHMuUmVjb3ZlcmFibGUgPSBleHBvcnRzLkluUnVsZVJlY292ZXJ5RXhjZXB0aW9uID0gZXhwb3J0cy5JTl9SVUxFX1JFQ09WRVJZX0VYQ0VQVElPTiA9IGV4cG9ydHMuRU9GX0ZPTExPV19LRVkgPSB2b2lkIDA7XG52YXIgdG9rZW5zX3B1YmxpY18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3NjYW4vdG9rZW5zX3B1YmxpY1wiKTtcbnZhciBpc0VtcHR5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VtcHR5XCIpKTtcbnZhciBkcm9wUmlnaHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2Ryb3BSaWdodFwiKSk7XG52YXIgZmxhdHRlbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZmxhdHRlblwiKSk7XG52YXIgbWFwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9tYXBcIikpO1xudmFyIGZpbmRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZpbmRcIikpO1xudmFyIGhhc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaGFzXCIpKTtcbnZhciBpbmNsdWRlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaW5jbHVkZXNcIikpO1xudmFyIGNsb25lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKSk7XG52YXIgZXhjZXB0aW9uc19wdWJsaWNfMSA9IHJlcXVpcmUoXCIuLi8uLi9leGNlcHRpb25zX3B1YmxpY1wiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb25zdGFudHNcIik7XG52YXIgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vcGFyc2VyXCIpO1xuZXhwb3J0cy5FT0ZfRk9MTE9XX0tFWSA9IHt9O1xuZXhwb3J0cy5JTl9SVUxFX1JFQ09WRVJZX0VYQ0VQVElPTiA9IFwiSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb25cIjtcbnZhciBJblJ1bGVSZWNvdmVyeUV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb24obWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gZXhwb3J0cy5JTl9SVUxFX1JFQ09WRVJZX0VYQ0VQVElPTjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb247XG59KEVycm9yKSk7XG5leHBvcnRzLkluUnVsZVJlY292ZXJ5RXhjZXB0aW9uID0gSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb247XG4vKipcbiAqIFRoaXMgdHJhaXQgaXMgcmVzcG9uc2libGUgZm9yIHRoZSBlcnJvciByZWNvdmVyeSBhbmQgZmF1bHQgdG9sZXJhbnQgbG9naWNcbiAqL1xudmFyIFJlY292ZXJhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY292ZXJhYmxlKCkge1xuICAgIH1cbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuaW5pdFJlY292ZXJhYmxlID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLmZpcnN0QWZ0ZXJSZXBNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZXN5bmNGb2xsb3dzID0ge307XG4gICAgICAgIHRoaXMucmVjb3ZlcnlFbmFibGVkID0gKDAsIGhhc18xLmRlZmF1bHQpKGNvbmZpZywgXCJyZWNvdmVyeUVuYWJsZWRcIilcbiAgICAgICAgICAgID8gY29uZmlnLnJlY292ZXJ5RW5hYmxlZCAvLyBhc3N1bWVzIGVuZCB1c2VyIHByb3ZpZGVzIHRoZSBjb3JyZWN0IGNvbmZpZyB2YWx1ZS90eXBlXG4gICAgICAgICAgICA6IHBhcnNlcl8xLkRFRkFVTFRfUEFSU0VSX0NPTkZJRy5yZWNvdmVyeUVuYWJsZWQ7XG4gICAgICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgTk9PUCB3aWxsIGJlIGlubGluZWQgd2hpY2hcbiAgICAgICAgLy8gZWZmZWN0aXZlbHkgbWVhbnMgdGhhdCB0aGlzIG9wdGlvbmFsIGZlYXR1cmUgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgLy8gd2hlbiBub3QgdXNlZC5cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcnlFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSA9IGF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmdldFRva2VuVG9JbnNlcnQgPSBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICB2YXIgdG9rVG9JbnNlcnQgPSAoMCwgdG9rZW5zX3B1YmxpY18xLmNyZWF0ZVRva2VuSW5zdGFuY2UpKHRva1R5cGUsIFwiXCIsIE5hTiwgTmFOLCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuICAgICAgICB0b2tUb0luc2VydC5pc0luc2VydGVkSW5SZWNvdmVyeSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tUb0luc2VydDtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5jYW5Ub2tlblR5cGVCZUluc2VydGVkSW5SZWNvdmVyeSA9IGZ1bmN0aW9uICh0b2tUeXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmNhblRva2VuVHlwZUJlRGVsZXRlZEluUmVjb3ZlcnkgPSBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS50cnlJblJlcGV0aXRpb25SZWNvdmVyeSA9IGZ1bmN0aW9uIChncmFtbWFyUnVsZSwgZ3JhbW1hclJ1bGVBcmdzLCBsb29rQWhlYWRGdW5jLCBleHBlY3RlZFRva1R5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gVE9ETzogY2FuIHRoZSByZXN5bmNUb2tlblR5cGUgYmUgY2FjaGVkP1xuICAgICAgICB2YXIgcmVTeW5jVG9rVHlwZSA9IHRoaXMuZmluZFJlU3luY1Rva2VuVHlwZSgpO1xuICAgICAgICB2YXIgc2F2ZWRMZXhlclN0YXRlID0gdGhpcy5leHBvcnRMZXhlclN0YXRlKCk7XG4gICAgICAgIHZhciByZXN5bmNlZFRva2VucyA9IFtdO1xuICAgICAgICB2YXIgcGFzc2VkUmVzeW5jUG9pbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG5leHRUb2tlbldpdGhvdXRSZXN5bmMgPSB0aGlzLkxBKDEpO1xuICAgICAgICB2YXIgY3VyclRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgdmFyIGdlbmVyYXRlRXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzVG9rZW4gPSBfdGhpcy5MQSgwKTtcbiAgICAgICAgICAgIC8vIHdlIGFyZSBwcmVlbXB0aXZlbHkgcmUtc3luY2luZyBiZWZvcmUgYW4gZXJyb3IgaGFzIGJlZW4gZGV0ZWN0ZWQsIHRoZXJlZm9yIHdlIG11c3QgcmVwcm9kdWNlXG4gICAgICAgICAgICAvLyB0aGUgZXJyb3IgdGhhdCB3b3VsZCBoYXZlIGJlZW4gdGhyb3duXG4gICAgICAgICAgICB2YXIgbXNnID0gX3RoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkVG9rVHlwZSxcbiAgICAgICAgICAgICAgICBhY3R1YWw6IG5leHRUb2tlbldpdGhvdXRSZXN5bmMsXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzVG9rZW4sXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IF90aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgZXhjZXB0aW9uc19wdWJsaWNfMS5NaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24obXNnLCBuZXh0VG9rZW5XaXRob3V0UmVzeW5jLCBfdGhpcy5MQSgwKSk7XG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgdG9rZW4gaGVyZSB3aWxsIGJlIHRoZSBvcmlnaW5hbCBjYXVzZSBvZiB0aGUgZXJyb3IsIHRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHJlc3luY2VkVG9rZW5zIHByb3BlcnR5LlxuICAgICAgICAgICAgZXJyb3IucmVzeW5jZWRUb2tlbnMgPSAoMCwgZHJvcFJpZ2h0XzEuZGVmYXVsdCkocmVzeW5jZWRUb2tlbnMpO1xuICAgICAgICAgICAgX3RoaXMuU0FWRV9FUlJPUihlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHdoaWxlICghcGFzc2VkUmVzeW5jUG9pbnQpIHtcbiAgICAgICAgICAgIC8vIHJlLXN5bmNlZCB0byBhIHBvaW50IHdoZXJlIHdlIGNhbiBzYWZlbHkgZXhpdCB0aGUgcmVwZXRpdGlvbi9cbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuTWF0Y2hlcihjdXJyVG9rZW4sIGV4cGVjdGVkVG9rVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUVycm9yTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gbXVzdCByZXR1cm4gaGVyZSB0byBhdm9pZCByZXZlcnRpbmcgdGhlIGlucHV0SWR4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsb29rQWhlYWRGdW5jLmNhbGwodGhpcykpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBza2lwcGVkIGVub3VnaCB0b2tlbnMgc28gd2UgY2FuIHJlc3luYyByaWdodCBiYWNrIGludG8gYW5vdGhlciBpdGVyYXRpb24gb2YgdGhlIHJlcGV0aXRpb24gZ3JhbW1hciBydWxlXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVFcnJvck1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmUgaW52b2NhdGlvbiBpbiBvdGhlciB0byBzdXBwb3J0IG11bHRpcGxlIHJlLXN5bmNzIGluIHRoZSBzYW1lIHRvcCBsZXZlbCByZXBldGl0aW9uIGdyYW1tYXIgcnVsZVxuICAgICAgICAgICAgICAgIGdyYW1tYXJSdWxlLmFwcGx5KHRoaXMsIGdyYW1tYXJSdWxlQXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBtdXN0IHJldHVybiBoZXJlIHRvIGF2b2lkIHJldmVydGluZyB0aGUgaW5wdXRJZHhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudG9rZW5NYXRjaGVyKGN1cnJUb2tlbiwgcmVTeW5jVG9rVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBwYXNzZWRSZXN5bmNQb2ludCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyVG9rZW4gPSB0aGlzLlNLSVBfVE9LRU4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRvUmVzeW5jVG9rZW5zKGN1cnJUb2tlbiwgcmVzeW5jZWRUb2tlbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHdlIHdlcmUgdW5hYmxlIHRvIGZpbmQgYSBDTE9TRVIgcG9pbnQgdG8gcmVzeW5jIGluc2lkZSB0aGUgUmVwZXRpdGlvbiwgcmVzZXQgdGhlIHN0YXRlLlxuICAgICAgICAvLyBUaGUgcGFyc2luZyBleGNlcHRpb24gd2Ugd2VyZSB0cnlpbmcgdG8gcHJldmVudCB3aWxsIGhhcHBlbiBpbiB0aGUgTkVYVCBwYXJzaW5nIHN0ZXAuIGl0IG1heSBiZSBoYW5kbGVkIGJ5XG4gICAgICAgIC8vIFwiYmV0d2VlbiBydWxlc1wiIHJlc3luYyByZWNvdmVyeSBsYXRlciBpbiB0aGUgZmxvdy5cbiAgICAgICAgdGhpcy5pbXBvcnRMZXhlclN0YXRlKHNhdmVkTGV4ZXJTdGF0ZSk7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuc2hvdWxkSW5SZXBldGl0aW9uUmVjb3ZlcnlCZVRyaWVkID0gZnVuY3Rpb24gKGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoLCBuZXh0VG9rSWR4LCBub3RTdHVjaykge1xuICAgICAgICAvLyBFZGdlIGNhc2Ugb2YgYXJyaXZpbmcgZnJvbSBhIE1BTlkgcmVwZXRpdGlvbiB3aGljaCBpcyBzdHVja1xuICAgICAgICAvLyBBdHRlbXB0aW5nIHJlY292ZXJ5IGluIHRoaXMgY2FzZSBjb3VsZCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgIGlmIChub3RTdHVjayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBubyBuZWVkIHRvIHJlY292ZXIsIG5leHQgdG9rZW4gaXMgd2hhdCB3ZSBleHBlY3QuLi5cbiAgICAgICAgaWYgKHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksIGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVycm9yIHJlY292ZXJ5IGlzIGRpc2FibGVkIGR1cmluZyBiYWNrdHJhY2tpbmcgYXMgaXQgY2FuIG1ha2UgdGhlIHBhcnNlciBpZ25vcmUgYSB2YWxpZCBncmFtbWFyIHBhdGhcbiAgICAgICAgLy8gYW5kIHByZWZlciBzb21lIGJhY2t0cmFja2luZyBwYXRoIHRoYXQgaW5jbHVkZXMgcmVjb3ZlcmVkIGVycm9ycy5cbiAgICAgICAgaWYgKHRoaXMuaXNCYWNrVHJhY2tpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGNhbiBwZXJmb3JtIGluUnVsZSByZWNvdmVyeSAoc2luZ2xlIHRva2VuIGluc2VydGlvbiBvciBkZWxldGlvbikgd2UgYWx3YXlzIHByZWZlciB0aGF0IHJlY292ZXJ5IGFsZ29yaXRobVxuICAgICAgICAvLyBiZWNhdXNlIGlmIGl0IHdvcmtzLCBpdCBtYWtlcyB0aGUgbGVhc3QgYW1vdW50IG9mIGNoYW5nZXMgdG8gdGhlIGlucHV0IHN0cmVhbSAoZ3JlZWR5IGFsZ29yaXRobSlcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gUmVkdW5kYW50SWZTdGF0ZW1lbnRKU1xuICAgICAgICBpZiAodGhpcy5jYW5QZXJmb3JtSW5SdWxlUmVjb3ZlcnkoZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gsIHRoaXMuZ2V0Rm9sbG93c0ZvckluUnVsZVJlY292ZXJ5KGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoLCBuZXh0VG9rSWR4KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIEVycm9yIFJlY292ZXJ5IGZ1bmN0aW9uYWxpdHlcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuZ2V0Rm9sbG93c0ZvckluUnVsZVJlY292ZXJ5ID0gZnVuY3Rpb24gKHRva1R5cGUsIHRva0lkeEluUnVsZSkge1xuICAgICAgICB2YXIgZ3JhbW1hclBhdGggPSB0aGlzLmdldEN1cnJlbnRHcmFtbWFyUGF0aCh0b2tUeXBlLCB0b2tJZHhJblJ1bGUpO1xuICAgICAgICB2YXIgZm9sbG93cyA9IHRoaXMuZ2V0TmV4dFBvc3NpYmxlVG9rZW5UeXBlcyhncmFtbWFyUGF0aCk7XG4gICAgICAgIHJldHVybiBmb2xsb3dzO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLnRyeUluUnVsZVJlY292ZXJ5ID0gZnVuY3Rpb24gKGV4cGVjdGVkVG9rVHlwZSwgZm9sbG93cykge1xuICAgICAgICBpZiAodGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuSW5zZXJ0aW9uKGV4cGVjdGVkVG9rVHlwZSwgZm9sbG93cykpIHtcbiAgICAgICAgICAgIHZhciB0b2tUb0luc2VydCA9IHRoaXMuZ2V0VG9rZW5Ub0luc2VydChleHBlY3RlZFRva1R5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRva1RvSW5zZXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbihleHBlY3RlZFRva1R5cGUpKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFRvayA9IHRoaXMuU0tJUF9UT0tFTigpO1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0VG9rO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBJblJ1bGVSZWNvdmVyeUV4Y2VwdGlvbihcInNhZCBzYWQgcGFuZGFcIik7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuY2FuUGVyZm9ybUluUnVsZVJlY292ZXJ5ID0gZnVuY3Rpb24gKGV4cGVjdGVkVG9rZW4sIGZvbGxvd3MpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5JbnNlcnRpb24oZXhwZWN0ZWRUb2tlbiwgZm9sbG93cykgfHxcbiAgICAgICAgICAgIHRoaXMuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkRlbGV0aW9uKGV4cGVjdGVkVG9rZW4pKTtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuSW5zZXJ0aW9uID0gZnVuY3Rpb24gKGV4cGVjdGVkVG9rVHlwZSwgZm9sbG93cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuY2FuVG9rZW5UeXBlQmVJbnNlcnRlZEluUmVjb3ZlcnkoZXhwZWN0ZWRUb2tUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG11c3Qga25vdyB0aGUgcG9zc2libGUgZm9sbG93aW5nIHRva2VucyB0byBwZXJmb3JtIHNpbmdsZSB0b2tlbiBpbnNlcnRpb25cbiAgICAgICAgaWYgKCgwLCBpc0VtcHR5XzEuZGVmYXVsdCkoZm9sbG93cykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWlzbWF0Y2hlZFRvayA9IHRoaXMuTEEoMSk7XG4gICAgICAgIHZhciBpc01pc01hdGNoZWRUb2tJbkZvbGxvd3MgPSAoMCwgZmluZF8xLmRlZmF1bHQpKGZvbGxvd3MsIGZ1bmN0aW9uIChwb3NzaWJsZUZvbGxvd3NUb2tUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudG9rZW5NYXRjaGVyKG1pc21hdGNoZWRUb2ssIHBvc3NpYmxlRm9sbG93c1Rva1R5cGUpO1xuICAgICAgICB9KSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gaXNNaXNNYXRjaGVkVG9rSW5Gb2xsb3dzO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbiA9IGZ1bmN0aW9uIChleHBlY3RlZFRva1R5cGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhblRva2VuVHlwZUJlRGVsZXRlZEluUmVjb3ZlcnkoZXhwZWN0ZWRUb2tUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc05leHRUb2tlbldoYXRJc0V4cGVjdGVkID0gdGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgyKSwgZXhwZWN0ZWRUb2tUeXBlKTtcbiAgICAgICAgcmV0dXJuIGlzTmV4dFRva2VuV2hhdElzRXhwZWN0ZWQ7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuaXNJbkN1cnJlbnRSdWxlUmVTeW5jU2V0ID0gZnVuY3Rpb24gKHRva2VuVHlwZUlkeCkge1xuICAgICAgICB2YXIgZm9sbG93S2V5ID0gdGhpcy5nZXRDdXJyRm9sbG93S2V5KCk7XG4gICAgICAgIHZhciBjdXJyZW50UnVsZVJlU3luY1NldCA9IHRoaXMuZ2V0Rm9sbG93U2V0RnJvbUZvbGxvd0tleShmb2xsb3dLZXkpO1xuICAgICAgICByZXR1cm4gKDAsIGluY2x1ZGVzXzEuZGVmYXVsdCkoY3VycmVudFJ1bGVSZVN5bmNTZXQsIHRva2VuVHlwZUlkeCk7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuZmluZFJlU3luY1Rva2VuVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFsbFBvc3NpYmxlUmVTeW5jVG9rVHlwZXMgPSB0aGlzLmZsYXR0ZW5Gb2xsb3dTZXQoKTtcbiAgICAgICAgLy8gdGhpcyBsb29wIHdpbGwgYWx3YXlzIHRlcm1pbmF0ZSBhcyBFT0YgaXMgYWx3YXlzIGluIHRoZSBmb2xsb3cgc3RhY2sgYW5kIGFsc28gYWx3YXlzICh2aXJ0dWFsbHkpIGluIHRoZSBpbnB1dFxuICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgdmFyIGsgPSAyO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGZvdW5kTWF0Y2ggPSAoMCwgZmluZF8xLmRlZmF1bHQpKGFsbFBvc3NpYmxlUmVTeW5jVG9rVHlwZXMsIGZ1bmN0aW9uIChyZXN5bmNUb2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbk1hdGNoID0gKDAsIHRva2Vuc19wdWJsaWNfMS50b2tlbk1hdGNoZXIpKG5leHRUb2tlbiwgcmVzeW5jVG9rVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbk1hdGNoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZm91bmRNYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kTWF0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0VG9rZW4gPSB0aGlzLkxBKGspO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuZ2V0Q3VyckZvbGxvd0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGhlIGxlbmd0aCBpcyBhdCBsZWFzdCBvbmUgYXMgd2UgYWx3YXlzIGFkZCB0aGUgcnVsZU5hbWUgdG8gdGhlIHN0YWNrIGJlZm9yZSBpbnZva2luZyB0aGUgcnVsZS5cbiAgICAgICAgaWYgKHRoaXMuUlVMRV9TVEFDSy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkVPRl9GT0xMT1dfS0VZO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyUnVsZVNob3J0TmFtZSA9IHRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpO1xuICAgICAgICB2YXIgY3VyclJ1bGVJZHggPSB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVPY2N1cnJlbmNlSW5kZXgoKTtcbiAgICAgICAgdmFyIHByZXZSdWxlU2hvcnROYW1lID0gdGhpcy5nZXRQcmV2aW91c0V4cGxpY2l0UnVsZVNob3J0TmFtZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUoY3VyclJ1bGVTaG9ydE5hbWUpLFxuICAgICAgICAgICAgaWR4SW5DYWxsaW5nUnVsZTogY3VyclJ1bGVJZHgsXG4gICAgICAgICAgICBpblJ1bGU6IHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUocHJldlJ1bGVTaG9ydE5hbWUpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuYnVpbGRGdWxsRm9sbG93S2V5U3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBleHBsaWNpdFJ1bGVTdGFjayA9IHRoaXMuUlVMRV9TVEFDSztcbiAgICAgICAgdmFyIGV4cGxpY2l0T2NjdXJyZW5jZVN0YWNrID0gdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0s7XG4gICAgICAgIHJldHVybiAoMCwgbWFwXzEuZGVmYXVsdCkoZXhwbGljaXRSdWxlU3RhY2ssIGZ1bmN0aW9uIChydWxlTmFtZSwgaWR4KSB7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuRU9GX0ZPTExPV19LRVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBfdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShydWxlTmFtZSksXG4gICAgICAgICAgICAgICAgaWR4SW5DYWxsaW5nUnVsZTogZXhwbGljaXRPY2N1cnJlbmNlU3RhY2tbaWR4XSxcbiAgICAgICAgICAgICAgICBpblJ1bGU6IF90aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKGV4cGxpY2l0UnVsZVN0YWNrW2lkeCAtIDFdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuZmxhdHRlbkZvbGxvd1NldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZvbGxvd1N0YWNrID0gKDAsIG1hcF8xLmRlZmF1bHQpKHRoaXMuYnVpbGRGdWxsRm9sbG93S2V5U3RhY2soKSwgZnVuY3Rpb24gKGN1cnJLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRGb2xsb3dTZXRGcm9tRm9sbG93S2V5KGN1cnJLZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgwLCBmbGF0dGVuXzEuZGVmYXVsdCkoZm9sbG93U3RhY2spO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmdldEZvbGxvd1NldEZyb21Gb2xsb3dLZXkgPSBmdW5jdGlvbiAoZm9sbG93S2V5KSB7XG4gICAgICAgIGlmIChmb2xsb3dLZXkgPT09IGV4cG9ydHMuRU9GX0ZPTExPV19LRVkpIHtcbiAgICAgICAgICAgIHJldHVybiBbdG9rZW5zX3B1YmxpY18xLkVPRl07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvbGxvd05hbWUgPSBmb2xsb3dLZXkucnVsZU5hbWUgKyBmb2xsb3dLZXkuaWR4SW5DYWxsaW5nUnVsZSArIGNvbnN0YW50c18xLklOICsgZm9sbG93S2V5LmluUnVsZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzeW5jRm9sbG93c1tmb2xsb3dOYW1lXTtcbiAgICB9O1xuICAgIC8vIEl0IGRvZXMgbm90IG1ha2UgYW55IHNlbnNlIHRvIGluY2x1ZGUgYSB2aXJ0dWFsIEVPRiB0b2tlbiBpbiB0aGUgbGlzdCBvZiByZXN5bmNlZCB0b2tlbnNcbiAgICAvLyBhcyBFT0YgZG9lcyBub3QgcmVhbGx5IGV4aXN0IGFuZCB0aHVzIGRvZXMgbm90IGNvbnRhaW4gYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiAobGluZS9jb2x1bW4gbnVtYmVycylcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuYWRkVG9SZXN5bmNUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW4sIHJlc3luY1Rva2Vucykge1xuICAgICAgICBpZiAoIXRoaXMudG9rZW5NYXRjaGVyKHRva2VuLCB0b2tlbnNfcHVibGljXzEuRU9GKSkge1xuICAgICAgICAgICAgcmVzeW5jVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN5bmNUb2tlbnM7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUucmVTeW5jVG8gPSBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICB2YXIgcmVzeW5jZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIG5leHRUb2sgPSB0aGlzLkxBKDEpO1xuICAgICAgICB3aGlsZSAodGhpcy50b2tlbk1hdGNoZXIobmV4dFRvaywgdG9rVHlwZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBuZXh0VG9rID0gdGhpcy5TS0lQX1RPS0VOKCk7XG4gICAgICAgICAgICB0aGlzLmFkZFRvUmVzeW5jVG9rZW5zKG5leHRUb2ssIHJlc3luY2VkVG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgbGFzdCB0b2tlbiBpcyBub3QgcGFydCBvZiB0aGUgZXJyb3IuXG4gICAgICAgIHJldHVybiAoMCwgZHJvcFJpZ2h0XzEuZGVmYXVsdCkocmVzeW5jZWRUb2tlbnMpO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSA9IGZ1bmN0aW9uIChwcm9kRnVuYywgYXJncywgbG9va2FoZWFkRnVuYywgZHNsTWV0aG9kSWR4LCBwcm9kT2NjdXJyZW5jZSwgbmV4dFRva3NXYWxrZXIsIG5vdFN0dWNrKSB7XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgdGhpcyBpcyBhIE5PLU9QXG4gICAgICAgIC8vIFRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gaXMgd2l0aCB0aGUgZnVuY3Rpb24obm90IG1ldGhvZCkgYmVsb3dcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5nZXRDdXJyZW50R3JhbW1hclBhdGggPSBmdW5jdGlvbiAodG9rVHlwZSwgdG9rSWR4SW5SdWxlKSB7XG4gICAgICAgIHZhciBwYXRoUnVsZVN0YWNrID0gdGhpcy5nZXRIdW1hblJlYWRhYmxlUnVsZVN0YWNrKCk7XG4gICAgICAgIHZhciBwYXRoT2NjdXJyZW5jZVN0YWNrID0gKDAsIGNsb25lXzEuZGVmYXVsdCkodGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0spO1xuICAgICAgICB2YXIgZ3JhbW1hclBhdGggPSB7XG4gICAgICAgICAgICBydWxlU3RhY2s6IHBhdGhSdWxlU3RhY2ssXG4gICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IHBhdGhPY2N1cnJlbmNlU3RhY2ssXG4gICAgICAgICAgICBsYXN0VG9rOiB0b2tUeXBlLFxuICAgICAgICAgICAgbGFzdFRva09jY3VycmVuY2U6IHRva0lkeEluUnVsZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ3JhbW1hclBhdGg7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuZ2V0SHVtYW5SZWFkYWJsZVJ1bGVTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuICgwLCBtYXBfMS5kZWZhdWx0KSh0aGlzLlJVTEVfU1RBQ0ssIGZ1bmN0aW9uIChjdXJyU2hvcnROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUoY3VyclNob3J0TmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY292ZXJhYmxlO1xufSgpKTtcbmV4cG9ydHMuUmVjb3ZlcmFibGUgPSBSZWNvdmVyYWJsZTtcbmZ1bmN0aW9uIGF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeShwcm9kRnVuYywgYXJncywgbG9va2FoZWFkRnVuYywgZHNsTWV0aG9kSWR4LCBwcm9kT2NjdXJyZW5jZSwgbmV4dFRva3NXYWxrZXIsIG5vdFN0dWNrKSB7XG4gICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGRzbE1ldGhvZElkeCwgcHJvZE9jY3VycmVuY2UpO1xuICAgIHZhciBmaXJzdEFmdGVyUmVwSW5mbyA9IHRoaXMuZmlyc3RBZnRlclJlcE1hcFtrZXldO1xuICAgIGlmIChmaXJzdEFmdGVyUmVwSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBjdXJyUnVsZU5hbWUgPSB0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKTtcbiAgICAgICAgdmFyIHJ1bGVHcmFtbWFyID0gdGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKVtjdXJyUnVsZU5hbWVdO1xuICAgICAgICB2YXIgd2Fsa2VyID0gbmV3IG5leHRUb2tzV2Fsa2VyKHJ1bGVHcmFtbWFyLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIGZpcnN0QWZ0ZXJSZXBJbmZvID0gd2Fsa2VyLnN0YXJ0V2Fsa2luZygpO1xuICAgICAgICB0aGlzLmZpcnN0QWZ0ZXJSZXBNYXBba2V5XSA9IGZpcnN0QWZ0ZXJSZXBJbmZvO1xuICAgIH1cbiAgICB2YXIgZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2ggPSBmaXJzdEFmdGVyUmVwSW5mby50b2tlbjtcbiAgICB2YXIgbmV4dFRva0lkeCA9IGZpcnN0QWZ0ZXJSZXBJbmZvLm9jY3VycmVuY2U7XG4gICAgdmFyIGlzRW5kT2ZSdWxlID0gZmlyc3RBZnRlclJlcEluZm8uaXNFbmRPZlJ1bGU7XG4gICAgLy8gc3BlY2lhbCBlZGdlIGNhc2Ugb2YgYSBUT1AgbW9zdCByZXBldGl0aW9uIGFmdGVyIHdoaWNoIHRoZSBpbnB1dCBzaG91bGQgRU5ELlxuICAgIC8vIHRoaXMgd2lsbCBmb3JjZSBhbiBhdHRlbXB0IGZvciBpblJ1bGUgcmVjb3ZlcnkgaW4gdGhhdCBzY2VuYXJpby5cbiAgICBpZiAodGhpcy5SVUxFX1NUQUNLLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBpc0VuZE9mUnVsZSAmJlxuICAgICAgICBleHBlY3RUb2tBZnRlckxhc3RNYXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoID0gdG9rZW5zX3B1YmxpY18xLkVPRjtcbiAgICAgICAgbmV4dFRva0lkeCA9IDE7XG4gICAgfVxuICAgIC8vIFdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gcmUtc3luYyB0by4uLlxuICAgIC8vIHRoaXMgY29uZGl0aW9uIHdhcyBleHRyYWN0ZWQgZnJvbSBgc2hvdWxkSW5SZXBldGl0aW9uUmVjb3ZlcnlCZVRyaWVkYCB0byBhY3QgYXMgYSB0eXBlLWd1YXJkXG4gICAgaWYgKGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoID09PSB1bmRlZmluZWQgfHwgbmV4dFRva0lkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvdWxkSW5SZXBldGl0aW9uUmVjb3ZlcnlCZVRyaWVkKGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoLCBuZXh0VG9rSWR4LCBub3RTdHVjaykpIHtcbiAgICAgICAgLy8gVE9ETzogcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBpbnN0ZWFkIG9mIHBhc3NpbmcgdGhlIG9yaWdpbmFsIGFyZ3MgaGVyZSwgd2UgbW9kaWZ5XG4gICAgICAgIC8vIHRoZSBhcmdzIHBhcmFtIChvciBjcmVhdGUgYSBuZXcgb25lKSBhbmQgbWFrZSBzdXJlIHRoZSBsb29rYWhlYWQgZnVuYyBpcyBleHBsaWNpdGx5IHByb3ZpZGVkXG4gICAgICAgIC8vIHRvIGF2b2lkIHNlYXJjaGluZyB0aGUgY2FjaGUgZm9yIGl0IG9uY2UgbW9yZS5cbiAgICAgICAgdGhpcy50cnlJblJlcGV0aXRpb25SZWNvdmVyeShwcm9kRnVuYywgYXJncywgbG9va2FoZWFkRnVuYywgZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5ID0gYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjb3ZlcmFibGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TreeBuilder = void 0;\nvar cst_1 = __webpack_require__(/*! ../../cst/cst */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/cst/cst.js\");\nvar noop_1 = __importDefault(__webpack_require__(/*! lodash/noop */ \"(ssr)/./node_modules/lodash/noop.js\"));\nvar has_1 = __importDefault(__webpack_require__(/*! lodash/has */ \"(ssr)/./node_modules/lodash/has.js\"));\nvar keys_1 = __importDefault(__webpack_require__(/*! lodash/keys */ \"(ssr)/./node_modules/lodash/keys.js\"));\nvar isUndefined_1 = __importDefault(__webpack_require__(/*! lodash/isUndefined */ \"(ssr)/./node_modules/lodash/isUndefined.js\"));\nvar cst_visitor_1 = __webpack_require__(/*! ../../cst/cst_visitor */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js\");\nvar parser_1 = __webpack_require__(/*! ../parser */ \"(ssr)/./node_modules/chevrotain/lib/src/parse/parser/parser.js\");\n/**\n * This trait is responsible for the CST building logic.\n */\nvar TreeBuilder = /** @class */ (function () {\n    function TreeBuilder() {\n    }\n    TreeBuilder.prototype.initTreeBuilder = function (config) {\n        this.CST_STACK = [];\n        // outputCst is no longer exposed/defined in the pubic API\n        this.outputCst = config.outputCst;\n        this.nodeLocationTracking = (0, has_1.default)(config, \"nodeLocationTracking\")\n            ? config.nodeLocationTracking // assumes end user provides the correct config value/type\n            : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = noop_1.default;\n            this.cstFinallyStateUpdate = noop_1.default;\n            this.cstPostTerminal = noop_1.default;\n            this.cstPostNonTerminal = noop_1.default;\n            this.cstPostRule = noop_1.default;\n        }\n        else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = cst_1.setNodeLocationFull;\n                    this.setNodeLocationFromNode = cst_1.setNodeLocationFull;\n                    this.cstPostRule = noop_1.default;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop_1.default;\n                    this.setNodeLocationFromNode = noop_1.default;\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            }\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;\n                    this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;\n                    this.cstPostRule = noop_1.default;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop_1.default;\n                    this.setNodeLocationFromNode = noop_1.default;\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            }\n            else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = noop_1.default;\n                this.setNodeLocationFromNode = noop_1.default;\n                this.cstPostRule = noop_1.default;\n                this.setInitialNodeLocation = noop_1.default;\n            }\n            else {\n                throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\".concat(config.nodeLocationTracking, \"\\\"\"));\n            }\n        }\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n    TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n        var nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName) {\n        var cstNode = {\n            name: fullRuleName,\n            children: Object.create(null)\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    };\n    TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n        this.CST_STACK.pop();\n    };\n    TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n        // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n        var prevToken = this.LA(0);\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n        var prevToken = this.LA(0);\n        // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        (0, cst_1.addTerminalToCst)(rootCst, consumedToken, key);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    };\n    TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n        var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n        (0, cst_1.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n        if ((0, isUndefined_1.default)(this.baseCstVisitorConstructor)) {\n            var newBaseCstVisitorConstructor = (0, cst_visitor_1.createBaseSemanticVisitorConstructor)(this.className, (0, keys_1.default)(this.gastProductionsCache));\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n        if ((0, isUndefined_1.default)(this.baseCstVisitorWithDefaultsConstructor)) {\n            var newConstructor = (0, cst_visitor_1.createBaseVisitorConstructorWithDefaults)(this.className, (0, keys_1.default)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    };\n    TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    };\n    TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    };\n    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n        var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    };\n    return TreeBuilder;\n}());\nexports.TreeBuilder = TreeBuilder;\n//# sourceMappingURL=tree_builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvdHJlZV9idWlsZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLFlBQVksbUJBQU8sQ0FBQywrRUFBZTtBQUNuQyw2QkFBNkIsbUJBQU8sQ0FBQyx3REFBYTtBQUNsRCw0QkFBNEIsbUJBQU8sQ0FBQyxzREFBWTtBQUNoRCw2QkFBNkIsbUJBQU8sQ0FBQyx3REFBYTtBQUNsRCxvQ0FBb0MsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDaEUsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQXVCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxpRkFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvdHJlZV9idWlsZGVyLmpzPzQ3YjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyZWVCdWlsZGVyID0gdm9pZCAwO1xudmFyIGNzdF8xID0gcmVxdWlyZShcIi4uLy4uL2NzdC9jc3RcIik7XG52YXIgbm9vcF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvbm9vcFwiKSk7XG52YXIgaGFzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9oYXNcIikpO1xudmFyIGtleXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2tleXNcIikpO1xudmFyIGlzVW5kZWZpbmVkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc1VuZGVmaW5lZFwiKSk7XG52YXIgY3N0X3Zpc2l0b3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9jc3QvY3N0X3Zpc2l0b3JcIik7XG52YXIgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vcGFyc2VyXCIpO1xuLyoqXG4gKiBUaGlzIHRyYWl0IGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgQ1NUIGJ1aWxkaW5nIGxvZ2ljLlxuICovXG52YXIgVHJlZUJ1aWxkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJlZUJ1aWxkZXIoKSB7XG4gICAgfVxuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5pbml0VHJlZUJ1aWxkZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuQ1NUX1NUQUNLID0gW107XG4gICAgICAgIC8vIG91dHB1dENzdCBpcyBubyBsb25nZXIgZXhwb3NlZC9kZWZpbmVkIGluIHRoZSBwdWJpYyBBUElcbiAgICAgICAgdGhpcy5vdXRwdXRDc3QgPSBjb25maWcub3V0cHV0Q3N0O1xuICAgICAgICB0aGlzLm5vZGVMb2NhdGlvblRyYWNraW5nID0gKDAsIGhhc18xLmRlZmF1bHQpKGNvbmZpZywgXCJub2RlTG9jYXRpb25UcmFja2luZ1wiKVxuICAgICAgICAgICAgPyBjb25maWcubm9kZUxvY2F0aW9uVHJhY2tpbmcgLy8gYXNzdW1lcyBlbmQgdXNlciBwcm92aWRlcyB0aGUgY29ycmVjdCBjb25maWcgdmFsdWUvdHlwZVxuICAgICAgICAgICAgOiBwYXJzZXJfMS5ERUZBVUxUX1BBUlNFUl9DT05GSUcubm9kZUxvY2F0aW9uVHJhY2tpbmc7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRDc3QpIHtcbiAgICAgICAgICAgIHRoaXMuY3N0SW52b2NhdGlvblN0YXRlVXBkYXRlID0gbm9vcF8xLmRlZmF1bHQ7XG4gICAgICAgICAgICB0aGlzLmNzdEZpbmFsbHlTdGF0ZVVwZGF0ZSA9IG5vb3BfMS5kZWZhdWx0O1xuICAgICAgICAgICAgdGhpcy5jc3RQb3N0VGVybWluYWwgPSBub29wXzEuZGVmYXVsdDtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsID0gbm9vcF8xLmRlZmF1bHQ7XG4gICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlID0gbm9vcF8xLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoL2Z1bGwvaS50ZXN0KHRoaXMubm9kZUxvY2F0aW9uVHJhY2tpbmcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVjb3ZlcnlFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbVRva2VuID0gY3N0XzEuc2V0Tm9kZUxvY2F0aW9uRnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZSA9IGNzdF8xLnNldE5vZGVMb2NhdGlvbkZ1bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3N0UG9zdFJ1bGUgPSBub29wXzEuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uID0gdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uRnVsbFJlY292ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW4gPSBub29wXzEuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZSA9IG5vb3BfMS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlID0gdGhpcy5jc3RQb3N0UnVsZUZ1bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbiA9IHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbkZ1bGxSZWd1bGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKC9vbmx5T2Zmc2V0L2kudGVzdCh0aGlzLm5vZGVMb2NhdGlvblRyYWNraW5nKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY292ZXJ5RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IGNzdF8xLnNldE5vZGVMb2NhdGlvbk9ubHlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbU5vZGUgPSBjc3RfMS5zZXROb2RlTG9jYXRpb25Pbmx5T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlID0gbm9vcF8xLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVjb3Zlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IG5vb3BfMS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlID0gbm9vcF8xLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3N0UG9zdFJ1bGUgPSB0aGlzLmNzdFBvc3RSdWxlT25seU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbk9ubHlPZmZzZXRSZWd1bGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKC9ub25lL2kudGVzdCh0aGlzLm5vZGVMb2NhdGlvblRyYWNraW5nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbVRva2VuID0gbm9vcF8xLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZSA9IG5vb3BfMS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIHRoaXMuY3N0UG9zdFJ1bGUgPSBub29wXzEuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb24gPSBub29wXzEuZGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCA8bm9kZUxvY2F0aW9uVHJhY2tpbmc+IGNvbmZpZyBvcHRpb246IFxcXCJcIi5jb25jYXQoY29uZmlnLm5vZGVMb2NhdGlvblRyYWNraW5nLCBcIlxcXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbk9ubHlPZmZzZXRSZWNvdmVyeSA9IGZ1bmN0aW9uIChjc3ROb2RlKSB7XG4gICAgICAgIGNzdE5vZGUubG9jYXRpb24gPSB7XG4gICAgICAgICAgICBzdGFydE9mZnNldDogTmFOLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBOYU5cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5zZXRJbml0aWFsTm9kZUxvY2F0aW9uT25seU9mZnNldFJlZ3VsYXIgPSBmdW5jdGlvbiAoY3N0Tm9kZSkge1xuICAgICAgICBjc3ROb2RlLmxvY2F0aW9uID0ge1xuICAgICAgICAgICAgLy8gd2l0aG91dCBlcnJvciByZWNvdmVyeSB0aGUgc3RhcnRpbmcgTG9jYXRpb24gb2YgYSBuZXcgQ3N0Tm9kZSBpcyBndWFyYW50ZWVkXG4gICAgICAgICAgICAvLyBUbyBiZSB0aGUgbmV4dCBUb2tlbidzIHN0YXJ0T2Zmc2V0IChmb3IgdmFsaWQgaW5wdXRzKS5cbiAgICAgICAgICAgIC8vIEZvciBpbnZhbGlkIGlucHV0cyB0aGVyZSB3b24ndCBiZSBhbnkgQ1NUT3V0cHV0IHNvIHRoaXMgcG90ZW50aWFsXG4gICAgICAgICAgICAvLyBpbmFjY3VyYWN5IGRvZXMgbm90IG1hdHRlclxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHRoaXMuTEEoMSkuc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IE5hTlxuICAgICAgICB9O1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLnNldEluaXRpYWxOb2RlTG9jYXRpb25GdWxsUmVjb3ZlcnkgPSBmdW5jdGlvbiAoY3N0Tm9kZSkge1xuICAgICAgICBjc3ROb2RlLmxvY2F0aW9uID0ge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IE5hTixcbiAgICAgICAgICAgIHN0YXJ0TGluZTogTmFOLFxuICAgICAgICAgICAgc3RhcnRDb2x1bW46IE5hTixcbiAgICAgICAgICAgIGVuZE9mZnNldDogTmFOLFxuICAgICAgICAgICAgZW5kTGluZTogTmFOLFxuICAgICAgICAgICAgZW5kQ29sdW1uOiBOYU5cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAgICogIEBzZWUgc2V0SW5pdGlhbE5vZGVMb2NhdGlvbk9ubHlPZmZzZXRSZWd1bGFyIGZvciBleHBsYW5hdGlvbiB3aHkgdGhpcyB3b3JrXG4gIFxuICAgICAgICogQHBhcmFtIGNzdE5vZGVcbiAgICAgICAqL1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5zZXRJbml0aWFsTm9kZUxvY2F0aW9uRnVsbFJlZ3VsYXIgPSBmdW5jdGlvbiAoY3N0Tm9kZSkge1xuICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgY3N0Tm9kZS5sb2NhdGlvbiA9IHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBuZXh0VG9rZW4uc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICBzdGFydExpbmU6IG5leHRUb2tlbi5zdGFydExpbmUsXG4gICAgICAgICAgICBzdGFydENvbHVtbjogbmV4dFRva2VuLnN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBOYU4sXG4gICAgICAgICAgICBlbmRMaW5lOiBOYU4sXG4gICAgICAgICAgICBlbmRDb2x1bW46IE5hTlxuICAgICAgICB9O1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmNzdEludm9jYXRpb25TdGF0ZVVwZGF0ZSA9IGZ1bmN0aW9uIChmdWxsUnVsZU5hbWUpIHtcbiAgICAgICAgdmFyIGNzdE5vZGUgPSB7XG4gICAgICAgICAgICBuYW1lOiBmdWxsUnVsZU5hbWUsXG4gICAgICAgICAgICBjaGlsZHJlbjogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb24oY3N0Tm9kZSk7XG4gICAgICAgIHRoaXMuQ1NUX1NUQUNLLnB1c2goY3N0Tm9kZSk7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuY3N0RmluYWxseVN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLkNTVF9TVEFDSy5wb3AoKTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5jc3RQb3N0UnVsZUZ1bGwgPSBmdW5jdGlvbiAocnVsZUNzdE5vZGUpIHtcbiAgICAgICAgLy8gY2FzdHMgdG8gYHJlcXVpcmVkPENzdE5vZGVMb2NhdGlvbj5gIGFyZSBzYWZlIGJlY2F1c2UgYGNzdFBvc3RSdWxlRnVsbGAgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGZ1bGwgbG9jYXRpb24gaXMgZW5hYmxlZFxuICAgICAgICB2YXIgcHJldlRva2VuID0gdGhpcy5MQSgwKTtcbiAgICAgICAgdmFyIGxvYyA9IHJ1bGVDc3ROb2RlLmxvY2F0aW9uO1xuICAgICAgICAvLyBJZiB0aGlzIGNvbmRpdGlvbiBpcyB0cnVlIGl0IG1lYW5zIHdlIGNvbnN1bWVkIGF0IGxlYXN0IG9uZSBUb2tlblxuICAgICAgICAvLyBJbiB0aGlzIENzdE5vZGUuXG4gICAgICAgIGlmIChsb2Muc3RhcnRPZmZzZXQgPD0gcHJldlRva2VuLnN0YXJ0T2Zmc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBsb2MuZW5kT2Zmc2V0ID0gcHJldlRva2VuLmVuZE9mZnNldDtcbiAgICAgICAgICAgIGxvYy5lbmRMaW5lID0gcHJldlRva2VuLmVuZExpbmU7XG4gICAgICAgICAgICBsb2MuZW5kQ29sdW1uID0gcHJldlRva2VuLmVuZENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBcImVtcHR5XCIgQ3N0Tm9kZSBlZGdlIGNhc2VcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2Muc3RhcnRPZmZzZXQgPSBOYU47XG4gICAgICAgICAgICBsb2Muc3RhcnRMaW5lID0gTmFOO1xuICAgICAgICAgICAgbG9jLnN0YXJ0Q29sdW1uID0gTmFOO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuY3N0UG9zdFJ1bGVPbmx5T2Zmc2V0ID0gZnVuY3Rpb24gKHJ1bGVDc3ROb2RlKSB7XG4gICAgICAgIHZhciBwcmV2VG9rZW4gPSB0aGlzLkxBKDApO1xuICAgICAgICAvLyBgbG9jYXRpb24nIGlzIG5vdCBudWxsIGJlY2F1c2UgYGNzdFBvc3RSdWxlT25seU9mZnNldGAgd2lsbCBvbmx5IGJlIGludm9rZWQgd2hlbiBsb2NhdGlvbiB0cmFja2luZyBpcyBlbmFibGVkLlxuICAgICAgICB2YXIgbG9jID0gcnVsZUNzdE5vZGUubG9jYXRpb247XG4gICAgICAgIC8vIElmIHRoaXMgY29uZGl0aW9uIGlzIHRydWUgaXQgbWVhbnMgd2UgY29uc3VtZWQgYXQgbGVhc3Qgb25lIFRva2VuXG4gICAgICAgIC8vIEluIHRoaXMgQ3N0Tm9kZS5cbiAgICAgICAgaWYgKGxvYy5zdGFydE9mZnNldCA8PSBwcmV2VG9rZW4uc3RhcnRPZmZzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGxvYy5lbmRPZmZzZXQgPSBwcmV2VG9rZW4uZW5kT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiZW1wdHlcIiBDc3ROb2RlIGVkZ2UgY2FzZVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvYy5zdGFydE9mZnNldCA9IE5hTjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmNzdFBvc3RUZXJtaW5hbCA9IGZ1bmN0aW9uIChrZXksIGNvbnN1bWVkVG9rZW4pIHtcbiAgICAgICAgdmFyIHJvb3RDc3QgPSB0aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGggLSAxXTtcbiAgICAgICAgKDAsIGNzdF8xLmFkZFRlcm1pbmFsVG9Dc3QpKHJvb3RDc3QsIGNvbnN1bWVkVG9rZW4sIGtleSk7XG4gICAgICAgIC8vIFRoaXMgaXMgb25seSB1c2VkIHdoZW4gKipib3RoKiogZXJyb3IgcmVjb3ZlcnkgYW5kIENTVCBPdXRwdXQgYXJlIGVuYWJsZWQuXG4gICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbVRva2VuKHJvb3RDc3QubG9jYXRpb24sIGNvbnN1bWVkVG9rZW4pO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmNzdFBvc3ROb25UZXJtaW5hbCA9IGZ1bmN0aW9uIChydWxlQ3N0UmVzdWx0LCBydWxlTmFtZSkge1xuICAgICAgICB2YXIgcHJlQ3N0Tm9kZSA9IHRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aCAtIDFdO1xuICAgICAgICAoMCwgY3N0XzEuYWRkTm9uZVRlcm1pbmFsVG9Dc3QpKHByZUNzdE5vZGUsIHJ1bGVOYW1lLCBydWxlQ3N0UmVzdWx0KTtcbiAgICAgICAgLy8gVGhpcyBpcyBvbmx5IHVzZWQgd2hlbiAqKmJvdGgqKiBlcnJvciByZWNvdmVyeSBhbmQgQ1NUIE91dHB1dCBhcmUgZW5hYmxlZC5cbiAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZShwcmVDc3ROb2RlLmxvY2F0aW9uLCBydWxlQ3N0UmVzdWx0LmxvY2F0aW9uKTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5nZXRCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoKDAsIGlzVW5kZWZpbmVkXzEuZGVmYXVsdCkodGhpcy5iYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yKSkge1xuICAgICAgICAgICAgdmFyIG5ld0Jhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IgPSAoMCwgY3N0X3Zpc2l0b3JfMS5jcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3IpKHRoaXMuY2xhc3NOYW1lLCAoMCwga2V5c18xLmRlZmF1bHQpKHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvciA9IG5ld0Jhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gbmV3QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgoMCwgaXNVbmRlZmluZWRfMS5kZWZhdWx0KSh0aGlzLmJhc2VDc3RWaXNpdG9yV2l0aERlZmF1bHRzQ29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICB2YXIgbmV3Q29uc3RydWN0b3IgPSAoMCwgY3N0X3Zpc2l0b3JfMS5jcmVhdGVCYXNlVmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzKSh0aGlzLmNsYXNzTmFtZSwgKDAsIGtleXNfMS5kZWZhdWx0KSh0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKSwgdGhpcy5nZXRCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yKCkpO1xuICAgICAgICAgICAgdGhpcy5iYXNlQ3N0VmlzaXRvcldpdGhEZWZhdWx0c0NvbnN0cnVjdG9yID0gbmV3Q29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gbmV3Q29uc3RydWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUNzdFZpc2l0b3JXaXRoRGVmYXVsdHNDb25zdHJ1Y3RvcjtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcnVsZVN0YWNrID0gdGhpcy5SVUxFX1NUQUNLO1xuICAgICAgICByZXR1cm4gcnVsZVN0YWNrW3J1bGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5nZXRQcmV2aW91c0V4cGxpY2l0UnVsZVNob3J0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJ1bGVTdGFjayA9IHRoaXMuUlVMRV9TVEFDSztcbiAgICAgICAgcmV0dXJuIHJ1bGVTdGFja1tydWxlU3RhY2subGVuZ3RoIC0gMl07XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuZ2V0TGFzdEV4cGxpY2l0UnVsZU9jY3VycmVuY2VJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9jY3VycmVuY2VTdGFjayA9IHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLO1xuICAgICAgICByZXR1cm4gb2NjdXJyZW5jZVN0YWNrW29jY3VycmVuY2VTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIHJldHVybiBUcmVlQnVpbGRlcjtcbn0oKSk7XG5leHBvcnRzLlRyZWVCdWlsZGVyID0gVHJlZUJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmVlX2J1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js":
/*!****************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.applyMixins = void 0;\nfunction applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach(function (baseCtor) {\n        var baseProto = baseCtor.prototype;\n        Object.getOwnPropertyNames(baseProto).forEach(function (propName) {\n            if (propName === \"constructor\") {\n                return;\n            }\n            var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n            // Handle Accessors\n            if (basePropDescriptor &&\n                (basePropDescriptor.get || basePropDescriptor.set)) {\n                Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n            }\n            else {\n                derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n            }\n        });\n    });\n}\nexports.applyMixins = applyMixins;\n//# sourceMappingURL=apply_mixins.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci91dGlscy9hcHBseV9taXhpbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci91dGlscy9hcHBseV9taXhpbnMuanM/YjI3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXBwbHlNaXhpbnMgPSB2b2lkIDA7XG5mdW5jdGlvbiBhcHBseU1peGlucyhkZXJpdmVkQ3RvciwgYmFzZUN0b3JzKSB7XG4gICAgYmFzZUN0b3JzLmZvckVhY2goZnVuY3Rpb24gKGJhc2VDdG9yKSB7XG4gICAgICAgIHZhciBiYXNlUHJvdG8gPSBiYXNlQ3Rvci5wcm90b3R5cGU7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGJhc2VQcm90bykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wTmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJhc2VQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZVByb3RvLCBwcm9wTmFtZSk7XG4gICAgICAgICAgICAvLyBIYW5kbGUgQWNjZXNzb3JzXG4gICAgICAgICAgICBpZiAoYmFzZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgICAgKGJhc2VQcm9wRGVzY3JpcHRvci5nZXQgfHwgYmFzZVByb3BEZXNjcmlwdG9yLnNldCkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVyaXZlZEN0b3IucHJvdG90eXBlLCBwcm9wTmFtZSwgYmFzZVByb3BEZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcml2ZWRDdG9yLnByb3RvdHlwZVtwcm9wTmFtZV0gPSBiYXNlQ3Rvci5wcm90b3R5cGVbcHJvcE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYXBwbHlNaXhpbnMgPSBhcHBseU1peGlucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGx5X21peGlucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/scan/lexer.js":
/*!*******************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/lexer.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.charCodeToOptimizedIndex = exports.minOptimizationVal = exports.buildLineBreakIssueMessage = exports.LineTerminatorOptimizedTester = exports.isShortPattern = exports.isCustomPattern = exports.cloneEmptyGroups = exports.performWarningRuntimeChecks = exports.performRuntimeChecks = exports.addStickyFlag = exports.addStartOfInput = exports.findUnreachablePatterns = exports.findModesThatDoNotExist = exports.findInvalidGroupType = exports.findDuplicatePatterns = exports.findUnsupportedFlags = exports.findStartOfInputAnchor = exports.findEmptyMatchRegExps = exports.findEndOfInputAnchor = exports.findInvalidPatterns = exports.findMissingPatterns = exports.validatePatterns = exports.analyzeTokenTypes = exports.enableSticky = exports.disableSticky = exports.SUPPORT_STICKY = exports.MODES = exports.DEFAULT_MODE = void 0;\nvar regexp_to_ast_1 = __webpack_require__(/*! regexp-to-ast */ \"(ssr)/./node_modules/regexp-to-ast/lib/regexp-to-ast.js\");\nvar lexer_public_1 = __webpack_require__(/*! ./lexer_public */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/lexer_public.js\");\nvar first_1 = __importDefault(__webpack_require__(/*! lodash/first */ \"(ssr)/./node_modules/lodash/first.js\"));\nvar isEmpty_1 = __importDefault(__webpack_require__(/*! lodash/isEmpty */ \"(ssr)/./node_modules/lodash/isEmpty.js\"));\nvar compact_1 = __importDefault(__webpack_require__(/*! lodash/compact */ \"(ssr)/./node_modules/lodash/compact.js\"));\nvar isArray_1 = __importDefault(__webpack_require__(/*! lodash/isArray */ \"(ssr)/./node_modules/lodash/isArray.js\"));\nvar values_1 = __importDefault(__webpack_require__(/*! lodash/values */ \"(ssr)/./node_modules/lodash/values.js\"));\nvar flatten_1 = __importDefault(__webpack_require__(/*! lodash/flatten */ \"(ssr)/./node_modules/lodash/flatten.js\"));\nvar reject_1 = __importDefault(__webpack_require__(/*! lodash/reject */ \"(ssr)/./node_modules/lodash/reject.js\"));\nvar difference_1 = __importDefault(__webpack_require__(/*! lodash/difference */ \"(ssr)/./node_modules/lodash/difference.js\"));\nvar indexOf_1 = __importDefault(__webpack_require__(/*! lodash/indexOf */ \"(ssr)/./node_modules/lodash/indexOf.js\"));\nvar map_1 = __importDefault(__webpack_require__(/*! lodash/map */ \"(ssr)/./node_modules/lodash/map.js\"));\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar isString_1 = __importDefault(__webpack_require__(/*! lodash/isString */ \"(ssr)/./node_modules/lodash/isString.js\"));\nvar isFunction_1 = __importDefault(__webpack_require__(/*! lodash/isFunction */ \"(ssr)/./node_modules/lodash/isFunction.js\"));\nvar isUndefined_1 = __importDefault(__webpack_require__(/*! lodash/isUndefined */ \"(ssr)/./node_modules/lodash/isUndefined.js\"));\nvar find_1 = __importDefault(__webpack_require__(/*! lodash/find */ \"(ssr)/./node_modules/lodash/find.js\"));\nvar has_1 = __importDefault(__webpack_require__(/*! lodash/has */ \"(ssr)/./node_modules/lodash/has.js\"));\nvar keys_1 = __importDefault(__webpack_require__(/*! lodash/keys */ \"(ssr)/./node_modules/lodash/keys.js\"));\nvar isRegExp_1 = __importDefault(__webpack_require__(/*! lodash/isRegExp */ \"(ssr)/./node_modules/lodash/isRegExp.js\"));\nvar filter_1 = __importDefault(__webpack_require__(/*! lodash/filter */ \"(ssr)/./node_modules/lodash/filter.js\"));\nvar defaults_1 = __importDefault(__webpack_require__(/*! lodash/defaults */ \"(ssr)/./node_modules/lodash/defaults.js\"));\nvar reduce_1 = __importDefault(__webpack_require__(/*! lodash/reduce */ \"(ssr)/./node_modules/lodash/reduce.js\"));\nvar includes_1 = __importDefault(__webpack_require__(/*! lodash/includes */ \"(ssr)/./node_modules/lodash/includes.js\"));\nvar utils_1 = __webpack_require__(/*! @chevrotain/utils */ \"(ssr)/./node_modules/@chevrotain/utils/lib/src/api.js\");\nvar reg_exp_1 = __webpack_require__(/*! ./reg_exp */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/reg_exp.js\");\nvar reg_exp_parser_1 = __webpack_require__(/*! ./reg_exp_parser */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js\");\nvar PATTERN = \"PATTERN\";\nexports.DEFAULT_MODE = \"defaultMode\";\nexports.MODES = \"modes\";\nexports.SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nfunction disableSticky() {\n    exports.SUPPORT_STICKY = false;\n}\nexports.disableSticky = disableSticky;\nfunction enableSticky() {\n    exports.SUPPORT_STICKY = true;\n}\nexports.enableSticky = enableSticky;\nfunction analyzeTokenTypes(tokenTypes, options) {\n    options = (0, defaults_1.default)(options, {\n        useSticky: exports.SUPPORT_STICKY,\n        debug: false,\n        safeMode: false,\n        positionTracking: \"full\",\n        lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n        tracer: function (msg, action) { return action(); }\n    });\n    var tracer = options.tracer;\n    tracer(\"initCharCodeToOptimizedIndexMap\", function () {\n        initCharCodeToOptimizedIndexMap();\n    });\n    var onlyRelevantTypes;\n    tracer(\"Reject Lexer.NA\", function () {\n        onlyRelevantTypes = (0, reject_1.default)(tokenTypes, function (currType) {\n            return currType[PATTERN] === lexer_public_1.Lexer.NA;\n        });\n    });\n    var hasCustom = false;\n    var allTransformedPatterns;\n    tracer(\"Transform Patterns\", function () {\n        hasCustom = false;\n        allTransformedPatterns = (0, map_1.default)(onlyRelevantTypes, function (currType) {\n            var currPattern = currType[PATTERN];\n            /* istanbul ignore else */\n            if ((0, isRegExp_1.default)(currPattern)) {\n                var regExpSource = currPattern.source;\n                if (regExpSource.length === 1 &&\n                    // only these regExp meta characters which can appear in a length one regExp\n                    regExpSource !== \"^\" &&\n                    regExpSource !== \"$\" &&\n                    regExpSource !== \".\" &&\n                    !currPattern.ignoreCase) {\n                    return regExpSource;\n                }\n                else if (regExpSource.length === 2 &&\n                    regExpSource[0] === \"\\\\\" &&\n                    // not a meta character\n                    !(0, includes_1.default)([\n                        \"d\",\n                        \"D\",\n                        \"s\",\n                        \"S\",\n                        \"t\",\n                        \"r\",\n                        \"n\",\n                        \"t\",\n                        \"0\",\n                        \"c\",\n                        \"b\",\n                        \"B\",\n                        \"f\",\n                        \"v\",\n                        \"w\",\n                        \"W\"\n                    ], regExpSource[1])) {\n                    // escaped meta Characters: /\\+/ /\\[/\n                    // or redundant escaping: /\\a/\n                    // without the escaping \"\\\"\n                    return regExpSource[1];\n                }\n                else {\n                    return options.useSticky\n                        ? addStickyFlag(currPattern)\n                        : addStartOfInput(currPattern);\n                }\n            }\n            else if ((0, isFunction_1.default)(currPattern)) {\n                hasCustom = true;\n                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n                return { exec: currPattern };\n            }\n            else if (typeof currPattern === \"object\") {\n                hasCustom = true;\n                // ICustomPattern\n                return currPattern;\n            }\n            else if (typeof currPattern === \"string\") {\n                if (currPattern.length === 1) {\n                    return currPattern;\n                }\n                else {\n                    var escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n                    var wrappedRegExp = new RegExp(escapedRegExpString);\n                    return options.useSticky\n                        ? addStickyFlag(wrappedRegExp)\n                        : addStartOfInput(wrappedRegExp);\n                }\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    });\n    var patternIdxToType;\n    var patternIdxToGroup;\n    var patternIdxToLongerAltIdxArr;\n    var patternIdxToPushMode;\n    var patternIdxToPopMode;\n    tracer(\"misc mapping\", function () {\n        patternIdxToType = (0, map_1.default)(onlyRelevantTypes, function (currType) { return currType.tokenTypeIdx; });\n        patternIdxToGroup = (0, map_1.default)(onlyRelevantTypes, function (clazz) {\n            var groupName = clazz.GROUP;\n            /* istanbul ignore next */\n            if (groupName === lexer_public_1.Lexer.SKIPPED) {\n                return undefined;\n            }\n            else if ((0, isString_1.default)(groupName)) {\n                return groupName;\n            }\n            else if ((0, isUndefined_1.default)(groupName)) {\n                return false;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n        patternIdxToLongerAltIdxArr = (0, map_1.default)(onlyRelevantTypes, function (clazz) {\n            var longerAltType = clazz.LONGER_ALT;\n            if (longerAltType) {\n                var longerAltIdxArr = (0, isArray_1.default)(longerAltType)\n                    ? (0, map_1.default)(longerAltType, function (type) { return (0, indexOf_1.default)(onlyRelevantTypes, type); })\n                    : [(0, indexOf_1.default)(onlyRelevantTypes, longerAltType)];\n                return longerAltIdxArr;\n            }\n        });\n        patternIdxToPushMode = (0, map_1.default)(onlyRelevantTypes, function (clazz) { return clazz.PUSH_MODE; });\n        patternIdxToPopMode = (0, map_1.default)(onlyRelevantTypes, function (clazz) {\n            return (0, has_1.default)(clazz, \"POP_MODE\");\n        });\n    });\n    var patternIdxToCanLineTerminator;\n    tracer(\"Line Terminator Handling\", function () {\n        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n        patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function (tokType) { return false; });\n        if (options.positionTracking !== \"onlyOffset\") {\n            patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function (tokType) {\n                if ((0, has_1.default)(tokType, \"LINE_BREAKS\")) {\n                    return !!tokType.LINE_BREAKS;\n                }\n                else {\n                    return (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\n                        (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN));\n                }\n            });\n        }\n    });\n    var patternIdxToIsCustom;\n    var patternIdxToShort;\n    var emptyGroups;\n    var patternIdxToConfig;\n    tracer(\"Misc Mapping #2\", function () {\n        patternIdxToIsCustom = (0, map_1.default)(onlyRelevantTypes, isCustomPattern);\n        patternIdxToShort = (0, map_1.default)(allTransformedPatterns, isShortPattern);\n        emptyGroups = (0, reduce_1.default)(onlyRelevantTypes, function (acc, clazz) {\n            var groupName = clazz.GROUP;\n            if ((0, isString_1.default)(groupName) && !(groupName === lexer_public_1.Lexer.SKIPPED)) {\n                acc[groupName] = [];\n            }\n            return acc;\n        }, {});\n        patternIdxToConfig = (0, map_1.default)(allTransformedPatterns, function (x, idx) {\n            return {\n                pattern: allTransformedPatterns[idx],\n                longerAlt: patternIdxToLongerAltIdxArr[idx],\n                canLineTerminator: patternIdxToCanLineTerminator[idx],\n                isCustom: patternIdxToIsCustom[idx],\n                short: patternIdxToShort[idx],\n                group: patternIdxToGroup[idx],\n                push: patternIdxToPushMode[idx],\n                pop: patternIdxToPopMode[idx],\n                tokenTypeIdx: patternIdxToType[idx],\n                tokenType: onlyRelevantTypes[idx]\n            };\n        });\n    });\n    var canBeOptimized = true;\n    var charCodeToPatternIdxToConfig = [];\n    if (!options.safeMode) {\n        tracer(\"First Char Optimization\", function () {\n            charCodeToPatternIdxToConfig = (0, reduce_1.default)(onlyRelevantTypes, function (result, currTokType, idx) {\n                if (typeof currTokType.PATTERN === \"string\") {\n                    var charCode = currTokType.PATTERN.charCodeAt(0);\n                    var optimizedIdx = charCodeToOptimizedIndex(charCode);\n                    addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n                }\n                else if ((0, isArray_1.default)(currTokType.START_CHARS_HINT)) {\n                    var lastOptimizedIdx_1;\n                    (0, forEach_1.default)(currTokType.START_CHARS_HINT, function (charOrInt) {\n                        var charCode = typeof charOrInt === \"string\"\n                            ? charOrInt.charCodeAt(0)\n                            : charOrInt;\n                        var currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n                        // Avoid adding the config multiple times\n                        /* istanbul ignore else */\n                        // - Difficult to check this scenario effects as it is only a performance\n                        //   optimization that does not change correctness\n                        if (lastOptimizedIdx_1 !== currOptimizedIdx) {\n                            lastOptimizedIdx_1 = currOptimizedIdx;\n                            addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n                        }\n                    });\n                }\n                else if ((0, isRegExp_1.default)(currTokType.PATTERN)) {\n                    if (currTokType.PATTERN.unicode) {\n                        canBeOptimized = false;\n                        if (options.ensureOptimizations) {\n                            (0, utils_1.PRINT_ERROR)(\"\".concat(reg_exp_1.failedOptimizationPrefixMsg) +\n                                \"\\tUnable to analyze < \".concat(currTokType.PATTERN.toString(), \" > pattern.\\n\") +\n                                \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                                \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                                \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n                        }\n                    }\n                    else {\n                        var optimizedCodes = (0, reg_exp_1.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);\n                        /* istanbul ignore if */\n                        // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n                        // the first should be a different validation and the second cannot be tested.\n                        if ((0, isEmpty_1.default)(optimizedCodes)) {\n                            // we cannot understand what codes may start possible matches\n                            // The optimization correctness requires knowing start codes for ALL patterns.\n                            // Not actually sure this is an error, no debug message\n                            canBeOptimized = false;\n                        }\n                        (0, forEach_1.default)(optimizedCodes, function (code) {\n                            addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n                        });\n                    }\n                }\n                else {\n                    if (options.ensureOptimizations) {\n                        (0, utils_1.PRINT_ERROR)(\"\".concat(reg_exp_1.failedOptimizationPrefixMsg) +\n                            \"\\tTokenType: <\".concat(currTokType.name, \"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\") +\n                            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n                    }\n                    canBeOptimized = false;\n                }\n                return result;\n            }, []);\n        });\n    }\n    return {\n        emptyGroups: emptyGroups,\n        patternIdxToConfig: patternIdxToConfig,\n        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n        hasCustom: hasCustom,\n        canBeOptimized: canBeOptimized\n    };\n}\nexports.analyzeTokenTypes = analyzeTokenTypes;\nfunction validatePatterns(tokenTypes, validModesNames) {\n    var errors = [];\n    var missingResult = findMissingPatterns(tokenTypes);\n    errors = errors.concat(missingResult.errors);\n    var invalidResult = findInvalidPatterns(missingResult.valid);\n    var validTokenTypes = invalidResult.valid;\n    errors = errors.concat(invalidResult.errors);\n    errors = errors.concat(validateRegExpPattern(validTokenTypes));\n    errors = errors.concat(findInvalidGroupType(validTokenTypes));\n    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n    errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n    return errors;\n}\nexports.validatePatterns = validatePatterns;\nfunction validateRegExpPattern(tokenTypes) {\n    var errors = [];\n    var withRegExpPatterns = (0, filter_1.default)(tokenTypes, function (currTokType) {\n        return (0, isRegExp_1.default)(currTokType[PATTERN]);\n    });\n    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n    return errors;\n}\nfunction findMissingPatterns(tokenTypes) {\n    var tokenTypesWithMissingPattern = (0, filter_1.default)(tokenTypes, function (currType) {\n        return !(0, has_1.default)(currType, PATTERN);\n    });\n    var errors = (0, map_1.default)(tokenTypesWithMissingPattern, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- missing static 'PATTERN' property\",\n            type: lexer_public_1.LexerDefinitionErrorType.MISSING_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithMissingPattern);\n    return { errors: errors, valid: valid };\n}\nexports.findMissingPatterns = findMissingPatterns;\nfunction findInvalidPatterns(tokenTypes) {\n    var tokenTypesWithInvalidPattern = (0, filter_1.default)(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return (!(0, isRegExp_1.default)(pattern) &&\n            !(0, isFunction_1.default)(pattern) &&\n            !(0, has_1.default)(pattern, \"exec\") &&\n            !(0, isString_1.default)(pattern));\n    });\n    var errors = (0, map_1.default)(tokenTypesWithInvalidPattern, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' can only be a RegExp, a\" +\n                \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n            type: lexer_public_1.LexerDefinitionErrorType.INVALID_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithInvalidPattern);\n    return { errors: errors, valid: valid };\n}\nexports.findInvalidPatterns = findInvalidPatterns;\nvar end_of_input = /[^\\\\][$]/;\nfunction findEndOfInputAnchor(tokenTypes) {\n    var EndAnchorFinder = /** @class */ (function (_super) {\n        __extends(EndAnchorFinder, _super);\n        function EndAnchorFinder() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.found = false;\n            return _this;\n        }\n        EndAnchorFinder.prototype.visitEndAnchor = function (node) {\n            this.found = true;\n        };\n        return EndAnchorFinder;\n    }(regexp_to_ast_1.BaseRegExpVisitor));\n    var invalidRegex = (0, filter_1.default)(tokenTypes, function (currType) {\n        var pattern = currType.PATTERN;\n        try {\n            var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);\n            var endAnchorVisitor = new EndAnchorFinder();\n            endAnchorVisitor.visit(regexpAst);\n            return endAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return end_of_input.test(pattern.source);\n        }\n    });\n    var errors = (0, map_1.default)(invalidRegex, function (currType) {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n                \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: lexer_public_1.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nexports.findEndOfInputAnchor = findEndOfInputAnchor;\nfunction findEmptyMatchRegExps(tokenTypes) {\n    var matchesEmptyString = (0, filter_1.default)(tokenTypes, function (currType) {\n        var pattern = currType.PATTERN;\n        return pattern.test(\"\");\n    });\n    var errors = (0, map_1.default)(matchesEmptyString, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' must not match an empty string\",\n            type: lexer_public_1.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nexports.findEmptyMatchRegExps = findEmptyMatchRegExps;\nvar start_of_input = /[^\\\\[][\\^]|^\\^/;\nfunction findStartOfInputAnchor(tokenTypes) {\n    var StartAnchorFinder = /** @class */ (function (_super) {\n        __extends(StartAnchorFinder, _super);\n        function StartAnchorFinder() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.found = false;\n            return _this;\n        }\n        StartAnchorFinder.prototype.visitStartAnchor = function (node) {\n            this.found = true;\n        };\n        return StartAnchorFinder;\n    }(regexp_to_ast_1.BaseRegExpVisitor));\n    var invalidRegex = (0, filter_1.default)(tokenTypes, function (currType) {\n        var pattern = currType.PATTERN;\n        try {\n            var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);\n            var startAnchorVisitor = new StartAnchorFinder();\n            startAnchorVisitor.visit(regexpAst);\n            return startAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return start_of_input.test(pattern.source);\n        }\n    });\n    var errors = (0, map_1.default)(invalidRegex, function (currType) {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n                \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: lexer_public_1.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nexports.findStartOfInputAnchor = findStartOfInputAnchor;\nfunction findUnsupportedFlags(tokenTypes) {\n    var invalidFlags = (0, filter_1.default)(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n    });\n    var errors = (0, map_1.default)(invalidFlags, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n            type: lexer_public_1.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nexports.findUnsupportedFlags = findUnsupportedFlags;\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nfunction findDuplicatePatterns(tokenTypes) {\n    var found = [];\n    var identicalPatterns = (0, map_1.default)(tokenTypes, function (outerType) {\n        return (0, reduce_1.default)(tokenTypes, function (result, innerType) {\n            if (outerType.PATTERN.source === innerType.PATTERN.source &&\n                !(0, includes_1.default)(found, innerType) &&\n                innerType.PATTERN !== lexer_public_1.Lexer.NA) {\n                // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n                // in essence we are creating Equivalence classes on equality relation.\n                found.push(innerType);\n                result.push(innerType);\n                return result;\n            }\n            return result;\n        }, []);\n    });\n    identicalPatterns = (0, compact_1.default)(identicalPatterns);\n    var duplicatePatterns = (0, filter_1.default)(identicalPatterns, function (currIdenticalSet) {\n        return currIdenticalSet.length > 1;\n    });\n    var errors = (0, map_1.default)(duplicatePatterns, function (setOfIdentical) {\n        var tokenTypeNames = (0, map_1.default)(setOfIdentical, function (currType) {\n            return currType.name;\n        });\n        var dupPatternSrc = (0, first_1.default)(setOfIdentical).PATTERN;\n        return {\n            message: \"The same RegExp pattern ->\".concat(dupPatternSrc, \"<-\") +\n                \"has been used in all of the following Token Types: \".concat(tokenTypeNames.join(\", \"), \" <-\"),\n            type: lexer_public_1.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n            tokenTypes: setOfIdentical\n        };\n    });\n    return errors;\n}\nexports.findDuplicatePatterns = findDuplicatePatterns;\nfunction findInvalidGroupType(tokenTypes) {\n    var invalidTypes = (0, filter_1.default)(tokenTypes, function (clazz) {\n        if (!(0, has_1.default)(clazz, \"GROUP\")) {\n            return false;\n        }\n        var group = clazz.GROUP;\n        return group !== lexer_public_1.Lexer.SKIPPED && group !== lexer_public_1.Lexer.NA && !(0, isString_1.default)(group);\n    });\n    var errors = (0, map_1.default)(invalidTypes, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n            type: lexer_public_1.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nexports.findInvalidGroupType = findInvalidGroupType;\nfunction findModesThatDoNotExist(tokenTypes, validModes) {\n    var invalidModes = (0, filter_1.default)(tokenTypes, function (clazz) {\n        return (clazz.PUSH_MODE !== undefined && !(0, includes_1.default)(validModes, clazz.PUSH_MODE));\n    });\n    var errors = (0, map_1.default)(invalidModes, function (tokType) {\n        var msg = \"Token Type: ->\".concat(tokType.name, \"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\").concat(tokType.PUSH_MODE, \"<-\") +\n            \"which does not exist\";\n        return {\n            message: msg,\n            type: lexer_public_1.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n            tokenTypes: [tokType]\n        };\n    });\n    return errors;\n}\nexports.findModesThatDoNotExist = findModesThatDoNotExist;\nfunction findUnreachablePatterns(tokenTypes) {\n    var errors = [];\n    var canBeTested = (0, reduce_1.default)(tokenTypes, function (result, tokType, idx) {\n        var pattern = tokType.PATTERN;\n        if (pattern === lexer_public_1.Lexer.NA) {\n            return result;\n        }\n        // a more comprehensive validation for all forms of regExps would require\n        // deeper regExp analysis capabilities\n        if ((0, isString_1.default)(pattern)) {\n            result.push({ str: pattern, idx: idx, tokenType: tokType });\n        }\n        else if ((0, isRegExp_1.default)(pattern) && noMetaChar(pattern)) {\n            result.push({ str: pattern.source, idx: idx, tokenType: tokType });\n        }\n        return result;\n    }, []);\n    (0, forEach_1.default)(tokenTypes, function (tokType, testIdx) {\n        (0, forEach_1.default)(canBeTested, function (_a) {\n            var str = _a.str, idx = _a.idx, tokenType = _a.tokenType;\n            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n                var msg = \"Token: ->\".concat(tokenType.name, \"<- can never be matched.\\n\") +\n                    \"Because it appears AFTER the Token Type ->\".concat(tokType.name, \"<-\") +\n                    \"in the lexer's definition.\\n\" +\n                    \"See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";\n                errors.push({\n                    message: msg,\n                    type: lexer_public_1.LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n                    tokenTypes: [tokType, tokenType]\n                });\n            }\n        });\n    });\n    return errors;\n}\nexports.findUnreachablePatterns = findUnreachablePatterns;\nfunction testTokenType(str, pattern) {\n    /* istanbul ignore else */\n    if ((0, isRegExp_1.default)(pattern)) {\n        var regExpArray = pattern.exec(str);\n        return regExpArray !== null && regExpArray.index === 0;\n    }\n    else if ((0, isFunction_1.default)(pattern)) {\n        // maintain the API of custom patterns\n        return pattern(str, 0, [], {});\n    }\n    else if ((0, has_1.default)(pattern, \"exec\")) {\n        // maintain the API of custom patterns\n        return pattern.exec(str, 0, [], {});\n    }\n    else if (typeof pattern === \"string\") {\n        return pattern === str;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction noMetaChar(regExp) {\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n    var metaChars = [\n        \".\",\n        \"\\\\\",\n        \"[\",\n        \"]\",\n        \"|\",\n        \"^\",\n        \"$\",\n        \"(\",\n        \")\",\n        \"?\",\n        \"*\",\n        \"+\",\n        \"{\"\n    ];\n    return ((0, find_1.default)(metaChars, function (char) { return regExp.source.indexOf(char) !== -1; }) === undefined);\n}\nfunction addStartOfInput(pattern) {\n    var flags = pattern.ignoreCase ? \"i\" : \"\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(\"^(?:\".concat(pattern.source, \")\"), flags);\n}\nexports.addStartOfInput = addStartOfInput;\nfunction addStickyFlag(pattern) {\n    var flags = pattern.ignoreCase ? \"iy\" : \"y\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(\"\".concat(pattern.source), flags);\n}\nexports.addStickyFlag = addStickyFlag;\nfunction performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    var errors = [];\n    // some run time checks to help the end users.\n    if (!(0, has_1.default)(lexerDefinition, exports.DEFAULT_MODE)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                exports.DEFAULT_MODE +\n                \"> property in its definition\\n\",\n            type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n        });\n    }\n    if (!(0, has_1.default)(lexerDefinition, exports.MODES)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                exports.MODES +\n                \"> property in its definition\\n\",\n            type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n        });\n    }\n    if ((0, has_1.default)(lexerDefinition, exports.MODES) &&\n        (0, has_1.default)(lexerDefinition, exports.DEFAULT_MODE) &&\n        !(0, has_1.default)(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized with a \".concat(exports.DEFAULT_MODE, \": <\").concat(lexerDefinition.defaultMode, \">\") +\n                \"which does not exist\\n\",\n            type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n        });\n    }\n    if ((0, has_1.default)(lexerDefinition, exports.MODES)) {\n        (0, forEach_1.default)(lexerDefinition.modes, function (currModeValue, currModeName) {\n            (0, forEach_1.default)(currModeValue, function (currTokType, currIdx) {\n                if ((0, isUndefined_1.default)(currTokType)) {\n                    errors.push({\n                        message: \"A Lexer cannot be initialized using an undefined Token Type. Mode:\" +\n                            \"<\".concat(currModeName, \"> at index: <\").concat(currIdx, \">\\n\"),\n                        type: lexer_public_1.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n                    });\n                }\n                else if ((0, has_1.default)(currTokType, \"LONGER_ALT\")) {\n                    var longerAlt = (0, isArray_1.default)(currTokType.LONGER_ALT)\n                        ? currTokType.LONGER_ALT\n                        : [currTokType.LONGER_ALT];\n                    (0, forEach_1.default)(longerAlt, function (currLongerAlt) {\n                        if (!(0, isUndefined_1.default)(currLongerAlt) &&\n                            !(0, includes_1.default)(currModeValue, currLongerAlt)) {\n                            errors.push({\n                                message: \"A MultiMode Lexer cannot be initialized with a longer_alt <\".concat(currLongerAlt.name, \"> on token <\").concat(currTokType.name, \"> outside of mode <\").concat(currModeName, \">\\n\"),\n                                type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n                            });\n                        }\n                    });\n                }\n            });\n        });\n    }\n    return errors;\n}\nexports.performRuntimeChecks = performRuntimeChecks;\nfunction performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    var warnings = [];\n    var hasAnyLineBreak = false;\n    var allTokenTypes = (0, compact_1.default)((0, flatten_1.default)((0, values_1.default)(lexerDefinition.modes)));\n    var concreteTokenTypes = (0, reject_1.default)(allTokenTypes, function (currType) { return currType[PATTERN] === lexer_public_1.Lexer.NA; });\n    var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n    if (trackLines) {\n        (0, forEach_1.default)(concreteTokenTypes, function (tokType) {\n            var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n            if (currIssue !== false) {\n                var message = buildLineBreakIssueMessage(tokType, currIssue);\n                var warningDescriptor = {\n                    message: message,\n                    type: currIssue.issue,\n                    tokenType: tokType\n                };\n                warnings.push(warningDescriptor);\n            }\n            else {\n                // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n                if ((0, has_1.default)(tokType, \"LINE_BREAKS\")) {\n                    if (tokType.LINE_BREAKS === true) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n                else {\n                    if ((0, reg_exp_1.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n            }\n        });\n    }\n    if (trackLines && !hasAnyLineBreak) {\n        warnings.push({\n            message: \"Warning: No LINE_BREAKS Found.\\n\" +\n                \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n                \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n                \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n                \"\\tfor details.\",\n            type: lexer_public_1.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n        });\n    }\n    return warnings;\n}\nexports.performWarningRuntimeChecks = performWarningRuntimeChecks;\nfunction cloneEmptyGroups(emptyGroups) {\n    var clonedResult = {};\n    var groupKeys = (0, keys_1.default)(emptyGroups);\n    (0, forEach_1.default)(groupKeys, function (currKey) {\n        var currGroupValue = emptyGroups[currKey];\n        /* istanbul ignore else */\n        if ((0, isArray_1.default)(currGroupValue)) {\n            clonedResult[currKey] = [];\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    });\n    return clonedResult;\n}\nexports.cloneEmptyGroups = cloneEmptyGroups;\n// TODO: refactor to avoid duplication\nfunction isCustomPattern(tokenType) {\n    var pattern = tokenType.PATTERN;\n    /* istanbul ignore else */\n    if ((0, isRegExp_1.default)(pattern)) {\n        return false;\n    }\n    else if ((0, isFunction_1.default)(pattern)) {\n        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n        return true;\n    }\n    else if ((0, has_1.default)(pattern, \"exec\")) {\n        // ICustomPattern\n        return true;\n    }\n    else if ((0, isString_1.default)(pattern)) {\n        return false;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexports.isCustomPattern = isCustomPattern;\nfunction isShortPattern(pattern) {\n    if ((0, isString_1.default)(pattern) && pattern.length === 1) {\n        return pattern.charCodeAt(0);\n    }\n    else {\n        return false;\n    }\n}\nexports.isShortPattern = isShortPattern;\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexports.LineTerminatorOptimizedTester = {\n    // implements /\\n|\\r\\n?/g.test\n    test: function (text) {\n        var len = text.length;\n        for (var i = this.lastIndex; i < len; i++) {\n            var c = text.charCodeAt(i);\n            if (c === 10) {\n                this.lastIndex = i + 1;\n                return true;\n            }\n            else if (c === 13) {\n                if (text.charCodeAt(i + 1) === 10) {\n                    this.lastIndex = i + 2;\n                }\n                else {\n                    this.lastIndex = i + 1;\n                }\n                return true;\n            }\n        }\n        return false;\n    },\n    lastIndex: 0\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n    if ((0, has_1.default)(tokType, \"LINE_BREAKS\")) {\n        // if the user explicitly declared the line_breaks option we will respect their choice\n        // and assume it is correct.\n        return false;\n    }\n    else {\n        /* istanbul ignore else */\n        if ((0, isRegExp_1.default)(tokType.PATTERN)) {\n            try {\n                // TODO: why is the casting suddenly needed?\n                (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);\n            }\n            catch (e) {\n                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n                return {\n                    issue: lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n                    errMsg: e.message\n                };\n            }\n            return false;\n        }\n        else if ((0, isString_1.default)(tokType.PATTERN)) {\n            // string literal patterns can always be analyzed to detect line terminator usage\n            return false;\n        }\n        else if (isCustomPattern(tokType)) {\n            // custom token types\n            return { issue: lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n}\nfunction buildLineBreakIssueMessage(tokType, details) {\n    /* istanbul ignore else */\n    if (details.issue === lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n        return (\"Warning: unable to identify line terminator usage in pattern.\\n\" +\n            \"\\tThe problem is in the <\".concat(tokType.name, \"> Token Type\\n\") +\n            \"\\t Root cause: \".concat(details.errMsg, \".\\n\") +\n            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\");\n    }\n    else if (details.issue === lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n        return (\"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n            \"\\tThe problem is in the <\".concat(tokType.name, \"> Token Type\\n\") +\n            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\");\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexports.buildLineBreakIssueMessage = buildLineBreakIssueMessage;\nfunction getCharCodes(charsOrCodes) {\n    var charCodes = (0, map_1.default)(charsOrCodes, function (numOrString) {\n        if ((0, isString_1.default)(numOrString)) {\n            return numOrString.charCodeAt(0);\n        }\n        else {\n            return numOrString;\n        }\n    });\n    return charCodes;\n}\nfunction addToMapOfArrays(map, key, value) {\n    if (map[key] === undefined) {\n        map[key] = [value];\n    }\n    else {\n        map[key].push(value);\n    }\n}\nexports.minOptimizationVal = 256;\n/**\n * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nvar charCodeToOptimizedIdxMap = [];\nfunction charCodeToOptimizedIndex(charCode) {\n    return charCode < exports.minOptimizationVal\n        ? charCode\n        : charCodeToOptimizedIdxMap[charCode];\n}\nexports.charCodeToOptimizedIndex = charCodeToOptimizedIndex;\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nfunction initCharCodeToOptimizedIndexMap() {\n    if ((0, isEmpty_1.default)(charCodeToOptimizedIdxMap)) {\n        charCodeToOptimizedIdxMap = new Array(65536);\n        for (var i = 0; i < 65536; i++) {\n            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n        }\n    }\n}\n//# sourceMappingURL=lexer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vbGV4ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRywwQkFBMEIsR0FBRyxrQ0FBa0MsR0FBRyxxQ0FBcUMsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRyxtQ0FBbUMsR0FBRyw0QkFBNEIsR0FBRyxxQkFBcUIsR0FBRyx1QkFBdUIsR0FBRywrQkFBK0IsR0FBRywrQkFBK0IsR0FBRyw0QkFBNEIsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyw4QkFBOEIsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyxhQUFhLEdBQUcsb0JBQW9CO0FBQ256QixzQkFBc0IsbUJBQU8sQ0FBQyw4RUFBZTtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDN0MsOEJBQThCLG1CQUFPLENBQUMsMERBQWM7QUFDcEQsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsK0JBQStCLG1CQUFPLENBQUMsNERBQWU7QUFDdEQsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELCtCQUErQixtQkFBTyxDQUFDLDREQUFlO0FBQ3RELG1DQUFtQyxtQkFBTyxDQUFDLG9FQUFtQjtBQUM5RCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsNEJBQTRCLG1CQUFPLENBQUMsc0RBQVk7QUFDaEQsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELGlDQUFpQyxtQkFBTyxDQUFDLGdFQUFpQjtBQUMxRCxtQ0FBbUMsbUJBQU8sQ0FBQyxvRUFBbUI7QUFDOUQsb0NBQW9DLG1CQUFPLENBQUMsc0VBQW9CO0FBQ2hFLDZCQUE2QixtQkFBTyxDQUFDLHdEQUFhO0FBQ2xELDRCQUE0QixtQkFBTyxDQUFDLHNEQUFZO0FBQ2hELDZCQUE2QixtQkFBTyxDQUFDLHdEQUFhO0FBQ2xELGlDQUFpQyxtQkFBTyxDQUFDLGdFQUFpQjtBQUMxRCwrQkFBK0IsbUJBQU8sQ0FBQyw0REFBZTtBQUN0RCxpQ0FBaUMsbUJBQU8sQ0FBQyxnRUFBaUI7QUFDMUQsK0JBQStCLG1CQUFPLENBQUMsNERBQWU7QUFDdEQsaUNBQWlDLG1CQUFPLENBQUMsZ0VBQWlCO0FBQzFELGNBQWMsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQWtCO0FBQ2pEO0FBQ0Esb0JBQW9CO0FBQ3BCLGFBQWE7QUFDYixzQkFBc0I7QUFDdEI7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUksc0JBQXNCO0FBQzFCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsK0JBQStCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSx5REFBeUQ7QUFDbkk7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdGQUF3Rix5QkFBeUI7QUFDakg7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLGVBQWU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwQkFBMEIsZ0NBQWdDLGdCQUFnQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRDQUE0QztBQUN0RTtBQUNBO0FBQ0EsMEJBQTBCLG1EQUFtRDtBQUM3RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsNkRBQTZELDRDQUE0QztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Rix1REFBdUQ7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvc2Nhbi9sZXhlci5qcz9iMzZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hhckNvZGVUb09wdGltaXplZEluZGV4ID0gZXhwb3J0cy5taW5PcHRpbWl6YXRpb25WYWwgPSBleHBvcnRzLmJ1aWxkTGluZUJyZWFrSXNzdWVNZXNzYWdlID0gZXhwb3J0cy5MaW5lVGVybWluYXRvck9wdGltaXplZFRlc3RlciA9IGV4cG9ydHMuaXNTaG9ydFBhdHRlcm4gPSBleHBvcnRzLmlzQ3VzdG9tUGF0dGVybiA9IGV4cG9ydHMuY2xvbmVFbXB0eUdyb3VwcyA9IGV4cG9ydHMucGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzID0gZXhwb3J0cy5wZXJmb3JtUnVudGltZUNoZWNrcyA9IGV4cG9ydHMuYWRkU3RpY2t5RmxhZyA9IGV4cG9ydHMuYWRkU3RhcnRPZklucHV0ID0gZXhwb3J0cy5maW5kVW5yZWFjaGFibGVQYXR0ZXJucyA9IGV4cG9ydHMuZmluZE1vZGVzVGhhdERvTm90RXhpc3QgPSBleHBvcnRzLmZpbmRJbnZhbGlkR3JvdXBUeXBlID0gZXhwb3J0cy5maW5kRHVwbGljYXRlUGF0dGVybnMgPSBleHBvcnRzLmZpbmRVbnN1cHBvcnRlZEZsYWdzID0gZXhwb3J0cy5maW5kU3RhcnRPZklucHV0QW5jaG9yID0gZXhwb3J0cy5maW5kRW1wdHlNYXRjaFJlZ0V4cHMgPSBleHBvcnRzLmZpbmRFbmRPZklucHV0QW5jaG9yID0gZXhwb3J0cy5maW5kSW52YWxpZFBhdHRlcm5zID0gZXhwb3J0cy5maW5kTWlzc2luZ1BhdHRlcm5zID0gZXhwb3J0cy52YWxpZGF0ZVBhdHRlcm5zID0gZXhwb3J0cy5hbmFseXplVG9rZW5UeXBlcyA9IGV4cG9ydHMuZW5hYmxlU3RpY2t5ID0gZXhwb3J0cy5kaXNhYmxlU3RpY2t5ID0gZXhwb3J0cy5TVVBQT1JUX1NUSUNLWSA9IGV4cG9ydHMuTU9ERVMgPSBleHBvcnRzLkRFRkFVTFRfTU9ERSA9IHZvaWQgMDtcbnZhciByZWdleHBfdG9fYXN0XzEgPSByZXF1aXJlKFwicmVnZXhwLXRvLWFzdFwiKTtcbnZhciBsZXhlcl9wdWJsaWNfMSA9IHJlcXVpcmUoXCIuL2xleGVyX3B1YmxpY1wiKTtcbnZhciBmaXJzdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZmlyc3RcIikpO1xudmFyIGlzRW1wdHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzRW1wdHlcIikpO1xudmFyIGNvbXBhY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2NvbXBhY3RcIikpO1xudmFyIGlzQXJyYXlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIikpO1xudmFyIHZhbHVlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvdmFsdWVzXCIpKTtcbnZhciBmbGF0dGVuXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9mbGF0dGVuXCIpKTtcbnZhciByZWplY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3JlamVjdFwiKSk7XG52YXIgZGlmZmVyZW5jZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZGlmZmVyZW5jZVwiKSk7XG52YXIgaW5kZXhPZl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaW5kZXhPZlwiKSk7XG52YXIgbWFwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9tYXBcIikpO1xudmFyIGZvckVhY2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZvckVhY2hcIikpO1xudmFyIGlzU3RyaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc1N0cmluZ1wiKSk7XG52YXIgaXNGdW5jdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSk7XG52YXIgaXNVbmRlZmluZWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzVW5kZWZpbmVkXCIpKTtcbnZhciBmaW5kXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9maW5kXCIpKTtcbnZhciBoYXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2hhc1wiKSk7XG52YXIga2V5c18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gva2V5c1wiKSk7XG52YXIgaXNSZWdFeHBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzUmVnRXhwXCIpKTtcbnZhciBmaWx0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZpbHRlclwiKSk7XG52YXIgZGVmYXVsdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2RlZmF1bHRzXCIpKTtcbnZhciByZWR1Y2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3JlZHVjZVwiKSk7XG52YXIgaW5jbHVkZXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2luY2x1ZGVzXCIpKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIkBjaGV2cm90YWluL3V0aWxzXCIpO1xudmFyIHJlZ19leHBfMSA9IHJlcXVpcmUoXCIuL3JlZ19leHBcIik7XG52YXIgcmVnX2V4cF9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3JlZ19leHBfcGFyc2VyXCIpO1xudmFyIFBBVFRFUk4gPSBcIlBBVFRFUk5cIjtcbmV4cG9ydHMuREVGQVVMVF9NT0RFID0gXCJkZWZhdWx0TW9kZVwiO1xuZXhwb3J0cy5NT0RFUyA9IFwibW9kZXNcIjtcbmV4cG9ydHMuU1VQUE9SVF9TVElDS1kgPSB0eXBlb2YgbmV3IFJlZ0V4cChcIig/OilcIikuc3RpY2t5ID09PSBcImJvb2xlYW5cIjtcbmZ1bmN0aW9uIGRpc2FibGVTdGlja3koKSB7XG4gICAgZXhwb3J0cy5TVVBQT1JUX1NUSUNLWSA9IGZhbHNlO1xufVxuZXhwb3J0cy5kaXNhYmxlU3RpY2t5ID0gZGlzYWJsZVN0aWNreTtcbmZ1bmN0aW9uIGVuYWJsZVN0aWNreSgpIHtcbiAgICBleHBvcnRzLlNVUFBPUlRfU1RJQ0tZID0gdHJ1ZTtcbn1cbmV4cG9ydHMuZW5hYmxlU3RpY2t5ID0gZW5hYmxlU3RpY2t5O1xuZnVuY3Rpb24gYW5hbHl6ZVRva2VuVHlwZXModG9rZW5UeXBlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSAoMCwgZGVmYXVsdHNfMS5kZWZhdWx0KShvcHRpb25zLCB7XG4gICAgICAgIHVzZVN0aWNreTogZXhwb3J0cy5TVVBQT1JUX1NUSUNLWSxcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBzYWZlTW9kZTogZmFsc2UsXG4gICAgICAgIHBvc2l0aW9uVHJhY2tpbmc6IFwiZnVsbFwiLFxuICAgICAgICBsaW5lVGVybWluYXRvckNoYXJhY3RlcnM6IFtcIlxcclwiLCBcIlxcblwiXSxcbiAgICAgICAgdHJhY2VyOiBmdW5jdGlvbiAobXNnLCBhY3Rpb24pIHsgcmV0dXJuIGFjdGlvbigpOyB9XG4gICAgfSk7XG4gICAgdmFyIHRyYWNlciA9IG9wdGlvbnMudHJhY2VyO1xuICAgIHRyYWNlcihcImluaXRDaGFyQ29kZVRvT3B0aW1pemVkSW5kZXhNYXBcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpbml0Q2hhckNvZGVUb09wdGltaXplZEluZGV4TWFwKCk7XG4gICAgfSk7XG4gICAgdmFyIG9ubHlSZWxldmFudFR5cGVzO1xuICAgIHRyYWNlcihcIlJlamVjdCBMZXhlci5OQVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9ubHlSZWxldmFudFR5cGVzID0gKDAsIHJlamVjdF8xLmRlZmF1bHQpKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJUeXBlW1BBVFRFUk5dID09PSBsZXhlcl9wdWJsaWNfMS5MZXhlci5OQTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGhhc0N1c3RvbSA9IGZhbHNlO1xuICAgIHZhciBhbGxUcmFuc2Zvcm1lZFBhdHRlcm5zO1xuICAgIHRyYWNlcihcIlRyYW5zZm9ybSBQYXR0ZXJuc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhhc0N1c3RvbSA9IGZhbHNlO1xuICAgICAgICBhbGxUcmFuc2Zvcm1lZFBhdHRlcm5zID0gKDAsIG1hcF8xLmRlZmF1bHQpKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgICAgIHZhciBjdXJyUGF0dGVybiA9IGN1cnJUeXBlW1BBVFRFUk5dO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICgoMCwgaXNSZWdFeHBfMS5kZWZhdWx0KShjdXJyUGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnRXhwU291cmNlID0gY3VyclBhdHRlcm4uc291cmNlO1xuICAgICAgICAgICAgICAgIGlmIChyZWdFeHBTb3VyY2UubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgdGhlc2UgcmVnRXhwIG1ldGEgY2hhcmFjdGVycyB3aGljaCBjYW4gYXBwZWFyIGluIGEgbGVuZ3RoIG9uZSByZWdFeHBcbiAgICAgICAgICAgICAgICAgICAgcmVnRXhwU291cmNlICE9PSBcIl5cIiAmJlxuICAgICAgICAgICAgICAgICAgICByZWdFeHBTb3VyY2UgIT09IFwiJFwiICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZ0V4cFNvdXJjZSAhPT0gXCIuXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgIWN1cnJQYXR0ZXJuLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ0V4cFNvdXJjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVnRXhwU291cmNlLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICByZWdFeHBTb3VyY2VbMF0gPT09IFwiXFxcXFwiICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBhIG1ldGEgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICEoMCwgaW5jbHVkZXNfMS5kZWZhdWx0KShbXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJCXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIldcIlxuICAgICAgICAgICAgICAgICAgICBdLCByZWdFeHBTb3VyY2VbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZWQgbWV0YSBDaGFyYWN0ZXJzOiAvXFwrLyAvXFxbL1xuICAgICAgICAgICAgICAgICAgICAvLyBvciByZWR1bmRhbnQgZXNjYXBpbmc6IC9cXGEvXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgdGhlIGVzY2FwaW5nIFwiXFxcIlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnRXhwU291cmNlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMudXNlU3RpY2t5XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGFkZFN0aWNreUZsYWcoY3VyclBhdHRlcm4pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFkZFN0YXJ0T2ZJbnB1dChjdXJyUGF0dGVybik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIGlzRnVuY3Rpb25fMS5kZWZhdWx0KShjdXJyUGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICBoYXNDdXN0b20gPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIEN1c3RvbVBhdHRlcm5NYXRjaGVyRnVuYyAtIGN1c3RvbSBwYXR0ZXJucyBkbyBub3QgcmVxdWlyZSBhbnkgdHJhbnNmb3JtYXRpb25zLCBvbmx5IHdyYXBwaW5nIGluIGEgUmVnRXhwIExpa2Ugb2JqZWN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXhlYzogY3VyclBhdHRlcm4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjdXJyUGF0dGVybiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGhhc0N1c3RvbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gSUN1c3RvbVBhdHRlcm5cbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyclBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY3VyclBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyclBhdHRlcm4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyUGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlc2NhcGVkUmVnRXhwU3RyaW5nID0gY3VyclBhdHRlcm4ucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csIFwiXFxcXCQmXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZFJlZ0V4cCA9IG5ldyBSZWdFeHAoZXNjYXBlZFJlZ0V4cFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnVzZVN0aWNreVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhZGRTdGlja3lGbGFnKHdyYXBwZWRSZWdFeHApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFkZFN0YXJ0T2ZJbnB1dCh3cmFwcGVkUmVnRXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgcGF0dGVybklkeFRvVHlwZTtcbiAgICB2YXIgcGF0dGVybklkeFRvR3JvdXA7XG4gICAgdmFyIHBhdHRlcm5JZHhUb0xvbmdlckFsdElkeEFycjtcbiAgICB2YXIgcGF0dGVybklkeFRvUHVzaE1vZGU7XG4gICAgdmFyIHBhdHRlcm5JZHhUb1BvcE1vZGU7XG4gICAgdHJhY2VyKFwibWlzYyBtYXBwaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGF0dGVybklkeFRvVHlwZSA9ICgwLCBtYXBfMS5kZWZhdWx0KShvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7IHJldHVybiBjdXJyVHlwZS50b2tlblR5cGVJZHg7IH0pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9Hcm91cCA9ICgwLCBtYXBfMS5kZWZhdWx0KShvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKGNsYXp6KSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBOYW1lID0gY2xhenouR1JPVVA7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKGdyb3VwTmFtZSA9PT0gbGV4ZXJfcHVibGljXzEuTGV4ZXIuU0tJUFBFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgaXNTdHJpbmdfMS5kZWZhdWx0KShncm91cE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgwLCBpc1VuZGVmaW5lZF8xLmRlZmF1bHQpKGdyb3VwTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGF0dGVybklkeFRvTG9uZ2VyQWx0SWR4QXJyID0gKDAsIG1hcF8xLmRlZmF1bHQpKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgICAgIHZhciBsb25nZXJBbHRUeXBlID0gY2xhenouTE9OR0VSX0FMVDtcbiAgICAgICAgICAgIGlmIChsb25nZXJBbHRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvbmdlckFsdElkeEFyciA9ICgwLCBpc0FycmF5XzEuZGVmYXVsdCkobG9uZ2VyQWx0VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgbWFwXzEuZGVmYXVsdCkobG9uZ2VyQWx0VHlwZSwgZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuICgwLCBpbmRleE9mXzEuZGVmYXVsdCkob25seVJlbGV2YW50VHlwZXMsIHR5cGUpOyB9KVxuICAgICAgICAgICAgICAgICAgICA6IFsoMCwgaW5kZXhPZl8xLmRlZmF1bHQpKG9ubHlSZWxldmFudFR5cGVzLCBsb25nZXJBbHRUeXBlKV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvbmdlckFsdElkeEFycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhdHRlcm5JZHhUb1B1c2hNb2RlID0gKDAsIG1hcF8xLmRlZmF1bHQpKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAoY2xhenopIHsgcmV0dXJuIGNsYXp6LlBVU0hfTU9ERTsgfSk7XG4gICAgICAgIHBhdHRlcm5JZHhUb1BvcE1vZGUgPSAoMCwgbWFwXzEuZGVmYXVsdCkob25seVJlbGV2YW50VHlwZXMsIGZ1bmN0aW9uIChjbGF6eikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBoYXNfMS5kZWZhdWx0KShjbGF6eiwgXCJQT1BfTU9ERVwiKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIHBhdHRlcm5JZHhUb0NhbkxpbmVUZXJtaW5hdG9yO1xuICAgIHRyYWNlcihcIkxpbmUgVGVybWluYXRvciBIYW5kbGluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsaW5lVGVybWluYXRvckNoYXJDb2RlcyA9IGdldENoYXJDb2RlcyhvcHRpb25zLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycyk7XG4gICAgICAgIHBhdHRlcm5JZHhUb0NhbkxpbmVUZXJtaW5hdG9yID0gKDAsIG1hcF8xLmRlZmF1bHQpKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAodG9rVHlwZSkgeyByZXR1cm4gZmFsc2U7IH0pO1xuICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvblRyYWNraW5nICE9PSBcIm9ubHlPZmZzZXRcIikge1xuICAgICAgICAgICAgcGF0dGVybklkeFRvQ2FuTGluZVRlcm1pbmF0b3IgPSAoMCwgbWFwXzEuZGVmYXVsdCkob25seVJlbGV2YW50VHlwZXMsIGZ1bmN0aW9uICh0b2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBoYXNfMS5kZWZhdWx0KSh0b2tUeXBlLCBcIkxJTkVfQlJFQUtTXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXRva1R5cGUuTElORV9CUkVBS1M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNoZWNrTGluZUJyZWFrc0lzc3Vlcyh0b2tUeXBlLCBsaW5lVGVybWluYXRvckNoYXJDb2RlcykgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgcmVnX2V4cF8xLmNhbk1hdGNoQ2hhckNvZGUpKGxpbmVUZXJtaW5hdG9yQ2hhckNvZGVzLCB0b2tUeXBlLlBBVFRFUk4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBwYXR0ZXJuSWR4VG9Jc0N1c3RvbTtcbiAgICB2YXIgcGF0dGVybklkeFRvU2hvcnQ7XG4gICAgdmFyIGVtcHR5R3JvdXBzO1xuICAgIHZhciBwYXR0ZXJuSWR4VG9Db25maWc7XG4gICAgdHJhY2VyKFwiTWlzYyBNYXBwaW5nICMyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGF0dGVybklkeFRvSXNDdXN0b20gPSAoMCwgbWFwXzEuZGVmYXVsdCkob25seVJlbGV2YW50VHlwZXMsIGlzQ3VzdG9tUGF0dGVybik7XG4gICAgICAgIHBhdHRlcm5JZHhUb1Nob3J0ID0gKDAsIG1hcF8xLmRlZmF1bHQpKGFsbFRyYW5zZm9ybWVkUGF0dGVybnMsIGlzU2hvcnRQYXR0ZXJuKTtcbiAgICAgICAgZW1wdHlHcm91cHMgPSAoMCwgcmVkdWNlXzEuZGVmYXVsdCkob25seVJlbGV2YW50VHlwZXMsIGZ1bmN0aW9uIChhY2MsIGNsYXp6KSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBOYW1lID0gY2xhenouR1JPVVA7XG4gICAgICAgICAgICBpZiAoKDAsIGlzU3RyaW5nXzEuZGVmYXVsdCkoZ3JvdXBOYW1lKSAmJiAhKGdyb3VwTmFtZSA9PT0gbGV4ZXJfcHVibGljXzEuTGV4ZXIuU0tJUFBFRCkpIHtcbiAgICAgICAgICAgICAgICBhY2NbZ3JvdXBOYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9Db25maWcgPSAoMCwgbWFwXzEuZGVmYXVsdCkoYWxsVHJhbnNmb3JtZWRQYXR0ZXJucywgZnVuY3Rpb24gKHgsIGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBhbGxUcmFuc2Zvcm1lZFBhdHRlcm5zW2lkeF0sXG4gICAgICAgICAgICAgICAgbG9uZ2VyQWx0OiBwYXR0ZXJuSWR4VG9Mb25nZXJBbHRJZHhBcnJbaWR4XSxcbiAgICAgICAgICAgICAgICBjYW5MaW5lVGVybWluYXRvcjogcGF0dGVybklkeFRvQ2FuTGluZVRlcm1pbmF0b3JbaWR4XSxcbiAgICAgICAgICAgICAgICBpc0N1c3RvbTogcGF0dGVybklkeFRvSXNDdXN0b21baWR4XSxcbiAgICAgICAgICAgICAgICBzaG9ydDogcGF0dGVybklkeFRvU2hvcnRbaWR4XSxcbiAgICAgICAgICAgICAgICBncm91cDogcGF0dGVybklkeFRvR3JvdXBbaWR4XSxcbiAgICAgICAgICAgICAgICBwdXNoOiBwYXR0ZXJuSWR4VG9QdXNoTW9kZVtpZHhdLFxuICAgICAgICAgICAgICAgIHBvcDogcGF0dGVybklkeFRvUG9wTW9kZVtpZHhdLFxuICAgICAgICAgICAgICAgIHRva2VuVHlwZUlkeDogcGF0dGVybklkeFRvVHlwZVtpZHhdLFxuICAgICAgICAgICAgICAgIHRva2VuVHlwZTogb25seVJlbGV2YW50VHlwZXNbaWR4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGNhbkJlT3B0aW1pemVkID0gdHJ1ZTtcbiAgICB2YXIgY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyA9IFtdO1xuICAgIGlmICghb3B0aW9ucy5zYWZlTW9kZSkge1xuICAgICAgICB0cmFjZXIoXCJGaXJzdCBDaGFyIE9wdGltaXphdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnID0gKDAsIHJlZHVjZV8xLmRlZmF1bHQpKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAocmVzdWx0LCBjdXJyVG9rVHlwZSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyVG9rVHlwZS5QQVRURVJOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IGN1cnJUb2tUeXBlLlBBVFRFUk4uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGltaXplZElkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChjaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvTWFwT2ZBcnJheXMocmVzdWx0LCBvcHRpbWl6ZWRJZHgsIHBhdHRlcm5JZHhUb0NvbmZpZ1tpZHhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKDAsIGlzQXJyYXlfMS5kZWZhdWx0KShjdXJyVG9rVHlwZS5TVEFSVF9DSEFSU19ISU5UKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdE9wdGltaXplZElkeF8xO1xuICAgICAgICAgICAgICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKGN1cnJUb2tUeXBlLlNUQVJUX0NIQVJTX0hJTlQsIGZ1bmN0aW9uIChjaGFyT3JJbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHR5cGVvZiBjaGFyT3JJbnQgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNoYXJPckludC5jaGFyQ29kZUF0KDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjaGFyT3JJbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyck9wdGltaXplZElkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChjaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBhZGRpbmcgdGhlIGNvbmZpZyBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gRGlmZmljdWx0IHRvIGNoZWNrIHRoaXMgc2NlbmFyaW8gZWZmZWN0cyBhcyBpdCBpcyBvbmx5IGEgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgb3B0aW1pemF0aW9uIHRoYXQgZG9lcyBub3QgY2hhbmdlIGNvcnJlY3RuZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdE9wdGltaXplZElkeF8xICE9PSBjdXJyT3B0aW1pemVkSWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE9wdGltaXplZElkeF8xID0gY3Vyck9wdGltaXplZElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRUb01hcE9mQXJyYXlzKHJlc3VsdCwgY3Vyck9wdGltaXplZElkeCwgcGF0dGVybklkeFRvQ29uZmlnW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKDAsIGlzUmVnRXhwXzEuZGVmYXVsdCkoY3VyclRva1R5cGUuUEFUVEVSTikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJUb2tUeXBlLlBBVFRFUk4udW5pY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVPcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVuc3VyZU9wdGltaXphdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5QUklOVF9FUlJPUikoXCJcIi5jb25jYXQocmVnX2V4cF8xLmZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFVuYWJsZSB0byBhbmFseXplIDwgXCIuY29uY2F0KGN1cnJUb2tUeXBlLlBBVFRFUk4udG9TdHJpbmcoKSwgXCIgPiBwYXR0ZXJuLlxcblwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0VGhlIHJlZ2V4cCB1bmljb2RlIGZsYWcgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIHJlZ2V4cC10by1hc3QgbGlicmFyeS5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNVTklDT0RFX09QVElNSVpFXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGltaXplZENvZGVzID0gKDAsIHJlZ19leHBfMS5nZXRPcHRpbWl6ZWRTdGFydENvZGVzSW5kaWNlcykoY3VyclRva1R5cGUuUEFUVEVSTiwgb3B0aW9ucy5lbnN1cmVPcHRpbWl6YXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgY29kZSB3aWxsIG9ubHkgYmUgZW1wdHkgZ2l2ZW4gYW4gZW1wdHkgcmVnRXhwIG9yIGZhaWx1cmUgb2YgcmVnZXhwLXRvLWFzdCBsaWJyYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3Qgc2hvdWxkIGJlIGEgZGlmZmVyZW50IHZhbGlkYXRpb24gYW5kIHRoZSBzZWNvbmQgY2Fubm90IGJlIHRlc3RlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaXNFbXB0eV8xLmRlZmF1bHQpKG9wdGltaXplZENvZGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbm5vdCB1bmRlcnN0YW5kIHdoYXQgY29kZXMgbWF5IHN0YXJ0IHBvc3NpYmxlIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3B0aW1pemF0aW9uIGNvcnJlY3RuZXNzIHJlcXVpcmVzIGtub3dpbmcgc3RhcnQgY29kZXMgZm9yIEFMTCBwYXR0ZXJucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYWN0dWFsbHkgc3VyZSB0aGlzIGlzIGFuIGVycm9yLCBubyBkZWJ1ZyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVPcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBmb3JFYWNoXzEuZGVmYXVsdCkob3B0aW1pemVkQ29kZXMsIGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9NYXBPZkFycmF5cyhyZXN1bHQsIGNvZGUsIHBhdHRlcm5JZHhUb0NvbmZpZ1tpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lbnN1cmVPcHRpbWl6YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5QUklOVF9FUlJPUikoXCJcIi5jb25jYXQocmVnX2V4cF8xLmZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0VG9rZW5UeXBlOiA8XCIuY29uY2F0KGN1cnJUb2tUeXBlLm5hbWUsIFwiPiBpcyB1c2luZyBhIGN1c3RvbSB0b2tlbiBwYXR0ZXJuIHdpdGhvdXQgcHJvdmlkaW5nIDxzdGFydF9jaGFyc19oaW50PiBwYXJhbWV0ZXIuXFxuXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBsZXhlcidzIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9ucy5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNDVVNUT01fT1BUSU1JWkVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FuQmVPcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVtcHR5R3JvdXBzOiBlbXB0eUdyb3VwcyxcbiAgICAgICAgcGF0dGVybklkeFRvQ29uZmlnOiBwYXR0ZXJuSWR4VG9Db25maWcsXG4gICAgICAgIGNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWc6IGNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcsXG4gICAgICAgIGhhc0N1c3RvbTogaGFzQ3VzdG9tLFxuICAgICAgICBjYW5CZU9wdGltaXplZDogY2FuQmVPcHRpbWl6ZWRcbiAgICB9O1xufVxuZXhwb3J0cy5hbmFseXplVG9rZW5UeXBlcyA9IGFuYWx5emVUb2tlblR5cGVzO1xuZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJucyh0b2tlblR5cGVzLCB2YWxpZE1vZGVzTmFtZXMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIG1pc3NpbmdSZXN1bHQgPSBmaW5kTWlzc2luZ1BhdHRlcm5zKHRva2VuVHlwZXMpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQobWlzc2luZ1Jlc3VsdC5lcnJvcnMpO1xuICAgIHZhciBpbnZhbGlkUmVzdWx0ID0gZmluZEludmFsaWRQYXR0ZXJucyhtaXNzaW5nUmVzdWx0LnZhbGlkKTtcbiAgICB2YXIgdmFsaWRUb2tlblR5cGVzID0gaW52YWxpZFJlc3VsdC52YWxpZDtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGludmFsaWRSZXN1bHQuZXJyb3JzKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlUmVnRXhwUGF0dGVybih2YWxpZFRva2VuVHlwZXMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRJbnZhbGlkR3JvdXBUeXBlKHZhbGlkVG9rZW5UeXBlcykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZE1vZGVzVGhhdERvTm90RXhpc3QodmFsaWRUb2tlblR5cGVzLCB2YWxpZE1vZGVzTmFtZXMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRVbnJlYWNoYWJsZVBhdHRlcm5zKHZhbGlkVG9rZW5UeXBlcykpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnRzLnZhbGlkYXRlUGF0dGVybnMgPSB2YWxpZGF0ZVBhdHRlcm5zO1xuZnVuY3Rpb24gdmFsaWRhdGVSZWdFeHBQYXR0ZXJuKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHdpdGhSZWdFeHBQYXR0ZXJucyA9ICgwLCBmaWx0ZXJfMS5kZWZhdWx0KSh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpc1JlZ0V4cF8xLmRlZmF1bHQpKGN1cnJUb2tUeXBlW1BBVFRFUk5dKTtcbiAgICB9KTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRFbmRPZklucHV0QW5jaG9yKHdpdGhSZWdFeHBQYXR0ZXJucykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZFN0YXJ0T2ZJbnB1dEFuY2hvcih3aXRoUmVnRXhwUGF0dGVybnMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRVbnN1cHBvcnRlZEZsYWdzKHdpdGhSZWdFeHBQYXR0ZXJucykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZER1cGxpY2F0ZVBhdHRlcm5zKHdpdGhSZWdFeHBQYXR0ZXJucykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZEVtcHR5TWF0Y2hSZWdFeHBzKHdpdGhSZWdFeHBQYXR0ZXJucykpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBmaW5kTWlzc2luZ1BhdHRlcm5zKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgdG9rZW5UeXBlc1dpdGhNaXNzaW5nUGF0dGVybiA9ICgwLCBmaWx0ZXJfMS5kZWZhdWx0KSh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuICEoMCwgaGFzXzEuZGVmYXVsdCkoY3VyclR5cGUsIFBBVFRFUk4pO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSAoMCwgbWFwXzEuZGVmYXVsdCkodG9rZW5UeXBlc1dpdGhNaXNzaW5nUGF0dGVybiwgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gbWlzc2luZyBzdGF0aWMgJ1BBVFRFUk4nIHByb3BlcnR5XCIsXG4gICAgICAgICAgICB0eXBlOiBsZXhlcl9wdWJsaWNfMS5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuTUlTU0lOR19QQVRURVJOLFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHZhciB2YWxpZCA9ICgwLCBkaWZmZXJlbmNlXzEuZGVmYXVsdCkodG9rZW5UeXBlcywgdG9rZW5UeXBlc1dpdGhNaXNzaW5nUGF0dGVybik7XG4gICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcnMsIHZhbGlkOiB2YWxpZCB9O1xufVxuZXhwb3J0cy5maW5kTWlzc2luZ1BhdHRlcm5zID0gZmluZE1pc3NpbmdQYXR0ZXJucztcbmZ1bmN0aW9uIGZpbmRJbnZhbGlkUGF0dGVybnModG9rZW5UeXBlcykge1xuICAgIHZhciB0b2tlblR5cGVzV2l0aEludmFsaWRQYXR0ZXJuID0gKDAsIGZpbHRlcl8xLmRlZmF1bHQpKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGN1cnJUeXBlW1BBVFRFUk5dO1xuICAgICAgICByZXR1cm4gKCEoMCwgaXNSZWdFeHBfMS5kZWZhdWx0KShwYXR0ZXJuKSAmJlxuICAgICAgICAgICAgISgwLCBpc0Z1bmN0aW9uXzEuZGVmYXVsdCkocGF0dGVybikgJiZcbiAgICAgICAgICAgICEoMCwgaGFzXzEuZGVmYXVsdCkocGF0dGVybiwgXCJleGVjXCIpICYmXG4gICAgICAgICAgICAhKDAsIGlzU3RyaW5nXzEuZGVmYXVsdCkocGF0dGVybikpO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSAoMCwgbWFwXzEuZGVmYXVsdCkodG9rZW5UeXBlc1dpdGhJbnZhbGlkUGF0dGVybiwgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gc3RhdGljICdQQVRURVJOJyBjYW4gb25seSBiZSBhIFJlZ0V4cCwgYVwiICtcbiAgICAgICAgICAgICAgICBcIiBGdW5jdGlvbiBtYXRjaGluZyB0aGUge0N1c3RvbVBhdHRlcm5NYXRjaGVyRnVuY30gdHlwZSBvciBhbiBPYmplY3QgbWF0Y2hpbmcgdGhlIHtJQ3VzdG9tUGF0dGVybn0gaW50ZXJmYWNlLlwiLFxuICAgICAgICAgICAgdHlwZTogbGV4ZXJfcHVibGljXzEuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfUEFUVEVSTixcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFtjdXJyVHlwZV1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgdmFsaWQgPSAoMCwgZGlmZmVyZW5jZV8xLmRlZmF1bHQpKHRva2VuVHlwZXMsIHRva2VuVHlwZXNXaXRoSW52YWxpZFBhdHRlcm4pO1xuICAgIHJldHVybiB7IGVycm9yczogZXJyb3JzLCB2YWxpZDogdmFsaWQgfTtcbn1cbmV4cG9ydHMuZmluZEludmFsaWRQYXR0ZXJucyA9IGZpbmRJbnZhbGlkUGF0dGVybnM7XG52YXIgZW5kX29mX2lucHV0ID0gL1teXFxcXF1bJF0vO1xuZnVuY3Rpb24gZmluZEVuZE9mSW5wdXRBbmNob3IodG9rZW5UeXBlcykge1xuICAgIHZhciBFbmRBbmNob3JGaW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhFbmRBbmNob3JGaW5kZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEVuZEFuY2hvckZpbmRlcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBFbmRBbmNob3JGaW5kZXIucHJvdG90eXBlLnZpc2l0RW5kQW5jaG9yID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRW5kQW5jaG9yRmluZGVyO1xuICAgIH0ocmVnZXhwX3RvX2FzdF8xLkJhc2VSZWdFeHBWaXNpdG9yKSk7XG4gICAgdmFyIGludmFsaWRSZWdleCA9ICgwLCBmaWx0ZXJfMS5kZWZhdWx0KSh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBjdXJyVHlwZS5QQVRURVJOO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlZ2V4cEFzdCA9ICgwLCByZWdfZXhwX3BhcnNlcl8xLmdldFJlZ0V4cEFzdCkocGF0dGVybik7XG4gICAgICAgICAgICB2YXIgZW5kQW5jaG9yVmlzaXRvciA9IG5ldyBFbmRBbmNob3JGaW5kZXIoKTtcbiAgICAgICAgICAgIGVuZEFuY2hvclZpc2l0b3IudmlzaXQocmVnZXhwQXN0KTtcbiAgICAgICAgICAgIHJldHVybiBlbmRBbmNob3JWaXNpdG9yLmZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBvbGQgYmVoYXZpb3IgaW4gY2FzZSBvZiBydW50aW1lIGV4Y2VwdGlvbnMgd2l0aCByZWdleHAtdG8tYXN0LlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBjYW5ub3QgZW5zdXJlIGFuIGVycm9yIGluIHJlZ2V4cC10by1hc3QqL1xuICAgICAgICAgICAgcmV0dXJuIGVuZF9vZl9pbnB1dC50ZXN0KHBhdHRlcm4uc291cmNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSAoMCwgbWFwXzEuZGVmYXVsdCkoaW52YWxpZFJlZ2V4LCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVW5leHBlY3RlZCBSZWdFeHAgQW5jaG9yIEVycm9yOlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gc3RhdGljICdQQVRURVJOJyBjYW5ub3QgY29udGFpbiBlbmQgb2YgaW5wdXQgYW5jaG9yICckJ1xcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFNlZSBjaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0FOQ0hPUlNcIiArXG4gICAgICAgICAgICAgICAgXCJcXHRmb3IgZGV0YWlscy5cIixcbiAgICAgICAgICAgIHR5cGU6IGxleGVyX3B1YmxpY18xLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5FT0lfQU5DSE9SX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnRzLmZpbmRFbmRPZklucHV0QW5jaG9yID0gZmluZEVuZE9mSW5wdXRBbmNob3I7XG5mdW5jdGlvbiBmaW5kRW1wdHlNYXRjaFJlZ0V4cHModG9rZW5UeXBlcykge1xuICAgIHZhciBtYXRjaGVzRW1wdHlTdHJpbmcgPSAoMCwgZmlsdGVyXzEuZGVmYXVsdCkodG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gY3VyclR5cGUuUEFUVEVSTjtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChcIlwiKTtcbiAgICB9KTtcbiAgICB2YXIgZXJyb3JzID0gKDAsIG1hcF8xLmRlZmF1bHQpKG1hdGNoZXNFbXB0eVN0cmluZywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gc3RhdGljICdQQVRURVJOJyBtdXN0IG5vdCBtYXRjaCBhbiBlbXB0eSBzdHJpbmdcIixcbiAgICAgICAgICAgIHR5cGU6IGxleGVyX3B1YmxpY18xLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5FTVBUWV9NQVRDSF9QQVRURVJOLFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnRzLmZpbmRFbXB0eU1hdGNoUmVnRXhwcyA9IGZpbmRFbXB0eU1hdGNoUmVnRXhwcztcbnZhciBzdGFydF9vZl9pbnB1dCA9IC9bXlxcXFxbXVtcXF5dfF5cXF4vO1xuZnVuY3Rpb24gZmluZFN0YXJ0T2ZJbnB1dEFuY2hvcih0b2tlblR5cGVzKSB7XG4gICAgdmFyIFN0YXJ0QW5jaG9yRmluZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoU3RhcnRBbmNob3JGaW5kZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFN0YXJ0QW5jaG9yRmluZGVyKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5mb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIFN0YXJ0QW5jaG9yRmluZGVyLnByb3RvdHlwZS52aXNpdFN0YXJ0QW5jaG9yID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3RhcnRBbmNob3JGaW5kZXI7XG4gICAgfShyZWdleHBfdG9fYXN0XzEuQmFzZVJlZ0V4cFZpc2l0b3IpKTtcbiAgICB2YXIgaW52YWxpZFJlZ2V4ID0gKDAsIGZpbHRlcl8xLmRlZmF1bHQpKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGN1cnJUeXBlLlBBVFRFUk47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVnZXhwQXN0ID0gKDAsIHJlZ19leHBfcGFyc2VyXzEuZ2V0UmVnRXhwQXN0KShwYXR0ZXJuKTtcbiAgICAgICAgICAgIHZhciBzdGFydEFuY2hvclZpc2l0b3IgPSBuZXcgU3RhcnRBbmNob3JGaW5kZXIoKTtcbiAgICAgICAgICAgIHN0YXJ0QW5jaG9yVmlzaXRvci52aXNpdChyZWdleHBBc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0QW5jaG9yVmlzaXRvci5mb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gb2xkIGJlaGF2aW9yIGluIGNhc2Ugb2YgcnVudGltZSBleGNlcHRpb25zIHdpdGggcmVnZXhwLXRvLWFzdC5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gY2Fubm90IGVuc3VyZSBhbiBlcnJvciBpbiByZWdleHAtdG8tYXN0Ki9cbiAgICAgICAgICAgIHJldHVybiBzdGFydF9vZl9pbnB1dC50ZXN0KHBhdHRlcm4uc291cmNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSAoMCwgbWFwXzEuZGVmYXVsdCkoaW52YWxpZFJlZ2V4LCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVW5leHBlY3RlZCBSZWdFeHAgQW5jaG9yIEVycm9yOlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gc3RhdGljICdQQVRURVJOJyBjYW5ub3QgY29udGFpbiBzdGFydCBvZiBpbnB1dCBhbmNob3IgJ14nXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0U2VlIGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNBTkNIT1JTXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0Zm9yIGRldGFpbHMuXCIsXG4gICAgICAgICAgICB0eXBlOiBsZXhlcl9wdWJsaWNfMS5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuU09JX0FOQ0hPUl9GT1VORCxcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFtjdXJyVHlwZV1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0cy5maW5kU3RhcnRPZklucHV0QW5jaG9yID0gZmluZFN0YXJ0T2ZJbnB1dEFuY2hvcjtcbmZ1bmN0aW9uIGZpbmRVbnN1cHBvcnRlZEZsYWdzKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgaW52YWxpZEZsYWdzID0gKDAsIGZpbHRlcl8xLmRlZmF1bHQpKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGN1cnJUeXBlW1BBVFRFUk5dO1xuICAgICAgICByZXR1cm4gcGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCAmJiAocGF0dGVybi5tdWx0aWxpbmUgfHwgcGF0dGVybi5nbG9iYWwpO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSAoMCwgbWFwXzEuZGVmYXVsdCkoaW52YWxpZEZsYWdzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIG1heSBOT1QgY29udGFpbiBnbG9iYWwoJ2cnKSBvciBtdWx0aWxpbmUoJ20nKVwiLFxuICAgICAgICAgICAgdHlwZTogbGV4ZXJfcHVibGljXzEuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlVOU1VQUE9SVEVEX0ZMQUdTX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnRzLmZpbmRVbnN1cHBvcnRlZEZsYWdzID0gZmluZFVuc3VwcG9ydGVkRmxhZ3M7XG4vLyBUaGlzIGNhbiBvbmx5IHRlc3QgZm9yIGlkZW50aWNhbCBkdXBsaWNhdGUgUmVnRXhwcywgbm90IHNlbWFudGljYWxseSBlcXVpdmFsZW50IG9uZXMuXG5mdW5jdGlvbiBmaW5kRHVwbGljYXRlUGF0dGVybnModG9rZW5UeXBlcykge1xuICAgIHZhciBmb3VuZCA9IFtdO1xuICAgIHZhciBpZGVudGljYWxQYXR0ZXJucyA9ICgwLCBtYXBfMS5kZWZhdWx0KSh0b2tlblR5cGVzLCBmdW5jdGlvbiAob3V0ZXJUeXBlKSB7XG4gICAgICAgIHJldHVybiAoMCwgcmVkdWNlXzEuZGVmYXVsdCkodG9rZW5UeXBlcywgZnVuY3Rpb24gKHJlc3VsdCwgaW5uZXJUeXBlKSB7XG4gICAgICAgICAgICBpZiAob3V0ZXJUeXBlLlBBVFRFUk4uc291cmNlID09PSBpbm5lclR5cGUuUEFUVEVSTi5zb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAhKDAsIGluY2x1ZGVzXzEuZGVmYXVsdCkoZm91bmQsIGlubmVyVHlwZSkgJiZcbiAgICAgICAgICAgICAgICBpbm5lclR5cGUuUEFUVEVSTiAhPT0gbGV4ZXJfcHVibGljXzEuTGV4ZXIuTkEpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGF2b2lkcyBkdXBsaWNhdGVzIGluIHRoZSByZXN1bHQsIGVhY2ggVG9rZW4gVHlwZSBtYXkgb25seSBhcHBlYXIgaW4gb25lIFwic2V0XCJcbiAgICAgICAgICAgICAgICAvLyBpbiBlc3NlbmNlIHdlIGFyZSBjcmVhdGluZyBFcXVpdmFsZW5jZSBjbGFzc2VzIG9uIGVxdWFsaXR5IHJlbGF0aW9uLlxuICAgICAgICAgICAgICAgIGZvdW5kLnB1c2goaW5uZXJUeXBlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbm5lclR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCBbXSk7XG4gICAgfSk7XG4gICAgaWRlbnRpY2FsUGF0dGVybnMgPSAoMCwgY29tcGFjdF8xLmRlZmF1bHQpKGlkZW50aWNhbFBhdHRlcm5zKTtcbiAgICB2YXIgZHVwbGljYXRlUGF0dGVybnMgPSAoMCwgZmlsdGVyXzEuZGVmYXVsdCkoaWRlbnRpY2FsUGF0dGVybnMsIGZ1bmN0aW9uIChjdXJySWRlbnRpY2FsU2V0KSB7XG4gICAgICAgIHJldHVybiBjdXJySWRlbnRpY2FsU2V0Lmxlbmd0aCA+IDE7XG4gICAgfSk7XG4gICAgdmFyIGVycm9ycyA9ICgwLCBtYXBfMS5kZWZhdWx0KShkdXBsaWNhdGVQYXR0ZXJucywgZnVuY3Rpb24gKHNldE9mSWRlbnRpY2FsKSB7XG4gICAgICAgIHZhciB0b2tlblR5cGVOYW1lcyA9ICgwLCBtYXBfMS5kZWZhdWx0KShzZXRPZklkZW50aWNhbCwgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyclR5cGUubmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkdXBQYXR0ZXJuU3JjID0gKDAsIGZpcnN0XzEuZGVmYXVsdCkoc2V0T2ZJZGVudGljYWwpLlBBVFRFUk47XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRoZSBzYW1lIFJlZ0V4cCBwYXR0ZXJuIC0+XCIuY29uY2F0KGR1cFBhdHRlcm5TcmMsIFwiPC1cIikgK1xuICAgICAgICAgICAgICAgIFwiaGFzIGJlZW4gdXNlZCBpbiBhbGwgb2YgdGhlIGZvbGxvd2luZyBUb2tlbiBUeXBlczogXCIuY29uY2F0KHRva2VuVHlwZU5hbWVzLmpvaW4oXCIsIFwiKSwgXCIgPC1cIiksXG4gICAgICAgICAgICB0eXBlOiBsZXhlcl9wdWJsaWNfMS5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuRFVQTElDQVRFX1BBVFRFUk5TX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogc2V0T2ZJZGVudGljYWxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0cy5maW5kRHVwbGljYXRlUGF0dGVybnMgPSBmaW5kRHVwbGljYXRlUGF0dGVybnM7XG5mdW5jdGlvbiBmaW5kSW52YWxpZEdyb3VwVHlwZSh0b2tlblR5cGVzKSB7XG4gICAgdmFyIGludmFsaWRUeXBlcyA9ICgwLCBmaWx0ZXJfMS5kZWZhdWx0KSh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgaWYgKCEoMCwgaGFzXzEuZGVmYXVsdCkoY2xhenosIFwiR1JPVVBcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JvdXAgPSBjbGF6ei5HUk9VUDtcbiAgICAgICAgcmV0dXJuIGdyb3VwICE9PSBsZXhlcl9wdWJsaWNfMS5MZXhlci5TS0lQUEVEICYmIGdyb3VwICE9PSBsZXhlcl9wdWJsaWNfMS5MZXhlci5OQSAmJiAhKDAsIGlzU3RyaW5nXzEuZGVmYXVsdCkoZ3JvdXApO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSAoMCwgbWFwXzEuZGVmYXVsdCkoaW52YWxpZFR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ0dST1VQJyBjYW4gb25seSBiZSBMZXhlci5TS0lQUEVEL0xleGVyLk5BL0EgU3RyaW5nXCIsXG4gICAgICAgICAgICB0eXBlOiBsZXhlcl9wdWJsaWNfMS5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9HUk9VUF9UWVBFX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnRzLmZpbmRJbnZhbGlkR3JvdXBUeXBlID0gZmluZEludmFsaWRHcm91cFR5cGU7XG5mdW5jdGlvbiBmaW5kTW9kZXNUaGF0RG9Ob3RFeGlzdCh0b2tlblR5cGVzLCB2YWxpZE1vZGVzKSB7XG4gICAgdmFyIGludmFsaWRNb2RlcyA9ICgwLCBmaWx0ZXJfMS5kZWZhdWx0KSh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgcmV0dXJuIChjbGF6ei5QVVNIX01PREUgIT09IHVuZGVmaW5lZCAmJiAhKDAsIGluY2x1ZGVzXzEuZGVmYXVsdCkodmFsaWRNb2RlcywgY2xhenouUFVTSF9NT0RFKSk7XG4gICAgfSk7XG4gICAgdmFyIGVycm9ycyA9ICgwLCBtYXBfMS5kZWZhdWx0KShpbnZhbGlkTW9kZXMsIGZ1bmN0aW9uICh0b2tUeXBlKSB7XG4gICAgICAgIHZhciBtc2cgPSBcIlRva2VuIFR5cGU6IC0+XCIuY29uY2F0KHRva1R5cGUubmFtZSwgXCI8LSBzdGF0aWMgJ1BVU0hfTU9ERScgdmFsdWUgY2Fubm90IHJlZmVyIHRvIGEgTGV4ZXIgTW9kZSAtPlwiKS5jb25jYXQodG9rVHlwZS5QVVNIX01PREUsIFwiPC1cIikgK1xuICAgICAgICAgICAgXCJ3aGljaCBkb2VzIG5vdCBleGlzdFwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgdHlwZTogbGV4ZXJfcHVibGljXzEuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlBVU0hfTU9ERV9ET0VTX05PVF9FWElTVCxcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFt0b2tUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnRzLmZpbmRNb2Rlc1RoYXREb05vdEV4aXN0ID0gZmluZE1vZGVzVGhhdERvTm90RXhpc3Q7XG5mdW5jdGlvbiBmaW5kVW5yZWFjaGFibGVQYXR0ZXJucyh0b2tlblR5cGVzKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciBjYW5CZVRlc3RlZCA9ICgwLCByZWR1Y2VfMS5kZWZhdWx0KSh0b2tlblR5cGVzLCBmdW5jdGlvbiAocmVzdWx0LCB0b2tUeXBlLCBpZHgpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSB0b2tUeXBlLlBBVFRFUk47XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSBsZXhlcl9wdWJsaWNfMS5MZXhlci5OQSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhIG1vcmUgY29tcHJlaGVuc2l2ZSB2YWxpZGF0aW9uIGZvciBhbGwgZm9ybXMgb2YgcmVnRXhwcyB3b3VsZCByZXF1aXJlXG4gICAgICAgIC8vIGRlZXBlciByZWdFeHAgYW5hbHlzaXMgY2FwYWJpbGl0aWVzXG4gICAgICAgIGlmICgoMCwgaXNTdHJpbmdfMS5kZWZhdWx0KShwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBzdHI6IHBhdHRlcm4sIGlkeDogaWR4LCB0b2tlblR5cGU6IHRva1R5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIGlzUmVnRXhwXzEuZGVmYXVsdCkocGF0dGVybikgJiYgbm9NZXRhQ2hhcihwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBzdHI6IHBhdHRlcm4uc291cmNlLCBpZHg6IGlkeCwgdG9rZW5UeXBlOiB0b2tUeXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICAgICgwLCBmb3JFYWNoXzEuZGVmYXVsdCkodG9rZW5UeXBlcywgZnVuY3Rpb24gKHRva1R5cGUsIHRlc3RJZHgpIHtcbiAgICAgICAgKDAsIGZvckVhY2hfMS5kZWZhdWx0KShjYW5CZVRlc3RlZCwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gX2Euc3RyLCBpZHggPSBfYS5pZHgsIHRva2VuVHlwZSA9IF9hLnRva2VuVHlwZTtcbiAgICAgICAgICAgIGlmICh0ZXN0SWR4IDwgaWR4ICYmIHRlc3RUb2tlblR5cGUoc3RyLCB0b2tUeXBlLlBBVFRFUk4pKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IFwiVG9rZW46IC0+XCIuY29uY2F0KHRva2VuVHlwZS5uYW1lLCBcIjwtIGNhbiBuZXZlciBiZSBtYXRjaGVkLlxcblwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiQmVjYXVzZSBpdCBhcHBlYXJzIEFGVEVSIHRoZSBUb2tlbiBUeXBlIC0+XCIuY29uY2F0KHRva1R5cGUubmFtZSwgXCI8LVwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiaW4gdGhlIGxleGVyJ3MgZGVmaW5pdGlvbi5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiU2VlIGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNVTlJFQUNIQUJMRVwiO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBsZXhlcl9wdWJsaWNfMS5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuVU5SRUFDSEFCTEVfUEFUVEVSTixcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5UeXBlczogW3Rva1R5cGUsIHRva2VuVHlwZV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydHMuZmluZFVucmVhY2hhYmxlUGF0dGVybnMgPSBmaW5kVW5yZWFjaGFibGVQYXR0ZXJucztcbmZ1bmN0aW9uIHRlc3RUb2tlblR5cGUoc3RyLCBwYXR0ZXJuKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoKDAsIGlzUmVnRXhwXzEuZGVmYXVsdCkocGF0dGVybikpIHtcbiAgICAgICAgdmFyIHJlZ0V4cEFycmF5ID0gcGF0dGVybi5leGVjKHN0cik7XG4gICAgICAgIHJldHVybiByZWdFeHBBcnJheSAhPT0gbnVsbCAmJiByZWdFeHBBcnJheS5pbmRleCA9PT0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIGlzRnVuY3Rpb25fMS5kZWZhdWx0KShwYXR0ZXJuKSkge1xuICAgICAgICAvLyBtYWludGFpbiB0aGUgQVBJIG9mIGN1c3RvbSBwYXR0ZXJuc1xuICAgICAgICByZXR1cm4gcGF0dGVybihzdHIsIDAsIFtdLCB7fSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBoYXNfMS5kZWZhdWx0KShwYXR0ZXJuLCBcImV4ZWNcIikpIHtcbiAgICAgICAgLy8gbWFpbnRhaW4gdGhlIEFQSSBvZiBjdXN0b20gcGF0dGVybnNcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uZXhlYyhzdHIsIDAsIFtdLCB7fSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuID09PSBzdHI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vTWV0YUNoYXIocmVnRXhwKSB7XG4gICAgLy9odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHBcbiAgICB2YXIgbWV0YUNoYXJzID0gW1xuICAgICAgICBcIi5cIixcbiAgICAgICAgXCJcXFxcXCIsXG4gICAgICAgIFwiW1wiLFxuICAgICAgICBcIl1cIixcbiAgICAgICAgXCJ8XCIsXG4gICAgICAgIFwiXlwiLFxuICAgICAgICBcIiRcIixcbiAgICAgICAgXCIoXCIsXG4gICAgICAgIFwiKVwiLFxuICAgICAgICBcIj9cIixcbiAgICAgICAgXCIqXCIsXG4gICAgICAgIFwiK1wiLFxuICAgICAgICBcIntcIlxuICAgIF07XG4gICAgcmV0dXJuICgoMCwgZmluZF8xLmRlZmF1bHQpKG1ldGFDaGFycywgZnVuY3Rpb24gKGNoYXIpIHsgcmV0dXJuIHJlZ0V4cC5zb3VyY2UuaW5kZXhPZihjaGFyKSAhPT0gLTE7IH0pID09PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gYWRkU3RhcnRPZklucHV0KHBhdHRlcm4pIHtcbiAgICB2YXIgZmxhZ3MgPSBwYXR0ZXJuLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCI7XG4gICAgLy8gYWx3YXlzIHdyYXBwaW5nIGluIGEgbm9uZSBjYXB0dXJpbmcgZ3JvdXAgcHJlY2VkZWQgYnkgJ14nIHRvIG1ha2Ugc3VyZSBtYXRjaGluZyBjYW4gb25seSB3b3JrIG9uIHN0YXJ0IG9mIGlucHV0LlxuICAgIC8vIGR1cGxpY2F0ZS9yZWR1bmRhbnQgc3RhcnQgb2YgaW5wdXQgbWFya2VycyBoYXZlIG5vIG1lYW5pbmcgKC9eXl5eQS8gPT09IC9eQS8pXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIuY29uY2F0KHBhdHRlcm4uc291cmNlLCBcIilcIiksIGZsYWdzKTtcbn1cbmV4cG9ydHMuYWRkU3RhcnRPZklucHV0ID0gYWRkU3RhcnRPZklucHV0O1xuZnVuY3Rpb24gYWRkU3RpY2t5RmxhZyhwYXR0ZXJuKSB7XG4gICAgdmFyIGZsYWdzID0gcGF0dGVybi5pZ25vcmVDYXNlID8gXCJpeVwiIDogXCJ5XCI7XG4gICAgLy8gYWx3YXlzIHdyYXBwaW5nIGluIGEgbm9uZSBjYXB0dXJpbmcgZ3JvdXAgcHJlY2VkZWQgYnkgJ14nIHRvIG1ha2Ugc3VyZSBtYXRjaGluZyBjYW4gb25seSB3b3JrIG9uIHN0YXJ0IG9mIGlucHV0LlxuICAgIC8vIGR1cGxpY2F0ZS9yZWR1bmRhbnQgc3RhcnQgb2YgaW5wdXQgbWFya2VycyBoYXZlIG5vIG1lYW5pbmcgKC9eXl5eQS8gPT09IC9eQS8pXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJcIi5jb25jYXQocGF0dGVybi5zb3VyY2UpLCBmbGFncyk7XG59XG5leHBvcnRzLmFkZFN0aWNreUZsYWcgPSBhZGRTdGlja3lGbGFnO1xuZnVuY3Rpb24gcGVyZm9ybVJ1bnRpbWVDaGVja3MobGV4ZXJEZWZpbml0aW9uLCB0cmFja0xpbmVzLCBsaW5lVGVybWluYXRvckNoYXJhY3RlcnMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgLy8gc29tZSBydW4gdGltZSBjaGVja3MgdG8gaGVscCB0aGUgZW5kIHVzZXJzLlxuICAgIGlmICghKDAsIGhhc18xLmRlZmF1bHQpKGxleGVyRGVmaW5pdGlvbiwgZXhwb3J0cy5ERUZBVUxUX01PREUpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQSBNdWx0aU1vZGUgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGhvdXQgYSA8XCIgK1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuREVGQVVMVF9NT0RFICtcbiAgICAgICAgICAgICAgICBcIj4gcHJvcGVydHkgaW4gaXRzIGRlZmluaXRpb25cXG5cIixcbiAgICAgICAgICAgIHR5cGU6IGxleGVyX3B1YmxpY18xLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfREVGQVVMVF9NT0RFXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoISgwLCBoYXNfMS5kZWZhdWx0KShsZXhlckRlZmluaXRpb24sIGV4cG9ydHMuTU9ERVMpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQSBNdWx0aU1vZGUgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGhvdXQgYSA8XCIgK1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuTU9ERVMgK1xuICAgICAgICAgICAgICAgIFwiPiBwcm9wZXJ0eSBpbiBpdHMgZGVmaW5pdGlvblxcblwiLFxuICAgICAgICAgICAgdHlwZTogbGV4ZXJfcHVibGljXzEuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9NT0RFU19QUk9QRVJUWVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCgwLCBoYXNfMS5kZWZhdWx0KShsZXhlckRlZmluaXRpb24sIGV4cG9ydHMuTU9ERVMpICYmXG4gICAgICAgICgwLCBoYXNfMS5kZWZhdWx0KShsZXhlckRlZmluaXRpb24sIGV4cG9ydHMuREVGQVVMVF9NT0RFKSAmJlxuICAgICAgICAhKDAsIGhhc18xLmRlZmF1bHQpKGxleGVyRGVmaW5pdGlvbi5tb2RlcywgbGV4ZXJEZWZpbml0aW9uLmRlZmF1bHRNb2RlKSkge1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkEgTXVsdGlNb2RlIExleGVyIGNhbm5vdCBiZSBpbml0aWFsaXplZCB3aXRoIGEgXCIuY29uY2F0KGV4cG9ydHMuREVGQVVMVF9NT0RFLCBcIjogPFwiKS5jb25jYXQobGV4ZXJEZWZpbml0aW9uLmRlZmF1bHRNb2RlLCBcIj5cIikgK1xuICAgICAgICAgICAgICAgIFwid2hpY2ggZG9lcyBub3QgZXhpc3RcXG5cIixcbiAgICAgICAgICAgIHR5cGU6IGxleGVyX3B1YmxpY18xLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NVUxUSV9NT0RFX0xFWEVSX0RFRkFVTFRfTU9ERV9WQUxVRV9ET0VTX05PVF9FWElTVFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCgwLCBoYXNfMS5kZWZhdWx0KShsZXhlckRlZmluaXRpb24sIGV4cG9ydHMuTU9ERVMpKSB7XG4gICAgICAgICgwLCBmb3JFYWNoXzEuZGVmYXVsdCkobGV4ZXJEZWZpbml0aW9uLm1vZGVzLCBmdW5jdGlvbiAoY3Vyck1vZGVWYWx1ZSwgY3Vyck1vZGVOYW1lKSB7XG4gICAgICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKGN1cnJNb2RlVmFsdWUsIGZ1bmN0aW9uIChjdXJyVG9rVHlwZSwgY3VycklkeCkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgaXNVbmRlZmluZWRfMS5kZWZhdWx0KShjdXJyVG9rVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBIExleGVyIGNhbm5vdCBiZSBpbml0aWFsaXplZCB1c2luZyBhbiB1bmRlZmluZWQgVG9rZW4gVHlwZS4gTW9kZTpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8XCIuY29uY2F0KGN1cnJNb2RlTmFtZSwgXCI+IGF0IGluZGV4OiA8XCIpLmNvbmNhdChjdXJySWR4LCBcIj5cXG5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBsZXhlcl9wdWJsaWNfMS5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuTEVYRVJfREVGSU5JVElPTl9DQU5OT1RfQ09OVEFJTl9VTkRFRklORURcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgwLCBoYXNfMS5kZWZhdWx0KShjdXJyVG9rVHlwZSwgXCJMT05HRVJfQUxUXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb25nZXJBbHQgPSAoMCwgaXNBcnJheV8xLmRlZmF1bHQpKGN1cnJUb2tUeXBlLkxPTkdFUl9BTFQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGN1cnJUb2tUeXBlLkxPTkdFUl9BTFRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW2N1cnJUb2tUeXBlLkxPTkdFUl9BTFRdO1xuICAgICAgICAgICAgICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKGxvbmdlckFsdCwgZnVuY3Rpb24gKGN1cnJMb25nZXJBbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIGlzVW5kZWZpbmVkXzEuZGVmYXVsdCkoY3VyckxvbmdlckFsdCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKDAsIGluY2x1ZGVzXzEuZGVmYXVsdCkoY3Vyck1vZGVWYWx1ZSwgY3VyckxvbmdlckFsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQSBNdWx0aU1vZGUgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGggYSBsb25nZXJfYWx0IDxcIi5jb25jYXQoY3VyckxvbmdlckFsdC5uYW1lLCBcIj4gb24gdG9rZW4gPFwiKS5jb25jYXQoY3VyclRva1R5cGUubmFtZSwgXCI+IG91dHNpZGUgb2YgbW9kZSA8XCIpLmNvbmNhdChjdXJyTW9kZU5hbWUsIFwiPlxcblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbGV4ZXJfcHVibGljXzEuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk1VTFRJX01PREVfTEVYRVJfTE9OR0VSX0FMVF9OT1RfSU5fQ1VSUkVOVF9NT0RFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydHMucGVyZm9ybVJ1bnRpbWVDaGVja3MgPSBwZXJmb3JtUnVudGltZUNoZWNrcztcbmZ1bmN0aW9uIHBlcmZvcm1XYXJuaW5nUnVudGltZUNoZWNrcyhsZXhlckRlZmluaXRpb24sIHRyYWNrTGluZXMsIGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycykge1xuICAgIHZhciB3YXJuaW5ncyA9IFtdO1xuICAgIHZhciBoYXNBbnlMaW5lQnJlYWsgPSBmYWxzZTtcbiAgICB2YXIgYWxsVG9rZW5UeXBlcyA9ICgwLCBjb21wYWN0XzEuZGVmYXVsdCkoKDAsIGZsYXR0ZW5fMS5kZWZhdWx0KSgoMCwgdmFsdWVzXzEuZGVmYXVsdCkobGV4ZXJEZWZpbml0aW9uLm1vZGVzKSkpO1xuICAgIHZhciBjb25jcmV0ZVRva2VuVHlwZXMgPSAoMCwgcmVqZWN0XzEuZGVmYXVsdCkoYWxsVG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7IHJldHVybiBjdXJyVHlwZVtQQVRURVJOXSA9PT0gbGV4ZXJfcHVibGljXzEuTGV4ZXIuTkE7IH0pO1xuICAgIHZhciB0ZXJtaW5hdG9yQ2hhckNvZGVzID0gZ2V0Q2hhckNvZGVzKGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycyk7XG4gICAgaWYgKHRyYWNrTGluZXMpIHtcbiAgICAgICAgKDAsIGZvckVhY2hfMS5kZWZhdWx0KShjb25jcmV0ZVRva2VuVHlwZXMsIGZ1bmN0aW9uICh0b2tUeXBlKSB7XG4gICAgICAgICAgICB2YXIgY3Vycklzc3VlID0gY2hlY2tMaW5lQnJlYWtzSXNzdWVzKHRva1R5cGUsIHRlcm1pbmF0b3JDaGFyQ29kZXMpO1xuICAgICAgICAgICAgaWYgKGN1cnJJc3N1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGJ1aWxkTGluZUJyZWFrSXNzdWVNZXNzYWdlKHRva1R5cGUsIGN1cnJJc3N1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHdhcm5pbmdEZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjdXJySXNzdWUuaXNzdWUsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZTogdG9rVHlwZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd2FybmluZ3MucHVzaCh3YXJuaW5nRGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGF0dGVtcHQgdG8gc2NhbiBpZiB0aGUgdXNlciBleHBsaWNpdGx5IHNwZWNpZmllZCB0aGUgbGluZV9icmVha3Mgb3B0aW9uLlxuICAgICAgICAgICAgICAgIGlmICgoMCwgaGFzXzEuZGVmYXVsdCkodG9rVHlwZSwgXCJMSU5FX0JSRUFLU1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rVHlwZS5MSU5FX0JSRUFLUyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQW55TGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCByZWdfZXhwXzEuY2FuTWF0Y2hDaGFyQ29kZSkodGVybWluYXRvckNoYXJDb2RlcywgdG9rVHlwZS5QQVRURVJOKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQW55TGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0cmFja0xpbmVzICYmICFoYXNBbnlMaW5lQnJlYWspIHtcbiAgICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIldhcm5pbmc6IE5vIExJTkVfQlJFQUtTIEZvdW5kLlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFRoaXMgTGV4ZXIgaGFzIGJlZW4gZGVmaW5lZCB0byB0cmFjayBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24sXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0QnV0IG5vbmUgb2YgdGhlIFRva2VuIFR5cGVzIGNhbiBiZSBpZGVudGlmaWVkIGFzIG1hdGNoaW5nIGEgbGluZSB0ZXJtaW5hdG9yLlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFNlZSBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjTElORV9CUkVBS1MgXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0Zm9yIGRldGFpbHMuXCIsXG4gICAgICAgICAgICB0eXBlOiBsZXhlcl9wdWJsaWNfMS5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuTk9fTElORV9CUkVBS1NfRkxBR1NcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB3YXJuaW5ncztcbn1cbmV4cG9ydHMucGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzID0gcGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzO1xuZnVuY3Rpb24gY2xvbmVFbXB0eUdyb3VwcyhlbXB0eUdyb3Vwcykge1xuICAgIHZhciBjbG9uZWRSZXN1bHQgPSB7fTtcbiAgICB2YXIgZ3JvdXBLZXlzID0gKDAsIGtleXNfMS5kZWZhdWx0KShlbXB0eUdyb3Vwcyk7XG4gICAgKDAsIGZvckVhY2hfMS5kZWZhdWx0KShncm91cEtleXMsIGZ1bmN0aW9uIChjdXJyS2V5KSB7XG4gICAgICAgIHZhciBjdXJyR3JvdXBWYWx1ZSA9IGVtcHR5R3JvdXBzW2N1cnJLZXldO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoKDAsIGlzQXJyYXlfMS5kZWZhdWx0KShjdXJyR3JvdXBWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNsb25lZFJlc3VsdFtjdXJyS2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZWRSZXN1bHQ7XG59XG5leHBvcnRzLmNsb25lRW1wdHlHcm91cHMgPSBjbG9uZUVtcHR5R3JvdXBzO1xuLy8gVE9ETzogcmVmYWN0b3IgdG8gYXZvaWQgZHVwbGljYXRpb25cbmZ1bmN0aW9uIGlzQ3VzdG9tUGF0dGVybih0b2tlblR5cGUpIHtcbiAgICB2YXIgcGF0dGVybiA9IHRva2VuVHlwZS5QQVRURVJOO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKCgwLCBpc1JlZ0V4cF8xLmRlZmF1bHQpKHBhdHRlcm4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIGlzRnVuY3Rpb25fMS5kZWZhdWx0KShwYXR0ZXJuKSkge1xuICAgICAgICAvLyBDdXN0b21QYXR0ZXJuTWF0Y2hlckZ1bmMgLSBjdXN0b20gcGF0dGVybnMgZG8gbm90IHJlcXVpcmUgYW55IHRyYW5zZm9ybWF0aW9ucywgb25seSB3cmFwcGluZyBpbiBhIFJlZ0V4cCBMaWtlIG9iamVjdFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIGhhc18xLmRlZmF1bHQpKHBhdHRlcm4sIFwiZXhlY1wiKSkge1xuICAgICAgICAvLyBJQ3VzdG9tUGF0dGVyblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIGlzU3RyaW5nXzEuZGVmYXVsdCkocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG5leHBvcnRzLmlzQ3VzdG9tUGF0dGVybiA9IGlzQ3VzdG9tUGF0dGVybjtcbmZ1bmN0aW9uIGlzU2hvcnRQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICBpZiAoKDAsIGlzU3RyaW5nXzEuZGVmYXVsdCkocGF0dGVybikgJiYgcGF0dGVybi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzU2hvcnRQYXR0ZXJuID0gaXNTaG9ydFBhdHRlcm47XG4vKipcbiAqIEZhc3RlciB0aGFuIHVzaW5nIGEgUmVnRXhwIGZvciBkZWZhdWx0IG5ld2xpbmUgZGV0ZWN0aW9uIGR1cmluZyBsZXhpbmcuXG4gKi9cbmV4cG9ydHMuTGluZVRlcm1pbmF0b3JPcHRpbWl6ZWRUZXN0ZXIgPSB7XG4gICAgLy8gaW1wbGVtZW50cyAvXFxufFxcclxcbj8vZy50ZXN0XG4gICAgdGVzdDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRleHQubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sYXN0SW5kZXg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0SW5kZXggPSBpICsgMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGxhc3RJbmRleDogMFxufTtcbmZ1bmN0aW9uIGNoZWNrTGluZUJyZWFrc0lzc3Vlcyh0b2tUeXBlLCBsaW5lVGVybWluYXRvckNoYXJDb2Rlcykge1xuICAgIGlmICgoMCwgaGFzXzEuZGVmYXVsdCkodG9rVHlwZSwgXCJMSU5FX0JSRUFLU1wiKSkge1xuICAgICAgICAvLyBpZiB0aGUgdXNlciBleHBsaWNpdGx5IGRlY2xhcmVkIHRoZSBsaW5lX2JyZWFrcyBvcHRpb24gd2Ugd2lsbCByZXNwZWN0IHRoZWlyIGNob2ljZVxuICAgICAgICAvLyBhbmQgYXNzdW1lIGl0IGlzIGNvcnJlY3QuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICgoMCwgaXNSZWdFeHBfMS5kZWZhdWx0KSh0b2tUeXBlLlBBVFRFUk4pKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdoeSBpcyB0aGUgY2FzdGluZyBzdWRkZW5seSBuZWVkZWQ/XG4gICAgICAgICAgICAgICAgKDAsIHJlZ19leHBfMS5jYW5NYXRjaENoYXJDb2RlKShsaW5lVGVybWluYXRvckNoYXJDb2RlcywgdG9rVHlwZS5QQVRURVJOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSB0byB0ZXN0IHRoaXMgd2Ugd291bGQgaGF2ZSB0byBtb2NrIDxjYW5NYXRjaENoYXJDb2RlPiB0byB0aHJvdyBhbiBlcnJvciAqL1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlOiBsZXhlcl9wdWJsaWNfMS5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuSURFTlRJRllfVEVSTUlOQVRPUixcbiAgICAgICAgICAgICAgICAgICAgZXJyTXNnOiBlLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBpc1N0cmluZ18xLmRlZmF1bHQpKHRva1R5cGUuUEFUVEVSTikpIHtcbiAgICAgICAgICAgIC8vIHN0cmluZyBsaXRlcmFsIHBhdHRlcm5zIGNhbiBhbHdheXMgYmUgYW5hbHl6ZWQgdG8gZGV0ZWN0IGxpbmUgdGVybWluYXRvciB1c2FnZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ3VzdG9tUGF0dGVybih0b2tUeXBlKSkge1xuICAgICAgICAgICAgLy8gY3VzdG9tIHRva2VuIHR5cGVzXG4gICAgICAgICAgICByZXR1cm4geyBpc3N1ZTogbGV4ZXJfcHVibGljXzEuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkNVU1RPTV9MSU5FX0JSRUFLIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRMaW5lQnJlYWtJc3N1ZU1lc3NhZ2UodG9rVHlwZSwgZGV0YWlscykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGRldGFpbHMuaXNzdWUgPT09IGxleGVyX3B1YmxpY18xLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5JREVOVElGWV9URVJNSU5BVE9SKSB7XG4gICAgICAgIHJldHVybiAoXCJXYXJuaW5nOiB1bmFibGUgdG8gaWRlbnRpZnkgbGluZSB0ZXJtaW5hdG9yIHVzYWdlIGluIHBhdHRlcm4uXFxuXCIgK1xuICAgICAgICAgICAgXCJcXHRUaGUgcHJvYmxlbSBpcyBpbiB0aGUgPFwiLmNvbmNhdCh0b2tUeXBlLm5hbWUsIFwiPiBUb2tlbiBUeXBlXFxuXCIpICtcbiAgICAgICAgICAgIFwiXFx0IFJvb3QgY2F1c2U6IFwiLmNvbmNhdChkZXRhaWxzLmVyck1zZywgXCIuXFxuXCIpICtcbiAgICAgICAgICAgIFwiXFx0Rm9yIGRldGFpbHMgU2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjSURFTlRJRllfVEVSTUlOQVRPUlwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGV0YWlscy5pc3N1ZSA9PT0gbGV4ZXJfcHVibGljXzEuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkNVU1RPTV9MSU5FX0JSRUFLKSB7XG4gICAgICAgIHJldHVybiAoXCJXYXJuaW5nOiBBIEN1c3RvbSBUb2tlbiBQYXR0ZXJuIHNob3VsZCBzcGVjaWZ5IHRoZSA8bGluZV9icmVha3M+IG9wdGlvbi5cXG5cIiArXG4gICAgICAgICAgICBcIlxcdFRoZSBwcm9ibGVtIGlzIGluIHRoZSA8XCIuY29uY2F0KHRva1R5cGUubmFtZSwgXCI+IFRva2VuIFR5cGVcXG5cIikgK1xuICAgICAgICAgICAgXCJcXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNDVVNUT01fTElORV9CUkVBS1wiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZXhwb3J0cy5idWlsZExpbmVCcmVha0lzc3VlTWVzc2FnZSA9IGJ1aWxkTGluZUJyZWFrSXNzdWVNZXNzYWdlO1xuZnVuY3Rpb24gZ2V0Q2hhckNvZGVzKGNoYXJzT3JDb2Rlcykge1xuICAgIHZhciBjaGFyQ29kZXMgPSAoMCwgbWFwXzEuZGVmYXVsdCkoY2hhcnNPckNvZGVzLCBmdW5jdGlvbiAobnVtT3JTdHJpbmcpIHtcbiAgICAgICAgaWYgKCgwLCBpc1N0cmluZ18xLmRlZmF1bHQpKG51bU9yU3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bU9yU3RyaW5nLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtT3JTdHJpbmc7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2hhckNvZGVzO1xufVxuZnVuY3Rpb24gYWRkVG9NYXBPZkFycmF5cyhtYXAsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAobWFwW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtYXBba2V5XSA9IFt2YWx1ZV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXBba2V5XS5wdXNoKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLm1pbk9wdGltaXphdGlvblZhbCA9IDI1Njtcbi8qKlxuICogV2UgYXJlIG1hcHBpbmcgY2hhckNvZGUgYWJvdmUgQVNDSSAoMjU2KSBpbnRvIGJ1Y2tldHMgZWFjaCBpbiB0aGUgc2l6ZSBvZiAyNTYuXG4gKiBUaGlzIGlzIGJlY2F1c2UgQVNDSSBhcmUgdGhlIG1vc3QgY29tbW9uIHN0YXJ0IGNoYXJzIHNvIGVhY2ggb25lIG9mIHRob3NlIHdpbGwgZ2V0IGl0cyBvd25cbiAqIHBvc3NpYmxlIHRva2VuIGNvbmZpZ3MgdmVjdG9yLlxuICpcbiAqIFRva2VucyBzdGFydGluZyB3aXRoIGNoYXJDb2RlcyBcImFib3ZlXCIgQVNDSSBhcmUgdW5jb21tb24sIHNvIHdlIGNhbiBcImFmZm9yZFwiXG4gKiB0byBwbGFjZSB0aGVzZSBpbnRvIGJ1Y2tldHMgb2YgcG9zc2libGUgdG9rZW4gY29uZmlncywgV2hhdCB3ZSBnYWluIGZyb21cbiAqIHRoaXMgaXMgYXZvaWRpbmcgdGhlIGNhc2Ugb2YgY3JlYXRpbmcgYW4gb3B0aW1pemF0aW9uICdjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnJ1xuICogd2hpY2ggd291bGQgY29udGFpbiAxMCwwMDArIGFycmF5cyBvZiBzbWFsbCBzaXplIChlLmcgdW5pY29kZSBJZGVudGlmaWVycyBzY2VuYXJpbykuXG4gKiBPdXIgJ2NoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcnIG1heCBzaXplIHdpbGwgbm93IGJlOlxuICogMjU2ICsgKDJeMTYgLyAyXjgpIC0gMSA9PT0gNTExXG4gKlxuICogbm90ZSB0aGUgaGFjayBmb3IgZmFzdCBkaXZpc2lvbiBpbnRlZ2VyIHBhcnQgZXh0cmFjdGlvblxuICogU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDIyODUyOFxuICovXG52YXIgY2hhckNvZGVUb09wdGltaXplZElkeE1hcCA9IFtdO1xuZnVuY3Rpb24gY2hhckNvZGVUb09wdGltaXplZEluZGV4KGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlIDwgZXhwb3J0cy5taW5PcHRpbWl6YXRpb25WYWxcbiAgICAgICAgPyBjaGFyQ29kZVxuICAgICAgICA6IGNoYXJDb2RlVG9PcHRpbWl6ZWRJZHhNYXBbY2hhckNvZGVdO1xufVxuZXhwb3J0cy5jaGFyQ29kZVRvT3B0aW1pemVkSW5kZXggPSBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXg7XG4vKipcbiAqIFRoaXMgaXMgYSBjb21wcm9taXNlIGJldHdlZW4gY29sZCBzdGFydCAvIGhvdCBydW5uaW5nIHBlcmZvcm1hbmNlXG4gKiBDcmVhdGluZyB0aGlzIGFycmF5IHRha2VzIH4zbXMgb24gYSBtb2Rlcm4gbWFjaGluZSxcbiAqIEJ1dCBpZiB3ZSBwZXJmb3JtIHRoZSBjb21wdXRhdGlvbiBhdCBydW50aW1lIGFzIG5lZWRlZCB0aGUgQ1NTIExleGVyIGJlbmNobWFya1xuICogcGVyZm9ybWFuY2UgZGVncmFkZXMgYnkgfjEwJVxuICpcbiAqIFRPRE86IFBlcmhhcHMgaXQgc2hvdWxkIGJlIGxhenkgaW5pdGlhbGl6ZWQgb25seSBpZiBhIGNoYXJDb2RlID4gMjU1IGlzIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGluaXRDaGFyQ29kZVRvT3B0aW1pemVkSW5kZXhNYXAoKSB7XG4gICAgaWYgKCgwLCBpc0VtcHR5XzEuZGVmYXVsdCkoY2hhckNvZGVUb09wdGltaXplZElkeE1hcCkpIHtcbiAgICAgICAgY2hhckNvZGVUb09wdGltaXplZElkeE1hcCA9IG5ldyBBcnJheSg2NTUzNik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjU1MzY7IGkrKykge1xuICAgICAgICAgICAgY2hhckNvZGVUb09wdGltaXplZElkeE1hcFtpXSA9IGkgPiAyNTUgPyAyNTUgKyB+fihpIC8gMjU1KSA6IGk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXhlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/scan/lexer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/scan/lexer_errors_public.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/lexer_errors_public.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultLexerErrorProvider = void 0;\nexports.defaultLexerErrorProvider = {\n    buildUnableToPopLexerModeMessage: function (token) {\n        return \"Unable to pop Lexer Mode after encountering Token ->\".concat(token.image, \"<- The Mode Stack is empty\");\n    },\n    buildUnexpectedCharactersMessage: function (fullText, startOffset, length, line, column) {\n        return (\"unexpected character: ->\".concat(fullText.charAt(startOffset), \"<- at offset: \").concat(startOffset, \",\") + \" skipped \".concat(length, \" characters.\"));\n    }\n};\n//# sourceMappingURL=lexer_errors_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vbGV4ZXJfZXJyb3JzX3B1YmxpYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vbGV4ZXJfZXJyb3JzX3B1YmxpYy5qcz84NDA4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyID0gdm9pZCAwO1xuZXhwb3J0cy5kZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyID0ge1xuICAgIGJ1aWxkVW5hYmxlVG9Qb3BMZXhlck1vZGVNZXNzYWdlOiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIFwiVW5hYmxlIHRvIHBvcCBMZXhlciBNb2RlIGFmdGVyIGVuY291bnRlcmluZyBUb2tlbiAtPlwiLmNvbmNhdCh0b2tlbi5pbWFnZSwgXCI8LSBUaGUgTW9kZSBTdGFjayBpcyBlbXB0eVwiKTtcbiAgICB9LFxuICAgIGJ1aWxkVW5leHBlY3RlZENoYXJhY3RlcnNNZXNzYWdlOiBmdW5jdGlvbiAoZnVsbFRleHQsIHN0YXJ0T2Zmc2V0LCBsZW5ndGgsIGxpbmUsIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gKFwidW5leHBlY3RlZCBjaGFyYWN0ZXI6IC0+XCIuY29uY2F0KGZ1bGxUZXh0LmNoYXJBdChzdGFydE9mZnNldCksIFwiPC0gYXQgb2Zmc2V0OiBcIikuY29uY2F0KHN0YXJ0T2Zmc2V0LCBcIixcIikgKyBcIiBza2lwcGVkIFwiLmNvbmNhdChsZW5ndGgsIFwiIGNoYXJhY3RlcnMuXCIpKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV4ZXJfZXJyb3JzX3B1YmxpYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/scan/lexer_errors_public.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/scan/lexer_public.js":
/*!**************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/lexer_public.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Lexer = exports.LexerDefinitionErrorType = void 0;\nvar lexer_1 = __webpack_require__(/*! ./lexer */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/lexer.js\");\nvar noop_1 = __importDefault(__webpack_require__(/*! lodash/noop */ \"(ssr)/./node_modules/lodash/noop.js\"));\nvar isEmpty_1 = __importDefault(__webpack_require__(/*! lodash/isEmpty */ \"(ssr)/./node_modules/lodash/isEmpty.js\"));\nvar isArray_1 = __importDefault(__webpack_require__(/*! lodash/isArray */ \"(ssr)/./node_modules/lodash/isArray.js\"));\nvar last_1 = __importDefault(__webpack_require__(/*! lodash/last */ \"(ssr)/./node_modules/lodash/last.js\"));\nvar reject_1 = __importDefault(__webpack_require__(/*! lodash/reject */ \"(ssr)/./node_modules/lodash/reject.js\"));\nvar map_1 = __importDefault(__webpack_require__(/*! lodash/map */ \"(ssr)/./node_modules/lodash/map.js\"));\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar keys_1 = __importDefault(__webpack_require__(/*! lodash/keys */ \"(ssr)/./node_modules/lodash/keys.js\"));\nvar isUndefined_1 = __importDefault(__webpack_require__(/*! lodash/isUndefined */ \"(ssr)/./node_modules/lodash/isUndefined.js\"));\nvar identity_1 = __importDefault(__webpack_require__(/*! lodash/identity */ \"(ssr)/./node_modules/lodash/identity.js\"));\nvar assign_1 = __importDefault(__webpack_require__(/*! lodash/assign */ \"(ssr)/./node_modules/lodash/assign.js\"));\nvar reduce_1 = __importDefault(__webpack_require__(/*! lodash/reduce */ \"(ssr)/./node_modules/lodash/reduce.js\"));\nvar clone_1 = __importDefault(__webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"));\nvar utils_1 = __webpack_require__(/*! @chevrotain/utils */ \"(ssr)/./node_modules/@chevrotain/utils/lib/src/api.js\");\nvar tokens_1 = __webpack_require__(/*! ./tokens */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/tokens.js\");\nvar lexer_errors_public_1 = __webpack_require__(/*! ./lexer_errors_public */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/lexer_errors_public.js\");\nvar reg_exp_parser_1 = __webpack_require__(/*! ./reg_exp_parser */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js\");\nvar LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\"] = 17] = \"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\";\n})(LexerDefinitionErrorType = exports.LexerDefinitionErrorType || (exports.LexerDefinitionErrorType = {}));\nvar DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: \"full\",\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false,\n    recoveryEnabled: true\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nvar Lexer = /** @class */ (function () {\n    function Lexer(lexerDefinition, config) {\n        if (config === void 0) { config = DEFAULT_LEXER_CONFIG; }\n        var _this = this;\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        // Duplicated from the parser's perf trace trait to allow future extraction\n        // of the lexer to a separate package.\n        this.TRACE_INIT = function (phaseDesc, phaseImpl) {\n            // No need to optimize this using NOOP pattern because\n            // It is not called in a hot spot...\n            if (_this.traceInitPerf === true) {\n                _this.traceInitIndent++;\n                var indent = new Array(_this.traceInitIndent + 1).join(\"\\t\");\n                if (_this.traceInitIndent < _this.traceInitMaxIdent) {\n                    console.log(\"\".concat(indent, \"--> <\").concat(phaseDesc, \">\"));\n                }\n                var _a = (0, utils_1.timer)(phaseImpl), time = _a.time, value = _a.value;\n                /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n                var traceMethod = time > 10 ? console.warn : console.log;\n                if (_this.traceInitIndent < _this.traceInitMaxIdent) {\n                    traceMethod(\"\".concat(indent, \"<-- <\").concat(phaseDesc, \"> time: \").concat(time, \"ms\"));\n                }\n                _this.traceInitIndent--;\n                return value;\n            }\n            else {\n                return phaseImpl();\n            }\n        };\n        if (typeof config === \"boolean\") {\n            throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n                \"a boolean 2nd argument is no longer supported\");\n        }\n        // todo: defaults func?\n        this.config = (0, assign_1.default)({}, DEFAULT_LEXER_CONFIG, config);\n        var traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n            this.traceInitMaxIdent = Infinity;\n            this.traceInitPerf = true;\n        }\n        else if (typeof traceInitVal === \"number\") {\n            this.traceInitMaxIdent = traceInitVal;\n            this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT(\"Lexer Constructor\", function () {\n            var actualDefinition;\n            var hasOnlySingleMode = true;\n            _this.TRACE_INIT(\"Lexer Config handling\", function () {\n                if (_this.config.lineTerminatorsPattern ===\n                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n                    // optimized built-in implementation for the defaults definition of lineTerminators\n                    _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;\n                }\n                else {\n                    if (_this.config.lineTerminatorCharacters ===\n                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n                        throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n                    }\n                }\n                if (config.safeMode && config.ensureOptimizations) {\n                    throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n                }\n                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n                _this.trackEndLines = /full/i.test(_this.config.positionTracking);\n                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n                if ((0, isArray_1.default)(lexerDefinition)) {\n                    actualDefinition = {\n                        modes: { defaultMode: (0, clone_1.default)(lexerDefinition) },\n                        defaultMode: lexer_1.DEFAULT_MODE\n                    };\n                }\n                else {\n                    // no conversion needed, input should already be a IMultiModeLexerDefinition\n                    hasOnlySingleMode = false;\n                    actualDefinition = (0, clone_1.default)(lexerDefinition);\n                }\n            });\n            if (_this.config.skipValidations === false) {\n                _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n                _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n                    _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0, lexer_1.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n            }\n            // for extra robustness to avoid throwing an none informative error message\n            actualDefinition.modes = actualDefinition.modes\n                ? actualDefinition.modes\n                : {};\n            // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n            // this transformation is to increase robustness in the case of partially invalid lexer definition.\n            (0, forEach_1.default)(actualDefinition.modes, function (currModeValue, currModeName) {\n                actualDefinition.modes[currModeName] = (0, reject_1.default)(currModeValue, function (currTokType) { return (0, isUndefined_1.default)(currTokType); });\n            });\n            var allModeNames = (0, keys_1.default)(actualDefinition.modes);\n            (0, forEach_1.default)(actualDefinition.modes, function (currModDef, currModName) {\n                _this.TRACE_INIT(\"Mode: <\".concat(currModName, \"> processing\"), function () {\n                    _this.modes.push(currModName);\n                    if (_this.config.skipValidations === false) {\n                        _this.TRACE_INIT(\"validatePatterns\", function () {\n                            _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.validatePatterns)(currModDef, allModeNames));\n                        });\n                    }\n                    // If definition errors were encountered, the analysis phase may fail unexpectedly/\n                    // Considering a lexer with definition errors may never be used, there is no point\n                    // to performing the analysis anyhow...\n                    if ((0, isEmpty_1.default)(_this.lexerDefinitionErrors)) {\n                        (0, tokens_1.augmentTokenTypes)(currModDef);\n                        var currAnalyzeResult_1;\n                        _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n                            currAnalyzeResult_1 = (0, lexer_1.analyzeTokenTypes)(currModDef, {\n                                lineTerminatorCharacters: _this.config.lineTerminatorCharacters,\n                                positionTracking: config.positionTracking,\n                                ensureOptimizations: config.ensureOptimizations,\n                                safeMode: config.safeMode,\n                                tracer: _this.TRACE_INIT\n                            });\n                        });\n                        _this.patternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.patternIdxToConfig;\n                        _this.charCodeToPatternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n                        _this.emptyGroups = (0, assign_1.default)({}, _this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n                        _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;\n                        _this.canModeBeOptimized[currModName] =\n                            currAnalyzeResult_1.canBeOptimized;\n                    }\n                });\n            });\n            _this.defaultMode = actualDefinition.defaultMode;\n            if (!(0, isEmpty_1.default)(_this.lexerDefinitionErrors) &&\n                !_this.config.deferDefinitionErrorsHandling) {\n                var allErrMessages = (0, map_1.default)(_this.lexerDefinitionErrors, function (error) {\n                    return error.message;\n                });\n                var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n                throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n            }\n            // Only print warning if there are no errors, This will avoid pl\n            (0, forEach_1.default)(_this.lexerDefinitionWarning, function (warningDescriptor) {\n                (0, utils_1.PRINT_WARNING)(warningDescriptor.message);\n            });\n            _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n                // Choose the relevant internal implementations for this specific parser.\n                // These implementations should be in-lined by the JavaScript engine\n                // to provide optimal performance in each scenario.\n                if (lexer_1.SUPPORT_STICKY) {\n                    _this.chopInput = identity_1.default;\n                    _this.match = _this.matchWithTest;\n                }\n                else {\n                    _this.updateLastIndex = noop_1.default;\n                    _this.match = _this.matchWithExec;\n                }\n                if (hasOnlySingleMode) {\n                    _this.handleModes = noop_1.default;\n                }\n                if (_this.trackStartLines === false) {\n                    _this.computeNewColumn = identity_1.default;\n                }\n                if (_this.trackEndLines === false) {\n                    _this.updateTokenEndLineColumnLocation = noop_1.default;\n                }\n                if (/full/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createFullToken;\n                }\n                else if (/onlyStart/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createStartOnlyToken;\n                }\n                else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createOffsetOnlyToken;\n                }\n                else {\n                    throw Error(\"Invalid <positionTracking> config option: \\\"\".concat(_this.config.positionTracking, \"\\\"\"));\n                }\n                if (_this.hasCustom) {\n                    _this.addToken = _this.addTokenUsingPush;\n                    _this.handlePayload = _this.handlePayloadWithCustom;\n                }\n                else {\n                    _this.addToken = _this.addTokenUsingMemberAccess;\n                    _this.handlePayload = _this.handlePayloadNoCustom;\n                }\n            });\n            _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n                var unOptimizedModes = (0, reduce_1.default)(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n                    if (canBeOptimized === false) {\n                        cannotBeOptimized.push(modeName);\n                    }\n                    return cannotBeOptimized;\n                }, []);\n                if (config.ensureOptimizations && !(0, isEmpty_1.default)(unOptimizedModes)) {\n                    throw Error(\"Lexer Modes: < \".concat(unOptimizedModes.join(\", \"), \" > cannot be optimized.\\n\") +\n                        '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n                        \"\\t Or inspect the console log for details on how to resolve these issues.\");\n                }\n            });\n            _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n                (0, reg_exp_parser_1.clearRegExpParserCache)();\n            });\n            _this.TRACE_INIT(\"toFastProperties\", function () {\n                (0, utils_1.toFastProperties)(_this);\n            });\n        });\n    }\n    Lexer.prototype.tokenize = function (text, initialMode) {\n        if (initialMode === void 0) { initialMode = this.defaultMode; }\n        if (!(0, isEmpty_1.default)(this.lexerDefinitionErrors)) {\n            var allErrMessages = (0, map_1.default)(this.lexerDefinitionErrors, function (error) {\n                return error.message;\n            });\n            var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n                allErrMessagesString);\n        }\n        return this.tokenizeInternal(text, initialMode);\n    };\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    // this method also used quite a bit of `!` none null assertions because it is too optimized\n    // for `tsc` to always understand it is \"safe\"\n    Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n        var _this = this;\n        var i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n        var orgText = text;\n        var orgLength = orgText.length;\n        var offset = 0;\n        var matchedTokensIndex = 0;\n        // initializing the tokensArray to the \"guessed\" size.\n        // guessing too little will still reduce the number of array re-sizes on pushes.\n        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n        // but would still have a faster runtime by avoiding (All but one) array resizing.\n        var guessedNumberOfTokens = this.hasCustom\n            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n            : Math.floor(text.length / 10);\n        var matchedTokens = new Array(guessedNumberOfTokens);\n        var errors = [];\n        var line = this.trackStartLines ? 1 : undefined;\n        var column = this.trackStartLines ? 1 : undefined;\n        var groups = (0, lexer_1.cloneEmptyGroups)(this.emptyGroups);\n        var trackLines = this.trackStartLines;\n        var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n        var currModePatternsLength = 0;\n        var patternIdxToConfig = [];\n        var currCharCodeToPatternIdxToConfig = [];\n        var modeStack = [];\n        var emptyArray = [];\n        Object.freeze(emptyArray);\n        var getPossiblePatterns;\n        function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n        }\n        function getPossiblePatternsOptimized(charCode) {\n            var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(charCode);\n            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === undefined) {\n                return emptyArray;\n            }\n            else {\n                return possiblePatterns;\n            }\n        }\n        var pop_mode = function (popToken) {\n            // TODO: perhaps avoid this error in the edge case there is no more input?\n            if (modeStack.length === 1 &&\n                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n                // So no error should occur.\n                popToken.tokenType.PUSH_MODE === undefined) {\n                // if we try to pop the last mode there lexer will no longer have ANY mode.\n                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n                errors.push({\n                    offset: popToken.startOffset,\n                    line: popToken.startLine,\n                    column: popToken.startColumn,\n                    length: popToken.image.length,\n                    message: msg_1\n                });\n            }\n            else {\n                modeStack.pop();\n                var newMode = (0, last_1.default)(modeStack);\n                patternIdxToConfig = _this.patternIdxToConfig[newMode];\n                currCharCodeToPatternIdxToConfig =\n                    _this.charCodeToPatternIdxToConfig[newMode];\n                currModePatternsLength = patternIdxToConfig.length;\n                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;\n                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                    getPossiblePatterns = getPossiblePatternsOptimized;\n                }\n                else {\n                    getPossiblePatterns = getPossiblePatternsSlow;\n                }\n            }\n        };\n        function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig =\n                this.charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                getPossiblePatterns = getPossiblePatternsOptimized;\n            }\n            else {\n                getPossiblePatterns = getPossiblePatternsSlow;\n            }\n        }\n        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n        // seem to matter performance wise.\n        push_mode.call(this, initialMode);\n        var currConfig;\n        var recoveryEnabled = this.config.recoveryEnabled;\n        while (offset < orgLength) {\n            matchedImage = null;\n            var nextCharCode = orgText.charCodeAt(offset);\n            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            var chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for (i = 0; i < chosenPatternsLength; i++) {\n                currConfig = chosenPatternIdxToConfig[i];\n                var currPattern = currConfig.pattern;\n                payload = null;\n                // manually in-lined because > 600 chars won't be in-lined in V8\n                var singleCharCode = currConfig.short;\n                if (singleCharCode !== false) {\n                    if (nextCharCode === singleCharCode) {\n                        // single character string\n                        matchedImage = currPattern;\n                    }\n                }\n                else if (currConfig.isCustom === true) {\n                    match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                    if (match !== null) {\n                        matchedImage = match[0];\n                        if (match.payload !== undefined) {\n                            payload = match.payload;\n                        }\n                    }\n                    else {\n                        matchedImage = null;\n                    }\n                }\n                else {\n                    this.updateLastIndex(currPattern, offset);\n                    matchedImage = this.match(currPattern, text, offset);\n                }\n                if (matchedImage !== null) {\n                    // even though this pattern matched we must try a another longer alternative.\n                    // this can be used to prioritize keywords over identifiers\n                    longerAlt = currConfig.longerAlt;\n                    if (longerAlt !== undefined) {\n                        // TODO: micro optimize, avoid extra prop access\n                        // by saving/linking longerAlt on the original config?\n                        var longerAltLength = longerAlt.length;\n                        for (k = 0; k < longerAltLength; k++) {\n                            var longerAltConfig = patternIdxToConfig[longerAlt[k]];\n                            var longerAltPattern = longerAltConfig.pattern;\n                            altPayload = null;\n                            // single Char can never be a longer alt so no need to test it.\n                            // manually in-lined because > 600 chars won't be in-lined in V8\n                            if (longerAltConfig.isCustom === true) {\n                                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                                if (match !== null) {\n                                    matchAltImage = match[0];\n                                    if (match.payload !== undefined) {\n                                        altPayload = match.payload;\n                                    }\n                                }\n                                else {\n                                    matchAltImage = null;\n                                }\n                            }\n                            else {\n                                this.updateLastIndex(longerAltPattern, offset);\n                                matchAltImage = this.match(longerAltPattern, text, offset);\n                            }\n                            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                                matchedImage = matchAltImage;\n                                payload = altPayload;\n                                currConfig = longerAltConfig;\n                                // Exit the loop early after matching one of the longer alternatives\n                                // The first matched alternative takes precedence\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            // successful match\n            if (matchedImage !== null) {\n                imageLength = matchedImage.length;\n                group = currConfig.group;\n                if (group !== undefined) {\n                    tokType = currConfig.tokenTypeIdx;\n                    // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n                    // createFullToken method\n                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                    this.handlePayload(newToken, payload);\n                    // TODO: optimize NOOP in case there are no special groups?\n                    if (group === false) {\n                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                    }\n                    else {\n                        groups[group].push(newToken);\n                    }\n                }\n                text = this.chopInput(text, imageLength);\n                offset = offset + imageLength;\n                // TODO: with newlines the column may be assigned twice\n                column = this.computeNewColumn(column, imageLength);\n                if (trackLines === true && currConfig.canLineTerminator === true) {\n                    var numOfLTsInMatch = 0;\n                    var foundTerminator = void 0;\n                    var lastLTEndOffset = void 0;\n                    lineTerminatorPattern.lastIndex = 0;\n                    do {\n                        foundTerminator = lineTerminatorPattern.test(matchedImage);\n                        if (foundTerminator === true) {\n                            lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n                            numOfLTsInMatch++;\n                        }\n                    } while (foundTerminator === true);\n                    if (numOfLTsInMatch !== 0) {\n                        line = line + numOfLTsInMatch;\n                        column = imageLength - lastLTEndOffset;\n                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                    }\n                }\n                // will be NOOP if no modes present\n                this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            }\n            else {\n                // error recovery, drop characters until we identify a valid token's start point\n                var errorStartOffset = offset;\n                var errorLine = line;\n                var errorColumn = column;\n                var foundResyncPoint = recoveryEnabled === false;\n                while (foundResyncPoint === false && offset < orgLength) {\n                    // Identity Func (when sticky flag is enabled)\n                    text = this.chopInput(text, 1);\n                    offset++;\n                    for (j = 0; j < currModePatternsLength; j++) {\n                        var currConfig_1 = patternIdxToConfig[j];\n                        var currPattern = currConfig_1.pattern;\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        var singleCharCode = currConfig_1.short;\n                        if (singleCharCode !== false) {\n                            if (orgText.charCodeAt(offset) === singleCharCode) {\n                                // single character string\n                                foundResyncPoint = true;\n                            }\n                        }\n                        else if (currConfig_1.isCustom === true) {\n                            foundResyncPoint =\n                                currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n                        }\n                        else {\n                            this.updateLastIndex(currPattern, offset);\n                            foundResyncPoint = currPattern.exec(text) !== null;\n                        }\n                        if (foundResyncPoint === true) {\n                            break;\n                        }\n                    }\n                }\n                errLength = offset - errorStartOffset;\n                // at this point we either re-synced or reached the end of the input text\n                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n                errors.push({\n                    offset: errorStartOffset,\n                    line: errorLine,\n                    column: errorColumn,\n                    length: errLength,\n                    message: msg\n                });\n                if (recoveryEnabled === false) {\n                    break;\n                }\n            }\n        }\n        // if we do have custom patterns which push directly into the\n        // TODO: custom tokens should not push directly??\n        if (!this.hasCustom) {\n            // if we guessed a too large size for the tokens array this will shrink it to the right size.\n            matchedTokens.length = matchedTokensIndex;\n        }\n        return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors\n        };\n    };\n    Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n        if (config.pop === true) {\n            // need to save the PUSH_MODE property as if the mode is popped\n            // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n            var pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== undefined) {\n                push_mode.call(this, pushMode);\n            }\n        }\n        else if (config.push !== undefined) {\n            push_mode.call(this, config.push);\n        }\n    };\n    Lexer.prototype.chopInput = function (text, length) {\n        return text.substring(length);\n    };\n    Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n        regExp.lastIndex = newLastIndex;\n    };\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n        var lastCharIsLT, fixForEndingInLT;\n        if (group !== undefined) {\n            // a none skipped multi line Token, need to update endLine/endColumn\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n                // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n                newToken.endLine = line + fixForEndingInLT;\n                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n                // inclusive to exclusive range.\n                newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n            // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n        }\n    };\n    Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n        return oldColumn + imageLength;\n    };\n    Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            startLine: startLine,\n            startColumn: startColumn,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine: startLine,\n            endLine: startLine,\n            startColumn: startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n        tokenVector.push(tokenToAdd);\n        return index;\n    };\n    Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n        tokenVector[index] = tokenToAdd;\n        index++;\n        return index;\n    };\n    Lexer.prototype.handlePayloadNoCustom = function (token, payload) { };\n    Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n        if (payload !== null) {\n            token.payload = payload;\n        }\n    };\n    Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n        var found = pattern.test(text);\n        if (found === true) {\n            return text.substring(offset, pattern.lastIndex);\n        }\n        return null;\n    };\n    Lexer.prototype.matchWithExec = function (pattern, text) {\n        var regExpArray = pattern.exec(text);\n        return regExpArray !== null ? regExpArray[0] : null;\n    };\n    Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" +\n        \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n    Lexer.NA = /NOT_APPLICABLE/;\n    return Lexer;\n}());\nexports.Lexer = Lexer;\n//# sourceMappingURL=lexer_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vbGV4ZXJfcHVibGljLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGdDQUFnQztBQUNoRCxjQUFjLG1CQUFPLENBQUMsc0VBQVM7QUFDL0IsNkJBQTZCLG1CQUFPLENBQUMsd0RBQWE7QUFDbEQsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCw2QkFBNkIsbUJBQU8sQ0FBQyx3REFBYTtBQUNsRCwrQkFBK0IsbUJBQU8sQ0FBQyw0REFBZTtBQUN0RCw0QkFBNEIsbUJBQU8sQ0FBQyxzREFBWTtBQUNoRCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsNkJBQTZCLG1CQUFPLENBQUMsd0RBQWE7QUFDbEQsb0NBQW9DLG1CQUFPLENBQUMsc0VBQW9CO0FBQ2hFLGlDQUFpQyxtQkFBTyxDQUFDLGdFQUFpQjtBQUMxRCwrQkFBK0IsbUJBQU8sQ0FBQyw0REFBZTtBQUN0RCwrQkFBK0IsbUJBQU8sQ0FBQyw0REFBZTtBQUN0RCw4QkFBOEIsbUJBQU8sQ0FBQywwREFBYztBQUNwRCxjQUFjLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyw0QkFBNEIsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDM0QsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtFQUFrRSxnQ0FBZ0MsS0FBSztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvREFBb0Q7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFILGlEQUFpRDtBQUN0SyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9zY2FuL2xleGVyX3B1YmxpYy5qcz83YTM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MZXhlciA9IGV4cG9ydHMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlID0gdm9pZCAwO1xudmFyIGxleGVyXzEgPSByZXF1aXJlKFwiLi9sZXhlclwiKTtcbnZhciBub29wXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9ub29wXCIpKTtcbnZhciBpc0VtcHR5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VtcHR5XCIpKTtcbnZhciBpc0FycmF5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0FycmF5XCIpKTtcbnZhciBsYXN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9sYXN0XCIpKTtcbnZhciByZWplY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL3JlamVjdFwiKSk7XG52YXIgbWFwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9tYXBcIikpO1xudmFyIGZvckVhY2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2ZvckVhY2hcIikpO1xudmFyIGtleXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2tleXNcIikpO1xudmFyIGlzVW5kZWZpbmVkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc1VuZGVmaW5lZFwiKSk7XG52YXIgaWRlbnRpdHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lkZW50aXR5XCIpKTtcbnZhciBhc3NpZ25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2Fzc2lnblwiKSk7XG52YXIgcmVkdWNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9yZWR1Y2VcIikpO1xudmFyIGNsb25lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCJAY2hldnJvdGFpbi91dGlsc1wiKTtcbnZhciB0b2tlbnNfMSA9IHJlcXVpcmUoXCIuL3Rva2Vuc1wiKTtcbnZhciBsZXhlcl9lcnJvcnNfcHVibGljXzEgPSByZXF1aXJlKFwiLi9sZXhlcl9lcnJvcnNfcHVibGljXCIpO1xudmFyIHJlZ19leHBfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi9yZWdfZXhwX3BhcnNlclwiKTtcbnZhciBMZXhlckRlZmluaXRpb25FcnJvclR5cGU7XG4oZnVuY3Rpb24gKExleGVyRGVmaW5pdGlvbkVycm9yVHlwZSkge1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJNSVNTSU5HX1BBVFRFUk5cIl0gPSAwXSA9IFwiTUlTU0lOR19QQVRURVJOXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIklOVkFMSURfUEFUVEVSTlwiXSA9IDFdID0gXCJJTlZBTElEX1BBVFRFUk5cIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiRU9JX0FOQ0hPUl9GT1VORFwiXSA9IDJdID0gXCJFT0lfQU5DSE9SX0ZPVU5EXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlVOU1VQUE9SVEVEX0ZMQUdTX0ZPVU5EXCJdID0gM10gPSBcIlVOU1VQUE9SVEVEX0ZMQUdTX0ZPVU5EXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkRVUExJQ0FURV9QQVRURVJOU19GT1VORFwiXSA9IDRdID0gXCJEVVBMSUNBVEVfUEFUVEVSTlNfRk9VTkRcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSU5WQUxJRF9HUk9VUF9UWVBFX0ZPVU5EXCJdID0gNV0gPSBcIklOVkFMSURfR1JPVVBfVFlQRV9GT1VORFwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJQVVNIX01PREVfRE9FU19OT1RfRVhJU1RcIl0gPSA2XSA9IFwiUFVTSF9NT0RFX0RPRVNfTk9UX0VYSVNUXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9ERUZBVUxUX01PREVcIl0gPSA3XSA9IFwiTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX0RFRkFVTFRfTU9ERVwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJNVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfTU9ERVNfUFJPUEVSVFlcIl0gPSA4XSA9IFwiTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX01PREVTX1BST1BFUlRZXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIk1VTFRJX01PREVfTEVYRVJfREVGQVVMVF9NT0RFX1ZBTFVFX0RPRVNfTk9UX0VYSVNUXCJdID0gOV0gPSBcIk1VTFRJX01PREVfTEVYRVJfREVGQVVMVF9NT0RFX1ZBTFVFX0RPRVNfTk9UX0VYSVNUXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkxFWEVSX0RFRklOSVRJT05fQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEXCJdID0gMTBdID0gXCJMRVhFUl9ERUZJTklUSU9OX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRFwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJTT0lfQU5DSE9SX0ZPVU5EXCJdID0gMTFdID0gXCJTT0lfQU5DSE9SX0ZPVU5EXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkVNUFRZX01BVENIX1BBVFRFUk5cIl0gPSAxMl0gPSBcIkVNUFRZX01BVENIX1BBVFRFUk5cIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTk9fTElORV9CUkVBS1NfRkxBR1NcIl0gPSAxM10gPSBcIk5PX0xJTkVfQlJFQUtTX0ZMQUdTXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlVOUkVBQ0hBQkxFX1BBVFRFUk5cIl0gPSAxNF0gPSBcIlVOUkVBQ0hBQkxFX1BBVFRFUk5cIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSURFTlRJRllfVEVSTUlOQVRPUlwiXSA9IDE1XSA9IFwiSURFTlRJRllfVEVSTUlOQVRPUlwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJDVVNUT01fTElORV9CUkVBS1wiXSA9IDE2XSA9IFwiQ1VTVE9NX0xJTkVfQlJFQUtcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTVVMVElfTU9ERV9MRVhFUl9MT05HRVJfQUxUX05PVF9JTl9DVVJSRU5UX01PREVcIl0gPSAxN10gPSBcIk1VTFRJX01PREVfTEVYRVJfTE9OR0VSX0FMVF9OT1RfSU5fQ1VSUkVOVF9NT0RFXCI7XG59KShMZXhlckRlZmluaXRpb25FcnJvclR5cGUgPSBleHBvcnRzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZSB8fCAoZXhwb3J0cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUgPSB7fSkpO1xudmFyIERFRkFVTFRfTEVYRVJfQ09ORklHID0ge1xuICAgIGRlZmVyRGVmaW5pdGlvbkVycm9yc0hhbmRsaW5nOiBmYWxzZSxcbiAgICBwb3NpdGlvblRyYWNraW5nOiBcImZ1bGxcIixcbiAgICBsaW5lVGVybWluYXRvcnNQYXR0ZXJuOiAvXFxufFxcclxcbj8vZyxcbiAgICBsaW5lVGVybWluYXRvckNoYXJhY3RlcnM6IFtcIlxcblwiLCBcIlxcclwiXSxcbiAgICBlbnN1cmVPcHRpbWl6YXRpb25zOiBmYWxzZSxcbiAgICBzYWZlTW9kZTogZmFsc2UsXG4gICAgZXJyb3JNZXNzYWdlUHJvdmlkZXI6IGxleGVyX2Vycm9yc19wdWJsaWNfMS5kZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyLFxuICAgIHRyYWNlSW5pdFBlcmY6IGZhbHNlLFxuICAgIHNraXBWYWxpZGF0aW9uczogZmFsc2UsXG4gICAgcmVjb3ZlcnlFbmFibGVkOiB0cnVlXG59O1xuT2JqZWN0LmZyZWV6ZShERUZBVUxUX0xFWEVSX0NPTkZJRyk7XG52YXIgTGV4ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGV4ZXIobGV4ZXJEZWZpbml0aW9uLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IERFRkFVTFRfTEVYRVJfQ09ORklHOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubGV4ZXJEZWZpbml0aW9uID0gbGV4ZXJEZWZpbml0aW9uO1xuICAgICAgICB0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5wYXR0ZXJuSWR4VG9Db25maWcgPSB7fTtcbiAgICAgICAgdGhpcy5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnID0ge307XG4gICAgICAgIHRoaXMubW9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lbXB0eUdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnRyYWNrU3RhcnRMaW5lcyA9IHRydWU7XG4gICAgICAgIHRoaXMudHJhY2tFbmRMaW5lcyA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FuTW9kZUJlT3B0aW1pemVkID0ge307XG4gICAgICAgIC8vIER1cGxpY2F0ZWQgZnJvbSB0aGUgcGFyc2VyJ3MgcGVyZiB0cmFjZSB0cmFpdCB0byBhbGxvdyBmdXR1cmUgZXh0cmFjdGlvblxuICAgICAgICAvLyBvZiB0aGUgbGV4ZXIgdG8gYSBzZXBhcmF0ZSBwYWNrYWdlLlxuICAgICAgICB0aGlzLlRSQUNFX0lOSVQgPSBmdW5jdGlvbiAocGhhc2VEZXNjLCBwaGFzZUltcGwpIHtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gb3B0aW1pemUgdGhpcyB1c2luZyBOT09QIHBhdHRlcm4gYmVjYXVzZVxuICAgICAgICAgICAgLy8gSXQgaXMgbm90IGNhbGxlZCBpbiBhIGhvdCBzcG90Li4uXG4gICAgICAgICAgICBpZiAoX3RoaXMudHJhY2VJbml0UGVyZiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnRyYWNlSW5pdEluZGVudCsrO1xuICAgICAgICAgICAgICAgIHZhciBpbmRlbnQgPSBuZXcgQXJyYXkoX3RoaXMudHJhY2VJbml0SW5kZW50ICsgMSkuam9pbihcIlxcdFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudHJhY2VJbml0SW5kZW50IDwgX3RoaXMudHJhY2VJbml0TWF4SWRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJcIi5jb25jYXQoaW5kZW50LCBcIi0tPiA8XCIpLmNvbmNhdChwaGFzZURlc2MsIFwiPlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBfYSA9ICgwLCB1dGlsc18xLnRpbWVyKShwaGFzZUltcGwpLCB0aW1lID0gX2EudGltZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIERpZmZpY3VsdCB0byByZXByb2R1Y2Ugc3BlY2lmaWMgcGVyZm9ybWFuY2UgYmVoYXZpb3IgKD4xMG1zKSBpbiB0ZXN0cyAqL1xuICAgICAgICAgICAgICAgIHZhciB0cmFjZU1ldGhvZCA9IHRpbWUgPiAxMCA/IGNvbnNvbGUud2FybiA6IGNvbnNvbGUubG9nO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50cmFjZUluaXRJbmRlbnQgPCBfdGhpcy50cmFjZUluaXRNYXhJZGVudCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZU1ldGhvZChcIlwiLmNvbmNhdChpbmRlbnQsIFwiPC0tIDxcIikuY29uY2F0KHBoYXNlRGVzYywgXCI+IHRpbWU6IFwiKS5jb25jYXQodGltZSwgXCJtc1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnRyYWNlSW5pdEluZGVudC0tO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwaGFzZUltcGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIExleGVyIGNvbnN0cnVjdG9yIGlzIG5vdyBhbiBJTGV4ZXJDb25maWcgT2JqZWN0LlxcblwiICtcbiAgICAgICAgICAgICAgICBcImEgYm9vbGVhbiAybmQgYXJndW1lbnQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0b2RvOiBkZWZhdWx0cyBmdW5jP1xuICAgICAgICB0aGlzLmNvbmZpZyA9ICgwLCBhc3NpZ25fMS5kZWZhdWx0KSh7fSwgREVGQVVMVF9MRVhFUl9DT05GSUcsIGNvbmZpZyk7XG4gICAgICAgIHZhciB0cmFjZUluaXRWYWwgPSB0aGlzLmNvbmZpZy50cmFjZUluaXRQZXJmO1xuICAgICAgICBpZiAodHJhY2VJbml0VmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdE1heElkZW50ID0gSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdFBlcmYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0cmFjZUluaXRWYWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0TWF4SWRlbnQgPSB0cmFjZUluaXRWYWw7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdFBlcmYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2VJbml0SW5kZW50ID0gLTE7XG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcIkxleGVyIENvbnN0cnVjdG9yXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhY3R1YWxEZWZpbml0aW9uO1xuICAgICAgICAgICAgdmFyIGhhc09ubHlTaW5nbGVNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJMZXhlciBDb25maWcgaGFuZGxpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JzUGF0dGVybiA9PT1cbiAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9MRVhFUl9DT05GSUcubGluZVRlcm1pbmF0b3JzUGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWQgYnVpbHQtaW4gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBkZWZhdWx0cyBkZWZpbml0aW9uIG9mIGxpbmVUZXJtaW5hdG9yc1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JzUGF0dGVybiA9IGxleGVyXzEuTGluZVRlcm1pbmF0b3JPcHRpbWl6ZWRUZXN0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycyA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIERFRkFVTFRfTEVYRVJfQ09ORklHLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFcnJvcjogTWlzc2luZyA8bGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzPiBwcm9wZXJ0eSBvbiB0aGUgTGV4ZXIgY29uZmlnLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI01JU1NJTkdfTElORV9URVJNX0NIQVJTXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuc2FmZU1vZGUgJiYgY29uZmlnLmVuc3VyZU9wdGltaXphdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1wic2FmZU1vZGVcIiBhbmQgXCJlbnN1cmVPcHRpbWl6YXRpb25zXCIgZmxhZ3MgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhY2tTdGFydExpbmVzID0gL2Z1bGx8b25seVN0YXJ0L2kudGVzdChfdGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZyk7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhY2tFbmRMaW5lcyA9IC9mdWxsL2kudGVzdChfdGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZyk7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBTaW5nbGVNb2RlTGV4ZXJEZWZpbml0aW9uIGludG8gYSBJTXVsdGlNb2RlTGV4ZXJEZWZpbml0aW9uLlxuICAgICAgICAgICAgICAgIGlmICgoMCwgaXNBcnJheV8xLmRlZmF1bHQpKGxleGVyRGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVzOiB7IGRlZmF1bHRNb2RlOiAoMCwgY2xvbmVfMS5kZWZhdWx0KShsZXhlckRlZmluaXRpb24pIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TW9kZTogbGV4ZXJfMS5ERUZBVUxUX01PREVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIGNvbnZlcnNpb24gbmVlZGVkLCBpbnB1dCBzaG91bGQgYWxyZWFkeSBiZSBhIElNdWx0aU1vZGVMZXhlckRlZmluaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaGFzT25seVNpbmdsZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsRGVmaW5pdGlvbiA9ICgwLCBjbG9uZV8xLmRlZmF1bHQpKGxleGVyRGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLnNraXBWYWxpZGF0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwicGVyZm9ybVJ1bnRpbWVDaGVja3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMgPSBfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMuY29uY2F0KCgwLCBsZXhlcl8xLnBlcmZvcm1SdW50aW1lQ2hlY2tzKShhY3R1YWxEZWZpbml0aW9uLCBfdGhpcy50cmFja1N0YXJ0TGluZXMsIF90aGlzLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwicGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGV4ZXJEZWZpbml0aW9uV2FybmluZyA9IF90aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmcuY29uY2F0KCgwLCBsZXhlcl8xLnBlcmZvcm1XYXJuaW5nUnVudGltZUNoZWNrcykoYWN0dWFsRGVmaW5pdGlvbiwgX3RoaXMudHJhY2tTdGFydExpbmVzLCBfdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3IgZXh0cmEgcm9idXN0bmVzcyB0byBhdm9pZCB0aHJvd2luZyBhbiBub25lIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIGFjdHVhbERlZmluaXRpb24ubW9kZXMgPSBhY3R1YWxEZWZpbml0aW9uLm1vZGVzXG4gICAgICAgICAgICAgICAgPyBhY3R1YWxEZWZpbml0aW9uLm1vZGVzXG4gICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgICAgIC8vIGFuIGVycm9yIG9mIHVuZGVmaW5lZCBUb2tlblR5cGVzIHdpbGwgYmUgZGV0ZWN0ZWQgaW4gXCJwZXJmb3JtUnVudGltZUNoZWNrc1wiIGFib3ZlLlxuICAgICAgICAgICAgLy8gdGhpcyB0cmFuc2Zvcm1hdGlvbiBpcyB0byBpbmNyZWFzZSByb2J1c3RuZXNzIGluIHRoZSBjYXNlIG9mIHBhcnRpYWxseSBpbnZhbGlkIGxleGVyIGRlZmluaXRpb24uXG4gICAgICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKGFjdHVhbERlZmluaXRpb24ubW9kZXMsIGZ1bmN0aW9uIChjdXJyTW9kZVZhbHVlLCBjdXJyTW9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBhY3R1YWxEZWZpbml0aW9uLm1vZGVzW2N1cnJNb2RlTmFtZV0gPSAoMCwgcmVqZWN0XzEuZGVmYXVsdCkoY3Vyck1vZGVWYWx1ZSwgZnVuY3Rpb24gKGN1cnJUb2tUeXBlKSB7IHJldHVybiAoMCwgaXNVbmRlZmluZWRfMS5kZWZhdWx0KShjdXJyVG9rVHlwZSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgYWxsTW9kZU5hbWVzID0gKDAsIGtleXNfMS5kZWZhdWx0KShhY3R1YWxEZWZpbml0aW9uLm1vZGVzKTtcbiAgICAgICAgICAgICgwLCBmb3JFYWNoXzEuZGVmYXVsdCkoYWN0dWFsRGVmaW5pdGlvbi5tb2RlcywgZnVuY3Rpb24gKGN1cnJNb2REZWYsIGN1cnJNb2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIk1vZGU6IDxcIi5jb25jYXQoY3Vyck1vZE5hbWUsIFwiPiBwcm9jZXNzaW5nXCIpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1vZGVzLnB1c2goY3Vyck1vZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLnNraXBWYWxpZGF0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJ2YWxpZGF0ZVBhdHRlcm5zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMgPSBfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMuY29uY2F0KCgwLCBsZXhlcl8xLnZhbGlkYXRlUGF0dGVybnMpKGN1cnJNb2REZWYsIGFsbE1vZGVOYW1lcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGVmaW5pdGlvbiBlcnJvcnMgd2VyZSBlbmNvdW50ZXJlZCwgdGhlIGFuYWx5c2lzIHBoYXNlIG1heSBmYWlsIHVuZXhwZWN0ZWRseS9cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXJpbmcgYSBsZXhlciB3aXRoIGRlZmluaXRpb24gZXJyb3JzIG1heSBuZXZlciBiZSB1c2VkLCB0aGVyZSBpcyBubyBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBwZXJmb3JtaW5nIHRoZSBhbmFseXNpcyBhbnlob3cuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBpc0VtcHR5XzEuZGVmYXVsdCkoX3RoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHRva2Vuc18xLmF1Z21lbnRUb2tlblR5cGVzKShjdXJyTW9kRGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyQW5hbHl6ZVJlc3VsdF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcImFuYWx5emVUb2tlblR5cGVzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyQW5hbHl6ZVJlc3VsdF8xID0gKDAsIGxleGVyXzEuYW5hbHl6ZVRva2VuVHlwZXMpKGN1cnJNb2REZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzOiBfdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblRyYWNraW5nOiBjb25maWcucG9zaXRpb25UcmFja2luZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5zdXJlT3B0aW1pemF0aW9uczogY29uZmlnLmVuc3VyZU9wdGltaXphdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVNb2RlOiBjb25maWcuc2FmZU1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlcjogX3RoaXMuVFJBQ0VfSU5JVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXR0ZXJuSWR4VG9Db25maWdbY3Vyck1vZE5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyQW5hbHl6ZVJlc3VsdF8xLnBhdHRlcm5JZHhUb0NvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWdbY3Vyck1vZE5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyQW5hbHl6ZVJlc3VsdF8xLmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbXB0eUdyb3VwcyA9ICgwLCBhc3NpZ25fMS5kZWZhdWx0KSh7fSwgX3RoaXMuZW1wdHlHcm91cHMsIGN1cnJBbmFseXplUmVzdWx0XzEuZW1wdHlHcm91cHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFzQ3VzdG9tID0gY3VyckFuYWx5emVSZXN1bHRfMS5oYXNDdXN0b20gfHwgX3RoaXMuaGFzQ3VzdG9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FuTW9kZUJlT3B0aW1pemVkW2N1cnJNb2ROYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckFuYWx5emVSZXN1bHRfMS5jYW5CZU9wdGltaXplZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5kZWZhdWx0TW9kZSA9IGFjdHVhbERlZmluaXRpb24uZGVmYXVsdE1vZGU7XG4gICAgICAgICAgICBpZiAoISgwLCBpc0VtcHR5XzEuZGVmYXVsdCkoX3RoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzKSAmJlxuICAgICAgICAgICAgICAgICFfdGhpcy5jb25maWcuZGVmZXJEZWZpbml0aW9uRXJyb3JzSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxsRXJyTWVzc2FnZXMgPSAoMCwgbWFwXzEuZGVmYXVsdCkoX3RoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGFsbEVyck1lc3NhZ2VzU3RyaW5nID0gYWxsRXJyTWVzc2FnZXMuam9pbihcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9ycyBkZXRlY3RlZCBpbiBkZWZpbml0aW9uIG9mIExleGVyOlxcblwiICsgYWxsRXJyTWVzc2FnZXNTdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBwcmludCB3YXJuaW5nIGlmIHRoZXJlIGFyZSBubyBlcnJvcnMsIFRoaXMgd2lsbCBhdm9pZCBwbFxuICAgICAgICAgICAgKDAsIGZvckVhY2hfMS5kZWZhdWx0KShfdGhpcy5sZXhlckRlZmluaXRpb25XYXJuaW5nLCBmdW5jdGlvbiAod2FybmluZ0Rlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5QUklOVF9XQVJOSU5HKSh3YXJuaW5nRGVzY3JpcHRvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIkNob29zaW5nIHN1Yi1tZXRob2RzIGltcGxlbWVudGF0aW9uc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hvb3NlIHRoZSByZWxldmFudCBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbnMgZm9yIHRoaXMgc3BlY2lmaWMgcGFyc2VyLlxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYmUgaW4tbGluZWQgYnkgdGhlIEphdmFTY3JpcHQgZW5naW5lXG4gICAgICAgICAgICAgICAgLy8gdG8gcHJvdmlkZSBvcHRpbWFsIHBlcmZvcm1hbmNlIGluIGVhY2ggc2NlbmFyaW8uXG4gICAgICAgICAgICAgICAgaWYgKGxleGVyXzEuU1VQUE9SVF9TVElDS1kpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hvcElucHV0ID0gaWRlbnRpdHlfMS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXRjaCA9IF90aGlzLm1hdGNoV2l0aFRlc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVMYXN0SW5kZXggPSBub29wXzEuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWF0Y2ggPSBfdGhpcy5tYXRjaFdpdGhFeGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzT25seVNpbmdsZU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlTW9kZXMgPSBub29wXzEuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRyYWNrU3RhcnRMaW5lcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcHV0ZU5ld0NvbHVtbiA9IGlkZW50aXR5XzEuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRyYWNrRW5kTGluZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVRva2VuRW5kTGluZUNvbHVtbkxvY2F0aW9uID0gbm9vcF8xLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvZnVsbC9pLnRlc3QoX3RoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZVRva2VuSW5zdGFuY2UgPSBfdGhpcy5jcmVhdGVGdWxsVG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9vbmx5U3RhcnQvaS50ZXN0KF90aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVUb2tlbkluc3RhbmNlID0gX3RoaXMuY3JlYXRlU3RhcnRPbmx5VG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9vbmx5T2Zmc2V0L2kudGVzdChfdGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3JlYXRlVG9rZW5JbnN0YW5jZSA9IF90aGlzLmNyZWF0ZU9mZnNldE9ubHlUb2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCA8cG9zaXRpb25UcmFja2luZz4gY29uZmlnIG9wdGlvbjogXFxcIlwiLmNvbmNhdChfdGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZywgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmhhc0N1c3RvbSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRUb2tlbiA9IF90aGlzLmFkZFRva2VuVXNpbmdQdXNoO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVQYXlsb2FkID0gX3RoaXMuaGFuZGxlUGF5bG9hZFdpdGhDdXN0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRUb2tlbiA9IF90aGlzLmFkZFRva2VuVXNpbmdNZW1iZXJBY2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVBheWxvYWQgPSBfdGhpcy5oYW5kbGVQYXlsb2FkTm9DdXN0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiRmFpbGVkIE9wdGltaXphdGlvbiBXYXJuaW5nc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVuT3B0aW1pemVkTW9kZXMgPSAoMCwgcmVkdWNlXzEuZGVmYXVsdCkoX3RoaXMuY2FuTW9kZUJlT3B0aW1pemVkLCBmdW5jdGlvbiAoY2Fubm90QmVPcHRpbWl6ZWQsIGNhbkJlT3B0aW1pemVkLCBtb2RlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuQmVPcHRpbWl6ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5ub3RCZU9wdGltaXplZC5wdXNoKG1vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Fubm90QmVPcHRpbWl6ZWQ7XG4gICAgICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZW5zdXJlT3B0aW1pemF0aW9ucyAmJiAhKDAsIGlzRW1wdHlfMS5kZWZhdWx0KSh1bk9wdGltaXplZE1vZGVzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkxleGVyIE1vZGVzOiA8IFwiLmNvbmNhdCh1bk9wdGltaXplZE1vZGVzLmpvaW4oXCIsIFwiKSwgXCIgPiBjYW5ub3QgYmUgb3B0aW1pemVkLlxcblwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFx0IERpc2FibGUgdGhlIFwiZW5zdXJlT3B0aW1pemF0aW9uc1wiIGxleGVyIGNvbmZpZyBmbGFnIHRvIHNpbGVudGx5IGlnbm9yZSB0aGlzIGFuZCBydW4gdGhlIGxleGVyIGluIGFuIHVuLW9wdGltaXplZCBtb2RlLlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHQgT3IgaW5zcGVjdCB0aGUgY29uc29sZSBsb2cgZm9yIGRldGFpbHMgb24gaG93IHRvIHJlc29sdmUgdGhlc2UgaXNzdWVzLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJjbGVhclJlZ0V4cFBhcnNlckNhY2hlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAoMCwgcmVnX2V4cF9wYXJzZXJfMS5jbGVhclJlZ0V4cFBhcnNlckNhY2hlKSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwidG9GYXN0UHJvcGVydGllc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEudG9GYXN0UHJvcGVydGllcykoX3RoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBMZXhlci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAodGV4dCwgaW5pdGlhbE1vZGUpIHtcbiAgICAgICAgaWYgKGluaXRpYWxNb2RlID09PSB2b2lkIDApIHsgaW5pdGlhbE1vZGUgPSB0aGlzLmRlZmF1bHRNb2RlOyB9XG4gICAgICAgIGlmICghKDAsIGlzRW1wdHlfMS5kZWZhdWx0KSh0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycykpIHtcbiAgICAgICAgICAgIHZhciBhbGxFcnJNZXNzYWdlcyA9ICgwLCBtYXBfMS5kZWZhdWx0KSh0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBhbGxFcnJNZXNzYWdlc1N0cmluZyA9IGFsbEVyck1lc3NhZ2VzLmpvaW4oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBUb2tlbml6ZSBiZWNhdXNlIEVycm9ycyBkZXRlY3RlZCBpbiBkZWZpbml0aW9uIG9mIExleGVyOlxcblwiICtcbiAgICAgICAgICAgICAgICBhbGxFcnJNZXNzYWdlc1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5pemVJbnRlcm5hbCh0ZXh0LCBpbml0aWFsTW9kZSk7XG4gICAgfTtcbiAgICAvLyBUaGVyZSBpcyBxdWl0ZSBhIGJpdCBvZiBkdXBsaWNhdGlvbiBiZXR3ZWVuIHRoaXMgYW5kIFwidG9rZW5pemVJbnRlcm5hbExhenlcIlxuICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWwgZHVlIHRvIHBlcmZvcm1hbmNlIGNvbnNpZGVyYXRpb25zLlxuICAgIC8vIHRoaXMgbWV0aG9kIGFsc28gdXNlZCBxdWl0ZSBhIGJpdCBvZiBgIWAgbm9uZSBudWxsIGFzc2VydGlvbnMgYmVjYXVzZSBpdCBpcyB0b28gb3B0aW1pemVkXG4gICAgLy8gZm9yIGB0c2NgIHRvIGFsd2F5cyB1bmRlcnN0YW5kIGl0IGlzIFwic2FmZVwiXG4gICAgTGV4ZXIucHJvdG90eXBlLnRva2VuaXplSW50ZXJuYWwgPSBmdW5jdGlvbiAodGV4dCwgaW5pdGlhbE1vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGksIGosIGssIG1hdGNoQWx0SW1hZ2UsIGxvbmdlckFsdCwgbWF0Y2hlZEltYWdlLCBwYXlsb2FkLCBhbHRQYXlsb2FkLCBpbWFnZUxlbmd0aCwgZ3JvdXAsIHRva1R5cGUsIG5ld1Rva2VuLCBlcnJMZW5ndGgsIGRyb3BwZWRDaGFyLCBtc2csIG1hdGNoO1xuICAgICAgICB2YXIgb3JnVGV4dCA9IHRleHQ7XG4gICAgICAgIHZhciBvcmdMZW5ndGggPSBvcmdUZXh0Lmxlbmd0aDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBtYXRjaGVkVG9rZW5zSW5kZXggPSAwO1xuICAgICAgICAvLyBpbml0aWFsaXppbmcgdGhlIHRva2Vuc0FycmF5IHRvIHRoZSBcImd1ZXNzZWRcIiBzaXplLlxuICAgICAgICAvLyBndWVzc2luZyB0b28gbGl0dGxlIHdpbGwgc3RpbGwgcmVkdWNlIHRoZSBudW1iZXIgb2YgYXJyYXkgcmUtc2l6ZXMgb24gcHVzaGVzLlxuICAgICAgICAvLyBndWVzc2luZyB0b28gbGFyZ2UgKFRlc3RlZCBieSBndWVzc2luZyB4NCB0b28gbGFyZ2UpIG1heSBjb3N0IGEgYml0IG1vcmUgb2YgbWVtb3J5XG4gICAgICAgIC8vIGJ1dCB3b3VsZCBzdGlsbCBoYXZlIGEgZmFzdGVyIHJ1bnRpbWUgYnkgYXZvaWRpbmcgKEFsbCBidXQgb25lKSBhcnJheSByZXNpemluZy5cbiAgICAgICAgdmFyIGd1ZXNzZWROdW1iZXJPZlRva2VucyA9IHRoaXMuaGFzQ3VzdG9tXG4gICAgICAgICAgICA/IDAgLy8gd2lsbCBicmVhayBjdXN0b20gdG9rZW4gcGF0dGVybiBBUElzIHRoZSBtYXRjaGVkVG9rZW5zIGFycmF5IHdpbGwgY29udGFpbiB1bmRlZmluZWQgZWxlbWVudHMuXG4gICAgICAgICAgICA6IE1hdGguZmxvb3IodGV4dC5sZW5ndGggLyAxMCk7XG4gICAgICAgIHZhciBtYXRjaGVkVG9rZW5zID0gbmV3IEFycmF5KGd1ZXNzZWROdW1iZXJPZlRva2Vucyk7XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLnRyYWNrU3RhcnRMaW5lcyA/IDEgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLnRyYWNrU3RhcnRMaW5lcyA/IDEgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBncm91cHMgPSAoMCwgbGV4ZXJfMS5jbG9uZUVtcHR5R3JvdXBzKSh0aGlzLmVtcHR5R3JvdXBzKTtcbiAgICAgICAgdmFyIHRyYWNrTGluZXMgPSB0aGlzLnRyYWNrU3RhcnRMaW5lcztcbiAgICAgICAgdmFyIGxpbmVUZXJtaW5hdG9yUGF0dGVybiA9IHRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm47XG4gICAgICAgIHZhciBjdXJyTW9kZVBhdHRlcm5zTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHBhdHRlcm5JZHhUb0NvbmZpZyA9IFtdO1xuICAgICAgICB2YXIgY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPSBbXTtcbiAgICAgICAgdmFyIG1vZGVTdGFjayA9IFtdO1xuICAgICAgICB2YXIgZW1wdHlBcnJheSA9IFtdO1xuICAgICAgICBPYmplY3QuZnJlZXplKGVtcHR5QXJyYXkpO1xuICAgICAgICB2YXIgZ2V0UG9zc2libGVQYXR0ZXJucztcbiAgICAgICAgZnVuY3Rpb24gZ2V0UG9zc2libGVQYXR0ZXJuc1Nsb3coKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybklkeFRvQ29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFBvc3NpYmxlUGF0dGVybnNPcHRpbWl6ZWQoY2hhckNvZGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpbWl6ZWRDaGFySWR4ID0gKDAsIGxleGVyXzEuY2hhckNvZGVUb09wdGltaXplZEluZGV4KShjaGFyQ29kZSk7XG4gICAgICAgICAgICB2YXIgcG9zc2libGVQYXR0ZXJucyA9IGN1cnJDaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnW29wdGltaXplZENoYXJJZHhdO1xuICAgICAgICAgICAgaWYgKHBvc3NpYmxlUGF0dGVybnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc3NpYmxlUGF0dGVybnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvcF9tb2RlID0gZnVuY3Rpb24gKHBvcFRva2VuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBwZXJoYXBzIGF2b2lkIHRoaXMgZXJyb3IgaW4gdGhlIGVkZ2UgY2FzZSB0aGVyZSBpcyBubyBtb3JlIGlucHV0P1xuICAgICAgICAgICAgaWYgKG1vZGVTdGFjay5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGJvdGggYSBQT1BfTU9ERSBhbmQgYSBQVVNIX01PREUgdGhpcyBpcyBpbi1mYWN0IGEgXCJ0cmFuc2l0aW9uXCJcbiAgICAgICAgICAgICAgICAvLyBTbyBubyBlcnJvciBzaG91bGQgb2NjdXIuXG4gICAgICAgICAgICAgICAgcG9wVG9rZW4udG9rZW5UeXBlLlBVU0hfTU9ERSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgdHJ5IHRvIHBvcCB0aGUgbGFzdCBtb2RlIHRoZXJlIGxleGVyIHdpbGwgbm8gbG9uZ2VyIGhhdmUgQU5ZIG1vZGUuXG4gICAgICAgICAgICAgICAgLy8gdGh1cyB0aGUgcG9wIGlzIGlnbm9yZWQsIGFuIGVycm9yIHdpbGwgYmUgY3JlYXRlZCBhbmQgdGhlIGxleGVyIHdpbGwgY29udGludWUgcGFyc2luZyBpbiB0aGUgcHJldmlvdXMgbW9kZS5cbiAgICAgICAgICAgICAgICB2YXIgbXNnXzEgPSBfdGhpcy5jb25maWcuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRVbmFibGVUb1BvcExleGVyTW9kZU1lc3NhZ2UocG9wVG9rZW4pO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwb3BUb2tlbi5zdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogcG9wVG9rZW4uc3RhcnRMaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHBvcFRva2VuLnN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHBvcFRva2VuLmltYWdlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnXzFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TW9kZSA9ICgwLCBsYXN0XzEuZGVmYXVsdCkobW9kZVN0YWNrKTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuSWR4VG9Db25maWcgPSBfdGhpcy5wYXR0ZXJuSWR4VG9Db25maWdbbmV3TW9kZV07XG4gICAgICAgICAgICAgICAgY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnW25ld01vZGVdO1xuICAgICAgICAgICAgICAgIGN1cnJNb2RlUGF0dGVybnNMZW5ndGggPSBwYXR0ZXJuSWR4VG9Db25maWcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBtb2RlQ2FuQmVPcHRpbWl6ZWQgPSBfdGhpcy5jYW5Nb2RlQmVPcHRpbWl6ZWRbbmV3TW9kZV0gJiYgX3RoaXMuY29uZmlnLnNhZmVNb2RlID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgJiYgbW9kZUNhbkJlT3B0aW1pemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBvc3NpYmxlUGF0dGVybnMgPSBnZXRQb3NzaWJsZVBhdHRlcm5zT3B0aW1pemVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UG9zc2libGVQYXR0ZXJucyA9IGdldFBvc3NpYmxlUGF0dGVybnNTbG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcHVzaF9tb2RlKG5ld01vZGUpIHtcbiAgICAgICAgICAgIG1vZGVTdGFjay5wdXNoKG5ld01vZGUpO1xuICAgICAgICAgICAgY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPVxuICAgICAgICAgICAgICAgIHRoaXMuY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZ1tuZXdNb2RlXTtcbiAgICAgICAgICAgIHBhdHRlcm5JZHhUb0NvbmZpZyA9IHRoaXMucGF0dGVybklkeFRvQ29uZmlnW25ld01vZGVdO1xuICAgICAgICAgICAgY3Vyck1vZGVQYXR0ZXJuc0xlbmd0aCA9IHBhdHRlcm5JZHhUb0NvbmZpZy5sZW5ndGg7XG4gICAgICAgICAgICBjdXJyTW9kZVBhdHRlcm5zTGVuZ3RoID0gcGF0dGVybklkeFRvQ29uZmlnLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBtb2RlQ2FuQmVPcHRpbWl6ZWQgPSB0aGlzLmNhbk1vZGVCZU9wdGltaXplZFtuZXdNb2RlXSAmJiB0aGlzLmNvbmZpZy5zYWZlTW9kZSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgJiYgbW9kZUNhbkJlT3B0aW1pemVkKSB7XG4gICAgICAgICAgICAgICAgZ2V0UG9zc2libGVQYXR0ZXJucyA9IGdldFBvc3NpYmxlUGF0dGVybnNPcHRpbWl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRQb3NzaWJsZVBhdHRlcm5zID0gZ2V0UG9zc2libGVQYXR0ZXJuc1Nsb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBwYXR0ZXJuIHNlZW1zIHRvIGF2b2lkIGEgVjggZGUtb3B0aW1pemF0aW9uLCBhbHRob3VnaCB0aGF0IGRlLW9wdGltaXphdGlvbiBkb2VzIG5vdFxuICAgICAgICAvLyBzZWVtIHRvIG1hdHRlciBwZXJmb3JtYW5jZSB3aXNlLlxuICAgICAgICBwdXNoX21vZGUuY2FsbCh0aGlzLCBpbml0aWFsTW9kZSk7XG4gICAgICAgIHZhciBjdXJyQ29uZmlnO1xuICAgICAgICB2YXIgcmVjb3ZlcnlFbmFibGVkID0gdGhpcy5jb25maWcucmVjb3ZlcnlFbmFibGVkO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgb3JnTGVuZ3RoKSB7XG4gICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSBudWxsO1xuICAgICAgICAgICAgdmFyIG5leHRDaGFyQ29kZSA9IG9yZ1RleHQuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgdmFyIGNob3NlblBhdHRlcm5JZHhUb0NvbmZpZyA9IGdldFBvc3NpYmxlUGF0dGVybnMobmV4dENoYXJDb2RlKTtcbiAgICAgICAgICAgIHZhciBjaG9zZW5QYXR0ZXJuc0xlbmd0aCA9IGNob3NlblBhdHRlcm5JZHhUb0NvbmZpZy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hvc2VuUGF0dGVybnNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJDb25maWcgPSBjaG9zZW5QYXR0ZXJuSWR4VG9Db25maWdbaV07XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJQYXR0ZXJuID0gY3VyckNvbmZpZy5wYXR0ZXJuO1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIG1hbnVhbGx5IGluLWxpbmVkIGJlY2F1c2UgPiA2MDAgY2hhcnMgd29uJ3QgYmUgaW4tbGluZWQgaW4gVjhcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlQ2hhckNvZGUgPSBjdXJyQ29uZmlnLnNob3J0O1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVDaGFyQ29kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyQ29kZSA9PT0gc2luZ2xlQ2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjaGFyYWN0ZXIgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSBjdXJyUGF0dGVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyQ29uZmlnLmlzQ3VzdG9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gY3VyclBhdHRlcm4uZXhlYyhvcmdUZXh0LCBvZmZzZXQsIG1hdGNoZWRUb2tlbnMsIGdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEltYWdlID0gbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IG1hdGNoLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxhc3RJbmRleChjdXJyUGF0dGVybiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEltYWdlID0gdGhpcy5tYXRjaChjdXJyUGF0dGVybiwgdGV4dCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRJbWFnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIHRob3VnaCB0aGlzIHBhdHRlcm4gbWF0Y2hlZCB3ZSBtdXN0IHRyeSBhIGFub3RoZXIgbG9uZ2VyIGFsdGVybmF0aXZlLlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNhbiBiZSB1c2VkIHRvIHByaW9yaXRpemUga2V5d29yZHMgb3ZlciBpZGVudGlmaWVyc1xuICAgICAgICAgICAgICAgICAgICBsb25nZXJBbHQgPSBjdXJyQ29uZmlnLmxvbmdlckFsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvbmdlckFsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtaWNybyBvcHRpbWl6ZSwgYXZvaWQgZXh0cmEgcHJvcCBhY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IHNhdmluZy9saW5raW5nIGxvbmdlckFsdCBvbiB0aGUgb3JpZ2luYWwgY29uZmlnP1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmdlckFsdExlbmd0aCA9IGxvbmdlckFsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbG9uZ2VyQWx0TGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZ2VyQWx0Q29uZmlnID0gcGF0dGVybklkeFRvQ29uZmlnW2xvbmdlckFsdFtrXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmdlckFsdFBhdHRlcm4gPSBsb25nZXJBbHRDb25maWcucGF0dGVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRQYXlsb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgQ2hhciBjYW4gbmV2ZXIgYmUgYSBsb25nZXIgYWx0IHNvIG5vIG5lZWQgdG8gdGVzdCBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYW51YWxseSBpbi1saW5lZCBiZWNhdXNlID4gNjAwIGNoYXJzIHdvbid0IGJlIGluLWxpbmVkIGluIFY4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvbmdlckFsdENvbmZpZy5pc0N1c3RvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGxvbmdlckFsdFBhdHRlcm4uZXhlYyhvcmdUZXh0LCBvZmZzZXQsIG1hdGNoZWRUb2tlbnMsIGdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBbHRJbWFnZSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLnBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdFBheWxvYWQgPSBtYXRjaC5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBbHRJbWFnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFzdEluZGV4KGxvbmdlckFsdFBhdHRlcm4sIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQWx0SW1hZ2UgPSB0aGlzLm1hdGNoKGxvbmdlckFsdFBhdHRlcm4sIHRleHQsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaEFsdEltYWdlICYmIG1hdGNoQWx0SW1hZ2UubGVuZ3RoID4gbWF0Y2hlZEltYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSBtYXRjaEFsdEltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gYWx0UGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckNvbmZpZyA9IGxvbmdlckFsdENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhpdCB0aGUgbG9vcCBlYXJseSBhZnRlciBtYXRjaGluZyBvbmUgb2YgdGhlIGxvbmdlciBhbHRlcm5hdGl2ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpcnN0IG1hdGNoZWQgYWx0ZXJuYXRpdmUgdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBtYXRjaFxuICAgICAgICAgICAgaWYgKG1hdGNoZWRJbWFnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltYWdlTGVuZ3RoID0gbWF0Y2hlZEltYWdlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBncm91cCA9IGN1cnJDb25maWcuZ3JvdXA7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rVHlwZSA9IGN1cnJDb25maWcudG9rZW5UeXBlSWR4O1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBcIm9mZnNldCArIGltYWdlTGVuZ3RoXCIgYW5kIHRoZSBuZXcgY29sdW1uIG1heSBiZSBjb21wdXRlZCB0d2ljZSBpbiBjYXNlIG9mIFwiZnVsbFwiIGxvY2F0aW9uIGluZm9ybWF0aW9uIGluc2lkZVxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVGdWxsVG9rZW4gbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIG5ld1Rva2VuID0gdGhpcy5jcmVhdGVUb2tlbkluc3RhbmNlKG1hdGNoZWRJbWFnZSwgb2Zmc2V0LCB0b2tUeXBlLCBjdXJyQ29uZmlnLnRva2VuVHlwZSwgbGluZSwgY29sdW1uLCBpbWFnZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGF5bG9hZChuZXdUb2tlbiwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG9wdGltaXplIE5PT1AgaW4gY2FzZSB0aGVyZSBhcmUgbm8gc3BlY2lhbCBncm91cHM/XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRUb2tlbnNJbmRleCA9IHRoaXMuYWRkVG9rZW4obWF0Y2hlZFRva2VucywgbWF0Y2hlZFRva2Vuc0luZGV4LCBuZXdUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHNbZ3JvdXBdLnB1c2gobmV3VG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLmNob3BJbnB1dCh0ZXh0LCBpbWFnZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgaW1hZ2VMZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2l0aCBuZXdsaW5lcyB0aGUgY29sdW1uIG1heSBiZSBhc3NpZ25lZCB0d2ljZVxuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHRoaXMuY29tcHV0ZU5ld0NvbHVtbihjb2x1bW4sIGltYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tMaW5lcyA9PT0gdHJ1ZSAmJiBjdXJyQ29uZmlnLmNhbkxpbmVUZXJtaW5hdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1PZkxUc0luTWF0Y2ggPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRUZXJtaW5hdG9yID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdExURW5kT2Zmc2V0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBsaW5lVGVybWluYXRvclBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRUZXJtaW5hdG9yID0gbGluZVRlcm1pbmF0b3JQYXR0ZXJuLnRlc3QobWF0Y2hlZEltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFRlcm1pbmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TFRFbmRPZmZzZXQgPSBsaW5lVGVybWluYXRvclBhdHRlcm4ubGFzdEluZGV4IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1PZkxUc0luTWF0Y2grKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoZm91bmRUZXJtaW5hdG9yID09PSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bU9mTFRzSW5NYXRjaCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUgKyBudW1PZkxUc0luTWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBpbWFnZUxlbmd0aCAtIGxhc3RMVEVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVG9rZW5FbmRMaW5lQ29sdW1uTG9jYXRpb24obmV3VG9rZW4sIGdyb3VwLCBsYXN0TFRFbmRPZmZzZXQsIG51bU9mTFRzSW5NYXRjaCwgbGluZSwgY29sdW1uLCBpbWFnZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBOT09QIGlmIG5vIG1vZGVzIHByZXNlbnRcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vZGVzKGN1cnJDb25maWcsIHBvcF9tb2RlLCBwdXNoX21vZGUsIG5ld1Rva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVycm9yIHJlY292ZXJ5LCBkcm9wIGNoYXJhY3RlcnMgdW50aWwgd2UgaWRlbnRpZnkgYSB2YWxpZCB0b2tlbidzIHN0YXJ0IHBvaW50XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yU3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yQ29sdW1uID0gY29sdW1uO1xuICAgICAgICAgICAgICAgIHZhciBmb3VuZFJlc3luY1BvaW50ID0gcmVjb3ZlcnlFbmFibGVkID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZm91bmRSZXN5bmNQb2ludCA9PT0gZmFsc2UgJiYgb2Zmc2V0IDwgb3JnTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElkZW50aXR5IEZ1bmMgKHdoZW4gc3RpY2t5IGZsYWcgaXMgZW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMuY2hvcElucHV0KHRleHQsIDEpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJNb2RlUGF0dGVybnNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJDb25maWdfMSA9IHBhdHRlcm5JZHhUb0NvbmZpZ1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyUGF0dGVybiA9IGN1cnJDb25maWdfMS5wYXR0ZXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFudWFsbHkgaW4tbGluZWQgYmVjYXVzZSA+IDYwMCBjaGFycyB3b24ndCBiZSBpbi1saW5lZCBpbiBWOFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpbmdsZUNoYXJDb2RlID0gY3VyckNvbmZpZ18xLnNob3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZUNoYXJDb2RlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmdUZXh0LmNoYXJDb2RlQXQob2Zmc2V0KSA9PT0gc2luZ2xlQ2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGNoYXJhY3RlciBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRSZXN5bmNQb2ludCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyckNvbmZpZ18xLmlzQ3VzdG9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRSZXN5bmNQb2ludCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJQYXR0ZXJuLmV4ZWMob3JnVGV4dCwgb2Zmc2V0LCBtYXRjaGVkVG9rZW5zLCBncm91cHMpICE9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0SW5kZXgoY3VyclBhdHRlcm4sIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRSZXN5bmNQb2ludCA9IGN1cnJQYXR0ZXJuLmV4ZWModGV4dCkgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRSZXN5bmNQb2ludCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVyckxlbmd0aCA9IG9mZnNldCAtIGVycm9yU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB3ZSBlaXRoZXIgcmUtc3luY2VkIG9yIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgdGV4dFxuICAgICAgICAgICAgICAgIG1zZyA9IHRoaXMuY29uZmlnLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkVW5leHBlY3RlZENoYXJhY3RlcnNNZXNzYWdlKG9yZ1RleHQsIGVycm9yU3RhcnRPZmZzZXQsIGVyckxlbmd0aCwgZXJyb3JMaW5lLCBlcnJvckNvbHVtbik7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGVycm9yU3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGVycm9yTGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBlcnJvckNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBlcnJMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvdmVyeUVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBkbyBoYXZlIGN1c3RvbSBwYXR0ZXJucyB3aGljaCBwdXNoIGRpcmVjdGx5IGludG8gdGhlXG4gICAgICAgIC8vIFRPRE86IGN1c3RvbSB0b2tlbnMgc2hvdWxkIG5vdCBwdXNoIGRpcmVjdGx5Pz9cbiAgICAgICAgaWYgKCF0aGlzLmhhc0N1c3RvbSkge1xuICAgICAgICAgICAgLy8gaWYgd2UgZ3Vlc3NlZCBhIHRvbyBsYXJnZSBzaXplIGZvciB0aGUgdG9rZW5zIGFycmF5IHRoaXMgd2lsbCBzaHJpbmsgaXQgdG8gdGhlIHJpZ2h0IHNpemUuXG4gICAgICAgICAgICBtYXRjaGVkVG9rZW5zLmxlbmd0aCA9IG1hdGNoZWRUb2tlbnNJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW5zOiBtYXRjaGVkVG9rZW5zLFxuICAgICAgICAgICAgZ3JvdXBzOiBncm91cHMsXG4gICAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICB9O1xuICAgIH07XG4gICAgTGV4ZXIucHJvdG90eXBlLmhhbmRsZU1vZGVzID0gZnVuY3Rpb24gKGNvbmZpZywgcG9wX21vZGUsIHB1c2hfbW9kZSwgbmV3VG9rZW4pIHtcbiAgICAgICAgaWYgKGNvbmZpZy5wb3AgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gc2F2ZSB0aGUgUFVTSF9NT0RFIHByb3BlcnR5IGFzIGlmIHRoZSBtb2RlIGlzIHBvcHBlZFxuICAgICAgICAgICAgLy8gcGF0dGVybklkeFRvUG9wTW9kZSBpcyB1cGRhdGVkIHRvIHJlZmxlY3QgdGhlIG5ldyBtb2RlIGFmdGVyIHBvcHBpbmcgdGhlIHN0YWNrXG4gICAgICAgICAgICB2YXIgcHVzaE1vZGUgPSBjb25maWcucHVzaDtcbiAgICAgICAgICAgIHBvcF9tb2RlKG5ld1Rva2VuKTtcbiAgICAgICAgICAgIGlmIChwdXNoTW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHVzaF9tb2RlLmNhbGwodGhpcywgcHVzaE1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5wdXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHB1c2hfbW9kZS5jYWxsKHRoaXMsIGNvbmZpZy5wdXNoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGV4ZXIucHJvdG90eXBlLmNob3BJbnB1dCA9IGZ1bmN0aW9uICh0ZXh0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKGxlbmd0aCk7XG4gICAgfTtcbiAgICBMZXhlci5wcm90b3R5cGUudXBkYXRlTGFzdEluZGV4ID0gZnVuY3Rpb24gKHJlZ0V4cCwgbmV3TGFzdEluZGV4KSB7XG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSBuZXdMYXN0SW5kZXg7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBkZWNyZWFzZSB0aGlzIHVuZGVyIDYwMCBjaGFyYWN0ZXJzPyBpbnNwZWN0IHN0cmlwcGluZyBjb21tZW50cyBvcHRpb24gaW4gVFNDIGNvbXBpbGVyXG4gICAgTGV4ZXIucHJvdG90eXBlLnVwZGF0ZVRva2VuRW5kTGluZUNvbHVtbkxvY2F0aW9uID0gZnVuY3Rpb24gKG5ld1Rva2VuLCBncm91cCwgbGFzdExUSWR4LCBudW1PZkxUc0luTWF0Y2gsIGxpbmUsIGNvbHVtbiwgaW1hZ2VMZW5ndGgpIHtcbiAgICAgICAgdmFyIGxhc3RDaGFySXNMVCwgZml4Rm9yRW5kaW5nSW5MVDtcbiAgICAgICAgaWYgKGdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGEgbm9uZSBza2lwcGVkIG11bHRpIGxpbmUgVG9rZW4sIG5lZWQgdG8gdXBkYXRlIGVuZExpbmUvZW5kQ29sdW1uXG4gICAgICAgICAgICBsYXN0Q2hhcklzTFQgPSBsYXN0TFRJZHggPT09IGltYWdlTGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGZpeEZvckVuZGluZ0luTFQgPSBsYXN0Q2hhcklzTFQgPyAtMSA6IDA7XG4gICAgICAgICAgICBpZiAoIShudW1PZkxUc0luTWF0Y2ggPT09IDEgJiYgbGFzdENoYXJJc0xUID09PSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGEgdG9rZW4gZW5kcyBpbiBhIExUIHRoYXQgbGFzdCBMVCBvbmx5IGFmZmVjdHMgdGhlIGxpbmUgbnVtYmVyaW5nIG9mIGZvbGxvd2luZyBUb2tlbnNcbiAgICAgICAgICAgICAgICBuZXdUb2tlbi5lbmRMaW5lID0gbGluZSArIGZpeEZvckVuZGluZ0luTFQ7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGxhc3QgTFQgaW4gYSB0b2tlbiBkb2VzIG5vdCBhZmZlY3QgdGhlIGVuZENvbHVtbiBlaXRoZXIgYXMgdGhlIFtjb2x1bW5TdGFydCAuLi4gY29sdW1uRW5kKVxuICAgICAgICAgICAgICAgIC8vIGluY2x1c2l2ZSB0byBleGNsdXNpdmUgcmFuZ2UuXG4gICAgICAgICAgICAgICAgbmV3VG9rZW4uZW5kQ29sdW1uID0gY29sdW1uIC0gMSArIC1maXhGb3JFbmRpbmdJbkxUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSBzaW5nbGUgTFQgaW4gdGhlIGxhc3QgY2hhcmFjdGVyIG9mIGEgdG9rZW4sIG5vIG5lZWQgdG8gbW9kaWZ5IHRoZSBlbmRMaW5lL0VuZENvbHVtblxuICAgICAgICB9XG4gICAgfTtcbiAgICBMZXhlci5wcm90b3R5cGUuY29tcHV0ZU5ld0NvbHVtbiA9IGZ1bmN0aW9uIChvbGRDb2x1bW4sIGltYWdlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBvbGRDb2x1bW4gKyBpbWFnZUxlbmd0aDtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5jcmVhdGVPZmZzZXRPbmx5VG9rZW4gPSBmdW5jdGlvbiAoaW1hZ2UsIHN0YXJ0T2Zmc2V0LCB0b2tlblR5cGVJZHgsIHRva2VuVHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgdG9rZW5UeXBlSWR4OiB0b2tlblR5cGVJZHgsXG4gICAgICAgICAgICB0b2tlblR5cGU6IHRva2VuVHlwZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTGV4ZXIucHJvdG90eXBlLmNyZWF0ZVN0YXJ0T25seVRva2VuID0gZnVuY3Rpb24gKGltYWdlLCBzdGFydE9mZnNldCwgdG9rZW5UeXBlSWR4LCB0b2tlblR5cGUsIHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgICAgIHN0YXJ0TGluZTogc3RhcnRMaW5lLFxuICAgICAgICAgICAgc3RhcnRDb2x1bW46IHN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgdG9rZW5UeXBlSWR4OiB0b2tlblR5cGVJZHgsXG4gICAgICAgICAgICB0b2tlblR5cGU6IHRva2VuVHlwZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTGV4ZXIucHJvdG90eXBlLmNyZWF0ZUZ1bGxUb2tlbiA9IGZ1bmN0aW9uIChpbWFnZSwgc3RhcnRPZmZzZXQsIHRva2VuVHlwZUlkeCwgdG9rZW5UeXBlLCBzdGFydExpbmUsIHN0YXJ0Q29sdW1uLCBpbWFnZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBzdGFydE9mZnNldCArIGltYWdlTGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIHN0YXJ0TGluZTogc3RhcnRMaW5lLFxuICAgICAgICAgICAgZW5kTGluZTogc3RhcnRMaW5lLFxuICAgICAgICAgICAgc3RhcnRDb2x1bW46IHN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgZW5kQ29sdW1uOiBzdGFydENvbHVtbiArIGltYWdlTGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIHRva2VuVHlwZUlkeDogdG9rZW5UeXBlSWR4LFxuICAgICAgICAgICAgdG9rZW5UeXBlOiB0b2tlblR5cGVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5hZGRUb2tlblVzaW5nUHVzaCA9IGZ1bmN0aW9uICh0b2tlblZlY3RvciwgaW5kZXgsIHRva2VuVG9BZGQpIHtcbiAgICAgICAgdG9rZW5WZWN0b3IucHVzaCh0b2tlblRvQWRkKTtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgTGV4ZXIucHJvdG90eXBlLmFkZFRva2VuVXNpbmdNZW1iZXJBY2Nlc3MgPSBmdW5jdGlvbiAodG9rZW5WZWN0b3IsIGluZGV4LCB0b2tlblRvQWRkKSB7XG4gICAgICAgIHRva2VuVmVjdG9yW2luZGV4XSA9IHRva2VuVG9BZGQ7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5oYW5kbGVQYXlsb2FkTm9DdXN0b20gPSBmdW5jdGlvbiAodG9rZW4sIHBheWxvYWQpIHsgfTtcbiAgICBMZXhlci5wcm90b3R5cGUuaGFuZGxlUGF5bG9hZFdpdGhDdXN0b20gPSBmdW5jdGlvbiAodG9rZW4sIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRva2VuLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMZXhlci5wcm90b3R5cGUubWF0Y2hXaXRoVGVzdCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCB0ZXh0LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gcGF0dGVybi50ZXN0KHRleHQpO1xuICAgICAgICBpZiAoZm91bmQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZyhvZmZzZXQsIHBhdHRlcm4ubGFzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5tYXRjaFdpdGhFeGVjID0gZnVuY3Rpb24gKHBhdHRlcm4sIHRleHQpIHtcbiAgICAgICAgdmFyIHJlZ0V4cEFycmF5ID0gcGF0dGVybi5leGVjKHRleHQpO1xuICAgICAgICByZXR1cm4gcmVnRXhwQXJyYXkgIT09IG51bGwgPyByZWdFeHBBcnJheVswXSA6IG51bGw7XG4gICAgfTtcbiAgICBMZXhlci5TS0lQUEVEID0gXCJUaGlzIG1hcmtzIGEgc2tpcHBlZCBUb2tlbiBwYXR0ZXJuLCB0aGlzIG1lYW5zIGVhY2ggdG9rZW4gaWRlbnRpZmllZCBieSBpdCB3aWxsXCIgK1xuICAgICAgICBcImJlIGNvbnN1bWVkIGFuZCB0aGVuIHRocm93biBpbnRvIG9ibGl2aW9uLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGZvciBleGFtcGxlIHRvIGNvbXBsZXRlbHkgaWdub3JlIHdoaXRlc3BhY2UuXCI7XG4gICAgTGV4ZXIuTkEgPSAvTk9UX0FQUExJQ0FCTEUvO1xuICAgIHJldHVybiBMZXhlcjtcbn0oKSk7XG5leHBvcnRzLkxleGVyID0gTGV4ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXhlcl9wdWJsaWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/scan/lexer_public.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/scan/reg_exp.js":
/*!*********************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/reg_exp.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.canMatchCharCode = exports.firstCharOptimizedIndices = exports.getOptimizedStartCodesIndices = exports.failedOptimizationPrefixMsg = void 0;\nvar regexp_to_ast_1 = __webpack_require__(/*! regexp-to-ast */ \"(ssr)/./node_modules/regexp-to-ast/lib/regexp-to-ast.js\");\nvar isArray_1 = __importDefault(__webpack_require__(/*! lodash/isArray */ \"(ssr)/./node_modules/lodash/isArray.js\"));\nvar every_1 = __importDefault(__webpack_require__(/*! lodash/every */ \"(ssr)/./node_modules/lodash/every.js\"));\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar find_1 = __importDefault(__webpack_require__(/*! lodash/find */ \"(ssr)/./node_modules/lodash/find.js\"));\nvar values_1 = __importDefault(__webpack_require__(/*! lodash/values */ \"(ssr)/./node_modules/lodash/values.js\"));\nvar includes_1 = __importDefault(__webpack_require__(/*! lodash/includes */ \"(ssr)/./node_modules/lodash/includes.js\"));\nvar utils_1 = __webpack_require__(/*! @chevrotain/utils */ \"(ssr)/./node_modules/@chevrotain/utils/lib/src/api.js\");\nvar reg_exp_parser_1 = __webpack_require__(/*! ./reg_exp_parser */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js\");\nvar lexer_1 = __webpack_require__(/*! ./lexer */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/lexer.js\");\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexports.failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n    if (ensureOptimizations === void 0) { ensureOptimizations = false; }\n    try {\n        var ast = (0, reg_exp_parser_1.getRegExpAst)(regExp);\n        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n        return firstChars;\n    }\n    catch (e) {\n        /* istanbul ignore next */\n        // Testing this relies on the regexp-to-ast library having a bug... */\n        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n        if (e.message === complementErrorMessage) {\n            if (ensureOptimizations) {\n                (0, utils_1.PRINT_WARNING)(\"\".concat(exports.failedOptimizationPrefixMsg) +\n                    \"\\tUnable to optimize: < \".concat(regExp.toString(), \" >\\n\") +\n                    \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n            }\n        }\n        else {\n            var msgSuffix = \"\";\n            if (ensureOptimizations) {\n                msgSuffix =\n                    \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n                        \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n            }\n            (0, utils_1.PRINT_ERROR)(\"\".concat(exports.failedOptimizationPrefixMsg, \"\\n\") +\n                \"\\tFailed parsing: < \".concat(regExp.toString(), \" >\\n\") +\n                \"\\tUsing the regexp-to-ast library version: \".concat(regexp_to_ast_1.VERSION, \"\\n\") +\n                \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\n                msgSuffix);\n        }\n    }\n    return [];\n}\nexports.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch (ast.type) {\n        case \"Disjunction\":\n            for (var i = 0; i < ast.value.length; i++) {\n                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n            }\n            break;\n        case \"Alternative\":\n            var terms = ast.value;\n            for (var i = 0; i < terms.length; i++) {\n                var term = terms[i];\n                // skip terms that cannot effect the first char results\n                switch (term.type) {\n                    case \"EndAnchor\":\n                    // A group back reference cannot affect potential starting char.\n                    // because if a back reference is the first production than automatically\n                    // the group being referenced has had to come BEFORE so its codes have already been added\n                    case \"GroupBackReference\":\n                    // assertions do not affect potential starting codes\n                    case \"Lookahead\":\n                    case \"NegativeLookahead\":\n                    case \"StartAnchor\":\n                    case \"WordBoundary\":\n                    case \"NonWordBoundary\":\n                        continue;\n                }\n                var atom = term;\n                switch (atom.type) {\n                    case \"Character\":\n                        addOptimizedIdxToResult(atom.value, result, ignoreCase);\n                        break;\n                    case \"Set\":\n                        if (atom.complement === true) {\n                            throw Error(complementErrorMessage);\n                        }\n                        (0, forEach_1.default)(atom.value, function (code) {\n                            if (typeof code === \"number\") {\n                                addOptimizedIdxToResult(code, result, ignoreCase);\n                            }\n                            else {\n                                // range\n                                var range = code;\n                                // cannot optimize when ignoreCase is\n                                if (ignoreCase === true) {\n                                    for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                }\n                                // Optimization (2 orders of magnitude less work for very large ranges)\n                                else {\n                                    // handle unoptimized values\n                                    for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                                    if (range.to >= lexer_1.minOptimizationVal) {\n                                        var minUnOptVal = range.from >= lexer_1.minOptimizationVal\n                                            ? range.from\n                                            : lexer_1.minOptimizationVal;\n                                        var maxUnOptVal = range.to;\n                                        var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);\n                                        var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);\n                                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                                            result[currOptIdx] = currOptIdx;\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                    case \"Group\":\n                        firstCharOptimizedIndices(atom.value, result, ignoreCase);\n                        break;\n                    /* istanbul ignore next */\n                    default:\n                        throw Error(\"Non Exhaustive Match\");\n                }\n                // reached a mandatory production, no more **start** codes can be found on this alternative\n                var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n                if (\n                // A group may be optional due to empty contents /(?:)/\n                // or if everything inside it is optional /((a)?)/\n                (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n                    // If this term is not a group it may only be optional if it has an optional quantifier\n                    (atom.type !== \"Group\" && isOptionalQuantifier === false)) {\n                    break;\n                }\n            }\n            break;\n        /* istanbul ignore next */\n        default:\n            throw Error(\"non exhaustive match!\");\n    }\n    // console.log(Object.keys(result).length)\n    return (0, values_1.default)(result);\n}\nexports.firstCharOptimizedIndices = firstCharOptimizedIndices;\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n    var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);\n    result[optimizedCharIdx] = optimizedCharIdx;\n    if (ignoreCase === true) {\n        handleIgnoreCase(code, result);\n    }\n}\nfunction handleIgnoreCase(code, result) {\n    var char = String.fromCharCode(code);\n    var upperChar = char.toUpperCase();\n    /* istanbul ignore else */\n    if (upperChar !== char) {\n        var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));\n        result[optimizedCharIdx] = optimizedCharIdx;\n    }\n    else {\n        var lowerChar = char.toLowerCase();\n        if (lowerChar !== char) {\n            var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));\n            result[optimizedCharIdx] = optimizedCharIdx;\n        }\n    }\n}\nfunction findCode(setNode, targetCharCodes) {\n    return (0, find_1.default)(setNode.value, function (codeOrRange) {\n        if (typeof codeOrRange === \"number\") {\n            return (0, includes_1.default)(targetCharCodes, codeOrRange);\n        }\n        else {\n            // range\n            var range_1 = codeOrRange;\n            return ((0, find_1.default)(targetCharCodes, function (targetCode) { return range_1.from <= targetCode && targetCode <= range_1.to; }) !== undefined);\n        }\n    });\n}\nfunction isWholeOptional(ast) {\n    var quantifier = ast.quantifier;\n    if (quantifier && quantifier.atLeast === 0) {\n        return true;\n    }\n    if (!ast.value) {\n        return false;\n    }\n    return (0, isArray_1.default)(ast.value)\n        ? (0, every_1.default)(ast.value, isWholeOptional)\n        : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = /** @class */ (function (_super) {\n    __extends(CharCodeFinder, _super);\n    function CharCodeFinder(targetCharCodes) {\n        var _this = _super.call(this) || this;\n        _this.targetCharCodes = targetCharCodes;\n        _this.found = false;\n        return _this;\n    }\n    CharCodeFinder.prototype.visitChildren = function (node) {\n        // No need to keep looking...\n        if (this.found === true) {\n            return;\n        }\n        // switch lookaheads as they do not actually consume any characters thus\n        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n        switch (node.type) {\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                return;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                return;\n        }\n        _super.prototype.visitChildren.call(this, node);\n    };\n    CharCodeFinder.prototype.visitCharacter = function (node) {\n        if ((0, includes_1.default)(this.targetCharCodes, node.value)) {\n            this.found = true;\n        }\n    };\n    CharCodeFinder.prototype.visitSet = function (node) {\n        if (node.complement) {\n            if (findCode(node, this.targetCharCodes) === undefined) {\n                this.found = true;\n            }\n        }\n        else {\n            if (findCode(node, this.targetCharCodes) !== undefined) {\n                this.found = true;\n            }\n        }\n    };\n    return CharCodeFinder;\n}(regexp_to_ast_1.BaseRegExpVisitor));\nfunction canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n        var ast = (0, reg_exp_parser_1.getRegExpAst)(pattern);\n        var charCodeFinder = new CharCodeFinder(charCodes);\n        charCodeFinder.visit(ast);\n        return charCodeFinder.found;\n    }\n    else {\n        return ((0, find_1.default)(pattern, function (char) {\n            return (0, includes_1.default)(charCodes, char.charCodeAt(0));\n        }) !== undefined);\n    }\n}\nexports.canMatchCharCode = canMatchCharCode;\n//# sourceMappingURL=reg_exp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vcmVnX2V4cC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLGlDQUFpQyxHQUFHLHFDQUFxQyxHQUFHLG1DQUFtQztBQUMxSSxzQkFBc0IsbUJBQU8sQ0FBQyw4RUFBZTtBQUM3QyxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsOEJBQThCLG1CQUFPLENBQUMsMERBQWM7QUFDcEQsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELDZCQUE2QixtQkFBTyxDQUFDLHdEQUFhO0FBQ2xELCtCQUErQixtQkFBTyxDQUFDLDREQUFlO0FBQ3RELGlDQUFpQyxtQkFBTyxDQUFDLGdFQUFpQjtBQUMxRCxjQUFjLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ3pDLHVCQUF1QixtQkFBTyxDQUFDLHdGQUFrQjtBQUNqRCxjQUFjLG1CQUFPLENBQUMsc0VBQVM7QUFDL0I7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHVCQUF1QjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsaUVBQWlFO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLHlCQUF5QjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixnRUFBZ0U7QUFDako7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvc2Nhbi9yZWdfZXhwLmpzPzc5MzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYW5NYXRjaENoYXJDb2RlID0gZXhwb3J0cy5maXJzdENoYXJPcHRpbWl6ZWRJbmRpY2VzID0gZXhwb3J0cy5nZXRPcHRpbWl6ZWRTdGFydENvZGVzSW5kaWNlcyA9IGV4cG9ydHMuZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnID0gdm9pZCAwO1xudmFyIHJlZ2V4cF90b19hc3RfMSA9IHJlcXVpcmUoXCJyZWdleHAtdG8tYXN0XCIpO1xudmFyIGlzQXJyYXlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIikpO1xudmFyIGV2ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9ldmVyeVwiKSk7XG52YXIgZm9yRWFjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZm9yRWFjaFwiKSk7XG52YXIgZmluZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZmluZFwiKSk7XG52YXIgdmFsdWVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC92YWx1ZXNcIikpO1xudmFyIGluY2x1ZGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pbmNsdWRlc1wiKSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCJAY2hldnJvdGFpbi91dGlsc1wiKTtcbnZhciByZWdfZXhwX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vcmVnX2V4cF9wYXJzZXJcIik7XG52YXIgbGV4ZXJfMSA9IHJlcXVpcmUoXCIuL2xleGVyXCIpO1xudmFyIGNvbXBsZW1lbnRFcnJvck1lc3NhZ2UgPSBcIkNvbXBsZW1lbnQgU2V0cyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25cIjtcbmV4cG9ydHMuZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnID0gJ1VuYWJsZSB0byB1c2UgXCJmaXJzdCBjaGFyXCIgbGV4ZXIgb3B0aW1pemF0aW9uczpcXG4nO1xuZnVuY3Rpb24gZ2V0T3B0aW1pemVkU3RhcnRDb2Rlc0luZGljZXMocmVnRXhwLCBlbnN1cmVPcHRpbWl6YXRpb25zKSB7XG4gICAgaWYgKGVuc3VyZU9wdGltaXphdGlvbnMgPT09IHZvaWQgMCkgeyBlbnN1cmVPcHRpbWl6YXRpb25zID0gZmFsc2U7IH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgYXN0ID0gKDAsIHJlZ19leHBfcGFyc2VyXzEuZ2V0UmVnRXhwQXN0KShyZWdFeHApO1xuICAgICAgICB2YXIgZmlyc3RDaGFycyA9IGZpcnN0Q2hhck9wdGltaXplZEluZGljZXMoYXN0LnZhbHVlLCB7fSwgYXN0LmZsYWdzLmlnbm9yZUNhc2UpO1xuICAgICAgICByZXR1cm4gZmlyc3RDaGFycztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgLy8gVGVzdGluZyB0aGlzIHJlbGllcyBvbiB0aGUgcmVnZXhwLXRvLWFzdCBsaWJyYXJ5IGhhdmluZyBhIGJ1Zy4uLiAqL1xuICAgICAgICAvLyBUT0RPOiBvbmx5IHRoZSBlbHNlIGJyYW5jaCBuZWVkcyB0byBiZSBpZ25vcmVkLCB0cnkgdG8gZml4IHdpdGggbmV3ZXIgcHJldHRpZXIgLyB0c2NcbiAgICAgICAgaWYgKGUubWVzc2FnZSA9PT0gY29tcGxlbWVudEVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKGVuc3VyZU9wdGltaXphdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5QUklOVF9XQVJOSU5HKShcIlwiLmNvbmNhdChleHBvcnRzLmZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZykgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdFVuYWJsZSB0byBvcHRpbWl6ZTogPCBcIi5jb25jYXQocmVnRXhwLnRvU3RyaW5nKCksIFwiID5cXG5cIikgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdENvbXBsZW1lbnQgU2V0cyBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBvcHRpbWl6ZWQuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBsZXhlcidzIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9ucy5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0U2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQ09NUExFTUVOVCBmb3IgZGV0YWlscy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbXNnU3VmZml4ID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChlbnN1cmVPcHRpbWl6YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgbXNnU3VmZml4ID1cbiAgICAgICAgICAgICAgICAgICAgXCJcXG5cXHRUaGlzIHdpbGwgZGlzYWJsZSB0aGUgbGV4ZXIncyBmaXJzdCBjaGFyIG9wdGltaXphdGlvbnMuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNSRUdFWFBfUEFSU0lORyBmb3IgZGV0YWlscy5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCB1dGlsc18xLlBSSU5UX0VSUk9SKShcIlwiLmNvbmNhdChleHBvcnRzLmZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZywgXCJcXG5cIikgK1xuICAgICAgICAgICAgICAgIFwiXFx0RmFpbGVkIHBhcnNpbmc6IDwgXCIuY29uY2F0KHJlZ0V4cC50b1N0cmluZygpLCBcIiA+XFxuXCIpICtcbiAgICAgICAgICAgICAgICBcIlxcdFVzaW5nIHRoZSByZWdleHAtdG8tYXN0IGxpYnJhcnkgdmVyc2lvbjogXCIuY29uY2F0KHJlZ2V4cF90b19hc3RfMS5WRVJTSU9OLCBcIlxcblwiKSArXG4gICAgICAgICAgICAgICAgXCJcXHRQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdDogaHR0cHM6Ly9naXRodWIuY29tL2JkODIvcmVnZXhwLXRvLWFzdC9pc3N1ZXNcIiArXG4gICAgICAgICAgICAgICAgbXNnU3VmZml4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5leHBvcnRzLmdldE9wdGltaXplZFN0YXJ0Q29kZXNJbmRpY2VzID0gZ2V0T3B0aW1pemVkU3RhcnRDb2Rlc0luZGljZXM7XG5mdW5jdGlvbiBmaXJzdENoYXJPcHRpbWl6ZWRJbmRpY2VzKGFzdCwgcmVzdWx0LCBpZ25vcmVDYXNlKSB7XG4gICAgc3dpdGNoIChhc3QudHlwZSkge1xuICAgICAgICBjYXNlIFwiRGlzanVuY3Rpb25cIjpcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RDaGFyT3B0aW1pemVkSW5kaWNlcyhhc3QudmFsdWVbaV0sIHJlc3VsdCwgaWdub3JlQ2FzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkFsdGVybmF0aXZlXCI6XG4gICAgICAgICAgICB2YXIgdGVybXMgPSBhc3QudmFsdWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlcm0gPSB0ZXJtc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHRlcm1zIHRoYXQgY2Fubm90IGVmZmVjdCB0aGUgZmlyc3QgY2hhciByZXN1bHRzXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ZXJtLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVuZEFuY2hvclwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBBIGdyb3VwIGJhY2sgcmVmZXJlbmNlIGNhbm5vdCBhZmZlY3QgcG90ZW50aWFsIHN0YXJ0aW5nIGNoYXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaWYgYSBiYWNrIHJlZmVyZW5jZSBpcyB0aGUgZmlyc3QgcHJvZHVjdGlvbiB0aGFuIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGdyb3VwIGJlaW5nIHJlZmVyZW5jZWQgaGFzIGhhZCB0byBjb21lIEJFRk9SRSBzbyBpdHMgY29kZXMgaGF2ZSBhbHJlYWR5IGJlZW4gYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkdyb3VwQmFja1JlZmVyZW5jZVwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBhc3NlcnRpb25zIGRvIG5vdCBhZmZlY3QgcG90ZW50aWFsIHN0YXJ0aW5nIGNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMb29rYWhlYWRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk5lZ2F0aXZlTG9va2FoZWFkXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTdGFydEFuY2hvclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiV29yZEJvdW5kYXJ5XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJOb25Xb3JkQm91bmRhcnlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXRvbSA9IHRlcm07XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdG9tLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkNoYXJhY3RlclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW1pemVkSWR4VG9SZXN1bHQoYXRvbS52YWx1ZSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiU2V0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXRvbS5jb21wbGVtZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoY29tcGxlbWVudEVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKGF0b20udmFsdWUsIGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9wdGltaXplZElkeFRvUmVzdWx0KGNvZGUsIHJlc3VsdCwgaWdub3JlQ2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW5ub3Qgb3B0aW1pemUgd2hlbiBpZ25vcmVDYXNlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVDYXNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByYW5nZUNvZGUgPSByYW5nZS5mcm9tOyByYW5nZUNvZGUgPD0gcmFuZ2UudG87IHJhbmdlQ29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW1pemVkSWR4VG9SZXN1bHQocmFuZ2VDb2RlLCByZXN1bHQsIGlnbm9yZUNhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbiAoMiBvcmRlcnMgb2YgbWFnbml0dWRlIGxlc3Mgd29yayBmb3IgdmVyeSBsYXJnZSByYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHVub3B0aW1pemVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmFuZ2VDb2RlID0gcmFuZ2UuZnJvbTsgcmFuZ2VDb2RlIDw9IHJhbmdlLnRvICYmIHJhbmdlQ29kZSA8IGxleGVyXzEubWluT3B0aW1pemF0aW9uVmFsOyByYW5nZUNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9wdGltaXplZElkeFRvUmVzdWx0KHJhbmdlQ29kZSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlc3MgY29tbW9uIGNoYXJDb2RlIHdoZXJlIHdlIG9wdGltaXplIGZvciBmYXN0ZXIgaW5pdCB0aW1lLCBieSB1c2luZyBsYXJnZXIgXCJidWNrZXRzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS50byA+PSBsZXhlcl8xLm1pbk9wdGltaXphdGlvblZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5Vbk9wdFZhbCA9IHJhbmdlLmZyb20gPj0gbGV4ZXJfMS5taW5PcHRpbWl6YXRpb25WYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByYW5nZS5mcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbGV4ZXJfMS5taW5PcHRpbWl6YXRpb25WYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFVuT3B0VmFsID0gcmFuZ2UudG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbk9wdElkeCA9ICgwLCBsZXhlcl8xLmNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleCkobWluVW5PcHRWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhPcHRJZHggPSAoMCwgbGV4ZXJfMS5jaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgpKG1heFVuT3B0VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjdXJyT3B0SWR4ID0gbWluT3B0SWR4OyBjdXJyT3B0SWR4IDw9IG1heE9wdElkeDsgY3Vyck9wdElkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyT3B0SWR4XSA9IGN1cnJPcHRJZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkdyb3VwXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdENoYXJPcHRpbWl6ZWRJbmRpY2VzKGF0b20udmFsdWUsIHJlc3VsdCwgaWdub3JlQ2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTm9uIEV4aGF1c3RpdmUgTWF0Y2hcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlYWNoZWQgYSBtYW5kYXRvcnkgcHJvZHVjdGlvbiwgbm8gbW9yZSAqKnN0YXJ0KiogY29kZXMgY2FuIGJlIGZvdW5kIG9uIHRoaXMgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICAgICB2YXIgaXNPcHRpb25hbFF1YW50aWZpZXIgPSBhdG9tLnF1YW50aWZpZXIgIT09IHVuZGVmaW5lZCAmJiBhdG9tLnF1YW50aWZpZXIuYXRMZWFzdCA9PT0gMDtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gQSBncm91cCBtYXkgYmUgb3B0aW9uYWwgZHVlIHRvIGVtcHR5IGNvbnRlbnRzIC8oPzopL1xuICAgICAgICAgICAgICAgIC8vIG9yIGlmIGV2ZXJ5dGhpbmcgaW5zaWRlIGl0IGlzIG9wdGlvbmFsIC8oKGEpPykvXG4gICAgICAgICAgICAgICAgKGF0b20udHlwZSA9PT0gXCJHcm91cFwiICYmIGlzV2hvbGVPcHRpb25hbChhdG9tKSA9PT0gZmFsc2UpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgdGVybSBpcyBub3QgYSBncm91cCBpdCBtYXkgb25seSBiZSBvcHRpb25hbCBpZiBpdCBoYXMgYW4gb3B0aW9uYWwgcXVhbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAoYXRvbS50eXBlICE9PSBcIkdyb3VwXCIgJiYgaXNPcHRpb25hbFF1YW50aWZpZXIgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2ghXCIpO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhPYmplY3Qua2V5cyhyZXN1bHQpLmxlbmd0aClcbiAgICByZXR1cm4gKDAsIHZhbHVlc18xLmRlZmF1bHQpKHJlc3VsdCk7XG59XG5leHBvcnRzLmZpcnN0Q2hhck9wdGltaXplZEluZGljZXMgPSBmaXJzdENoYXJPcHRpbWl6ZWRJbmRpY2VzO1xuZnVuY3Rpb24gYWRkT3B0aW1pemVkSWR4VG9SZXN1bHQoY29kZSwgcmVzdWx0LCBpZ25vcmVDYXNlKSB7XG4gICAgdmFyIG9wdGltaXplZENoYXJJZHggPSAoMCwgbGV4ZXJfMS5jaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgpKGNvZGUpO1xuICAgIHJlc3VsdFtvcHRpbWl6ZWRDaGFySWR4XSA9IG9wdGltaXplZENoYXJJZHg7XG4gICAgaWYgKGlnbm9yZUNhc2UgPT09IHRydWUpIHtcbiAgICAgICAgaGFuZGxlSWdub3JlQ2FzZShjb2RlLCByZXN1bHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUlnbm9yZUNhc2UoY29kZSwgcmVzdWx0KSB7XG4gICAgdmFyIGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIHZhciB1cHBlckNoYXIgPSBjaGFyLnRvVXBwZXJDYXNlKCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodXBwZXJDaGFyICE9PSBjaGFyKSB7XG4gICAgICAgIHZhciBvcHRpbWl6ZWRDaGFySWR4ID0gKDAsIGxleGVyXzEuY2hhckNvZGVUb09wdGltaXplZEluZGV4KSh1cHBlckNoYXIuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIHJlc3VsdFtvcHRpbWl6ZWRDaGFySWR4XSA9IG9wdGltaXplZENoYXJJZHg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbG93ZXJDaGFyID0gY2hhci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobG93ZXJDaGFyICE9PSBjaGFyKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW1pemVkQ2hhcklkeCA9ICgwLCBsZXhlcl8xLmNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleCkobG93ZXJDaGFyLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgcmVzdWx0W29wdGltaXplZENoYXJJZHhdID0gb3B0aW1pemVkQ2hhcklkeDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRDb2RlKHNldE5vZGUsIHRhcmdldENoYXJDb2Rlcykge1xuICAgIHJldHVybiAoMCwgZmluZF8xLmRlZmF1bHQpKHNldE5vZGUudmFsdWUsIGZ1bmN0aW9uIChjb2RlT3JSYW5nZSkge1xuICAgICAgICBpZiAodHlwZW9mIGNvZGVPclJhbmdlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluY2x1ZGVzXzEuZGVmYXVsdCkodGFyZ2V0Q2hhckNvZGVzLCBjb2RlT3JSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByYW5nZVxuICAgICAgICAgICAgdmFyIHJhbmdlXzEgPSBjb2RlT3JSYW5nZTtcbiAgICAgICAgICAgIHJldHVybiAoKDAsIGZpbmRfMS5kZWZhdWx0KSh0YXJnZXRDaGFyQ29kZXMsIGZ1bmN0aW9uICh0YXJnZXRDb2RlKSB7IHJldHVybiByYW5nZV8xLmZyb20gPD0gdGFyZ2V0Q29kZSAmJiB0YXJnZXRDb2RlIDw9IHJhbmdlXzEudG87IH0pICE9PSB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc1dob2xlT3B0aW9uYWwoYXN0KSB7XG4gICAgdmFyIHF1YW50aWZpZXIgPSBhc3QucXVhbnRpZmllcjtcbiAgICBpZiAocXVhbnRpZmllciAmJiBxdWFudGlmaWVyLmF0TGVhc3QgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYXN0LnZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpc0FycmF5XzEuZGVmYXVsdCkoYXN0LnZhbHVlKVxuICAgICAgICA/ICgwLCBldmVyeV8xLmRlZmF1bHQpKGFzdC52YWx1ZSwgaXNXaG9sZU9wdGlvbmFsKVxuICAgICAgICA6IGlzV2hvbGVPcHRpb25hbChhc3QudmFsdWUpO1xufVxudmFyIENoYXJDb2RlRmluZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGFyQ29kZUZpbmRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGFyQ29kZUZpbmRlcih0YXJnZXRDaGFyQ29kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGFyZ2V0Q2hhckNvZGVzID0gdGFyZ2V0Q2hhckNvZGVzO1xuICAgICAgICBfdGhpcy5mb3VuZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENoYXJDb2RlRmluZGVyLnByb3RvdHlwZS52aXNpdENoaWxkcmVuID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBrZWVwIGxvb2tpbmcuLi5cbiAgICAgICAgaWYgKHRoaXMuZm91bmQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzd2l0Y2ggbG9va2FoZWFkcyBhcyB0aGV5IGRvIG5vdCBhY3R1YWxseSBjb25zdW1lIGFueSBjaGFyYWN0ZXJzIHRodXNcbiAgICAgICAgLy8gZmluZGluZyBhIGNoYXJDb2RlIGF0IGxvb2thaGVhZCBjb250ZXh0IGRvZXMgbm90IG1lYW4gdGhhdCByZWdleHAgY2FuIGFjdHVhbGx5IGNvbnRhaW4gaXQgaW4gYSBtYXRjaC5cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJMb29rYWhlYWRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0TG9va2FoZWFkKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJOZWdhdGl2ZUxvb2thaGVhZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXROZWdhdGl2ZUxvb2thaGVhZChub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS52aXNpdENoaWxkcmVuLmNhbGwodGhpcywgbm9kZSk7XG4gICAgfTtcbiAgICBDaGFyQ29kZUZpbmRlci5wcm90b3R5cGUudmlzaXRDaGFyYWN0ZXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoKDAsIGluY2x1ZGVzXzEuZGVmYXVsdCkodGhpcy50YXJnZXRDaGFyQ29kZXMsIG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2hhckNvZGVGaW5kZXIucHJvdG90eXBlLnZpc2l0U2V0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY29tcGxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGZpbmRDb2RlKG5vZGUsIHRoaXMudGFyZ2V0Q2hhckNvZGVzKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmluZENvZGUobm9kZSwgdGhpcy50YXJnZXRDaGFyQ29kZXMpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENoYXJDb2RlRmluZGVyO1xufShyZWdleHBfdG9fYXN0XzEuQmFzZVJlZ0V4cFZpc2l0b3IpKTtcbmZ1bmN0aW9uIGNhbk1hdGNoQ2hhckNvZGUoY2hhckNvZGVzLCBwYXR0ZXJuKSB7XG4gICAgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgdmFyIGFzdCA9ICgwLCByZWdfZXhwX3BhcnNlcl8xLmdldFJlZ0V4cEFzdCkocGF0dGVybik7XG4gICAgICAgIHZhciBjaGFyQ29kZUZpbmRlciA9IG5ldyBDaGFyQ29kZUZpbmRlcihjaGFyQ29kZXMpO1xuICAgICAgICBjaGFyQ29kZUZpbmRlci52aXNpdChhc3QpO1xuICAgICAgICByZXR1cm4gY2hhckNvZGVGaW5kZXIuZm91bmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKCgwLCBmaW5kXzEuZGVmYXVsdCkocGF0dGVybiwgZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5jbHVkZXNfMS5kZWZhdWx0KShjaGFyQ29kZXMsIGNoYXIuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIH0pICE9PSB1bmRlZmluZWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2FuTWF0Y2hDaGFyQ29kZSA9IGNhbk1hdGNoQ2hhckNvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdfZXhwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/scan/reg_exp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js":
/*!****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.clearRegExpParserCache = exports.getRegExpAst = void 0;\nvar regexp_to_ast_1 = __webpack_require__(/*! regexp-to-ast */ \"(ssr)/./node_modules/regexp-to-ast/lib/regexp-to-ast.js\");\nvar regExpAstCache = {};\nvar regExpParser = new regexp_to_ast_1.RegExpParser();\nfunction getRegExpAst(regExp) {\n    var regExpStr = regExp.toString();\n    if (regExpAstCache.hasOwnProperty(regExpStr)) {\n        return regExpAstCache[regExpStr];\n    }\n    else {\n        var regExpAst = regExpParser.pattern(regExpStr);\n        regExpAstCache[regExpStr] = regExpAst;\n        return regExpAst;\n    }\n}\nexports.getRegExpAst = getRegExpAst;\nfunction clearRegExpParserCache() {\n    regExpAstCache = {};\n}\nexports.clearRegExpParserCache = clearRegExpParserCache;\n//# sourceMappingURL=reg_exp_parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vcmVnX2V4cF9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsb0JBQW9CO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLDhFQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vcmVnX2V4cF9wYXJzZXIuanM/ODdhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2xlYXJSZWdFeHBQYXJzZXJDYWNoZSA9IGV4cG9ydHMuZ2V0UmVnRXhwQXN0ID0gdm9pZCAwO1xudmFyIHJlZ2V4cF90b19hc3RfMSA9IHJlcXVpcmUoXCJyZWdleHAtdG8tYXN0XCIpO1xudmFyIHJlZ0V4cEFzdENhY2hlID0ge307XG52YXIgcmVnRXhwUGFyc2VyID0gbmV3IHJlZ2V4cF90b19hc3RfMS5SZWdFeHBQYXJzZXIoKTtcbmZ1bmN0aW9uIGdldFJlZ0V4cEFzdChyZWdFeHApIHtcbiAgICB2YXIgcmVnRXhwU3RyID0gcmVnRXhwLnRvU3RyaW5nKCk7XG4gICAgaWYgKHJlZ0V4cEFzdENhY2hlLmhhc093blByb3BlcnR5KHJlZ0V4cFN0cikpIHtcbiAgICAgICAgcmV0dXJuIHJlZ0V4cEFzdENhY2hlW3JlZ0V4cFN0cl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVnRXhwQXN0ID0gcmVnRXhwUGFyc2VyLnBhdHRlcm4ocmVnRXhwU3RyKTtcbiAgICAgICAgcmVnRXhwQXN0Q2FjaGVbcmVnRXhwU3RyXSA9IHJlZ0V4cEFzdDtcbiAgICAgICAgcmV0dXJuIHJlZ0V4cEFzdDtcbiAgICB9XG59XG5leHBvcnRzLmdldFJlZ0V4cEFzdCA9IGdldFJlZ0V4cEFzdDtcbmZ1bmN0aW9uIGNsZWFyUmVnRXhwUGFyc2VyQ2FjaGUoKSB7XG4gICAgcmVnRXhwQXN0Q2FjaGUgPSB7fTtcbn1cbmV4cG9ydHMuY2xlYXJSZWdFeHBQYXJzZXJDYWNoZSA9IGNsZWFyUmVnRXhwUGFyc2VyQ2FjaGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdfZXhwX3BhcnNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/scan/tokens.js":
/*!********************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/tokens.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isTokenType = exports.hasExtendingTokensTypesMapProperty = exports.hasExtendingTokensTypesProperty = exports.hasCategoriesProperty = exports.hasShortKeyProperty = exports.singleAssignCategoriesToksMap = exports.assignCategoriesMapProp = exports.assignCategoriesTokensProp = exports.assignTokenDefaultProps = exports.expandCategories = exports.augmentTokenTypes = exports.tokenIdxToClass = exports.tokenShortNameIdx = exports.tokenStructuredMatcherNoCategories = exports.tokenStructuredMatcher = void 0;\nvar isEmpty_1 = __importDefault(__webpack_require__(/*! lodash/isEmpty */ \"(ssr)/./node_modules/lodash/isEmpty.js\"));\nvar compact_1 = __importDefault(__webpack_require__(/*! lodash/compact */ \"(ssr)/./node_modules/lodash/compact.js\"));\nvar isArray_1 = __importDefault(__webpack_require__(/*! lodash/isArray */ \"(ssr)/./node_modules/lodash/isArray.js\"));\nvar flatten_1 = __importDefault(__webpack_require__(/*! lodash/flatten */ \"(ssr)/./node_modules/lodash/flatten.js\"));\nvar difference_1 = __importDefault(__webpack_require__(/*! lodash/difference */ \"(ssr)/./node_modules/lodash/difference.js\"));\nvar map_1 = __importDefault(__webpack_require__(/*! lodash/map */ \"(ssr)/./node_modules/lodash/map.js\"));\nvar forEach_1 = __importDefault(__webpack_require__(/*! lodash/forEach */ \"(ssr)/./node_modules/lodash/forEach.js\"));\nvar has_1 = __importDefault(__webpack_require__(/*! lodash/has */ \"(ssr)/./node_modules/lodash/has.js\"));\nvar includes_1 = __importDefault(__webpack_require__(/*! lodash/includes */ \"(ssr)/./node_modules/lodash/includes.js\"));\nvar clone_1 = __importDefault(__webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"));\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\n    var instanceType = tokInstance.tokenTypeIdx;\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n    }\n    else {\n        return (tokConstructor.isParent === true &&\n            tokConstructor.categoryMatchesMap[instanceType] === true);\n    }\n}\nexports.tokenStructuredMatcher = tokenStructuredMatcher;\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexports.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;\nexports.tokenShortNameIdx = 1;\nexports.tokenIdxToClass = {};\nfunction augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    var tokenTypesAndParents = expandCategories(tokenTypes);\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents);\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents);\n    assignCategoriesTokensProp(tokenTypesAndParents);\n    (0, forEach_1.default)(tokenTypesAndParents, function (tokType) {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n    });\n}\nexports.augmentTokenTypes = augmentTokenTypes;\nfunction expandCategories(tokenTypes) {\n    var result = (0, clone_1.default)(tokenTypes);\n    var categories = tokenTypes;\n    var searching = true;\n    while (searching) {\n        categories = (0, compact_1.default)((0, flatten_1.default)((0, map_1.default)(categories, function (currTokType) { return currTokType.CATEGORIES; })));\n        var newCategories = (0, difference_1.default)(categories, result);\n        result = result.concat(newCategories);\n        if ((0, isEmpty_1.default)(newCategories)) {\n            searching = false;\n        }\n        else {\n            categories = newCategories;\n        }\n    }\n    return result;\n}\nexports.expandCategories = expandCategories;\nfunction assignTokenDefaultProps(tokenTypes) {\n    (0, forEach_1.default)(tokenTypes, function (currTokType) {\n        if (!hasShortKeyProperty(currTokType)) {\n            exports.tokenIdxToClass[exports.tokenShortNameIdx] = currTokType;\n            currTokType.tokenTypeIdx = exports.tokenShortNameIdx++;\n        }\n        // CATEGORIES? : TokenType | TokenType[]\n        if (hasCategoriesProperty(currTokType) &&\n            !(0, isArray_1.default)(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n        ) {\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n            currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n            currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n            currTokType.categoryMatchesMap = {};\n        }\n    });\n}\nexports.assignTokenDefaultProps = assignTokenDefaultProps;\nfunction assignCategoriesTokensProp(tokenTypes) {\n    (0, forEach_1.default)(tokenTypes, function (currTokType) {\n        // avoid duplications\n        currTokType.categoryMatches = [];\n        (0, forEach_1.default)(currTokType.categoryMatchesMap, function (val, key) {\n            currTokType.categoryMatches.push(exports.tokenIdxToClass[key].tokenTypeIdx);\n        });\n    });\n}\nexports.assignCategoriesTokensProp = assignCategoriesTokensProp;\nfunction assignCategoriesMapProp(tokenTypes) {\n    (0, forEach_1.default)(tokenTypes, function (currTokType) {\n        singleAssignCategoriesToksMap([], currTokType);\n    });\n}\nexports.assignCategoriesMapProp = assignCategoriesMapProp;\nfunction singleAssignCategoriesToksMap(path, nextNode) {\n    (0, forEach_1.default)(path, function (pathNode) {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n    });\n    (0, forEach_1.default)(nextNode.CATEGORIES, function (nextCategory) {\n        var newPath = path.concat(nextNode);\n        // avoids infinite loops due to cyclic categories.\n        if (!(0, includes_1.default)(newPath, nextCategory)) {\n            singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n    });\n}\nexports.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;\nfunction hasShortKeyProperty(tokType) {\n    return (0, has_1.default)(tokType, \"tokenTypeIdx\");\n}\nexports.hasShortKeyProperty = hasShortKeyProperty;\nfunction hasCategoriesProperty(tokType) {\n    return (0, has_1.default)(tokType, \"CATEGORIES\");\n}\nexports.hasCategoriesProperty = hasCategoriesProperty;\nfunction hasExtendingTokensTypesProperty(tokType) {\n    return (0, has_1.default)(tokType, \"categoryMatches\");\n}\nexports.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;\nfunction hasExtendingTokensTypesMapProperty(tokType) {\n    return (0, has_1.default)(tokType, \"categoryMatchesMap\");\n}\nexports.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;\nfunction isTokenType(tokType) {\n    return (0, has_1.default)(tokType, \"tokenTypeIdx\");\n}\nexports.isTokenType = isTokenType;\n//# sourceMappingURL=tokens.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vdG9rZW5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsMENBQTBDLEdBQUcsdUNBQXVDLEdBQUcsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcscUNBQXFDLEdBQUcsK0JBQStCLEdBQUcsa0NBQWtDLEdBQUcsK0JBQStCLEdBQUcsd0JBQXdCLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCLEdBQUcseUJBQXlCLEdBQUcsMENBQTBDLEdBQUcsOEJBQThCO0FBQ3BmLGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCxnQ0FBZ0MsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDeEQsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELGdDQUFnQyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN4RCxtQ0FBbUMsbUJBQU8sQ0FBQyxvRUFBbUI7QUFDOUQsNEJBQTRCLG1CQUFPLENBQUMsc0RBQVk7QUFDaEQsZ0NBQWdDLG1CQUFPLENBQUMsOERBQWdCO0FBQ3hELDRCQUE0QixtQkFBTyxDQUFDLHNEQUFZO0FBQ2hELGlDQUFpQyxtQkFBTyxDQUFDLGdFQUFpQjtBQUMxRCw4QkFBOEIsbUJBQU8sQ0FBQywwREFBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySCxnQ0FBZ0M7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vdG9rZW5zLmpzPzUwZTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzVG9rZW5UeXBlID0gZXhwb3J0cy5oYXNFeHRlbmRpbmdUb2tlbnNUeXBlc01hcFByb3BlcnR5ID0gZXhwb3J0cy5oYXNFeHRlbmRpbmdUb2tlbnNUeXBlc1Byb3BlcnR5ID0gZXhwb3J0cy5oYXNDYXRlZ29yaWVzUHJvcGVydHkgPSBleHBvcnRzLmhhc1Nob3J0S2V5UHJvcGVydHkgPSBleHBvcnRzLnNpbmdsZUFzc2lnbkNhdGVnb3JpZXNUb2tzTWFwID0gZXhwb3J0cy5hc3NpZ25DYXRlZ29yaWVzTWFwUHJvcCA9IGV4cG9ydHMuYXNzaWduQ2F0ZWdvcmllc1Rva2Vuc1Byb3AgPSBleHBvcnRzLmFzc2lnblRva2VuRGVmYXVsdFByb3BzID0gZXhwb3J0cy5leHBhbmRDYXRlZ29yaWVzID0gZXhwb3J0cy5hdWdtZW50VG9rZW5UeXBlcyA9IGV4cG9ydHMudG9rZW5JZHhUb0NsYXNzID0gZXhwb3J0cy50b2tlblNob3J0TmFtZUlkeCA9IGV4cG9ydHMudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllcyA9IGV4cG9ydHMudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlciA9IHZvaWQgMDtcbnZhciBpc0VtcHR5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0VtcHR5XCIpKTtcbnZhciBjb21wYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9jb21wYWN0XCIpKTtcbnZhciBpc0FycmF5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0FycmF5XCIpKTtcbnZhciBmbGF0dGVuXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9mbGF0dGVuXCIpKTtcbnZhciBkaWZmZXJlbmNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9kaWZmZXJlbmNlXCIpKTtcbnZhciBtYXBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL21hcFwiKSk7XG52YXIgZm9yRWFjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvZm9yRWFjaFwiKSk7XG52YXIgaGFzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9oYXNcIikpO1xudmFyIGluY2x1ZGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pbmNsdWRlc1wiKSk7XG52YXIgY2xvbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpKTtcbmZ1bmN0aW9uIHRva2VuU3RydWN0dXJlZE1hdGNoZXIodG9rSW5zdGFuY2UsIHRva0NvbnN0cnVjdG9yKSB7XG4gICAgdmFyIGluc3RhbmNlVHlwZSA9IHRva0luc3RhbmNlLnRva2VuVHlwZUlkeDtcbiAgICBpZiAoaW5zdGFuY2VUeXBlID09PSB0b2tDb25zdHJ1Y3Rvci50b2tlblR5cGVJZHgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKHRva0NvbnN0cnVjdG9yLmlzUGFyZW50ID09PSB0cnVlICYmXG4gICAgICAgICAgICB0b2tDb25zdHJ1Y3Rvci5jYXRlZ29yeU1hdGNoZXNNYXBbaW5zdGFuY2VUeXBlXSA9PT0gdHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy50b2tlblN0cnVjdHVyZWRNYXRjaGVyID0gdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcjtcbi8vIE9wdGltaXplZCB0b2tlbk1hdGNoZXIgaW4gY2FzZSBvdXIgZ3JhbW1hciBkb2VzIG5vdCB1c2UgdG9rZW4gY2F0ZWdvcmllc1xuLy8gQmVpbmcgc28gdGlueSBpdCBpcyBtdWNoIG1vcmUgbGlrZWx5IHRvIGJlIGluLWxpbmVkIGFuZCB0aGlzIGF2b2lkIHRoZSBmdW5jdGlvbiBjYWxsIG92ZXJoZWFkXG5mdW5jdGlvbiB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzKHRva2VuLCB0b2tUeXBlKSB7XG4gICAgcmV0dXJuIHRva2VuLnRva2VuVHlwZUlkeCA9PT0gdG9rVHlwZS50b2tlblR5cGVJZHg7XG59XG5leHBvcnRzLnRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXMgPSB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzO1xuZXhwb3J0cy50b2tlblNob3J0TmFtZUlkeCA9IDE7XG5leHBvcnRzLnRva2VuSWR4VG9DbGFzcyA9IHt9O1xuZnVuY3Rpb24gYXVnbWVudFRva2VuVHlwZXModG9rZW5UeXBlcykge1xuICAgIC8vIGNvbGxlY3QgdGhlIHBhcmVudCBUb2tlbiBUeXBlcyBhcyB3ZWxsLlxuICAgIHZhciB0b2tlblR5cGVzQW5kUGFyZW50cyA9IGV4cGFuZENhdGVnb3JpZXModG9rZW5UeXBlcyk7XG4gICAgLy8gYWRkIHJlcXVpcmVkIHRva2VuVHlwZSBhbmQgY2F0ZWdvcnlNYXRjaGVzIHByb3BlcnRpZXNcbiAgICBhc3NpZ25Ub2tlbkRlZmF1bHRQcm9wcyh0b2tlblR5cGVzQW5kUGFyZW50cyk7XG4gICAgLy8gZmlsbCB1cCB0aGUgY2F0ZWdvcnlNYXRjaGVzXG4gICAgYXNzaWduQ2F0ZWdvcmllc01hcFByb3AodG9rZW5UeXBlc0FuZFBhcmVudHMpO1xuICAgIGFzc2lnbkNhdGVnb3JpZXNUb2tlbnNQcm9wKHRva2VuVHlwZXNBbmRQYXJlbnRzKTtcbiAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKHRva2VuVHlwZXNBbmRQYXJlbnRzLCBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICB0b2tUeXBlLmlzUGFyZW50ID0gdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMubGVuZ3RoID4gMDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYXVnbWVudFRva2VuVHlwZXMgPSBhdWdtZW50VG9rZW5UeXBlcztcbmZ1bmN0aW9uIGV4cGFuZENhdGVnb3JpZXModG9rZW5UeXBlcykge1xuICAgIHZhciByZXN1bHQgPSAoMCwgY2xvbmVfMS5kZWZhdWx0KSh0b2tlblR5cGVzKTtcbiAgICB2YXIgY2F0ZWdvcmllcyA9IHRva2VuVHlwZXM7XG4gICAgdmFyIHNlYXJjaGluZyA9IHRydWU7XG4gICAgd2hpbGUgKHNlYXJjaGluZykge1xuICAgICAgICBjYXRlZ29yaWVzID0gKDAsIGNvbXBhY3RfMS5kZWZhdWx0KSgoMCwgZmxhdHRlbl8xLmRlZmF1bHQpKCgwLCBtYXBfMS5kZWZhdWx0KShjYXRlZ29yaWVzLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHsgcmV0dXJuIGN1cnJUb2tUeXBlLkNBVEVHT1JJRVM7IH0pKSk7XG4gICAgICAgIHZhciBuZXdDYXRlZ29yaWVzID0gKDAsIGRpZmZlcmVuY2VfMS5kZWZhdWx0KShjYXRlZ29yaWVzLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KG5ld0NhdGVnb3JpZXMpO1xuICAgICAgICBpZiAoKDAsIGlzRW1wdHlfMS5kZWZhdWx0KShuZXdDYXRlZ29yaWVzKSkge1xuICAgICAgICAgICAgc2VhcmNoaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzID0gbmV3Q2F0ZWdvcmllcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5leHBhbmRDYXRlZ29yaWVzID0gZXhwYW5kQ2F0ZWdvcmllcztcbmZ1bmN0aW9uIGFzc2lnblRva2VuRGVmYXVsdFByb3BzKHRva2VuVHlwZXMpIHtcbiAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVG9rVHlwZSkge1xuICAgICAgICBpZiAoIWhhc1Nob3J0S2V5UHJvcGVydHkoY3VyclRva1R5cGUpKSB7XG4gICAgICAgICAgICBleHBvcnRzLnRva2VuSWR4VG9DbGFzc1tleHBvcnRzLnRva2VuU2hvcnROYW1lSWR4XSA9IGN1cnJUb2tUeXBlO1xuICAgICAgICAgICAgY3VyclRva1R5cGUudG9rZW5UeXBlSWR4ID0gZXhwb3J0cy50b2tlblNob3J0TmFtZUlkeCsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIENBVEVHT1JJRVM/IDogVG9rZW5UeXBlIHwgVG9rZW5UeXBlW11cbiAgICAgICAgaWYgKGhhc0NhdGVnb3JpZXNQcm9wZXJ0eShjdXJyVG9rVHlwZSkgJiZcbiAgICAgICAgICAgICEoMCwgaXNBcnJheV8xLmRlZmF1bHQpKGN1cnJUb2tUeXBlLkNBVEVHT1JJRVMpXG4gICAgICAgIC8vICYmXG4gICAgICAgIC8vICFpc1VuZGVmaW5lZChjdXJyVG9rVHlwZS5DQVRFR09SSUVTLlBBVFRFUk4pXG4gICAgICAgICkge1xuICAgICAgICAgICAgY3VyclRva1R5cGUuQ0FURUdPUklFUyA9IFtjdXJyVG9rVHlwZS5DQVRFR09SSUVTXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0NhdGVnb3JpZXNQcm9wZXJ0eShjdXJyVG9rVHlwZSkpIHtcbiAgICAgICAgICAgIGN1cnJUb2tUeXBlLkNBVEVHT1JJRVMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0V4dGVuZGluZ1Rva2Vuc1R5cGVzUHJvcGVydHkoY3VyclRva1R5cGUpKSB7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0V4dGVuZGluZ1Rva2Vuc1R5cGVzTWFwUHJvcGVydHkoY3VyclRva1R5cGUpKSB7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXNNYXAgPSB7fTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5hc3NpZ25Ub2tlbkRlZmF1bHRQcm9wcyA9IGFzc2lnblRva2VuRGVmYXVsdFByb3BzO1xuZnVuY3Rpb24gYXNzaWduQ2F0ZWdvcmllc1Rva2Vuc1Byb3AodG9rZW5UeXBlcykge1xuICAgICgwLCBmb3JFYWNoXzEuZGVmYXVsdCkodG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUb2tUeXBlKSB7XG4gICAgICAgIC8vIGF2b2lkIGR1cGxpY2F0aW9uc1xuICAgICAgICBjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMgPSBbXTtcbiAgICAgICAgKDAsIGZvckVhY2hfMS5kZWZhdWx0KShjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXNNYXAsIGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgICAgICAgICAgY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzLnB1c2goZXhwb3J0cy50b2tlbklkeFRvQ2xhc3Nba2V5XS50b2tlblR5cGVJZHgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYXNzaWduQ2F0ZWdvcmllc1Rva2Vuc1Byb3AgPSBhc3NpZ25DYXRlZ29yaWVzVG9rZW5zUHJvcDtcbmZ1bmN0aW9uIGFzc2lnbkNhdGVnb3JpZXNNYXBQcm9wKHRva2VuVHlwZXMpIHtcbiAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVG9rVHlwZSkge1xuICAgICAgICBzaW5nbGVBc3NpZ25DYXRlZ29yaWVzVG9rc01hcChbXSwgY3VyclRva1R5cGUpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5hc3NpZ25DYXRlZ29yaWVzTWFwUHJvcCA9IGFzc2lnbkNhdGVnb3JpZXNNYXBQcm9wO1xuZnVuY3Rpb24gc2luZ2xlQXNzaWduQ2F0ZWdvcmllc1Rva3NNYXAocGF0aCwgbmV4dE5vZGUpIHtcbiAgICAoMCwgZm9yRWFjaF8xLmRlZmF1bHQpKHBhdGgsIGZ1bmN0aW9uIChwYXRoTm9kZSkge1xuICAgICAgICBuZXh0Tm9kZS5jYXRlZ29yeU1hdGNoZXNNYXBbcGF0aE5vZGUudG9rZW5UeXBlSWR4XSA9IHRydWU7XG4gICAgfSk7XG4gICAgKDAsIGZvckVhY2hfMS5kZWZhdWx0KShuZXh0Tm9kZS5DQVRFR09SSUVTLCBmdW5jdGlvbiAobmV4dENhdGVnb3J5KSB7XG4gICAgICAgIHZhciBuZXdQYXRoID0gcGF0aC5jb25jYXQobmV4dE5vZGUpO1xuICAgICAgICAvLyBhdm9pZHMgaW5maW5pdGUgbG9vcHMgZHVlIHRvIGN5Y2xpYyBjYXRlZ29yaWVzLlxuICAgICAgICBpZiAoISgwLCBpbmNsdWRlc18xLmRlZmF1bHQpKG5ld1BhdGgsIG5leHRDYXRlZ29yeSkpIHtcbiAgICAgICAgICAgIHNpbmdsZUFzc2lnbkNhdGVnb3JpZXNUb2tzTWFwKG5ld1BhdGgsIG5leHRDYXRlZ29yeSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuc2luZ2xlQXNzaWduQ2F0ZWdvcmllc1Rva3NNYXAgPSBzaW5nbGVBc3NpZ25DYXRlZ29yaWVzVG9rc01hcDtcbmZ1bmN0aW9uIGhhc1Nob3J0S2V5UHJvcGVydHkodG9rVHlwZSkge1xuICAgIHJldHVybiAoMCwgaGFzXzEuZGVmYXVsdCkodG9rVHlwZSwgXCJ0b2tlblR5cGVJZHhcIik7XG59XG5leHBvcnRzLmhhc1Nob3J0S2V5UHJvcGVydHkgPSBoYXNTaG9ydEtleVByb3BlcnR5O1xuZnVuY3Rpb24gaGFzQ2F0ZWdvcmllc1Byb3BlcnR5KHRva1R5cGUpIHtcbiAgICByZXR1cm4gKDAsIGhhc18xLmRlZmF1bHQpKHRva1R5cGUsIFwiQ0FURUdPUklFU1wiKTtcbn1cbmV4cG9ydHMuaGFzQ2F0ZWdvcmllc1Byb3BlcnR5ID0gaGFzQ2F0ZWdvcmllc1Byb3BlcnR5O1xuZnVuY3Rpb24gaGFzRXh0ZW5kaW5nVG9rZW5zVHlwZXNQcm9wZXJ0eSh0b2tUeXBlKSB7XG4gICAgcmV0dXJuICgwLCBoYXNfMS5kZWZhdWx0KSh0b2tUeXBlLCBcImNhdGVnb3J5TWF0Y2hlc1wiKTtcbn1cbmV4cG9ydHMuaGFzRXh0ZW5kaW5nVG9rZW5zVHlwZXNQcm9wZXJ0eSA9IGhhc0V4dGVuZGluZ1Rva2Vuc1R5cGVzUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNFeHRlbmRpbmdUb2tlbnNUeXBlc01hcFByb3BlcnR5KHRva1R5cGUpIHtcbiAgICByZXR1cm4gKDAsIGhhc18xLmRlZmF1bHQpKHRva1R5cGUsIFwiY2F0ZWdvcnlNYXRjaGVzTWFwXCIpO1xufVxuZXhwb3J0cy5oYXNFeHRlbmRpbmdUb2tlbnNUeXBlc01hcFByb3BlcnR5ID0gaGFzRXh0ZW5kaW5nVG9rZW5zVHlwZXNNYXBQcm9wZXJ0eTtcbmZ1bmN0aW9uIGlzVG9rZW5UeXBlKHRva1R5cGUpIHtcbiAgICByZXR1cm4gKDAsIGhhc18xLmRlZmF1bHQpKHRva1R5cGUsIFwidG9rZW5UeXBlSWR4XCIpO1xufVxuZXhwb3J0cy5pc1Rva2VuVHlwZSA9IGlzVG9rZW5UeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9rZW5zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/scan/tokens.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/scan/tokens_public.js":
/*!***************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/tokens_public.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tokenMatcher = exports.createTokenInstance = exports.EOF = exports.createToken = exports.hasTokenLabel = exports.tokenName = exports.tokenLabel = void 0;\nvar isString_1 = __importDefault(__webpack_require__(/*! lodash/isString */ \"(ssr)/./node_modules/lodash/isString.js\"));\nvar has_1 = __importDefault(__webpack_require__(/*! lodash/has */ \"(ssr)/./node_modules/lodash/has.js\"));\nvar isUndefined_1 = __importDefault(__webpack_require__(/*! lodash/isUndefined */ \"(ssr)/./node_modules/lodash/isUndefined.js\"));\nvar lexer_public_1 = __webpack_require__(/*! ./lexer_public */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/lexer_public.js\");\nvar tokens_1 = __webpack_require__(/*! ./tokens */ \"(ssr)/./node_modules/chevrotain/lib/src/scan/tokens.js\");\nfunction tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n    }\n    else {\n        return tokType.name;\n    }\n}\nexports.tokenLabel = tokenLabel;\nfunction tokenName(tokType) {\n    return tokType.name;\n}\nexports.tokenName = tokenName;\nfunction hasTokenLabel(obj) {\n    return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== \"\";\n}\nexports.hasTokenLabel = hasTokenLabel;\nvar PARENT = \"parent\";\nvar CATEGORIES = \"categories\";\nvar LABEL = \"label\";\nvar GROUP = \"group\";\nvar PUSH_MODE = \"push_mode\";\nvar POP_MODE = \"pop_mode\";\nvar LONGER_ALT = \"longer_alt\";\nvar LINE_BREAKS = \"line_breaks\";\nvar START_CHARS_HINT = \"start_chars_hint\";\nfunction createToken(config) {\n    return createTokenInternal(config);\n}\nexports.createToken = createToken;\nfunction createTokenInternal(config) {\n    var pattern = config.pattern;\n    var tokenType = {};\n    tokenType.name = config.name;\n    if (!(0, isUndefined_1.default)(pattern)) {\n        tokenType.PATTERN = pattern;\n    }\n    if ((0, has_1.default)(config, PARENT)) {\n        throw (\"The parent property is no longer supported.\\n\" +\n            \"See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\");\n    }\n    if ((0, has_1.default)(config, CATEGORIES)) {\n        // casting to ANY as this will be fixed inside `augmentTokenTypes``\n        tokenType.CATEGORIES = config[CATEGORIES];\n    }\n    (0, tokens_1.augmentTokenTypes)([tokenType]);\n    if ((0, has_1.default)(config, LABEL)) {\n        tokenType.LABEL = config[LABEL];\n    }\n    if ((0, has_1.default)(config, GROUP)) {\n        tokenType.GROUP = config[GROUP];\n    }\n    if ((0, has_1.default)(config, POP_MODE)) {\n        tokenType.POP_MODE = config[POP_MODE];\n    }\n    if ((0, has_1.default)(config, PUSH_MODE)) {\n        tokenType.PUSH_MODE = config[PUSH_MODE];\n    }\n    if ((0, has_1.default)(config, LONGER_ALT)) {\n        tokenType.LONGER_ALT = config[LONGER_ALT];\n    }\n    if ((0, has_1.default)(config, LINE_BREAKS)) {\n        tokenType.LINE_BREAKS = config[LINE_BREAKS];\n    }\n    if ((0, has_1.default)(config, START_CHARS_HINT)) {\n        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n    }\n    return tokenType;\n}\nexports.EOF = createToken({ name: \"EOF\", pattern: lexer_public_1.Lexer.NA });\n(0, tokens_1.augmentTokenTypes)([exports.EOF]);\nfunction createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n    return {\n        image: image,\n        startOffset: startOffset,\n        endOffset: endOffset,\n        startLine: startLine,\n        endLine: endLine,\n        startColumn: startColumn,\n        endColumn: endColumn,\n        tokenTypeIdx: tokType.tokenTypeIdx,\n        tokenType: tokType\n    };\n}\nexports.createTokenInstance = createTokenInstance;\nfunction tokenMatcher(token, tokType) {\n    return (0, tokens_1.tokenStructuredMatcher)(token, tokType);\n}\nexports.tokenMatcher = tokenMatcher;\n//# sourceMappingURL=tokens_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vdG9rZW5zX3B1YmxpYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLDJCQUEyQixHQUFHLFdBQVcsR0FBRyxtQkFBbUIsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyxrQkFBa0I7QUFDdkosaUNBQWlDLG1CQUFPLENBQUMsZ0VBQWlCO0FBQzFELDRCQUE0QixtQkFBTyxDQUFDLHNEQUFZO0FBQ2hELG9DQUFvQyxtQkFBTyxDQUFDLHNFQUFvQjtBQUNoRSxxQkFBcUIsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDN0MsZUFBZSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUIsK0NBQStDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvc2Nhbi90b2tlbnNfcHVibGljLmpzPzdlM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRva2VuTWF0Y2hlciA9IGV4cG9ydHMuY3JlYXRlVG9rZW5JbnN0YW5jZSA9IGV4cG9ydHMuRU9GID0gZXhwb3J0cy5jcmVhdGVUb2tlbiA9IGV4cG9ydHMuaGFzVG9rZW5MYWJlbCA9IGV4cG9ydHMudG9rZW5OYW1lID0gZXhwb3J0cy50b2tlbkxhYmVsID0gdm9pZCAwO1xudmFyIGlzU3RyaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc1N0cmluZ1wiKSk7XG52YXIgaGFzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9oYXNcIikpO1xudmFyIGlzVW5kZWZpbmVkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc1VuZGVmaW5lZFwiKSk7XG52YXIgbGV4ZXJfcHVibGljXzEgPSByZXF1aXJlKFwiLi9sZXhlcl9wdWJsaWNcIik7XG52YXIgdG9rZW5zXzEgPSByZXF1aXJlKFwiLi90b2tlbnNcIik7XG5mdW5jdGlvbiB0b2tlbkxhYmVsKHRva1R5cGUpIHtcbiAgICBpZiAoaGFzVG9rZW5MYWJlbCh0b2tUeXBlKSkge1xuICAgICAgICByZXR1cm4gdG9rVHlwZS5MQUJFTDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tUeXBlLm5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy50b2tlbkxhYmVsID0gdG9rZW5MYWJlbDtcbmZ1bmN0aW9uIHRva2VuTmFtZSh0b2tUeXBlKSB7XG4gICAgcmV0dXJuIHRva1R5cGUubmFtZTtcbn1cbmV4cG9ydHMudG9rZW5OYW1lID0gdG9rZW5OYW1lO1xuZnVuY3Rpb24gaGFzVG9rZW5MYWJlbChvYmopIHtcbiAgICByZXR1cm4gKDAsIGlzU3RyaW5nXzEuZGVmYXVsdCkob2JqLkxBQkVMKSAmJiBvYmouTEFCRUwgIT09IFwiXCI7XG59XG5leHBvcnRzLmhhc1Rva2VuTGFiZWwgPSBoYXNUb2tlbkxhYmVsO1xudmFyIFBBUkVOVCA9IFwicGFyZW50XCI7XG52YXIgQ0FURUdPUklFUyA9IFwiY2F0ZWdvcmllc1wiO1xudmFyIExBQkVMID0gXCJsYWJlbFwiO1xudmFyIEdST1VQID0gXCJncm91cFwiO1xudmFyIFBVU0hfTU9ERSA9IFwicHVzaF9tb2RlXCI7XG52YXIgUE9QX01PREUgPSBcInBvcF9tb2RlXCI7XG52YXIgTE9OR0VSX0FMVCA9IFwibG9uZ2VyX2FsdFwiO1xudmFyIExJTkVfQlJFQUtTID0gXCJsaW5lX2JyZWFrc1wiO1xudmFyIFNUQVJUX0NIQVJTX0hJTlQgPSBcInN0YXJ0X2NoYXJzX2hpbnRcIjtcbmZ1bmN0aW9uIGNyZWF0ZVRva2VuKGNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbkludGVybmFsKGNvbmZpZyk7XG59XG5leHBvcnRzLmNyZWF0ZVRva2VuID0gY3JlYXRlVG9rZW47XG5mdW5jdGlvbiBjcmVhdGVUb2tlbkludGVybmFsKGNvbmZpZykge1xuICAgIHZhciBwYXR0ZXJuID0gY29uZmlnLnBhdHRlcm47XG4gICAgdmFyIHRva2VuVHlwZSA9IHt9O1xuICAgIHRva2VuVHlwZS5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgaWYgKCEoMCwgaXNVbmRlZmluZWRfMS5kZWZhdWx0KShwYXR0ZXJuKSkge1xuICAgICAgICB0b2tlblR5cGUuUEFUVEVSTiA9IHBhdHRlcm47XG4gICAgfVxuICAgIGlmICgoMCwgaGFzXzEuZGVmYXVsdCkoY29uZmlnLCBQQVJFTlQpKSB7XG4gICAgICAgIHRocm93IChcIlRoZSBwYXJlbnQgcHJvcGVydHkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5cXG5cIiArXG4gICAgICAgICAgICBcIlNlZTogaHR0cHM6Ly9naXRodWIuY29tL2NoZXZyb3RhaW4vY2hldnJvdGFpbi9pc3N1ZXMvNTY0I2lzc3VlY29tbWVudC0zNDkwNjIzNDYgZm9yIGRldGFpbHMuXCIpO1xuICAgIH1cbiAgICBpZiAoKDAsIGhhc18xLmRlZmF1bHQpKGNvbmZpZywgQ0FURUdPUklFUykpIHtcbiAgICAgICAgLy8gY2FzdGluZyB0byBBTlkgYXMgdGhpcyB3aWxsIGJlIGZpeGVkIGluc2lkZSBgYXVnbWVudFRva2VuVHlwZXNgYFxuICAgICAgICB0b2tlblR5cGUuQ0FURUdPUklFUyA9IGNvbmZpZ1tDQVRFR09SSUVTXTtcbiAgICB9XG4gICAgKDAsIHRva2Vuc18xLmF1Z21lbnRUb2tlblR5cGVzKShbdG9rZW5UeXBlXSk7XG4gICAgaWYgKCgwLCBoYXNfMS5kZWZhdWx0KShjb25maWcsIExBQkVMKSkge1xuICAgICAgICB0b2tlblR5cGUuTEFCRUwgPSBjb25maWdbTEFCRUxdO1xuICAgIH1cbiAgICBpZiAoKDAsIGhhc18xLmRlZmF1bHQpKGNvbmZpZywgR1JPVVApKSB7XG4gICAgICAgIHRva2VuVHlwZS5HUk9VUCA9IGNvbmZpZ1tHUk9VUF07XG4gICAgfVxuICAgIGlmICgoMCwgaGFzXzEuZGVmYXVsdCkoY29uZmlnLCBQT1BfTU9ERSkpIHtcbiAgICAgICAgdG9rZW5UeXBlLlBPUF9NT0RFID0gY29uZmlnW1BPUF9NT0RFXTtcbiAgICB9XG4gICAgaWYgKCgwLCBoYXNfMS5kZWZhdWx0KShjb25maWcsIFBVU0hfTU9ERSkpIHtcbiAgICAgICAgdG9rZW5UeXBlLlBVU0hfTU9ERSA9IGNvbmZpZ1tQVVNIX01PREVdO1xuICAgIH1cbiAgICBpZiAoKDAsIGhhc18xLmRlZmF1bHQpKGNvbmZpZywgTE9OR0VSX0FMVCkpIHtcbiAgICAgICAgdG9rZW5UeXBlLkxPTkdFUl9BTFQgPSBjb25maWdbTE9OR0VSX0FMVF07XG4gICAgfVxuICAgIGlmICgoMCwgaGFzXzEuZGVmYXVsdCkoY29uZmlnLCBMSU5FX0JSRUFLUykpIHtcbiAgICAgICAgdG9rZW5UeXBlLkxJTkVfQlJFQUtTID0gY29uZmlnW0xJTkVfQlJFQUtTXTtcbiAgICB9XG4gICAgaWYgKCgwLCBoYXNfMS5kZWZhdWx0KShjb25maWcsIFNUQVJUX0NIQVJTX0hJTlQpKSB7XG4gICAgICAgIHRva2VuVHlwZS5TVEFSVF9DSEFSU19ISU5UID0gY29uZmlnW1NUQVJUX0NIQVJTX0hJTlRdO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5UeXBlO1xufVxuZXhwb3J0cy5FT0YgPSBjcmVhdGVUb2tlbih7IG5hbWU6IFwiRU9GXCIsIHBhdHRlcm46IGxleGVyX3B1YmxpY18xLkxleGVyLk5BIH0pO1xuKDAsIHRva2Vuc18xLmF1Z21lbnRUb2tlblR5cGVzKShbZXhwb3J0cy5FT0ZdKTtcbmZ1bmN0aW9uIGNyZWF0ZVRva2VuSW5zdGFuY2UodG9rVHlwZSwgaW1hZ2UsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHN0YXJ0TGluZSwgZW5kTGluZSwgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICBlbmRPZmZzZXQ6IGVuZE9mZnNldCxcbiAgICAgICAgc3RhcnRMaW5lOiBzdGFydExpbmUsXG4gICAgICAgIGVuZExpbmU6IGVuZExpbmUsXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBzdGFydENvbHVtbixcbiAgICAgICAgZW5kQ29sdW1uOiBlbmRDb2x1bW4sXG4gICAgICAgIHRva2VuVHlwZUlkeDogdG9rVHlwZS50b2tlblR5cGVJZHgsXG4gICAgICAgIHRva2VuVHlwZTogdG9rVHlwZVxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZVRva2VuSW5zdGFuY2UgPSBjcmVhdGVUb2tlbkluc3RhbmNlO1xuZnVuY3Rpb24gdG9rZW5NYXRjaGVyKHRva2VuLCB0b2tUeXBlKSB7XG4gICAgcmV0dXJuICgwLCB0b2tlbnNfMS50b2tlblN0cnVjdHVyZWRNYXRjaGVyKSh0b2tlbiwgdG9rVHlwZSk7XG59XG5leHBvcnRzLnRva2VuTWF0Y2hlciA9IHRva2VuTWF0Y2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRva2Vuc19wdWJsaWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/scan/tokens_public.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/chevrotain/lib/src/version.js":
/*!****************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/version.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VERSION = void 0;\n// needs a separate module as this is required inside chevrotain productive code\n// and also in the entry point for webpack(api.ts).\n// A separate file avoids cyclic dependencies and webpack errors.\nexports.VERSION = \"10.5.0\";\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3ZlcnNpb24uanM/Njg5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVkVSU0lPTiA9IHZvaWQgMDtcbi8vIG5lZWRzIGEgc2VwYXJhdGUgbW9kdWxlIGFzIHRoaXMgaXMgcmVxdWlyZWQgaW5zaWRlIGNoZXZyb3RhaW4gcHJvZHVjdGl2ZSBjb2RlXG4vLyBhbmQgYWxzbyBpbiB0aGUgZW50cnkgcG9pbnQgZm9yIHdlYnBhY2soYXBpLnRzKS5cbi8vIEEgc2VwYXJhdGUgZmlsZSBhdm9pZHMgY3ljbGljIGRlcGVuZGVuY2llcyBhbmQgd2VicGFjayBlcnJvcnMuXG5leHBvcnRzLlZFUlNJT04gPSBcIjEwLjUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chevrotain/lib/src/version.js\n");

/***/ })

};
;