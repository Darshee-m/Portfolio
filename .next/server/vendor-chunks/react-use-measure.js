"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-use-measure";
exports.ids = ["vendor-chunks/react-use-measure"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-use-measure/dist/web.cjs.js":
/*!********************************************************!*\
  !*** ./node_modules/react-use-measure/dist/web.cjs.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar createDebounce = __webpack_require__(/*! debounce */ \"(ssr)/./node_modules/debounce/index.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar createDebounce__default = /*#__PURE__*/_interopDefaultLegacy(createDebounce);\n\nfunction useMeasure(_temp) {\n  var _ref = _temp === void 0 ? {\n    debounce: 0,\n    scroll: false,\n    offsetSize: false\n  } : _temp,\n      debounce = _ref.debounce,\n      scroll = _ref.scroll,\n      polyfill = _ref.polyfill,\n      offsetSize = _ref.offsetSize;\n\n  var ResizeObserver = polyfill || (typeof window === 'undefined' ? function ResizeObserver() {} : window.ResizeObserver);\n\n  if (!ResizeObserver) {\n    throw new Error('This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills');\n  }\n\n  var _useState = react.useState({\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    bottom: 0,\n    right: 0,\n    x: 0,\n    y: 0\n  }),\n      bounds = _useState[0],\n      set = _useState[1]; // keep all state in a ref\n\n\n  var state = react.useRef({\n    element: null,\n    scrollContainers: null,\n    resizeObserver: null,\n    lastBounds: bounds\n  }); // set actual debounce values early, so effects know if they should react accordingly\n\n  var scrollDebounce = debounce ? typeof debounce === 'number' ? debounce : debounce.scroll : null;\n  var resizeDebounce = debounce ? typeof debounce === 'number' ? debounce : debounce.resize : null; // make sure to update state only as long as the component is truly mounted\n\n  var mounted = react.useRef(false);\n  react.useEffect(function () {\n    mounted.current = true;\n    return function () {\n      return void (mounted.current = false);\n    };\n  }); // memoize handlers, so event-listeners know when they should update\n\n  var _useMemo = react.useMemo(function () {\n    var callback = function callback() {\n      if (!state.current.element) return;\n\n      var _ref2 = state.current.element.getBoundingClientRect(),\n          left = _ref2.left,\n          top = _ref2.top,\n          width = _ref2.width,\n          height = _ref2.height,\n          bottom = _ref2.bottom,\n          right = _ref2.right,\n          x = _ref2.x,\n          y = _ref2.y;\n\n      var size = {\n        left: left,\n        top: top,\n        width: width,\n        height: height,\n        bottom: bottom,\n        right: right,\n        x: x,\n        y: y\n      };\n\n      if (state.current.element instanceof HTMLElement && offsetSize) {\n        size.height = state.current.element.offsetHeight;\n        size.width = state.current.element.offsetWidth;\n      }\n\n      Object.freeze(size);\n      if (mounted.current && !areBoundsEqual(state.current.lastBounds, size)) set(state.current.lastBounds = size);\n    };\n\n    return [callback, resizeDebounce ? createDebounce__default[\"default\"](callback, resizeDebounce) : callback, scrollDebounce ? createDebounce__default[\"default\"](callback, scrollDebounce) : callback];\n  }, [set, offsetSize, scrollDebounce, resizeDebounce]),\n      forceRefresh = _useMemo[0],\n      resizeChange = _useMemo[1],\n      scrollChange = _useMemo[2]; // cleanup current scroll-listeners / observers\n\n\n  function removeListeners() {\n    if (state.current.scrollContainers) {\n      state.current.scrollContainers.forEach(function (element) {\n        return element.removeEventListener('scroll', scrollChange, true);\n      });\n      state.current.scrollContainers = null;\n    }\n\n    if (state.current.resizeObserver) {\n      state.current.resizeObserver.disconnect();\n      state.current.resizeObserver = null;\n    }\n  } // add scroll-listeners / observers\n\n\n  function addListeners() {\n    if (!state.current.element) return;\n    state.current.resizeObserver = new ResizeObserver(scrollChange);\n    state.current.resizeObserver.observe(state.current.element);\n\n    if (scroll && state.current.scrollContainers) {\n      state.current.scrollContainers.forEach(function (scrollContainer) {\n        return scrollContainer.addEventListener('scroll', scrollChange, {\n          capture: true,\n          passive: true\n        });\n      });\n    }\n  } // the ref we expose to the user\n\n\n  var ref = function ref(node) {\n    if (!node || node === state.current.element) return;\n    removeListeners();\n    state.current.element = node;\n    state.current.scrollContainers = findScrollContainers(node);\n    addListeners();\n  }; // add general event listeners\n\n\n  useOnWindowScroll(scrollChange, Boolean(scroll));\n  useOnWindowResize(resizeChange); // respond to changes that are relevant for the listeners\n\n  react.useEffect(function () {\n    removeListeners();\n    addListeners();\n  }, [scroll, scrollChange, resizeChange]); // remove all listeners when the components unmounts\n\n  react.useEffect(function () {\n    return removeListeners;\n  }, []);\n  return [ref, bounds, forceRefresh];\n} // Adds native resize listener to window\n\n\nfunction useOnWindowResize(onWindowResize) {\n  react.useEffect(function () {\n    var cb = onWindowResize;\n    window.addEventListener('resize', cb);\n    return function () {\n      return void window.removeEventListener('resize', cb);\n    };\n  }, [onWindowResize]);\n}\n\nfunction useOnWindowScroll(onScroll, enabled) {\n  react.useEffect(function () {\n    if (enabled) {\n      var _cb = onScroll;\n      window.addEventListener('scroll', _cb, {\n        capture: true,\n        passive: true\n      });\n      return function () {\n        return void window.removeEventListener('scroll', _cb, true);\n      };\n    }\n  }, [onScroll, enabled]);\n} // Returns a list of scroll offsets\n\n\nfunction findScrollContainers(element) {\n  var result = [];\n  if (!element || element === document.body) return result;\n\n  var _window$getComputedSt = window.getComputedStyle(element),\n      overflow = _window$getComputedSt.overflow,\n      overflowX = _window$getComputedSt.overflowX,\n      overflowY = _window$getComputedSt.overflowY;\n\n  if ([overflow, overflowX, overflowY].some(function (prop) {\n    return prop === 'auto' || prop === 'scroll';\n  })) result.push(element);\n  return [].concat(result, findScrollContainers(element.parentElement));\n} // Checks if element boundaries are equal\n\n\nvar keys = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height'];\n\nvar areBoundsEqual = function areBoundsEqual(a, b) {\n  return keys.every(function (key) {\n    return a[key] === b[key];\n  });\n};\n\nmodule.exports = useMeasure;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdXNlLW1lYXN1cmUvZGlzdC93ZWIuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyx3R0FBTztBQUMzQixxQkFBcUIsbUJBQU8sQ0FBQyx3REFBVTs7QUFFdkMscUNBQXFDLDREQUE0RDs7QUFFakc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpR0FBaUc7O0FBRWpHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQkFBMEI7OztBQUcxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0Esb0dBQW9HOztBQUVwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtDQUFrQzs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxHQUFHLHlDQUF5Qzs7QUFFNUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9yZWFjdC11c2UtbWVhc3VyZS9kaXN0L3dlYi5janMuanM/NGM2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgY3JlYXRlRGVib3VuY2UgPSByZXF1aXJlKCdkZWJvdW5jZScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIGNyZWF0ZURlYm91bmNlX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShjcmVhdGVEZWJvdW5jZSk7XG5cbmZ1bmN0aW9uIHVzZU1lYXN1cmUoX3RlbXApIHtcbiAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge1xuICAgIGRlYm91bmNlOiAwLFxuICAgIHNjcm9sbDogZmFsc2UsXG4gICAgb2Zmc2V0U2l6ZTogZmFsc2VcbiAgfSA6IF90ZW1wLFxuICAgICAgZGVib3VuY2UgPSBfcmVmLmRlYm91bmNlLFxuICAgICAgc2Nyb2xsID0gX3JlZi5zY3JvbGwsXG4gICAgICBwb2x5ZmlsbCA9IF9yZWYucG9seWZpbGwsXG4gICAgICBvZmZzZXRTaXplID0gX3JlZi5vZmZzZXRTaXplO1xuXG4gIHZhciBSZXNpemVPYnNlcnZlciA9IHBvbHlmaWxsIHx8ICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKCkge30gOiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIpO1xuXG4gIGlmICghUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFJlc2l6ZU9ic2VydmVyIG91dCBvZiB0aGUgYm94LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1zcHJpbmcvcmVhY3QtdXNlLW1lYXN1cmUvI3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbHMnKTtcbiAgfVxuXG4gIHZhciBfdXNlU3RhdGUgPSByZWFjdC51c2VTdGF0ZSh7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICByaWdodDogMCxcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSksXG4gICAgICBib3VuZHMgPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXQgPSBfdXNlU3RhdGVbMV07IC8vIGtlZXAgYWxsIHN0YXRlIGluIGEgcmVmXG5cblxuICB2YXIgc3RhdGUgPSByZWFjdC51c2VSZWYoe1xuICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgc2Nyb2xsQ29udGFpbmVyczogbnVsbCxcbiAgICByZXNpemVPYnNlcnZlcjogbnVsbCxcbiAgICBsYXN0Qm91bmRzOiBib3VuZHNcbiAgfSk7IC8vIHNldCBhY3R1YWwgZGVib3VuY2UgdmFsdWVzIGVhcmx5LCBzbyBlZmZlY3RzIGtub3cgaWYgdGhleSBzaG91bGQgcmVhY3QgYWNjb3JkaW5nbHlcblxuICB2YXIgc2Nyb2xsRGVib3VuY2UgPSBkZWJvdW5jZSA/IHR5cGVvZiBkZWJvdW5jZSA9PT0gJ251bWJlcicgPyBkZWJvdW5jZSA6IGRlYm91bmNlLnNjcm9sbCA6IG51bGw7XG4gIHZhciByZXNpemVEZWJvdW5jZSA9IGRlYm91bmNlID8gdHlwZW9mIGRlYm91bmNlID09PSAnbnVtYmVyJyA/IGRlYm91bmNlIDogZGVib3VuY2UucmVzaXplIDogbnVsbDsgLy8gbWFrZSBzdXJlIHRvIHVwZGF0ZSBzdGF0ZSBvbmx5IGFzIGxvbmcgYXMgdGhlIGNvbXBvbmVudCBpcyB0cnVseSBtb3VudGVkXG5cbiAgdmFyIG1vdW50ZWQgPSByZWFjdC51c2VSZWYoZmFsc2UpO1xuICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIG1vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2b2lkIChtb3VudGVkLmN1cnJlbnQgPSBmYWxzZSk7XG4gICAgfTtcbiAgfSk7IC8vIG1lbW9pemUgaGFuZGxlcnMsIHNvIGV2ZW50LWxpc3RlbmVycyBrbm93IHdoZW4gdGhleSBzaG91bGQgdXBkYXRlXG5cbiAgdmFyIF91c2VNZW1vID0gcmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICBpZiAoIXN0YXRlLmN1cnJlbnQuZWxlbWVudCkgcmV0dXJuO1xuXG4gICAgICB2YXIgX3JlZjIgPSBzdGF0ZS5jdXJyZW50LmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgbGVmdCA9IF9yZWYyLmxlZnQsXG4gICAgICAgICAgdG9wID0gX3JlZjIudG9wLFxuICAgICAgICAgIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0LFxuICAgICAgICAgIGJvdHRvbSA9IF9yZWYyLmJvdHRvbSxcbiAgICAgICAgICByaWdodCA9IF9yZWYyLnJpZ2h0LFxuICAgICAgICAgIHggPSBfcmVmMi54LFxuICAgICAgICAgIHkgPSBfcmVmMi55O1xuXG4gICAgICB2YXIgc2l6ZSA9IHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH07XG5cbiAgICAgIGlmIChzdGF0ZS5jdXJyZW50LmVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBvZmZzZXRTaXplKSB7XG4gICAgICAgIHNpemUuaGVpZ2h0ID0gc3RhdGUuY3VycmVudC5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgc2l6ZS53aWR0aCA9IHN0YXRlLmN1cnJlbnQuZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmZyZWV6ZShzaXplKTtcbiAgICAgIGlmIChtb3VudGVkLmN1cnJlbnQgJiYgIWFyZUJvdW5kc0VxdWFsKHN0YXRlLmN1cnJlbnQubGFzdEJvdW5kcywgc2l6ZSkpIHNldChzdGF0ZS5jdXJyZW50Lmxhc3RCb3VuZHMgPSBzaXplKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFtjYWxsYmFjaywgcmVzaXplRGVib3VuY2UgPyBjcmVhdGVEZWJvdW5jZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2FsbGJhY2ssIHJlc2l6ZURlYm91bmNlKSA6IGNhbGxiYWNrLCBzY3JvbGxEZWJvdW5jZSA/IGNyZWF0ZURlYm91bmNlX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjYWxsYmFjaywgc2Nyb2xsRGVib3VuY2UpIDogY2FsbGJhY2tdO1xuICB9LCBbc2V0LCBvZmZzZXRTaXplLCBzY3JvbGxEZWJvdW5jZSwgcmVzaXplRGVib3VuY2VdKSxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF91c2VNZW1vWzBdLFxuICAgICAgcmVzaXplQ2hhbmdlID0gX3VzZU1lbW9bMV0sXG4gICAgICBzY3JvbGxDaGFuZ2UgPSBfdXNlTWVtb1syXTsgLy8gY2xlYW51cCBjdXJyZW50IHNjcm9sbC1saXN0ZW5lcnMgLyBvYnNlcnZlcnNcblxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBpZiAoc3RhdGUuY3VycmVudC5zY3JvbGxDb250YWluZXJzKSB7XG4gICAgICBzdGF0ZS5jdXJyZW50LnNjcm9sbENvbnRhaW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxDaGFuZ2UsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICBzdGF0ZS5jdXJyZW50LnNjcm9sbENvbnRhaW5lcnMgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5jdXJyZW50LnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICBzdGF0ZS5jdXJyZW50LnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHN0YXRlLmN1cnJlbnQucmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgfSAvLyBhZGQgc2Nyb2xsLWxpc3RlbmVycyAvIG9ic2VydmVyc1xuXG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmICghc3RhdGUuY3VycmVudC5lbGVtZW50KSByZXR1cm47XG4gICAgc3RhdGUuY3VycmVudC5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihzY3JvbGxDaGFuZ2UpO1xuICAgIHN0YXRlLmN1cnJlbnQucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShzdGF0ZS5jdXJyZW50LmVsZW1lbnQpO1xuXG4gICAgaWYgKHNjcm9sbCAmJiBzdGF0ZS5jdXJyZW50LnNjcm9sbENvbnRhaW5lcnMpIHtcbiAgICAgIHN0YXRlLmN1cnJlbnQuc2Nyb2xsQ29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxDb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIHNjcm9sbENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxDaGFuZ2UsIHtcbiAgICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy8gdGhlIHJlZiB3ZSBleHBvc2UgdG8gdGhlIHVzZXJcblxuXG4gIHZhciByZWYgPSBmdW5jdGlvbiByZWYobm9kZSkge1xuICAgIGlmICghbm9kZSB8fCBub2RlID09PSBzdGF0ZS5jdXJyZW50LmVsZW1lbnQpIHJldHVybjtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICBzdGF0ZS5jdXJyZW50LmVsZW1lbnQgPSBub2RlO1xuICAgIHN0YXRlLmN1cnJlbnQuc2Nyb2xsQ29udGFpbmVycyA9IGZpbmRTY3JvbGxDb250YWluZXJzKG5vZGUpO1xuICAgIGFkZExpc3RlbmVycygpO1xuICB9OyAvLyBhZGQgZ2VuZXJhbCBldmVudCBsaXN0ZW5lcnNcblxuXG4gIHVzZU9uV2luZG93U2Nyb2xsKHNjcm9sbENoYW5nZSwgQm9vbGVhbihzY3JvbGwpKTtcbiAgdXNlT25XaW5kb3dSZXNpemUocmVzaXplQ2hhbmdlKTsgLy8gcmVzcG9uZCB0byBjaGFuZ2VzIHRoYXQgYXJlIHJlbGV2YW50IGZvciB0aGUgbGlzdGVuZXJzXG5cbiAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICBhZGRMaXN0ZW5lcnMoKTtcbiAgfSwgW3Njcm9sbCwgc2Nyb2xsQ2hhbmdlLCByZXNpemVDaGFuZ2VdKTsgLy8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgd2hlbiB0aGUgY29tcG9uZW50cyB1bm1vdW50c1xuXG4gIHJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVycztcbiAgfSwgW10pO1xuICByZXR1cm4gW3JlZiwgYm91bmRzLCBmb3JjZVJlZnJlc2hdO1xufSAvLyBBZGRzIG5hdGl2ZSByZXNpemUgbGlzdGVuZXIgdG8gd2luZG93XG5cblxuZnVuY3Rpb24gdXNlT25XaW5kb3dSZXNpemUob25XaW5kb3dSZXNpemUpIHtcbiAgcmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2IgPSBvbldpbmRvd1Jlc2l6ZTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgY2IpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdm9pZCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgY2IpO1xuICAgIH07XG4gIH0sIFtvbldpbmRvd1Jlc2l6ZV0pO1xufVxuXG5mdW5jdGlvbiB1c2VPbldpbmRvd1Njcm9sbChvblNjcm9sbCwgZW5hYmxlZCkge1xuICByZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmFibGVkKSB7XG4gICAgICB2YXIgX2NiID0gb25TY3JvbGw7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX2NiLCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF9jYiwgdHJ1ZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW29uU2Nyb2xsLCBlbmFibGVkXSk7XG59IC8vIFJldHVybnMgYSBsaXN0IG9mIHNjcm9sbCBvZmZzZXRzXG5cblxuZnVuY3Rpb24gZmluZFNjcm9sbENvbnRhaW5lcnMoZWxlbWVudCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmICghZWxlbWVudCB8fCBlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSByZXR1cm4gcmVzdWx0O1xuXG4gIHZhciBfd2luZG93JGdldENvbXB1dGVkU3QgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX3dpbmRvdyRnZXRDb21wdXRlZFN0Lm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX3dpbmRvdyRnZXRDb21wdXRlZFN0Lm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF93aW5kb3ckZ2V0Q29tcHV0ZWRTdC5vdmVyZmxvd1k7XG5cbiAgaWYgKFtvdmVyZmxvdywgb3ZlcmZsb3dYLCBvdmVyZmxvd1ldLnNvbWUoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCA9PT0gJ2F1dG8nIHx8IHByb3AgPT09ICdzY3JvbGwnO1xuICB9KSkgcmVzdWx0LnB1c2goZWxlbWVudCk7XG4gIHJldHVybiBbXS5jb25jYXQocmVzdWx0LCBmaW5kU2Nyb2xsQ29udGFpbmVycyhlbGVtZW50LnBhcmVudEVsZW1lbnQpKTtcbn0gLy8gQ2hlY2tzIGlmIGVsZW1lbnQgYm91bmRhcmllcyBhcmUgZXF1YWxcblxuXG52YXIga2V5cyA9IFsneCcsICd5JywgJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICd3aWR0aCcsICdoZWlnaHQnXTtcblxudmFyIGFyZUJvdW5kc0VxdWFsID0gZnVuY3Rpb24gYXJlQm91bmRzRXF1YWwoYSwgYikge1xuICByZXR1cm4ga2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGFba2V5XSA9PT0gYltrZXldO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdXNlTWVhc3VyZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-use-measure/dist/web.cjs.js\n");

/***/ })

};
;