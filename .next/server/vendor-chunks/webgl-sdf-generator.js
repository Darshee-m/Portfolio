/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/webgl-sdf-generator";
exports.ids = ["vendor-chunks/webgl-sdf-generator"];
exports.modules = {

/***/ "(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.js ***!
  \**********************************************************************/
/***/ (function(module) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  function SDFGenerator() {\n  var exports = (function (exports) {\n\n    /**\n     * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n     */\n    function pointOnQuadraticBezier (x0, y0, x1, y1, x2, y2, t, pointOut) {\n      var t2 = 1 - t;\n      pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n      pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n    }\n\n    /**\n     * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n     */\n    function pointOnCubicBezier (x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n      var t2 = 1 - t;\n      pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n      pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n    }\n\n    /**\n     * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n     * @param {function(\n     *   command: 'L'|'Q'|'C',\n     *   startX: number,\n     *   startY: number,\n     *   endX: number,\n     *   endY: number,\n     *   ctrl1X?: number,\n     *   ctrl1Y?: number,\n     *   ctrl2X?: number,\n     *   ctrl2Y?: number\n     * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n     *                      command identifier (only L/Q/C commands) and its numeric arguments.\n     */\n    function forEachPathCommand(pathString, commandCallback) {\n      var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n      var match, firstX, firstY, prevX, prevY;\n      while ((match = segmentRE.exec(pathString))) {\n        var args = match[2]\n          .replace(/^\\s*|\\s*$/g, '')\n          .split(/[,\\s]+/)\n          .map(function (v) { return parseFloat(v); });\n        switch (match[1]) {\n          case 'M':\n            prevX = firstX = args[0];\n            prevY = firstY = args[1];\n            break\n          case 'L':\n            if (args[0] !== prevX || args[1] !== prevY) { // yup, some fonts have zero-length line commands\n              commandCallback('L', prevX, prevY, (prevX = args[0]), (prevY = args[1]));\n            }\n            break\n          case 'Q': {\n            commandCallback('Q', prevX, prevY, (prevX = args[2]), (prevY = args[3]), args[0], args[1]);\n            break\n          }\n          case 'C': {\n            commandCallback('C', prevX, prevY, (prevX = args[4]), (prevY = args[5]), args[0], args[1], args[2], args[3]);\n            break\n          }\n          case 'Z':\n            if (prevX !== firstX || prevY !== firstY) {\n              commandCallback('L', prevX, prevY, firstX, firstY);\n            }\n            break\n        }\n      }\n    }\n\n    /**\n     * Convert a path string to a series of straight line segments\n     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n     * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n     *        function that will be called once for every line segment\n     * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n     *        bezier curve in the path. Defaults to 16.\n     */\n    function pathToLineSegments (pathString, segmentCallback, curvePoints) {\n      if ( curvePoints === void 0 ) curvePoints = 16;\n\n      var tempPoint = { x: 0, y: 0 };\n      forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n        switch (command) {\n          case 'L':\n            segmentCallback(startX, startY, endX, endY);\n            break\n          case 'Q': {\n            var prevCurveX = startX;\n            var prevCurveY = startY;\n            for (var i = 1; i < curvePoints; i++) {\n              pointOnQuadraticBezier(\n                startX, startY,\n                ctrl1X, ctrl1Y,\n                endX, endY,\n                i / (curvePoints - 1),\n                tempPoint\n              );\n              segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n              prevCurveX = tempPoint.x;\n              prevCurveY = tempPoint.y;\n            }\n            break\n          }\n          case 'C': {\n            var prevCurveX$1 = startX;\n            var prevCurveY$1 = startY;\n            for (var i$1 = 1; i$1 < curvePoints; i$1++) {\n              pointOnCubicBezier(\n                startX, startY,\n                ctrl1X, ctrl1Y,\n                ctrl2X, ctrl2Y,\n                endX, endY,\n                i$1 / (curvePoints - 1),\n                tempPoint\n              );\n              segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n              prevCurveX$1 = tempPoint.x;\n              prevCurveY$1 = tempPoint.y;\n            }\n            break\n          }\n        }\n      });\n    }\n\n    var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n    var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n\n    var cache = new WeakMap();\n\n    var glContextParams = {\n      premultipliedAlpha: false,\n      preserveDrawingBuffer: true,\n      antialias: false,\n      depth: false,\n    };\n\n    /**\n     * This is a little helper library for WebGL. It assists with state management for a GL context.\n     * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n     *\n     * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n     * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n     */\n    function withWebGLContext (glOrCanvas, callback) {\n      var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;\n      var wrapper = cache.get(gl);\n      if (!wrapper) {\n        var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n        var extensions = {};\n        var programs = {};\n        var textures = {};\n        var textureUnit = -1;\n        var framebufferStack = [];\n\n        gl.canvas.addEventListener('webglcontextlost', function (e) {\n          handleContextLoss();\n          e.preventDefault();\n        }, false);\n\n        function getExtension (name) {\n          var ext = extensions[name];\n          if (!ext) {\n            ext = extensions[name] = gl.getExtension(name);\n            if (!ext) {\n              throw new Error((name + \" not supported\"))\n            }\n          }\n          return ext\n        }\n\n        function compileShader (src, type) {\n          var shader = gl.createShader(type);\n          gl.shaderSource(shader, src);\n          gl.compileShader(shader);\n          // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n          // if (!status && !gl.isContextLost()) {\n          //   throw new Error(gl.getShaderInfoLog(shader).trim())\n          // }\n          return shader\n        }\n\n        function withProgram (name, vert, frag, func) {\n          if (!programs[name]) {\n            var attributes = {};\n            var uniforms = {};\n            var program = gl.createProgram();\n            gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n            gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n            gl.linkProgram(program);\n\n            programs[name] = {\n              program: program,\n              transaction: function transaction (func) {\n                gl.useProgram(program);\n                func({\n                  setUniform: function setUniform (type, name) {\n                    var values = [], len = arguments.length - 2;\n                    while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];\n\n                    var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                    gl[(\"uniform\" + type)].apply(gl, [ uniformLoc ].concat( values ));\n                  },\n\n                  setAttribute: function setAttribute (name, size, usage, instancingDivisor, data) {\n                    var attr = attributes[name];\n                    if (!attr) {\n                      attr = attributes[name] = {\n                        buf: gl.createBuffer(), // TODO should we destroy our buffers?\n                        loc: gl.getAttribLocation(program, name),\n                        data: null\n                      };\n                    }\n                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                    gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                    gl.enableVertexAttribArray(attr.loc);\n                    if (isWebGL2) {\n                      gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                    } else {\n                      getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                    }\n                    if (data !== attr.data) {\n                      gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                      attr.data = data;\n                    }\n                  }\n                });\n              }\n            };\n          }\n\n          programs[name].transaction(func);\n        }\n\n        function withTexture (name, func) {\n          textureUnit++;\n          try {\n            gl.activeTexture(gl.TEXTURE0 + textureUnit);\n            var texture = textures[name];\n            if (!texture) {\n              texture = textures[name] = gl.createTexture();\n              gl.bindTexture(gl.TEXTURE_2D, texture);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            }\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            func(texture, textureUnit);\n          } finally {\n            textureUnit--;\n          }\n        }\n\n        function withTextureFramebuffer (texture, textureUnit, func) {\n          var framebuffer = gl.createFramebuffer();\n          framebufferStack.push(framebuffer);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n          gl.activeTexture(gl.TEXTURE0 + textureUnit);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n          try {\n            func(framebuffer);\n          } finally {\n            gl.deleteFramebuffer(framebuffer);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n          }\n        }\n\n        function handleContextLoss () {\n          extensions = {};\n          programs = {};\n          textures = {};\n          textureUnit = -1;\n          framebufferStack.length = 0;\n        }\n\n        cache.set(gl, wrapper = {\n          gl: gl,\n          isWebGL2: isWebGL2,\n          getExtension: getExtension,\n          withProgram: withProgram,\n          withTexture: withTexture,\n          withTextureFramebuffer: withTextureFramebuffer,\n          handleContextLoss: handleContextLoss,\n        });\n      }\n      callback(wrapper);\n    }\n\n\n    function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n      if ( channels === void 0 ) channels = 15;\n      if ( framebuffer === void 0 ) framebuffer = null;\n\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var withProgram = ref.withProgram;\n        var withTexture = ref.withTexture;\n\n        withTexture('copy', function (tex, texUnit) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n          withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {\n            var setUniform = ref.setUniform;\n            var setAttribute = ref.setAttribute;\n\n            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));\n            setUniform('1i', 'image', texUnit);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n            gl.disable(gl.BLEND);\n            gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n            gl.viewport(x, y, width, height);\n            gl.scissor(x, y, width, height);\n            gl.drawArrays(gl.TRIANGLES, 0, 3);\n          });\n        });\n      });\n    }\n\n    /**\n     * Resizing a canvas clears its contents; this utility copies the previous contents over.\n     * @param canvas\n     * @param newWidth\n     * @param newHeight\n     */\n    function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n      var width = canvas.width;\n      var height = canvas.height;\n      withWebGLContext(canvas, function (ref) {\n        var gl = ref.gl;\n\n        var data = new Uint8Array(width * height * 4);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        canvas.width = newWidth;\n        canvas.height = newHeight;\n        renderImageData(gl, data, 0, 0, width, height);\n      });\n    }\n\n    var webglUtils = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      withWebGLContext: withWebGLContext,\n      renderImageData: renderImageData,\n      resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n    });\n\n    function generate$2 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n      var textureData = new Uint8Array(sdfWidth * sdfHeight);\n\n      var viewBoxWidth = viewBox[2] - viewBox[0];\n      var viewBoxHeight = viewBox[3] - viewBox[1];\n\n      // Decompose all paths into straight line segments and add them to an index\n      var segments = [];\n      pathToLineSegments(path, function (x1, y1, x2, y2) {\n        segments.push({\n          x1: x1, y1: y1, x2: x2, y2: y2,\n          minX: Math.min(x1, x2),\n          minY: Math.min(y1, y2),\n          maxX: Math.max(x1, x2),\n          maxY: Math.max(y1, y2)\n        });\n      });\n\n      // Sort segments by maxX, this will let us short-circuit some loops below\n      segments.sort(function (a, b) { return a.maxX - b.maxX; });\n\n      // For each target SDF texel, find the distance from its center to its nearest line segment,\n      // map that distance to an alpha value, and write that alpha to the texel\n      for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {\n        for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {\n          var signedDist = findNearestSignedDistance(\n            viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,\n            viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight\n          );\n\n          // Use an exponential scale to ensure the texels very near the glyph path have adequate\n          // precision, while allowing the distance field to cover the entire texture, given that\n          // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n          var alpha = Math.pow((1 - Math.abs(signedDist) / maxDistance), sdfExponent) / 2;\n          if (signedDist < 0) {\n            alpha = 1 - alpha;\n          }\n\n          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n          textureData[sdfY * sdfWidth + sdfX] = alpha;\n        }\n      }\n\n      return textureData\n\n      /**\n       * For a given x/y, search the index for the closest line segment and return\n       * its signed distance. Negative = inside, positive = outside, zero = on edge\n       * @param x\n       * @param y\n       * @returns {number}\n       */\n      function findNearestSignedDistance (x, y) {\n        var closestDistSq = Infinity;\n        var closestDist = Infinity;\n\n        for (var i = segments.length; i--;) {\n          var seg = segments[i];\n          if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit\n          if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n            var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n            if (distSq < closestDistSq) {\n              closestDistSq = distSq;\n              closestDist = Math.sqrt(closestDistSq);\n            }\n          }\n        }\n\n        // Flip to negative distance if inside the poly\n        if (isPointInPoly(x, y)) {\n          closestDist = -closestDist;\n        }\n        return closestDist\n      }\n\n      /**\n       * Determine whether the given point lies inside or outside the glyph. Uses a simple\n       * winding-number ray casting algorithm using a ray pointing east from the point.\n       */\n      function isPointInPoly (x, y) {\n        var winding = 0;\n        for (var i = segments.length; i--;) {\n          var seg = segments[i];\n          if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit\n          var intersects = ((seg.y1 > y) !== (seg.y2 > y)) && (x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1);\n          if (intersects) {\n            winding += seg.y1 < seg.y2 ? 1 : -1;\n          }\n        }\n        return winding !== 0\n      }\n    }\n\n    function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n      if ( x === void 0 ) x = 0;\n      if ( y === void 0 ) y = 0;\n      if ( channel === void 0 ) channel = 0;\n\n      generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n    }\n\n    function generateIntoFramebuffer$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n      if ( x === void 0 ) x = 0;\n      if ( y === void 0 ) y = 0;\n      if ( channel === void 0 ) channel = 0;\n\n      var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);\n      // Expand single-channel data to rbga\n      var rgbaData = new Uint8Array(data.length * 4);\n      for (var i = 0; i < data.length; i++) {\n        rgbaData[i * 4 + channel] = data[i];\n      }\n      renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << (3 - channel), framebuffer);\n    }\n\n    /**\n     * Find the absolute distance from a point to a line segment at closest approach\n     */\n    function absSquareDistanceToLineSegment (x, y, lineX0, lineY0, lineX1, lineY1) {\n      var ldx = lineX1 - lineX0;\n      var ldy = lineY1 - lineY0;\n      var lengthSq = ldx * ldx + ldy * ldy;\n      var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n      var dx = x - (lineX0 + t * ldx);\n      var dy = y - (lineY0 + t * ldy);\n      return dx * dx + dy * dy\n    }\n\n    var javascript = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      generate: generate$2,\n      generateIntoCanvas: generateIntoCanvas$2,\n      generateIntoFramebuffer: generateIntoFramebuffer$1\n    });\n\n    var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n    var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n\n    var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\";\n\n    // Single triangle covering viewport\n    var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);\n\n    var implicitContext = null;\n    var isTestingSupport = false;\n    var NULL_OBJECT = {};\n    var supportByCanvas = new WeakMap(); // canvas -> bool\n\n    function validateSupport (glOrCanvas) {\n      if (!isTestingSupport && !isSupported(glOrCanvas)) {\n        throw new Error('WebGL generation not supported')\n      }\n    }\n\n    function generate$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n      if ( glOrCanvas === void 0 ) glOrCanvas = null;\n\n      if (!glOrCanvas) {\n        glOrCanvas = implicitContext;\n        if (!glOrCanvas) {\n          var canvas = typeof OffscreenCanvas === 'function'\n            ? new OffscreenCanvas(1, 1)\n            : typeof document !== 'undefined'\n              ? document.createElement('canvas')\n              : null;\n          if (!canvas) {\n            throw new Error('OffscreenCanvas or DOM canvas not supported')\n          }\n          glOrCanvas = implicitContext = canvas.getContext('webgl', { depth: false });\n        }\n      }\n\n      validateSupport(glOrCanvas);\n\n      var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n\n      // Render into a background texture framebuffer\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var withTexture = ref.withTexture;\n        var withTextureFramebuffer = ref.withTextureFramebuffer;\n\n        withTexture('readable', function (texture, textureUnit) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n          withTextureFramebuffer(texture, textureUnit, function (framebuffer) {\n            generateIntoFramebuffer(\n              sdfWidth,\n              sdfHeight,\n              path,\n              viewBox,\n              maxDistance,\n              sdfExponent,\n              gl,\n              framebuffer,\n              0,\n              0,\n              0 // red channel\n            );\n            gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n          });\n        });\n      });\n\n      // Throw away all but the red channel\n      var data = new Uint8Array(sdfWidth * sdfHeight);\n      for (var i = 0, j = 0; i < rgbaData.length; i += 4) {\n        data[j++] = rgbaData[i];\n      }\n\n      return data\n    }\n\n    function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n      if ( x === void 0 ) x = 0;\n      if ( y === void 0 ) y = 0;\n      if ( channel === void 0 ) channel = 0;\n\n      generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n    }\n\n    function generateIntoFramebuffer (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n      if ( x === void 0 ) x = 0;\n      if ( y === void 0 ) y = 0;\n      if ( channel === void 0 ) channel = 0;\n\n      // Verify support\n      validateSupport(glOrCanvas);\n\n      // Compute path segments\n      var lineSegmentCoords = [];\n      pathToLineSegments(path, function (x1, y1, x2, y2) {\n        lineSegmentCoords.push(x1, y1, x2, y2);\n      });\n      lineSegmentCoords = new Float32Array(lineSegmentCoords);\n\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var isWebGL2 = ref.isWebGL2;\n        var getExtension = ref.getExtension;\n        var withProgram = ref.withProgram;\n        var withTexture = ref.withTexture;\n        var withTextureFramebuffer = ref.withTextureFramebuffer;\n        var handleContextLoss = ref.handleContextLoss;\n\n        withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {\n          if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n            gl.texImage2D(\n              gl.TEXTURE_2D, 0, gl.RGBA,\n              intermediateTexture._lastWidth = sdfWidth,\n              intermediateTexture._lastHeight = sdfHeight,\n              0, gl.RGBA, gl.UNSIGNED_BYTE, null\n            );\n          }\n\n          // Unsigned distance pass\n          withProgram('main', mainVertex, mainFragment, function (ref) {\n            var setAttribute = ref.setAttribute;\n            var setUniform = ref.setUniform;\n\n            // Init extensions\n            var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');\n            var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');\n\n            // Init/update attributes\n            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n            setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);\n\n            // Init/update uniforms\n            setUniform.apply(void 0, [ '4f', 'uGlyphBounds' ].concat( viewBox ));\n            setUniform('1f', 'uMaxDistance', maxDistance);\n            setUniform('1f', 'uExponent', sdfExponent);\n\n            // Render initial unsigned distance / winding number info to a texture\n            withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {\n              gl.enable(gl.BLEND);\n              gl.colorMask(true, true, true, true);\n              gl.viewport(0, 0, sdfWidth, sdfHeight);\n              gl.scissor(0, 0, sdfWidth, sdfHeight);\n              gl.blendFunc(gl.ONE, gl.ONE);\n              // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n              // Alpha holds the closest (MAX) unsigned distance.\n              gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n              gl.clear(gl.COLOR_BUFFER_BIT);\n              if (isWebGL2) {\n                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n              } else {\n                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n              }\n              // Debug\n              // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n              // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n              // console.log('intermediate texture data: ', debug)\n            });\n          });\n\n          // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n          withProgram('post', viewportQuadVertex, postFragment, function (program) {\n            program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n            program.setUniform('1i', 'tex', intermediateTextureUnit);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n            gl.disable(gl.BLEND);\n            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n            gl.viewport(x, y, sdfWidth, sdfHeight);\n            gl.scissor(x, y, sdfWidth, sdfHeight);\n            gl.drawArrays(gl.TRIANGLES, 0, 3);\n          });\n        });\n\n        // Handle context loss occurring during any of the above calls\n        if (gl.isContextLost()) {\n          handleContextLoss();\n          throw new Error('webgl context lost')\n        }\n      });\n    }\n\n    function isSupported (glOrCanvas) {\n      var key = (!glOrCanvas || glOrCanvas === implicitContext) ? NULL_OBJECT : (glOrCanvas.canvas || glOrCanvas);\n      var supported = supportByCanvas.get(key);\n      if (supported === undefined) {\n        isTestingSupport = true;\n        var failReason = null;\n        try {\n          // Since we can't detect all failure modes up front, let's just do a trial run of a\n          // simple path and compare what we get back to the correct expected result. This will\n          // also serve to prime the shader compilation.\n          var expectedResult = [\n            97, 106, 97, 61,\n            99, 137, 118, 80,\n            80, 118, 137, 99,\n            61, 97, 106, 97\n          ];\n          var testResult = generate$1(\n            4,\n            4,\n            'M8,8L16,8L24,24L16,24Z',\n            [0, 0, 32, 32],\n            24,\n            1,\n            glOrCanvas\n          );\n          supported = testResult && expectedResult.length === testResult.length &&\n            testResult.every(function (val, i) { return val === expectedResult[i]; });\n          if (!supported) {\n            failReason = 'bad trial run results';\n            console.info(expectedResult, testResult);\n          }\n        } catch (err) {\n          // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n          supported = false;\n          failReason = err.message;\n        }\n        if (failReason) {\n          console.warn('WebGL SDF generation not supported:', failReason);\n        }\n        isTestingSupport = false;\n        supportByCanvas.set(key, supported);\n      }\n      return supported\n    }\n\n    var webgl = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      generate: generate$1,\n      generateIntoCanvas: generateIntoCanvas$1,\n      generateIntoFramebuffer: generateIntoFramebuffer,\n      isSupported: isSupported\n    });\n\n    /**\n     * Generate an SDF texture image for a 2D path.\n     *\n     * @param {number} sdfWidth - width of the SDF output image in pixels.\n     * @param {number} sdfHeight - height of the SDF output image in pixels.\n     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n     *        to half the maximum viewBox dimension.\n     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n     *        will give greater precision nearer the glyph's path.\n     * @return {Uint8Array}\n     */\n    function generate(\n      sdfWidth,\n      sdfHeight,\n      path,\n      viewBox,\n      maxDistance,\n      sdfExponent\n    ) {\n      if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n      try {\n        return generate$1.apply(webgl, arguments)\n      } catch(e) {\n        console.info('WebGL SDF generation failed, falling back to JS', e);\n        return generate$2.apply(javascript, arguments)\n      }\n    }\n\n    /**\n     * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n     * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n     * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n     *\n     * @param {number} sdfWidth - width of the SDF output image in pixels.\n     * @param {number} sdfHeight - height of the SDF output image in pixels.\n     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n     *        to half the maximum viewBox dimension.\n     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n     *        will give greater precision nearer the glyph's path.\n     * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n     *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n     *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n     * @param {number} x - the x position at which to render the SDF.\n     * @param {number} y - the y position at which to render the SDF.\n     * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n     * @return {Uint8Array}\n     */\n    function generateIntoCanvas(\n      sdfWidth,\n      sdfHeight,\n      path,\n      viewBox,\n      maxDistance,\n      sdfExponent,\n      canvas,\n      x,\n      y,\n      channel\n    ) {\n      if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n      if ( sdfExponent === void 0 ) sdfExponent = 1;\n      if ( x === void 0 ) x = 0;\n      if ( y === void 0 ) y = 0;\n      if ( channel === void 0 ) channel = 0;\n\n      try {\n        return generateIntoCanvas$1.apply(webgl, arguments)\n      } catch(e) {\n        console.info('WebGL SDF generation failed, falling back to JS', e);\n        return generateIntoCanvas$2.apply(javascript, arguments)\n      }\n    }\n\n    exports.forEachPathCommand = forEachPathCommand;\n    exports.generate = generate;\n    exports.generateIntoCanvas = generateIntoCanvas;\n    exports.javascript = javascript;\n    exports.pathToLineSegments = pathToLineSegments;\n    exports.webgl = webgl;\n    exports.webglUtils = webglUtils;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n    return exports;\n\n  }({}));\n  return exports\n  }\n\n  return SDFGenerator;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViZ2wtc2RmLWdlbmVyYXRvci9kaXN0L3dlYmdsLXNkZi1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDa0g7QUFDcEgsQ0FBQyxzQkFBc0I7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsK0NBQStDO0FBQ3RFLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUSwrQ0FBK0M7QUFDdEUsZUFBZSxzREFBc0Q7QUFDckU7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSxxREFBcUQ7QUFDNUUsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUSwyRkFBMkY7QUFDbEg7QUFDQSxlQUFlLFFBQVEsOEVBQThFO0FBQ3JHO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsYUFBYTs7QUFFaEU7O0FBRUEsR0FBRyxHQUFHO0FBQ047QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy93ZWJnbC1zZGYtZ2VuZXJhdG9yL2Rpc3Qvd2ViZ2wtc2RmLWdlbmVyYXRvci5qcz81OTc1Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLndlYmdsX3NkZl9nZW5lcmF0b3IgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gU0RGR2VuZXJhdG9yKCkge1xuICB2YXIgZXhwb3J0cyA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgcG9pbnQgb24gYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlIGF0IHQgd2hlcmUgdCBpcyBpbiB0aGUgcmFuZ2UgWzAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcG9pbnRPblF1YWRyYXRpY0JlemllciAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgdCwgcG9pbnRPdXQpIHtcbiAgICAgIHZhciB0MiA9IDEgLSB0O1xuICAgICAgcG9pbnRPdXQueCA9IHQyICogdDIgKiB4MCArIDIgKiB0MiAqIHQgKiB4MSArIHQgKiB0ICogeDI7XG4gICAgICBwb2ludE91dC55ID0gdDIgKiB0MiAqIHkwICsgMiAqIHQyICogdCAqIHkxICsgdCAqIHQgKiB5MjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBwb2ludCBvbiBhIGN1YmljIGJlemllciBjdXJ2ZSBhdCB0IHdoZXJlIHQgaXMgaW4gdGhlIHJhbmdlIFswLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBvaW50T25DdWJpY0JlemllciAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0LCBwb2ludE91dCkge1xuICAgICAgdmFyIHQyID0gMSAtIHQ7XG4gICAgICBwb2ludE91dC54ID0gdDIgKiB0MiAqIHQyICogeDAgKyAzICogdDIgKiB0MiAqIHQgKiB4MSArIDMgKiB0MiAqIHQgKiB0ICogeDIgKyB0ICogdCAqIHQgKiB4MztcbiAgICAgIHBvaW50T3V0LnkgPSB0MiAqIHQyICogdDIgKiB5MCArIDMgKiB0MiAqIHQyICogdCAqIHkxICsgMyAqIHQyICogdCAqIHQgKiB5MiArIHQgKiB0ICogdCAqIHkzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgcGF0aCBzdHJpbmcgaW50byBpdHMgY29uc3RpdHVlbnQgbGluZS9jdXJ2ZSBjb21tYW5kcywgaW52b2tpbmcgYSBjYWxsYmFjayBmb3IgZWFjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZyAtIEFuIFNWRy1saWtlIHBhdGggc3RyaW5nIHRvIHBhcnNlOyBzaG91bGQgb25seSBjb250YWluIGNvbW1hbmRzOiBNL0wvUS9DL1pcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFxuICAgICAqICAgY29tbWFuZDogJ0wnfCdRJ3wnQycsXG4gICAgICogICBzdGFydFg6IG51bWJlcixcbiAgICAgKiAgIHN0YXJ0WTogbnVtYmVyLFxuICAgICAqICAgZW5kWDogbnVtYmVyLFxuICAgICAqICAgZW5kWTogbnVtYmVyLFxuICAgICAqICAgY3RybDFYPzogbnVtYmVyLFxuICAgICAqICAgY3RybDFZPzogbnVtYmVyLFxuICAgICAqICAgY3RybDJYPzogbnVtYmVyLFxuICAgICAqICAgY3RybDJZPzogbnVtYmVyXG4gICAgICogKX0gY29tbWFuZENhbGxiYWNrIC0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGVhY2ggcGFyc2VkIHBhdGggY29tbWFuZCwgcGFzc2luZyB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kIGlkZW50aWZpZXIgKG9ubHkgTC9RL0MgY29tbWFuZHMpIGFuZCBpdHMgbnVtZXJpYyBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFBhdGhDb21tYW5kKHBhdGhTdHJpbmcsIGNvbW1hbmRDYWxsYmFjaykge1xuICAgICAgdmFyIHNlZ21lbnRSRSA9IC8oW01MUUNaXSkoW15NTFFDWl0qKS9nO1xuICAgICAgdmFyIG1hdGNoLCBmaXJzdFgsIGZpcnN0WSwgcHJldlgsIHByZXZZO1xuICAgICAgd2hpbGUgKChtYXRjaCA9IHNlZ21lbnRSRS5leGVjKHBhdGhTdHJpbmcpKSkge1xuICAgICAgICB2YXIgYXJncyA9IG1hdGNoWzJdXG4gICAgICAgICAgLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKVxuICAgICAgICAgIC5zcGxpdCgvWyxcXHNdKy8pXG4gICAgICAgICAgLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gcGFyc2VGbG9hdCh2KTsgfSk7XG4gICAgICAgIHN3aXRjaCAobWF0Y2hbMV0pIHtcbiAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIHByZXZYID0gZmlyc3RYID0gYXJnc1swXTtcbiAgICAgICAgICAgIHByZXZZID0gZmlyc3RZID0gYXJnc1sxXTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICBpZiAoYXJnc1swXSAhPT0gcHJldlggfHwgYXJnc1sxXSAhPT0gcHJldlkpIHsgLy8geXVwLCBzb21lIGZvbnRzIGhhdmUgemVyby1sZW5ndGggbGluZSBjb21tYW5kc1xuICAgICAgICAgICAgICBjb21tYW5kQ2FsbGJhY2soJ0wnLCBwcmV2WCwgcHJldlksIChwcmV2WCA9IGFyZ3NbMF0pLCAocHJldlkgPSBhcmdzWzFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ1EnOiB7XG4gICAgICAgICAgICBjb21tYW5kQ2FsbGJhY2soJ1EnLCBwcmV2WCwgcHJldlksIChwcmV2WCA9IGFyZ3NbMl0pLCAocHJldlkgPSBhcmdzWzNdKSwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdDJzoge1xuICAgICAgICAgICAgY29tbWFuZENhbGxiYWNrKCdDJywgcHJldlgsIHByZXZZLCAocHJldlggPSBhcmdzWzRdKSwgKHByZXZZID0gYXJnc1s1XSksIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICBpZiAocHJldlggIT09IGZpcnN0WCB8fCBwcmV2WSAhPT0gZmlyc3RZKSB7XG4gICAgICAgICAgICAgIGNvbW1hbmRDYWxsYmFjaygnTCcsIHByZXZYLCBwcmV2WSwgZmlyc3RYLCBmaXJzdFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBwYXRoIHN0cmluZyB0byBhIHNlcmllcyBvZiBzdHJhaWdodCBsaW5lIHNlZ21lbnRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmcgLSBBbiBTVkctbGlrZSBwYXRoIHN0cmluZyB0byBwYXJzZTsgc2hvdWxkIG9ubHkgY29udGFpbiBjb21tYW5kczogTS9ML1EvQy9aXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih4MTpudW1iZXIsIHkxOm51bWJlciwgeDI6bnVtYmVyLCB5MjpudW1iZXIpfSBzZWdtZW50Q2FsbGJhY2sgLSBBIGNhbGxiYWNrXG4gICAgICogICAgICAgIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZXZlcnkgbGluZSBzZWdtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjdXJ2ZVBvaW50c10gLSBIb3cgbWFueSBzdHJhaWdodCBsaW5lIHNlZ21lbnRzIHRvIHVzZSB3aGVuIGFwcHJveGltYXRpbmcgYVxuICAgICAqICAgICAgICBiZXppZXIgY3VydmUgaW4gdGhlIHBhdGguIERlZmF1bHRzIHRvIDE2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhdGhUb0xpbmVTZWdtZW50cyAocGF0aFN0cmluZywgc2VnbWVudENhbGxiYWNrLCBjdXJ2ZVBvaW50cykge1xuICAgICAgaWYgKCBjdXJ2ZVBvaW50cyA9PT0gdm9pZCAwICkgY3VydmVQb2ludHMgPSAxNjtcblxuICAgICAgdmFyIHRlbXBQb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgZm9yRWFjaFBhdGhDb21tYW5kKHBhdGhTdHJpbmcsIGZ1bmN0aW9uIChjb21tYW5kLCBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgY3RybDFYLCBjdHJsMVksIGN0cmwyWCwgY3RybDJZKSB7XG4gICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgc2VnbWVudENhbGxiYWNrKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnUSc6IHtcbiAgICAgICAgICAgIHZhciBwcmV2Q3VydmVYID0gc3RhcnRYO1xuICAgICAgICAgICAgdmFyIHByZXZDdXJ2ZVkgPSBzdGFydFk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGN1cnZlUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgcG9pbnRPblF1YWRyYXRpY0JlemllcihcbiAgICAgICAgICAgICAgICBzdGFydFgsIHN0YXJ0WSxcbiAgICAgICAgICAgICAgICBjdHJsMVgsIGN0cmwxWSxcbiAgICAgICAgICAgICAgICBlbmRYLCBlbmRZLFxuICAgICAgICAgICAgICAgIGkgLyAoY3VydmVQb2ludHMgLSAxKSxcbiAgICAgICAgICAgICAgICB0ZW1wUG9pbnRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgc2VnbWVudENhbGxiYWNrKHByZXZDdXJ2ZVgsIHByZXZDdXJ2ZVksIHRlbXBQb2ludC54LCB0ZW1wUG9pbnQueSk7XG4gICAgICAgICAgICAgIHByZXZDdXJ2ZVggPSB0ZW1wUG9pbnQueDtcbiAgICAgICAgICAgICAgcHJldkN1cnZlWSA9IHRlbXBQb2ludC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQyc6IHtcbiAgICAgICAgICAgIHZhciBwcmV2Q3VydmVYJDEgPSBzdGFydFg7XG4gICAgICAgICAgICB2YXIgcHJldkN1cnZlWSQxID0gc3RhcnRZO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDwgY3VydmVQb2ludHM7IGkkMSsrKSB7XG4gICAgICAgICAgICAgIHBvaW50T25DdWJpY0JlemllcihcbiAgICAgICAgICAgICAgICBzdGFydFgsIHN0YXJ0WSxcbiAgICAgICAgICAgICAgICBjdHJsMVgsIGN0cmwxWSxcbiAgICAgICAgICAgICAgICBjdHJsMlgsIGN0cmwyWSxcbiAgICAgICAgICAgICAgICBlbmRYLCBlbmRZLFxuICAgICAgICAgICAgICAgIGkkMSAvIChjdXJ2ZVBvaW50cyAtIDEpLFxuICAgICAgICAgICAgICAgIHRlbXBQb2ludFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBzZWdtZW50Q2FsbGJhY2socHJldkN1cnZlWCQxLCBwcmV2Q3VydmVZJDEsIHRlbXBQb2ludC54LCB0ZW1wUG9pbnQueSk7XG4gICAgICAgICAgICAgIHByZXZDdXJ2ZVgkMSA9IHRlbXBQb2ludC54O1xuICAgICAgICAgICAgICBwcmV2Q3VydmVZJDEgPSB0ZW1wUG9pbnQueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgdmlld3BvcnRRdWFkVmVydGV4ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7YXR0cmlidXRlIHZlYzIgYVVWO3ZhcnlpbmcgdmVjMiB2VVY7dm9pZCBtYWluKCl7dlVWPWFVVjtnbF9Qb3NpdGlvbj12ZWM0KG1peCh2ZWMyKC0xLjApLHZlYzIoMS4wKSxhVVYpLDAuMCwxLjApO31cIjtcblxuICAgIHZhciBjb3B5VGV4RnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDt1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7dmFyeWluZyB2ZWMyIHZVVjt2b2lkIG1haW4oKXtnbF9GcmFnQ29sb3I9dGV4dHVyZTJEKHRleCx2VVYpO31cIjtcblxuICAgIHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICB2YXIgZ2xDb250ZXh0UGFyYW1zID0ge1xuICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZSxcbiAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICBkZXB0aDogZmFsc2UsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBsaXR0bGUgaGVscGVyIGxpYnJhcnkgZm9yIFdlYkdMLiBJdCBhc3Npc3RzIHdpdGggc3RhdGUgbWFuYWdlbWVudCBmb3IgYSBHTCBjb250ZXh0LlxuICAgICAqIEl0J3MgcHJldHR5IHRpZ2h0bHkgd3JhcHBlZCB0byB0aGUgbmVlZHMgb2YgdGhpcyBwYWNrYWdlLCBub3QgdmVyeSBnZW5lcmFsLXB1cnBvc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IE9mZnNjcmVlbkNhbnZhcyB9IGdsT3JDYW52YXMgLSB0aGUgR0wgY29udGV4dCB0byB3cmFwXG4gICAgICogQHBhcmFtIHsgKHtnbCwgZ2V0RXh0ZW5zaW9uLCB3aXRoUHJvZ3JhbSwgd2l0aFRleHR1cmUsIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIsIGhhbmRsZUNvbnRleHRMb3NzfSkgPT4gdm9pZCB9IGNhbGxiYWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2l0aFdlYkdMQ29udGV4dCAoZ2xPckNhbnZhcywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBnbCA9IGdsT3JDYW52YXMuZ2V0Q29udGV4dCA/IGdsT3JDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBnbENvbnRleHRQYXJhbXMpIDogZ2xPckNhbnZhcztcbiAgICAgIHZhciB3cmFwcGVyID0gY2FjaGUuZ2V0KGdsKTtcbiAgICAgIGlmICghd3JhcHBlcikge1xuICAgICAgICB2YXIgaXNXZWJHTDIgPSB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgICAgICB2YXIgZXh0ZW5zaW9ucyA9IHt9O1xuICAgICAgICB2YXIgcHJvZ3JhbXMgPSB7fTtcbiAgICAgICAgdmFyIHRleHR1cmVzID0ge307XG4gICAgICAgIHZhciB0ZXh0dXJlVW5pdCA9IC0xO1xuICAgICAgICB2YXIgZnJhbWVidWZmZXJTdGFjayA9IFtdO1xuXG4gICAgICAgIGdsLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBoYW5kbGVDb250ZXh0TG9zcygpO1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldEV4dGVuc2lvbiAobmFtZSkge1xuICAgICAgICAgIHZhciBleHQgPSBleHRlbnNpb25zW25hbWVdO1xuICAgICAgICAgIGlmICghZXh0KSB7XG4gICAgICAgICAgICBleHQgPSBleHRlbnNpb25zW25hbWVdID0gZ2wuZ2V0RXh0ZW5zaW9uKG5hbWUpO1xuICAgICAgICAgICAgaWYgKCFleHQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChuYW1lICsgXCIgbm90IHN1cHBvcnRlZFwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV4dFxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcGlsZVNoYWRlciAoc3JjLCB0eXBlKSB7XG4gICAgICAgICAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICAgICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICAgICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgICAvLyBjb25zdCBzdGF0dXMgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUylcbiAgICAgICAgICAvLyBpZiAoIXN0YXR1cyAmJiAhZ2wuaXNDb250ZXh0TG9zdCgpKSB7XG4gICAgICAgICAgLy8gICB0aHJvdyBuZXcgRXJyb3IoZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpLnRyaW0oKSlcbiAgICAgICAgICAvLyB9XG4gICAgICAgICAgcmV0dXJuIHNoYWRlclxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gd2l0aFByb2dyYW0gKG5hbWUsIHZlcnQsIGZyYWcsIGZ1bmMpIHtcbiAgICAgICAgICBpZiAoIXByb2dyYW1zW25hbWVdKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgdmFyIHVuaWZvcm1zID0ge307XG4gICAgICAgICAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBjb21waWxlU2hhZGVyKHZlcnQsIGdsLlZFUlRFWF9TSEFERVIpKTtcbiAgICAgICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBjb21waWxlU2hhZGVyKGZyYWcsIGdsLkZSQUdNRU5UX1NIQURFUikpO1xuICAgICAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAgICAgICAgIHByb2dyYW1zW25hbWVdID0ge1xuICAgICAgICAgICAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogZnVuY3Rpb24gdHJhbnNhY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgICAgIGZ1bmMoe1xuICAgICAgICAgICAgICAgICAgc2V0VW5pZm9ybTogZnVuY3Rpb24gc2V0VW5pZm9ybSAodHlwZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIGxlbi0tID4gMCApIHZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDIgXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdW5pZm9ybUxvYyA9IHVuaWZvcm1zW25hbWVdIHx8ICh1bmlmb3Jtc1tuYW1lXSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGdsWyhcInVuaWZvcm1cIiArIHR5cGUpXS5hcHBseShnbCwgWyB1bmlmb3JtTG9jIF0uY29uY2F0KCB2YWx1ZXMgKSk7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobmFtZSwgc2l6ZSwgdXNhZ2UsIGluc3RhbmNpbmdEaXZpc29yLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJpYnV0ZXNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWY6IGdsLmNyZWF0ZUJ1ZmZlcigpLCAvLyBUT0RPIHNob3VsZCB3ZSBkZXN0cm95IG91ciBidWZmZXJzP1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhdHRyLmJ1Zik7XG4gICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0ci5sb2MsIHNpemUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHIubG9jKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyLmxvYywgaW5zdGFuY2luZ0Rpdmlzb3IpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShhdHRyLmxvYywgaW5zdGFuY2luZ0Rpdmlzb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhICE9PSBhdHRyLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgdXNhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcm9ncmFtc1tuYW1lXS50cmFuc2FjdGlvbihmdW5jKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHdpdGhUZXh0dXJlIChuYW1lLCBmdW5jKSB7XG4gICAgICAgICAgdGV4dHVyZVVuaXQrKztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gdGV4dHVyZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgICAgICAgICAgdGV4dHVyZSA9IHRleHR1cmVzW25hbWVdID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgICAgIGZ1bmModGV4dHVyZSwgdGV4dHVyZVVuaXQpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0ZXh0dXJlVW5pdC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIgKHRleHR1cmUsIHRleHR1cmVVbml0LCBmdW5jKSB7XG4gICAgICAgICAgdmFyIGZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgICBmcmFtZWJ1ZmZlclN0YWNrLnB1c2goZnJhbWVidWZmZXIpO1xuICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnVuYyhmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXJTdGFja1stLWZyYW1lYnVmZmVyU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ29udGV4dExvc3MgKCkge1xuICAgICAgICAgIGV4dGVuc2lvbnMgPSB7fTtcbiAgICAgICAgICBwcm9ncmFtcyA9IHt9O1xuICAgICAgICAgIHRleHR1cmVzID0ge307XG4gICAgICAgICAgdGV4dHVyZVVuaXQgPSAtMTtcbiAgICAgICAgICBmcmFtZWJ1ZmZlclN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjYWNoZS5zZXQoZ2wsIHdyYXBwZXIgPSB7XG4gICAgICAgICAgZ2w6IGdsLFxuICAgICAgICAgIGlzV2ViR0wyOiBpc1dlYkdMMixcbiAgICAgICAgICBnZXRFeHRlbnNpb246IGdldEV4dGVuc2lvbixcbiAgICAgICAgICB3aXRoUHJvZ3JhbTogd2l0aFByb2dyYW0sXG4gICAgICAgICAgd2l0aFRleHR1cmU6IHdpdGhUZXh0dXJlLFxuICAgICAgICAgIHdpdGhUZXh0dXJlRnJhbWVidWZmZXI6IHdpdGhUZXh0dXJlRnJhbWVidWZmZXIsXG4gICAgICAgICAgaGFuZGxlQ29udGV4dExvc3M6IGhhbmRsZUNvbnRleHRMb3NzLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKHdyYXBwZXIpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcmVuZGVySW1hZ2VEYXRhKGdsT3JDYW52YXMsIGltYWdlRGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIGZyYW1lYnVmZmVyKSB7XG4gICAgICBpZiAoIGNoYW5uZWxzID09PSB2b2lkIDAgKSBjaGFubmVscyA9IDE1O1xuICAgICAgaWYgKCBmcmFtZWJ1ZmZlciA9PT0gdm9pZCAwICkgZnJhbWVidWZmZXIgPSBudWxsO1xuXG4gICAgICB3aXRoV2ViR0xDb250ZXh0KGdsT3JDYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgICB2YXIgd2l0aFByb2dyYW0gPSByZWYud2l0aFByb2dyYW07XG4gICAgICAgIHZhciB3aXRoVGV4dHVyZSA9IHJlZi53aXRoVGV4dHVyZTtcblxuICAgICAgICB3aXRoVGV4dHVyZSgnY29weScsIGZ1bmN0aW9uICh0ZXgsIHRleFVuaXQpIHtcbiAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHdpZHRoLCBoZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltYWdlRGF0YSk7XG4gICAgICAgICAgd2l0aFByb2dyYW0oJ2NvcHknLCB2aWV3cG9ydFF1YWRWZXJ0ZXgsIGNvcHlUZXhGcmFnbWVudCwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIHNldFVuaWZvcm0gPSByZWYuc2V0VW5pZm9ybTtcbiAgICAgICAgICAgIHZhciBzZXRBdHRyaWJ1dGUgPSByZWYuc2V0QXR0cmlidXRlO1xuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoJ2FVVicsIDIsIGdsLlNUQVRJQ19EUkFXLCAwLCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAyLCAwLCAwLCAyXSkpO1xuICAgICAgICAgICAgc2V0VW5pZm9ybSgnMWknLCAnaW1hZ2UnLCB0ZXhVbml0KTtcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgfHwgbnVsbCk7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgIGdsLmNvbG9yTWFzayhjaGFubmVscyAmIDgsIGNoYW5uZWxzICYgNCwgY2hhbm5lbHMgJiAyLCBjaGFubmVscyAmIDEpO1xuICAgICAgICAgICAgZ2wudmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBnbC5zY2lzc29yKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6aW5nIGEgY2FudmFzIGNsZWFycyBpdHMgY29udGVudHM7IHRoaXMgdXRpbGl0eSBjb3BpZXMgdGhlIHByZXZpb3VzIGNvbnRlbnRzIG92ZXIuXG4gICAgICogQHBhcmFtIGNhbnZhc1xuICAgICAqIEBwYXJhbSBuZXdXaWR0aFxuICAgICAqIEBwYXJhbSBuZXdIZWlnaHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZyhjYW52YXMsIG5ld1dpZHRoLCBuZXdIZWlnaHQpIHtcbiAgICAgIHZhciB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgd2l0aFdlYkdMQ29udGV4dChjYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xuXG4gICAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICAgIHJlbmRlckltYWdlRGF0YShnbCwgZGF0YSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgd2ViZ2xVdGlscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgIHdpdGhXZWJHTENvbnRleHQ6IHdpdGhXZWJHTENvbnRleHQsXG4gICAgICByZW5kZXJJbWFnZURhdGE6IHJlbmRlckltYWdlRGF0YSxcbiAgICAgIHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nOiByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZ1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGUkMiAoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50KSB7XG4gICAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG5cbiAgICAgIHZhciB0ZXh0dXJlRGF0YSA9IG5ldyBVaW50OEFycmF5KHNkZldpZHRoICogc2RmSGVpZ2h0KTtcblxuICAgICAgdmFyIHZpZXdCb3hXaWR0aCA9IHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdO1xuICAgICAgdmFyIHZpZXdCb3hIZWlnaHQgPSB2aWV3Qm94WzNdIC0gdmlld0JveFsxXTtcblxuICAgICAgLy8gRGVjb21wb3NlIGFsbCBwYXRocyBpbnRvIHN0cmFpZ2h0IGxpbmUgc2VnbWVudHMgYW5kIGFkZCB0aGVtIHRvIGFuIGluZGV4XG4gICAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICAgIHBhdGhUb0xpbmVTZWdtZW50cyhwYXRoLCBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgeDE6IHgxLCB5MTogeTEsIHgyOiB4MiwgeTI6IHkyLFxuICAgICAgICAgIG1pblg6IE1hdGgubWluKHgxLCB4MiksXG4gICAgICAgICAgbWluWTogTWF0aC5taW4oeTEsIHkyKSxcbiAgICAgICAgICBtYXhYOiBNYXRoLm1heCh4MSwgeDIpLFxuICAgICAgICAgIG1heFk6IE1hdGgubWF4KHkxLCB5MilcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU29ydCBzZWdtZW50cyBieSBtYXhYLCB0aGlzIHdpbGwgbGV0IHVzIHNob3J0LWNpcmN1aXQgc29tZSBsb29wcyBiZWxvd1xuICAgICAgc2VnbWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5tYXhYIC0gYi5tYXhYOyB9KTtcblxuICAgICAgLy8gRm9yIGVhY2ggdGFyZ2V0IFNERiB0ZXhlbCwgZmluZCB0aGUgZGlzdGFuY2UgZnJvbSBpdHMgY2VudGVyIHRvIGl0cyBuZWFyZXN0IGxpbmUgc2VnbWVudCxcbiAgICAgIC8vIG1hcCB0aGF0IGRpc3RhbmNlIHRvIGFuIGFscGhhIHZhbHVlLCBhbmQgd3JpdGUgdGhhdCBhbHBoYSB0byB0aGUgdGV4ZWxcbiAgICAgIGZvciAodmFyIHNkZlggPSAwOyBzZGZYIDwgc2RmV2lkdGg7IHNkZlgrKykge1xuICAgICAgICBmb3IgKHZhciBzZGZZID0gMDsgc2RmWSA8IHNkZkhlaWdodDsgc2RmWSsrKSB7XG4gICAgICAgICAgdmFyIHNpZ25lZERpc3QgPSBmaW5kTmVhcmVzdFNpZ25lZERpc3RhbmNlKFxuICAgICAgICAgICAgdmlld0JveFswXSArIHZpZXdCb3hXaWR0aCAqIChzZGZYICsgMC41KSAvIHNkZldpZHRoLFxuICAgICAgICAgICAgdmlld0JveFsxXSArIHZpZXdCb3hIZWlnaHQgKiAoc2RmWSArIDAuNSkgLyBzZGZIZWlnaHRcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gVXNlIGFuIGV4cG9uZW50aWFsIHNjYWxlIHRvIGVuc3VyZSB0aGUgdGV4ZWxzIHZlcnkgbmVhciB0aGUgZ2x5cGggcGF0aCBoYXZlIGFkZXF1YXRlXG4gICAgICAgICAgLy8gcHJlY2lzaW9uLCB3aGlsZSBhbGxvd2luZyB0aGUgZGlzdGFuY2UgZmllbGQgdG8gY292ZXIgdGhlIGVudGlyZSB0ZXh0dXJlLCBnaXZlbiB0aGF0XG4gICAgICAgICAgLy8gdGhlcmUgYXJlIG9ubHkgOCBiaXRzIGF2YWlsYWJsZS4gRm9ybXVsYSB2aXN1YWxpemVkOiBodHRwczovL3d3dy5kZXNtb3MuY29tL2NhbGN1bGF0b3IvdWlhcTVhcWlhbVxuICAgICAgICAgIHZhciBhbHBoYSA9IE1hdGgucG93KCgxIC0gTWF0aC5hYnMoc2lnbmVkRGlzdCkgLyBtYXhEaXN0YW5jZSksIHNkZkV4cG9uZW50KSAvIDI7XG4gICAgICAgICAgaWYgKHNpZ25lZERpc3QgPCAwKSB7XG4gICAgICAgICAgICBhbHBoYSA9IDEgLSBhbHBoYTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbHBoYSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZChhbHBoYSAqIDI1NSkpKTsgLy9jbGFtcFxuICAgICAgICAgIHRleHR1cmVEYXRhW3NkZlkgKiBzZGZXaWR0aCArIHNkZlhdID0gYWxwaGE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRleHR1cmVEYXRhXG5cbiAgICAgIC8qKlxuICAgICAgICogRm9yIGEgZ2l2ZW4geC95LCBzZWFyY2ggdGhlIGluZGV4IGZvciB0aGUgY2xvc2VzdCBsaW5lIHNlZ21lbnQgYW5kIHJldHVyblxuICAgICAgICogaXRzIHNpZ25lZCBkaXN0YW5jZS4gTmVnYXRpdmUgPSBpbnNpZGUsIHBvc2l0aXZlID0gb3V0c2lkZSwgemVybyA9IG9uIGVkZ2VcbiAgICAgICAqIEBwYXJhbSB4XG4gICAgICAgKiBAcGFyYW0geVxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZmluZE5lYXJlc3RTaWduZWREaXN0YW5jZSAoeCwgeSkge1xuICAgICAgICB2YXIgY2xvc2VzdERpc3RTcSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgY2xvc2VzdERpc3QgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IgKHZhciBpID0gc2VnbWVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgdmFyIHNlZyA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgIGlmIChzZWcubWF4WCArIGNsb3Nlc3REaXN0IDw9IHgpIHsgYnJlYWsgfSAvL3NvcnRpbmcgYnkgbWF4WCBtZWFucyBubyBtb3JlIGNhbiBiZSBjbG9zZXIsIHNvIHdlIGNhbiBzaG9ydC1jaXJjdWl0XG4gICAgICAgICAgaWYgKHggKyBjbG9zZXN0RGlzdCA+IHNlZy5taW5YICYmIHkgLSBjbG9zZXN0RGlzdCA8IHNlZy5tYXhZICYmIHkgKyBjbG9zZXN0RGlzdCA+IHNlZy5taW5ZKSB7XG4gICAgICAgICAgICB2YXIgZGlzdFNxID0gYWJzU3F1YXJlRGlzdGFuY2VUb0xpbmVTZWdtZW50KHgsIHksIHNlZy54MSwgc2VnLnkxLCBzZWcueDIsIHNlZy55Mik7XG4gICAgICAgICAgICBpZiAoZGlzdFNxIDwgY2xvc2VzdERpc3RTcSkge1xuICAgICAgICAgICAgICBjbG9zZXN0RGlzdFNxID0gZGlzdFNxO1xuICAgICAgICAgICAgICBjbG9zZXN0RGlzdCA9IE1hdGguc3FydChjbG9zZXN0RGlzdFNxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGbGlwIHRvIG5lZ2F0aXZlIGRpc3RhbmNlIGlmIGluc2lkZSB0aGUgcG9seVxuICAgICAgICBpZiAoaXNQb2ludEluUG9seSh4LCB5KSkge1xuICAgICAgICAgIGNsb3Nlc3REaXN0ID0gLWNsb3Nlc3REaXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9zZXN0RGlzdFxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBsaWVzIGluc2lkZSBvciBvdXRzaWRlIHRoZSBnbHlwaC4gVXNlcyBhIHNpbXBsZVxuICAgICAgICogd2luZGluZy1udW1iZXIgcmF5IGNhc3RpbmcgYWxnb3JpdGhtIHVzaW5nIGEgcmF5IHBvaW50aW5nIGVhc3QgZnJvbSB0aGUgcG9pbnQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGlzUG9pbnRJblBvbHkgKHgsIHkpIHtcbiAgICAgICAgdmFyIHdpbmRpbmcgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gc2VnbWVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgdmFyIHNlZyA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgIGlmIChzZWcubWF4WCA8PSB4KSB7IGJyZWFrIH0gLy9zb3J0aW5nIGJ5IG1heFggbWVhbnMgbm8gbW9yZSBjYW4gY3Jvc3MsIHNvIHdlIGNhbiBzaG9ydC1jaXJjdWl0XG4gICAgICAgICAgdmFyIGludGVyc2VjdHMgPSAoKHNlZy55MSA+IHkpICE9PSAoc2VnLnkyID4geSkpICYmICh4IDwgKHNlZy54MiAtIHNlZy54MSkgKiAoeSAtIHNlZy55MSkgLyAoc2VnLnkyIC0gc2VnLnkxKSArIHNlZy54MSk7XG4gICAgICAgICAgaWYgKGludGVyc2VjdHMpIHtcbiAgICAgICAgICAgIHdpbmRpbmcgKz0gc2VnLnkxIDwgc2VnLnkyID8gMSA6IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2luZGluZyAhPT0gMFxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0NhbnZhcyQyKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICAgIGlmICggY2hhbm5lbCA9PT0gdm9pZCAwICkgY2hhbm5lbCA9IDA7XG5cbiAgICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyJDEoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBjYW52YXMsIG51bGwsIHgsIHksIGNoYW5uZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyJDEgKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgZ2xPckNhbnZhcywgZnJhbWVidWZmZXIsIHgsIHksIGNoYW5uZWwpIHtcbiAgICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgICBpZiAoIHkgPT09IHZvaWQgMCApIHkgPSAwO1xuICAgICAgaWYgKCBjaGFubmVsID09PSB2b2lkIDAgKSBjaGFubmVsID0gMDtcblxuICAgICAgdmFyIGRhdGEgPSBnZW5lcmF0ZSQyKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCk7XG4gICAgICAvLyBFeHBhbmQgc2luZ2xlLWNoYW5uZWwgZGF0YSB0byByYmdhXG4gICAgICB2YXIgcmdiYURhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCAqIDQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJnYmFEYXRhW2kgKiA0ICsgY2hhbm5lbF0gPSBkYXRhW2ldO1xuICAgICAgfVxuICAgICAgcmVuZGVySW1hZ2VEYXRhKGdsT3JDYW52YXMsIHJnYmFEYXRhLCB4LCB5LCBzZGZXaWR0aCwgc2RmSGVpZ2h0LCAxIDw8ICgzIC0gY2hhbm5lbCksIGZyYW1lYnVmZmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBsaW5lIHNlZ21lbnQgYXQgY2xvc2VzdCBhcHByb2FjaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFic1NxdWFyZURpc3RhbmNlVG9MaW5lU2VnbWVudCAoeCwgeSwgbGluZVgwLCBsaW5lWTAsIGxpbmVYMSwgbGluZVkxKSB7XG4gICAgICB2YXIgbGR4ID0gbGluZVgxIC0gbGluZVgwO1xuICAgICAgdmFyIGxkeSA9IGxpbmVZMSAtIGxpbmVZMDtcbiAgICAgIHZhciBsZW5ndGhTcSA9IGxkeCAqIGxkeCArIGxkeSAqIGxkeTtcbiAgICAgIHZhciB0ID0gbGVuZ3RoU3EgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoKHggLSBsaW5lWDApICogbGR4ICsgKHkgLSBsaW5lWTApICogbGR5KSAvIGxlbmd0aFNxKSkgOiAwO1xuICAgICAgdmFyIGR4ID0geCAtIChsaW5lWDAgKyB0ICogbGR4KTtcbiAgICAgIHZhciBkeSA9IHkgLSAobGluZVkwICsgdCAqIGxkeSk7XG4gICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHlcbiAgICB9XG5cbiAgICB2YXIgamF2YXNjcmlwdCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgIGdlbmVyYXRlOiBnZW5lcmF0ZSQyLFxuICAgICAgZ2VuZXJhdGVJbnRvQ2FudmFzOiBnZW5lcmF0ZUludG9DYW52YXMkMixcbiAgICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyOiBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciQxXG4gICAgfSk7XG5cbiAgICB2YXIgbWFpblZlcnRleCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3VuaWZvcm0gdmVjNCB1R2x5cGhCb3VuZHM7YXR0cmlidXRlIHZlYzIgYVVWO2F0dHJpYnV0ZSB2ZWM0IGFMaW5lU2VnbWVudDt2YXJ5aW5nIHZlYzQgdkxpbmVTZWdtZW50O3ZhcnlpbmcgdmVjMiB2R2x5cGhYWTt2b2lkIG1haW4oKXt2TGluZVNlZ21lbnQ9YUxpbmVTZWdtZW50O3ZHbHlwaFhZPW1peCh1R2x5cGhCb3VuZHMueHksdUdseXBoQm91bmRzLnp3LGFVVik7Z2xfUG9zaXRpb249dmVjNChtaXgodmVjMigtMS4wKSx2ZWMyKDEuMCksYVVWKSwwLjAsMS4wKTt9XCI7XG5cbiAgICB2YXIgbWFpbkZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSB2ZWM0IHVHbHlwaEJvdW5kczt1bmlmb3JtIGZsb2F0IHVNYXhEaXN0YW5jZTt1bmlmb3JtIGZsb2F0IHVFeHBvbmVudDt2YXJ5aW5nIHZlYzQgdkxpbmVTZWdtZW50O3ZhcnlpbmcgdmVjMiB2R2x5cGhYWTtmbG9hdCBhYnNEaXN0VG9TZWdtZW50KHZlYzIgcG9pbnQsdmVjMiBsaW5lQSx2ZWMyIGxpbmVCKXt2ZWMyIGxpbmVEaXI9bGluZUItbGluZUE7ZmxvYXQgbGVuU3E9ZG90KGxpbmVEaXIsbGluZURpcik7ZmxvYXQgdD1sZW5TcT09MC4wID8gMC4wIDogY2xhbXAoZG90KHBvaW50LWxpbmVBLGxpbmVEaXIpL2xlblNxLDAuMCwxLjApO3ZlYzIgbGluZVB0PWxpbmVBK3QqbGluZURpcjtyZXR1cm4gZGlzdGFuY2UocG9pbnQsbGluZVB0KTt9dm9pZCBtYWluKCl7dmVjNCBzZWc9dkxpbmVTZWdtZW50O3ZlYzIgcD12R2x5cGhYWTtmbG9hdCBkaXN0PWFic0Rpc3RUb1NlZ21lbnQocCxzZWcueHksc2VnLnp3KTtmbG9hdCB2YWw9cG93KDEuMC1jbGFtcChkaXN0L3VNYXhEaXN0YW5jZSwwLjAsMS4wKSx1RXhwb25lbnQpKjAuNTtib29sIGNyb3NzaW5nPShzZWcueT5wLnkhPXNlZy53PnAueSkmJihwLng8KHNlZy56LXNlZy54KSoocC55LXNlZy55KS8oc2VnLnctc2VnLnkpK3NlZy54KTtib29sIGNyb3NzaW5nVXA9Y3Jvc3NpbmcmJnZMaW5lU2VnbWVudC55PHZMaW5lU2VnbWVudC53O2dsX0ZyYWdDb2xvcj12ZWM0KGNyb3NzaW5nVXAgPyAxLjAvMjU1LjAgOiAwLjAsY3Jvc3NpbmcmJiFjcm9zc2luZ1VwID8gMS4wLzI1NS4wIDogMC4wLDAuMCx2YWwpO31cIjtcblxuICAgIHZhciBwb3N0RnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDt1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7dmFyeWluZyB2ZWMyIHZVVjt2b2lkIG1haW4oKXt2ZWM0IGNvbG9yPXRleHR1cmUyRCh0ZXgsdlVWKTtib29sIGluc2lkZT1jb2xvci5yIT1jb2xvci5nO2Zsb2F0IHZhbD1pbnNpZGUgPyAxLjAtY29sb3IuYSA6IGNvbG9yLmE7Z2xfRnJhZ0NvbG9yPXZlYzQodmFsKTt9XCI7XG5cbiAgICAvLyBTaW5nbGUgdHJpYW5nbGUgY292ZXJpbmcgdmlld3BvcnRcbiAgICB2YXIgdmlld3BvcnRVVnMgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAyLCAwLCAwLCAyXSk7XG5cbiAgICB2YXIgaW1wbGljaXRDb250ZXh0ID0gbnVsbDtcbiAgICB2YXIgaXNUZXN0aW5nU3VwcG9ydCA9IGZhbHNlO1xuICAgIHZhciBOVUxMX09CSkVDVCA9IHt9O1xuICAgIHZhciBzdXBwb3J0QnlDYW52YXMgPSBuZXcgV2Vha01hcCgpOyAvLyBjYW52YXMgLT4gYm9vbFxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTdXBwb3J0IChnbE9yQ2FudmFzKSB7XG4gICAgICBpZiAoIWlzVGVzdGluZ1N1cHBvcnQgJiYgIWlzU3VwcG9ydGVkKGdsT3JDYW52YXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZSQxIChzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGdsT3JDYW52YXMpIHtcbiAgICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICAgIGlmICggZ2xPckNhbnZhcyA9PT0gdm9pZCAwICkgZ2xPckNhbnZhcyA9IG51bGw7XG5cbiAgICAgIGlmICghZ2xPckNhbnZhcykge1xuICAgICAgICBnbE9yQ2FudmFzID0gaW1wbGljaXRDb250ZXh0O1xuICAgICAgICBpZiAoIWdsT3JDYW52YXMpIHtcbiAgICAgICAgICB2YXIgY2FudmFzID0gdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpXG4gICAgICAgICAgICA6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2Zmc2NyZWVuQ2FudmFzIG9yIERPTSBjYW52YXMgbm90IHN1cHBvcnRlZCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIGdsT3JDYW52YXMgPSBpbXBsaWNpdENvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCB7IGRlcHRoOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YWxpZGF0ZVN1cHBvcnQoZ2xPckNhbnZhcyk7XG5cbiAgICAgIHZhciByZ2JhRGF0YSA9IG5ldyBVaW50OEFycmF5KHNkZldpZHRoICogc2RmSGVpZ2h0ICogNCk7IC8vbm90IFVpbnQ4Q2xhbXBlZEFycmF5LCBjdXogU2FmYXJpXG5cbiAgICAgIC8vIFJlbmRlciBpbnRvIGEgYmFja2dyb3VuZCB0ZXh0dXJlIGZyYW1lYnVmZmVyXG4gICAgICB3aXRoV2ViR0xDb250ZXh0KGdsT3JDYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgICB2YXIgd2l0aFRleHR1cmUgPSByZWYud2l0aFRleHR1cmU7XG4gICAgICAgIHZhciB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyID0gcmVmLndpdGhUZXh0dXJlRnJhbWVidWZmZXI7XG5cbiAgICAgICAgd2l0aFRleHR1cmUoJ3JlYWRhYmxlJywgZnVuY3Rpb24gKHRleHR1cmUsIHRleHR1cmVVbml0KSB7XG4gICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBzZGZXaWR0aCwgc2RmSGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblxuICAgICAgICAgIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIodGV4dHVyZSwgdGV4dHVyZVVuaXQsIGZ1bmN0aW9uIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIoXG4gICAgICAgICAgICAgIHNkZldpZHRoLFxuICAgICAgICAgICAgICBzZGZIZWlnaHQsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIHZpZXdCb3gsXG4gICAgICAgICAgICAgIG1heERpc3RhbmNlLFxuICAgICAgICAgICAgICBzZGZFeHBvbmVudCxcbiAgICAgICAgICAgICAgZ2wsXG4gICAgICAgICAgICAgIGZyYW1lYnVmZmVyLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAwIC8vIHJlZCBjaGFubmVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZ2wucmVhZFBpeGVscygwLCAwLCBzZGZXaWR0aCwgc2RmSGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCByZ2JhRGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRocm93IGF3YXkgYWxsIGJ1dCB0aGUgcmVkIGNoYW5uZWxcbiAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoc2RmV2lkdGggKiBzZGZIZWlnaHQpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgcmdiYURhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtqKytdID0gcmdiYURhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVJbnRvQ2FudmFzJDEoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpIHtcbiAgICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgICBpZiAoIHkgPT09IHZvaWQgMCApIHkgPSAwO1xuICAgICAgaWYgKCBjaGFubmVsID09PSB2b2lkIDAgKSBjaGFubmVsID0gMDtcblxuICAgICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBjYW52YXMsIG51bGwsIHgsIHksIGNoYW5uZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyIChzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGdsT3JDYW52YXMsIGZyYW1lYnVmZmVyLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICAgIGlmICggY2hhbm5lbCA9PT0gdm9pZCAwICkgY2hhbm5lbCA9IDA7XG5cbiAgICAgIC8vIFZlcmlmeSBzdXBwb3J0XG4gICAgICB2YWxpZGF0ZVN1cHBvcnQoZ2xPckNhbnZhcyk7XG5cbiAgICAgIC8vIENvbXB1dGUgcGF0aCBzZWdtZW50c1xuICAgICAgdmFyIGxpbmVTZWdtZW50Q29vcmRzID0gW107XG4gICAgICBwYXRoVG9MaW5lU2VnbWVudHMocGF0aCwgZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIGxpbmVTZWdtZW50Q29vcmRzLnB1c2goeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgfSk7XG4gICAgICBsaW5lU2VnbWVudENvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkobGluZVNlZ21lbnRDb29yZHMpO1xuXG4gICAgICB3aXRoV2ViR0xDb250ZXh0KGdsT3JDYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgICB2YXIgaXNXZWJHTDIgPSByZWYuaXNXZWJHTDI7XG4gICAgICAgIHZhciBnZXRFeHRlbnNpb24gPSByZWYuZ2V0RXh0ZW5zaW9uO1xuICAgICAgICB2YXIgd2l0aFByb2dyYW0gPSByZWYud2l0aFByb2dyYW07XG4gICAgICAgIHZhciB3aXRoVGV4dHVyZSA9IHJlZi53aXRoVGV4dHVyZTtcbiAgICAgICAgdmFyIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIgPSByZWYud2l0aFRleHR1cmVGcmFtZWJ1ZmZlcjtcbiAgICAgICAgdmFyIGhhbmRsZUNvbnRleHRMb3NzID0gcmVmLmhhbmRsZUNvbnRleHRMb3NzO1xuXG4gICAgICAgIHdpdGhUZXh0dXJlKCdyYXdEaXN0YW5jZXMnLCBmdW5jdGlvbiAoaW50ZXJtZWRpYXRlVGV4dHVyZSwgaW50ZXJtZWRpYXRlVGV4dHVyZVVuaXQpIHtcbiAgICAgICAgICBpZiAoc2RmV2lkdGggIT09IGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RXaWR0aCB8fCBzZGZIZWlnaHQgIT09IGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RIZWlnaHQpIHtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsXG4gICAgICAgICAgICAgIGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RXaWR0aCA9IHNkZldpZHRoLFxuICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVUZXh0dXJlLl9sYXN0SGVpZ2h0ID0gc2RmSGVpZ2h0LFxuICAgICAgICAgICAgICAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVuc2lnbmVkIGRpc3RhbmNlIHBhc3NcbiAgICAgICAgICB3aXRoUHJvZ3JhbSgnbWFpbicsIG1haW5WZXJ0ZXgsIG1haW5GcmFnbWVudCwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIHNldEF0dHJpYnV0ZSA9IHJlZi5zZXRBdHRyaWJ1dGU7XG4gICAgICAgICAgICB2YXIgc2V0VW5pZm9ybSA9IHJlZi5zZXRVbmlmb3JtO1xuXG4gICAgICAgICAgICAvLyBJbml0IGV4dGVuc2lvbnNcbiAgICAgICAgICAgIHZhciBpbnN0YW5jaW5nRXh0ZW5zaW9uID0gIWlzV2ViR0wyICYmIGdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuICAgICAgICAgICAgdmFyIGJsZW5kTWluTWF4RXh0ZW5zaW9uID0gIWlzV2ViR0wyICYmIGdldEV4dGVuc2lvbignRVhUX2JsZW5kX21pbm1heCcpO1xuXG4gICAgICAgICAgICAvLyBJbml0L3VwZGF0ZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoJ2FVVicsIDIsIGdsLlNUQVRJQ19EUkFXLCAwLCB2aWV3cG9ydFVWcyk7XG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoJ2FMaW5lU2VnbWVudCcsIDQsIGdsLkRZTkFNSUNfRFJBVywgMSwgbGluZVNlZ21lbnRDb29yZHMpO1xuXG4gICAgICAgICAgICAvLyBJbml0L3VwZGF0ZSB1bmlmb3Jtc1xuICAgICAgICAgICAgc2V0VW5pZm9ybS5hcHBseSh2b2lkIDAsIFsgJzRmJywgJ3VHbHlwaEJvdW5kcycgXS5jb25jYXQoIHZpZXdCb3ggKSk7XG4gICAgICAgICAgICBzZXRVbmlmb3JtKCcxZicsICd1TWF4RGlzdGFuY2UnLCBtYXhEaXN0YW5jZSk7XG4gICAgICAgICAgICBzZXRVbmlmb3JtKCcxZicsICd1RXhwb25lbnQnLCBzZGZFeHBvbmVudCk7XG5cbiAgICAgICAgICAgIC8vIFJlbmRlciBpbml0aWFsIHVuc2lnbmVkIGRpc3RhbmNlIC8gd2luZGluZyBudW1iZXIgaW5mbyB0byBhIHRleHR1cmVcbiAgICAgICAgICAgIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIoaW50ZXJtZWRpYXRlVGV4dHVyZSwgaW50ZXJtZWRpYXRlVGV4dHVyZVVuaXQsIGZ1bmN0aW9uIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQpO1xuICAgICAgICAgICAgICBnbC5zY2lzc29yKDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQpO1xuICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xuICAgICAgICAgICAgICAvLyBSZWQrR3JlZW4gY2hhbm5lbHMgYXJlIGluY3JlbWVudGVkIChGVU5DX0FERCkgZm9yIHNlZ21lbnQtcmF5IGNyb3NzaW5ncyB0byBnaXZlIGEgXCJ3aW5kaW5nIG51bWJlclwiLlxuICAgICAgICAgICAgICAvLyBBbHBoYSBob2xkcyB0aGUgY2xvc2VzdCAoTUFYKSB1bnNpZ25lZCBkaXN0YW5jZS5cbiAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGdsLkZVTkNfQURELCBpc1dlYkdMMiA/IGdsLk1BWCA6IGJsZW5kTWluTWF4RXh0ZW5zaW9uLk1BWF9FWFQpO1xuICAgICAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgICAgICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5c0luc3RhbmNlZChnbC5UUklBTkdMRVMsIDAsIDMsIGxpbmVTZWdtZW50Q29vcmRzLmxlbmd0aCAvIDQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RhbmNpbmdFeHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKGdsLlRSSUFOR0xFUywgMCwgMywgbGluZVNlZ21lbnRDb29yZHMubGVuZ3RoIC8gNCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRGVidWdcbiAgICAgICAgICAgICAgLy8gY29uc3QgZGVidWcgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCAqIDQpXG4gICAgICAgICAgICAgIC8vIGdsLnJlYWRQaXhlbHMoMCwgMCwgc2RmV2lkdGgsIHNkZkhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGVidWcpXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbnRlcm1lZGlhdGUgdGV4dHVyZSBkYXRhOiAnLCBkZWJ1ZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gVXNlIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgdGV4dHVyZSB0byBhcHBseSBpbnNpZGUvb3V0c2lkZSBhbmQgd3JpdGUgdG8gdGhlIG91dHB1dCBmcmFtZWJ1ZmZlciByZWN0K2NoYW5uZWwuXG4gICAgICAgICAgd2l0aFByb2dyYW0oJ3Bvc3QnLCB2aWV3cG9ydFF1YWRWZXJ0ZXgsIHBvc3RGcmFnbWVudCwgZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICAgIHByb2dyYW0uc2V0QXR0cmlidXRlKCdhVVYnLCAyLCBnbC5TVEFUSUNfRFJBVywgMCwgdmlld3BvcnRVVnMpO1xuICAgICAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtKCcxaScsICd0ZXgnLCBpbnRlcm1lZGlhdGVUZXh0dXJlVW5pdCk7XG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuY29sb3JNYXNrKGNoYW5uZWwgPT09IDAsIGNoYW5uZWwgPT09IDEsIGNoYW5uZWwgPT09IDIsIGNoYW5uZWwgPT09IDMpO1xuICAgICAgICAgICAgZ2wudmlld3BvcnQoeCwgeSwgc2RmV2lkdGgsIHNkZkhlaWdodCk7XG4gICAgICAgICAgICBnbC5zY2lzc29yKHgsIHksIHNkZldpZHRoLCBzZGZIZWlnaHQpO1xuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBIYW5kbGUgY29udGV4dCBsb3NzIG9jY3VycmluZyBkdXJpbmcgYW55IG9mIHRoZSBhYm92ZSBjYWxsc1xuICAgICAgICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpKSB7XG4gICAgICAgICAgaGFuZGxlQ29udGV4dExvc3MoKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dlYmdsIGNvbnRleHQgbG9zdCcpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3VwcG9ydGVkIChnbE9yQ2FudmFzKSB7XG4gICAgICB2YXIga2V5ID0gKCFnbE9yQ2FudmFzIHx8IGdsT3JDYW52YXMgPT09IGltcGxpY2l0Q29udGV4dCkgPyBOVUxMX09CSkVDVCA6IChnbE9yQ2FudmFzLmNhbnZhcyB8fCBnbE9yQ2FudmFzKTtcbiAgICAgIHZhciBzdXBwb3J0ZWQgPSBzdXBwb3J0QnlDYW52YXMuZ2V0KGtleSk7XG4gICAgICBpZiAoc3VwcG9ydGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaXNUZXN0aW5nU3VwcG9ydCA9IHRydWU7XG4gICAgICAgIHZhciBmYWlsUmVhc29uID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBTaW5jZSB3ZSBjYW4ndCBkZXRlY3QgYWxsIGZhaWx1cmUgbW9kZXMgdXAgZnJvbnQsIGxldCdzIGp1c3QgZG8gYSB0cmlhbCBydW4gb2YgYVxuICAgICAgICAgIC8vIHNpbXBsZSBwYXRoIGFuZCBjb21wYXJlIHdoYXQgd2UgZ2V0IGJhY2sgdG8gdGhlIGNvcnJlY3QgZXhwZWN0ZWQgcmVzdWx0LiBUaGlzIHdpbGxcbiAgICAgICAgICAvLyBhbHNvIHNlcnZlIHRvIHByaW1lIHRoZSBzaGFkZXIgY29tcGlsYXRpb24uXG4gICAgICAgICAgdmFyIGV4cGVjdGVkUmVzdWx0ID0gW1xuICAgICAgICAgICAgOTcsIDEwNiwgOTcsIDYxLFxuICAgICAgICAgICAgOTksIDEzNywgMTE4LCA4MCxcbiAgICAgICAgICAgIDgwLCAxMTgsIDEzNywgOTksXG4gICAgICAgICAgICA2MSwgOTcsIDEwNiwgOTdcbiAgICAgICAgICBdO1xuICAgICAgICAgIHZhciB0ZXN0UmVzdWx0ID0gZ2VuZXJhdGUkMShcbiAgICAgICAgICAgIDQsXG4gICAgICAgICAgICA0LFxuICAgICAgICAgICAgJ004LDhMMTYsOEwyNCwyNEwxNiwyNFonLFxuICAgICAgICAgICAgWzAsIDAsIDMyLCAzMl0sXG4gICAgICAgICAgICAyNCxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBnbE9yQ2FudmFzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdXBwb3J0ZWQgPSB0ZXN0UmVzdWx0ICYmIGV4cGVjdGVkUmVzdWx0Lmxlbmd0aCA9PT0gdGVzdFJlc3VsdC5sZW5ndGggJiZcbiAgICAgICAgICAgIHRlc3RSZXN1bHQuZXZlcnkoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gdmFsID09PSBleHBlY3RlZFJlc3VsdFtpXTsgfSk7XG4gICAgICAgICAgaWYgKCFzdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGZhaWxSZWFzb24gPSAnYmFkIHRyaWFsIHJ1biByZXN1bHRzJztcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhleHBlY3RlZFJlc3VsdCwgdGVzdFJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBUT0RPIGlmIGl0IHRocmV3IGR1ZSB0byB3ZWJnbCBjb250ZXh0IGxvc3MsIHNob3VsZCB3ZSBtYXliZSBsZWF2ZSBpc1N1cHBvcnRlZCBhcyBudWxsIGFuZCB0cnkgYWdhaW4gbGF0ZXI/XG4gICAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgZmFpbFJlYXNvbiA9IGVyci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmYWlsUmVhc29uKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdXZWJHTCBTREYgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkOicsIGZhaWxSZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIGlzVGVzdGluZ1N1cHBvcnQgPSBmYWxzZTtcbiAgICAgICAgc3VwcG9ydEJ5Q2FudmFzLnNldChrZXksIHN1cHBvcnRlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwcG9ydGVkXG4gICAgfVxuXG4gICAgdmFyIHdlYmdsID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgZ2VuZXJhdGU6IGdlbmVyYXRlJDEsXG4gICAgICBnZW5lcmF0ZUludG9DYW52YXM6IGdlbmVyYXRlSW50b0NhbnZhcyQxLFxuICAgICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXI6IGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyLFxuICAgICAgaXNTdXBwb3J0ZWQ6IGlzU3VwcG9ydGVkXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBTREYgdGV4dHVyZSBpbWFnZSBmb3IgYSAyRCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNkZldpZHRoIC0gd2lkdGggb2YgdGhlIFNERiBvdXRwdXQgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZGZIZWlnaHQgLSBoZWlnaHQgb2YgdGhlIFNERiBvdXRwdXQgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gYW4gU1ZHLWxpa2UgcGF0aCBzdHJpbmcgZGVzY3JpYmluZyB0aGUgZ2x5cGg7IHNob3VsZCBvbmx5IGNvbnRhaW4gY29tbWFuZHM6IE0vTC9RL0MvWi5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB2aWV3Qm94IC0gW21pblgsIG1pblksIG1heFgsIG1heFldIGluIGZvbnQgdW5pdHMgYWxpZ25pbmcgd2l0aCB0aGUgdGV4dHVyZSdzIGVkZ2VzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhEaXN0YW5jZSAtIHRoZSBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGdseXBoIHBhdGggaW4gZm9udCB1bml0cyB0aGF0IHdpbGwgYmUgZW5jb2RlZDsgZGVmYXVsdHNcbiAgICAgKiAgICAgICAgdG8gaGFsZiB0aGUgbWF4aW11bSB2aWV3Qm94IGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NkZkV4cG9uZW50XSAtIHNwZWNpZmllcyBhbiBleHBvbmVudCBmb3IgZW5jb2RpbmcgdGhlIFNERidzIGRpc3RhbmNlIHZhbHVlczsgaGlnaGVyIGV4cG9uZW50c1xuICAgICAqICAgICAgICB3aWxsIGdpdmUgZ3JlYXRlciBwcmVjaXNpb24gbmVhcmVyIHRoZSBnbHlwaCdzIHBhdGguXG4gICAgICogQHJldHVybiB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZShcbiAgICAgIHNkZldpZHRoLFxuICAgICAgc2RmSGVpZ2h0LFxuICAgICAgcGF0aCxcbiAgICAgIHZpZXdCb3gsXG4gICAgICBtYXhEaXN0YW5jZSxcbiAgICAgIHNkZkV4cG9uZW50XG4gICAgKSB7XG4gICAgICBpZiAoIG1heERpc3RhbmNlID09PSB2b2lkIDAgKSBtYXhEaXN0YW5jZSA9IE1hdGgubWF4KHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdLCB2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgLyAyO1xuICAgICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGUkMS5hcHBseSh3ZWJnbCwgYXJndW1lbnRzKVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnV2ViR0wgU0RGIGdlbmVyYXRpb24gZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gSlMnLCBlKTtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlJDIuYXBwbHkoamF2YXNjcmlwdCwgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIFNERiB0ZXh0dXJlIGltYWdlIGZvciBhIDJEIHBhdGgsIGluc2VydGluZyB0aGUgcmVzdWx0IGludG8gYSBXZWJHTCBgY2FudmFzYCBhdCBhIGdpdmVuIHgveSBwb3NpdGlvblxuICAgICAqIGFuZCBjb2xvciBjaGFubmVsLiBUaGlzIGlzIGdlbmVyYWxseSBtdWNoIGZhc3RlciB0aGFuIGNhbGxpbmcgYGdlbmVyYXRlYCBiZWNhdXNlIGl0IGRvZXMgbm90IHJlcXVpcmUgcmVhZGluZyBwaXhlbHNcbiAgICAgKiBiYWNrIGZyb20gdGhlIEdQVS0+Q1BVIC0tIHRoZSBgY2FudmFzYCBjYW4gYmUgdXNlZCBkaXJlY3RseSBhcyBhIFdlYkdMIHRleHR1cmUgaW1hZ2UsIHNvIGl0IGFsbCBzdGF5cyBvbiB0aGUgR1BVLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNkZldpZHRoIC0gd2lkdGggb2YgdGhlIFNERiBvdXRwdXQgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzZGZIZWlnaHQgLSBoZWlnaHQgb2YgdGhlIFNERiBvdXRwdXQgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gYW4gU1ZHLWxpa2UgcGF0aCBzdHJpbmcgZGVzY3JpYmluZyB0aGUgZ2x5cGg7IHNob3VsZCBvbmx5IGNvbnRhaW4gY29tbWFuZHM6IE0vTC9RL0MvWi5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB2aWV3Qm94IC0gW21pblgsIG1pblksIG1heFgsIG1heFldIGluIGZvbnQgdW5pdHMgYWxpZ25pbmcgd2l0aCB0aGUgdGV4dHVyZSdzIGVkZ2VzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhEaXN0YW5jZSAtIHRoZSBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGdseXBoIHBhdGggaW4gZm9udCB1bml0cyB0aGF0IHdpbGwgYmUgZW5jb2RlZDsgZGVmYXVsdHNcbiAgICAgKiAgICAgICAgdG8gaGFsZiB0aGUgbWF4aW11bSB2aWV3Qm94IGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NkZkV4cG9uZW50XSAtIHNwZWNpZmllcyBhbiBleHBvbmVudCBmb3IgZW5jb2RpbmcgdGhlIFNERidzIGRpc3RhbmNlIHZhbHVlczsgaGlnaGVyIGV4cG9uZW50c1xuICAgICAqICAgICAgICB3aWxsIGdpdmUgZ3JlYXRlciBwcmVjaXNpb24gbmVhcmVyIHRoZSBnbHlwaCdzIHBhdGguXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxPZmZzY3JlZW5DYW52YXN9IGNhbnZhcyAtIGEgV2ViR0wtZW5hYmxlZCBjYW52YXMgaW50byB3aGljaCB0aGUgU0RGIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICogICAgICAgIE9ubHkgdGhlIHJlbGV2YW50IHJlY3QvY2hhbm5lbCB3aWxsIGJlIG1vZGlmaWVkLCB0aGUgcmVzdCB3aWxsIGJlIHByZXNlcnZlZC4gVG8gYXZvaWQgdW5wcmVkaWN0YWJsZSByZXN1bHRzXG4gICAgICogICAgICAgIGR1ZSB0byBzaGFyZWQgR0wgY29udGV4dCBzdGF0ZSwgdGhpcyBjYW52YXMgc2hvdWxkIGJlIGRlZGljYXRlZCB0byB1c2UgYnkgdGhpcyBsaWJyYXJ5IGFsb25lLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggcG9zaXRpb24gYXQgd2hpY2ggdG8gcmVuZGVyIHRoZSBTREYuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBwb3NpdGlvbiBhdCB3aGljaCB0byByZW5kZXIgdGhlIFNERi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbCAtIHRoZSBjb2xvciBjaGFubmVsIGluZGV4ICgwLTQpIGludG8gd2hpY2ggdGhlIFNERiB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVJbnRvQ2FudmFzKFxuICAgICAgc2RmV2lkdGgsXG4gICAgICBzZGZIZWlnaHQsXG4gICAgICBwYXRoLFxuICAgICAgdmlld0JveCxcbiAgICAgIG1heERpc3RhbmNlLFxuICAgICAgc2RmRXhwb25lbnQsXG4gICAgICBjYW52YXMsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNoYW5uZWxcbiAgICApIHtcbiAgICAgIGlmICggbWF4RGlzdGFuY2UgPT09IHZvaWQgMCApIG1heERpc3RhbmNlID0gTWF0aC5tYXgodmlld0JveFsyXSAtIHZpZXdCb3hbMF0sIHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAvIDI7XG4gICAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICAgIGlmICggY2hhbm5lbCA9PT0gdm9pZCAwICkgY2hhbm5lbCA9IDA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUludG9DYW52YXMkMS5hcHBseSh3ZWJnbCwgYXJndW1lbnRzKVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnV2ViR0wgU0RGIGdlbmVyYXRpb24gZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gSlMnLCBlKTtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlSW50b0NhbnZhcyQyLmFwcGx5KGphdmFzY3JpcHQsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzLmZvckVhY2hQYXRoQ29tbWFuZCA9IGZvckVhY2hQYXRoQ29tbWFuZDtcbiAgICBleHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XG4gICAgZXhwb3J0cy5nZW5lcmF0ZUludG9DYW52YXMgPSBnZW5lcmF0ZUludG9DYW52YXM7XG4gICAgZXhwb3J0cy5qYXZhc2NyaXB0ID0gamF2YXNjcmlwdDtcbiAgICBleHBvcnRzLnBhdGhUb0xpbmVTZWdtZW50cyA9IHBhdGhUb0xpbmVTZWdtZW50cztcbiAgICBleHBvcnRzLndlYmdsID0gd2ViZ2w7XG4gICAgZXhwb3J0cy53ZWJnbFV0aWxzID0gd2ViZ2xVdGlscztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbiAgICByZXR1cm4gZXhwb3J0cztcblxuICB9KHt9KSk7XG4gIHJldHVybiBleHBvcnRzXG4gIH1cblxuICByZXR1cm4gU0RGR2VuZXJhdG9yO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.js\n");

/***/ })

};
;