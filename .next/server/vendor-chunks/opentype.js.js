/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/opentype.js";
exports.ids = ["vendor-chunks/opentype.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/opentype.js/dist/opentype.js":
/*!***************************************************!*\
  !*** ./node_modules/opentype.js/dist/opentype.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/**\n * https://opentype.js.org v1.3.4 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens\n */\n\n(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, (function (exports) { 'use strict';\n\n\t/*! https://mths.be/codepointat v0.2.0 by @mathias */\n\tif (!String.prototype.codePointAt) {\n\t\t(function() {\n\t\t\tvar defineProperty = (function() {\n\t\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\t\ttry {\n\t\t\t\t\tvar object = {};\n\t\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t\t} catch(error) {}\n\t\t\t\treturn result;\n\t\t\t}());\n\t\t\tvar codePointAt = function(position) {\n\t\t\t\tif (this == null) {\n\t\t\t\t\tthrow TypeError();\n\t\t\t\t}\n\t\t\t\tvar string = String(this);\n\t\t\t\tvar size = string.length;\n\t\t\t\t// `ToInteger`\n\t\t\t\tvar index = position ? Number(position) : 0;\n\t\t\t\tif (index != index) { // better `isNaN`\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t\t// Account for out-of-bounds indices:\n\t\t\t\tif (index < 0 || index >= size) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\t// Get the first code unit\n\t\t\t\tvar first = string.charCodeAt(index);\n\t\t\t\tvar second;\n\t\t\t\tif ( // check if it’s the start of a surrogate pair\n\t\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\t\tsize > index + 1 // there is a next code unit\n\t\t\t\t) {\n\t\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\t\treturn (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn first;\n\t\t\t};\n\t\t\tif (defineProperty) {\n\t\t\t\tdefineProperty(String.prototype, 'codePointAt', {\n\t\t\t\t\t'value': codePointAt,\n\t\t\t\t\t'configurable': true,\n\t\t\t\t\t'writable': true\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tString.prototype.codePointAt = codePointAt;\n\t\t\t}\n\t\t}());\n\t}\n\n\tvar TINF_OK = 0;\n\tvar TINF_DATA_ERROR = -3;\n\n\tfunction Tree() {\n\t  this.table = new Uint16Array(16);   /* table of code length counts */\n\t  this.trans = new Uint16Array(288);  /* code -> symbol translation table */\n\t}\n\n\tfunction Data(source, dest) {\n\t  this.source = source;\n\t  this.sourceIndex = 0;\n\t  this.tag = 0;\n\t  this.bitcount = 0;\n\t  \n\t  this.dest = dest;\n\t  this.destLen = 0;\n\t  \n\t  this.ltree = new Tree();  /* dynamic length/symbol tree */\n\t  this.dtree = new Tree();  /* dynamic distance tree */\n\t}\n\n\t/* --------------------------------------------------- *\n\t * -- uninitialized global data (static structures) -- *\n\t * --------------------------------------------------- */\n\n\tvar sltree = new Tree();\n\tvar sdtree = new Tree();\n\n\t/* extra bits and base tables for length codes */\n\tvar length_bits = new Uint8Array(30);\n\tvar length_base = new Uint16Array(30);\n\n\t/* extra bits and base tables for distance codes */\n\tvar dist_bits = new Uint8Array(30);\n\tvar dist_base = new Uint16Array(30);\n\n\t/* special ordering of code length codes */\n\tvar clcidx = new Uint8Array([\n\t  16, 17, 18, 0, 8, 7, 9, 6,\n\t  10, 5, 11, 4, 12, 3, 13, 2,\n\t  14, 1, 15\n\t]);\n\n\t/* used by tinf_decode_trees, avoids allocations every call */\n\tvar code_tree = new Tree();\n\tvar lengths = new Uint8Array(288 + 32);\n\n\t/* ----------------------- *\n\t * -- utility functions -- *\n\t * ----------------------- */\n\n\t/* build extra bits and base tables */\n\tfunction tinf_build_bits_base(bits, base, delta, first) {\n\t  var i, sum;\n\n\t  /* build bits table */\n\t  for (i = 0; i < delta; ++i) { bits[i] = 0; }\n\t  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }\n\n\t  /* build base table */\n\t  for (sum = first, i = 0; i < 30; ++i) {\n\t    base[i] = sum;\n\t    sum += 1 << bits[i];\n\t  }\n\t}\n\n\t/* build the fixed huffman trees */\n\tfunction tinf_build_fixed_trees(lt, dt) {\n\t  var i;\n\n\t  /* build fixed length tree */\n\t  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }\n\n\t  lt.table[7] = 24;\n\t  lt.table[8] = 152;\n\t  lt.table[9] = 112;\n\n\t  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }\n\t  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }\n\t  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }\n\t  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }\n\n\t  /* build fixed distance tree */\n\t  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }\n\n\t  dt.table[5] = 32;\n\n\t  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }\n\t}\n\n\t/* given an array of code lengths, build a tree */\n\tvar offs = new Uint16Array(16);\n\n\tfunction tinf_build_tree(t, lengths, off, num) {\n\t  var i, sum;\n\n\t  /* clear code length count table */\n\t  for (i = 0; i < 16; ++i) { t.table[i] = 0; }\n\n\t  /* scan symbol lengths, and sum code length counts */\n\t  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }\n\n\t  t.table[0] = 0;\n\n\t  /* compute offset table for distribution sort */\n\t  for (sum = 0, i = 0; i < 16; ++i) {\n\t    offs[i] = sum;\n\t    sum += t.table[i];\n\t  }\n\n\t  /* create code->symbol translation table (symbols sorted by code) */\n\t  for (i = 0; i < num; ++i) {\n\t    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }\n\t  }\n\t}\n\n\t/* ---------------------- *\n\t * -- decode functions -- *\n\t * ---------------------- */\n\n\t/* get one bit from source stream */\n\tfunction tinf_getbit(d) {\n\t  /* check if tag is empty */\n\t  if (!d.bitcount--) {\n\t    /* load next tag */\n\t    d.tag = d.source[d.sourceIndex++];\n\t    d.bitcount = 7;\n\t  }\n\n\t  /* shift bit out of tag */\n\t  var bit = d.tag & 1;\n\t  d.tag >>>= 1;\n\n\t  return bit;\n\t}\n\n\t/* read a num bit value from a stream and add base */\n\tfunction tinf_read_bits(d, num, base) {\n\t  if (!num)\n\t    { return base; }\n\n\t  while (d.bitcount < 24) {\n\t    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n\t    d.bitcount += 8;\n\t  }\n\n\t  var val = d.tag & (0xffff >>> (16 - num));\n\t  d.tag >>>= num;\n\t  d.bitcount -= num;\n\t  return val + base;\n\t}\n\n\t/* given a data stream and a tree, decode a symbol */\n\tfunction tinf_decode_symbol(d, t) {\n\t  while (d.bitcount < 24) {\n\t    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n\t    d.bitcount += 8;\n\t  }\n\t  \n\t  var sum = 0, cur = 0, len = 0;\n\t  var tag = d.tag;\n\n\t  /* get more bits while code value is above sum */\n\t  do {\n\t    cur = 2 * cur + (tag & 1);\n\t    tag >>>= 1;\n\t    ++len;\n\n\t    sum += t.table[len];\n\t    cur -= t.table[len];\n\t  } while (cur >= 0);\n\t  \n\t  d.tag = tag;\n\t  d.bitcount -= len;\n\n\t  return t.trans[sum + cur];\n\t}\n\n\t/* given a data stream, decode dynamic trees from it */\n\tfunction tinf_decode_trees(d, lt, dt) {\n\t  var hlit, hdist, hclen;\n\t  var i, num, length;\n\n\t  /* get 5 bits HLIT (257-286) */\n\t  hlit = tinf_read_bits(d, 5, 257);\n\n\t  /* get 5 bits HDIST (1-32) */\n\t  hdist = tinf_read_bits(d, 5, 1);\n\n\t  /* get 4 bits HCLEN (4-19) */\n\t  hclen = tinf_read_bits(d, 4, 4);\n\n\t  for (i = 0; i < 19; ++i) { lengths[i] = 0; }\n\n\t  /* read code lengths for code length alphabet */\n\t  for (i = 0; i < hclen; ++i) {\n\t    /* get 3 bits code length (0-7) */\n\t    var clen = tinf_read_bits(d, 3, 0);\n\t    lengths[clcidx[i]] = clen;\n\t  }\n\n\t  /* build code length tree */\n\t  tinf_build_tree(code_tree, lengths, 0, 19);\n\n\t  /* decode code lengths for the dynamic trees */\n\t  for (num = 0; num < hlit + hdist;) {\n\t    var sym = tinf_decode_symbol(d, code_tree);\n\n\t    switch (sym) {\n\t      case 16:\n\t        /* copy previous code length 3-6 times (read 2 bits) */\n\t        var prev = lengths[num - 1];\n\t        for (length = tinf_read_bits(d, 2, 3); length; --length) {\n\t          lengths[num++] = prev;\n\t        }\n\t        break;\n\t      case 17:\n\t        /* repeat code length 0 for 3-10 times (read 3 bits) */\n\t        for (length = tinf_read_bits(d, 3, 3); length; --length) {\n\t          lengths[num++] = 0;\n\t        }\n\t        break;\n\t      case 18:\n\t        /* repeat code length 0 for 11-138 times (read 7 bits) */\n\t        for (length = tinf_read_bits(d, 7, 11); length; --length) {\n\t          lengths[num++] = 0;\n\t        }\n\t        break;\n\t      default:\n\t        /* values 0-15 represent the actual code lengths */\n\t        lengths[num++] = sym;\n\t        break;\n\t    }\n\t  }\n\n\t  /* build dynamic trees */\n\t  tinf_build_tree(lt, lengths, 0, hlit);\n\t  tinf_build_tree(dt, lengths, hlit, hdist);\n\t}\n\n\t/* ----------------------------- *\n\t * -- block inflate functions -- *\n\t * ----------------------------- */\n\n\t/* given a stream and two trees, inflate a block of data */\n\tfunction tinf_inflate_block_data(d, lt, dt) {\n\t  while (1) {\n\t    var sym = tinf_decode_symbol(d, lt);\n\n\t    /* check for end of block */\n\t    if (sym === 256) {\n\t      return TINF_OK;\n\t    }\n\n\t    if (sym < 256) {\n\t      d.dest[d.destLen++] = sym;\n\t    } else {\n\t      var length, dist, offs;\n\t      var i;\n\n\t      sym -= 257;\n\n\t      /* possibly get more bits from length code */\n\t      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);\n\n\t      dist = tinf_decode_symbol(d, dt);\n\n\t      /* possibly get more bits from distance code */\n\t      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);\n\n\t      /* copy match */\n\t      for (i = offs; i < offs + length; ++i) {\n\t        d.dest[d.destLen++] = d.dest[i];\n\t      }\n\t    }\n\t  }\n\t}\n\n\t/* inflate an uncompressed block of data */\n\tfunction tinf_inflate_uncompressed_block(d) {\n\t  var length, invlength;\n\t  var i;\n\t  \n\t  /* unread from bitbuffer */\n\t  while (d.bitcount > 8) {\n\t    d.sourceIndex--;\n\t    d.bitcount -= 8;\n\t  }\n\n\t  /* get length */\n\t  length = d.source[d.sourceIndex + 1];\n\t  length = 256 * length + d.source[d.sourceIndex];\n\n\t  /* get one's complement of length */\n\t  invlength = d.source[d.sourceIndex + 3];\n\t  invlength = 256 * invlength + d.source[d.sourceIndex + 2];\n\n\t  /* check length */\n\t  if (length !== (~invlength & 0x0000ffff))\n\t    { return TINF_DATA_ERROR; }\n\n\t  d.sourceIndex += 4;\n\n\t  /* copy block */\n\t  for (i = length; i; --i)\n\t    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }\n\n\t  /* make sure we start next block on a byte boundary */\n\t  d.bitcount = 0;\n\n\t  return TINF_OK;\n\t}\n\n\t/* inflate stream from source to dest */\n\tfunction tinf_uncompress(source, dest) {\n\t  var d = new Data(source, dest);\n\t  var bfinal, btype, res;\n\n\t  do {\n\t    /* read final block flag */\n\t    bfinal = tinf_getbit(d);\n\n\t    /* read block type (2 bits) */\n\t    btype = tinf_read_bits(d, 2, 0);\n\n\t    /* decompress block */\n\t    switch (btype) {\n\t      case 0:\n\t        /* decompress uncompressed block */\n\t        res = tinf_inflate_uncompressed_block(d);\n\t        break;\n\t      case 1:\n\t        /* decompress block with fixed huffman trees */\n\t        res = tinf_inflate_block_data(d, sltree, sdtree);\n\t        break;\n\t      case 2:\n\t        /* decompress block with dynamic huffman trees */\n\t        tinf_decode_trees(d, d.ltree, d.dtree);\n\t        res = tinf_inflate_block_data(d, d.ltree, d.dtree);\n\t        break;\n\t      default:\n\t        res = TINF_DATA_ERROR;\n\t    }\n\n\t    if (res !== TINF_OK)\n\t      { throw new Error('Data error'); }\n\n\t  } while (!bfinal);\n\n\t  if (d.destLen < d.dest.length) {\n\t    if (typeof d.dest.slice === 'function')\n\t      { return d.dest.slice(0, d.destLen); }\n\t    else\n\t      { return d.dest.subarray(0, d.destLen); }\n\t  }\n\t  \n\t  return d.dest;\n\t}\n\n\t/* -------------------- *\n\t * -- initialization -- *\n\t * -------------------- */\n\n\t/* build fixed huffman trees */\n\ttinf_build_fixed_trees(sltree, sdtree);\n\n\t/* build extra bits and base tables */\n\ttinf_build_bits_base(length_bits, length_base, 4, 3);\n\ttinf_build_bits_base(dist_bits, dist_base, 2, 1);\n\n\t/* fix a special case */\n\tlength_bits[28] = 0;\n\tlength_base[28] = 258;\n\n\tvar tinyInflate = tinf_uncompress;\n\n\t// The Bounding Box object\n\n\tfunction derive(v0, v1, v2, v3, t) {\n\t    return Math.pow(1 - t, 3) * v0 +\n\t        3 * Math.pow(1 - t, 2) * t * v1 +\n\t        3 * (1 - t) * Math.pow(t, 2) * v2 +\n\t        Math.pow(t, 3) * v3;\n\t}\n\t/**\n\t * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.\n\t * It is used to calculate the bounding box of a glyph or text path.\n\t *\n\t * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.\n\t *\n\t * @exports opentype.BoundingBox\n\t * @class\n\t * @constructor\n\t */\n\tfunction BoundingBox() {\n\t    this.x1 = Number.NaN;\n\t    this.y1 = Number.NaN;\n\t    this.x2 = Number.NaN;\n\t    this.y2 = Number.NaN;\n\t}\n\n\t/**\n\t * Returns true if the bounding box is empty, that is, no points have been added to the box yet.\n\t */\n\tBoundingBox.prototype.isEmpty = function() {\n\t    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);\n\t};\n\n\t/**\n\t * Add the point to the bounding box.\n\t * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.\n\t * @param {number} x - The X coordinate of the point.\n\t * @param {number} y - The Y coordinate of the point.\n\t */\n\tBoundingBox.prototype.addPoint = function(x, y) {\n\t    if (typeof x === 'number') {\n\t        if (isNaN(this.x1) || isNaN(this.x2)) {\n\t            this.x1 = x;\n\t            this.x2 = x;\n\t        }\n\t        if (x < this.x1) {\n\t            this.x1 = x;\n\t        }\n\t        if (x > this.x2) {\n\t            this.x2 = x;\n\t        }\n\t    }\n\t    if (typeof y === 'number') {\n\t        if (isNaN(this.y1) || isNaN(this.y2)) {\n\t            this.y1 = y;\n\t            this.y2 = y;\n\t        }\n\t        if (y < this.y1) {\n\t            this.y1 = y;\n\t        }\n\t        if (y > this.y2) {\n\t            this.y2 = y;\n\t        }\n\t    }\n\t};\n\n\t/**\n\t * Add a X coordinate to the bounding box.\n\t * This extends the bounding box to include the X coordinate.\n\t * This function is used internally inside of addBezier.\n\t * @param {number} x - The X coordinate of the point.\n\t */\n\tBoundingBox.prototype.addX = function(x) {\n\t    this.addPoint(x, null);\n\t};\n\n\t/**\n\t * Add a Y coordinate to the bounding box.\n\t * This extends the bounding box to include the Y coordinate.\n\t * This function is used internally inside of addBezier.\n\t * @param {number} y - The Y coordinate of the point.\n\t */\n\tBoundingBox.prototype.addY = function(y) {\n\t    this.addPoint(null, y);\n\t};\n\n\t/**\n\t * Add a Bézier curve to the bounding box.\n\t * This extends the bounding box to include the entire Bézier.\n\t * @param {number} x0 - The starting X coordinate.\n\t * @param {number} y0 - The starting Y coordinate.\n\t * @param {number} x1 - The X coordinate of the first control point.\n\t * @param {number} y1 - The Y coordinate of the first control point.\n\t * @param {number} x2 - The X coordinate of the second control point.\n\t * @param {number} y2 - The Y coordinate of the second control point.\n\t * @param {number} x - The ending X coordinate.\n\t * @param {number} y - The ending Y coordinate.\n\t */\n\tBoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {\n\t    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html\n\t    // and https://github.com/icons8/svg-path-bounding-box\n\n\t    var p0 = [x0, y0];\n\t    var p1 = [x1, y1];\n\t    var p2 = [x2, y2];\n\t    var p3 = [x, y];\n\n\t    this.addPoint(x0, y0);\n\t    this.addPoint(x, y);\n\n\t    for (var i = 0; i <= 1; i++) {\n\t        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n\t        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n\t        var c = 3 * p1[i] - 3 * p0[i];\n\n\t        if (a === 0) {\n\t            if (b === 0) { continue; }\n\t            var t = -c / b;\n\t            if (0 < t && t < 1) {\n\t                if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }\n\t                if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }\n\t            }\n\t            continue;\n\t        }\n\n\t        var b2ac = Math.pow(b, 2) - 4 * c * a;\n\t        if (b2ac < 0) { continue; }\n\t        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n\t        if (0 < t1 && t1 < 1) {\n\t            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }\n\t            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }\n\t        }\n\t        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n\t        if (0 < t2 && t2 < 1) {\n\t            if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }\n\t            if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }\n\t        }\n\t    }\n\t};\n\n\t/**\n\t * Add a quadratic curve to the bounding box.\n\t * This extends the bounding box to include the entire quadratic curve.\n\t * @param {number} x0 - The starting X coordinate.\n\t * @param {number} y0 - The starting Y coordinate.\n\t * @param {number} x1 - The X coordinate of the control point.\n\t * @param {number} y1 - The Y coordinate of the control point.\n\t * @param {number} x - The ending X coordinate.\n\t * @param {number} y - The ending Y coordinate.\n\t */\n\tBoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {\n\t    var cp1x = x0 + 2 / 3 * (x1 - x0);\n\t    var cp1y = y0 + 2 / 3 * (y1 - y0);\n\t    var cp2x = cp1x + 1 / 3 * (x - x0);\n\t    var cp2y = cp1y + 1 / 3 * (y - y0);\n\t    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);\n\t};\n\n\t// Geometric objects\n\n\t/**\n\t * A bézier path containing a set of path commands similar to a SVG path.\n\t * Paths can be drawn on a context using `draw`.\n\t * @exports opentype.Path\n\t * @class\n\t * @constructor\n\t */\n\tfunction Path() {\n\t    this.commands = [];\n\t    this.fill = 'black';\n\t    this.stroke = null;\n\t    this.strokeWidth = 1;\n\t}\n\n\t/**\n\t * @param  {number} x\n\t * @param  {number} y\n\t */\n\tPath.prototype.moveTo = function(x, y) {\n\t    this.commands.push({\n\t        type: 'M',\n\t        x: x,\n\t        y: y\n\t    });\n\t};\n\n\t/**\n\t * @param  {number} x\n\t * @param  {number} y\n\t */\n\tPath.prototype.lineTo = function(x, y) {\n\t    this.commands.push({\n\t        type: 'L',\n\t        x: x,\n\t        y: y\n\t    });\n\t};\n\n\t/**\n\t * Draws cubic curve\n\t * @function\n\t * curveTo\n\t * @memberof opentype.Path.prototype\n\t * @param  {number} x1 - x of control 1\n\t * @param  {number} y1 - y of control 1\n\t * @param  {number} x2 - x of control 2\n\t * @param  {number} y2 - y of control 2\n\t * @param  {number} x - x of path point\n\t * @param  {number} y - y of path point\n\t */\n\n\t/**\n\t * Draws cubic curve\n\t * @function\n\t * bezierCurveTo\n\t * @memberof opentype.Path.prototype\n\t * @param  {number} x1 - x of control 1\n\t * @param  {number} y1 - y of control 1\n\t * @param  {number} x2 - x of control 2\n\t * @param  {number} y2 - y of control 2\n\t * @param  {number} x - x of path point\n\t * @param  {number} y - y of path point\n\t * @see curveTo\n\t */\n\tPath.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {\n\t    this.commands.push({\n\t        type: 'C',\n\t        x1: x1,\n\t        y1: y1,\n\t        x2: x2,\n\t        y2: y2,\n\t        x: x,\n\t        y: y\n\t    });\n\t};\n\n\t/**\n\t * Draws quadratic curve\n\t * @function\n\t * quadraticCurveTo\n\t * @memberof opentype.Path.prototype\n\t * @param  {number} x1 - x of control\n\t * @param  {number} y1 - y of control\n\t * @param  {number} x - x of path point\n\t * @param  {number} y - y of path point\n\t */\n\n\t/**\n\t * Draws quadratic curve\n\t * @function\n\t * quadTo\n\t * @memberof opentype.Path.prototype\n\t * @param  {number} x1 - x of control\n\t * @param  {number} y1 - y of control\n\t * @param  {number} x - x of path point\n\t * @param  {number} y - y of path point\n\t */\n\tPath.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {\n\t    this.commands.push({\n\t        type: 'Q',\n\t        x1: x1,\n\t        y1: y1,\n\t        x: x,\n\t        y: y\n\t    });\n\t};\n\n\t/**\n\t * Closes the path\n\t * @function closePath\n\t * @memberof opentype.Path.prototype\n\t */\n\n\t/**\n\t * Close the path\n\t * @function close\n\t * @memberof opentype.Path.prototype\n\t */\n\tPath.prototype.close = Path.prototype.closePath = function() {\n\t    this.commands.push({\n\t        type: 'Z'\n\t    });\n\t};\n\n\t/**\n\t * Add the given path or list of commands to the commands of this path.\n\t * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.\n\t */\n\tPath.prototype.extend = function(pathOrCommands) {\n\t    if (pathOrCommands.commands) {\n\t        pathOrCommands = pathOrCommands.commands;\n\t    } else if (pathOrCommands instanceof BoundingBox) {\n\t        var box = pathOrCommands;\n\t        this.moveTo(box.x1, box.y1);\n\t        this.lineTo(box.x2, box.y1);\n\t        this.lineTo(box.x2, box.y2);\n\t        this.lineTo(box.x1, box.y2);\n\t        this.close();\n\t        return;\n\t    }\n\n\t    Array.prototype.push.apply(this.commands, pathOrCommands);\n\t};\n\n\t/**\n\t * Calculate the bounding box of the path.\n\t * @returns {opentype.BoundingBox}\n\t */\n\tPath.prototype.getBoundingBox = function() {\n\t    var box = new BoundingBox();\n\n\t    var startX = 0;\n\t    var startY = 0;\n\t    var prevX = 0;\n\t    var prevY = 0;\n\t    for (var i = 0; i < this.commands.length; i++) {\n\t        var cmd = this.commands[i];\n\t        switch (cmd.type) {\n\t            case 'M':\n\t                box.addPoint(cmd.x, cmd.y);\n\t                startX = prevX = cmd.x;\n\t                startY = prevY = cmd.y;\n\t                break;\n\t            case 'L':\n\t                box.addPoint(cmd.x, cmd.y);\n\t                prevX = cmd.x;\n\t                prevY = cmd.y;\n\t                break;\n\t            case 'Q':\n\t                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);\n\t                prevX = cmd.x;\n\t                prevY = cmd.y;\n\t                break;\n\t            case 'C':\n\t                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n\t                prevX = cmd.x;\n\t                prevY = cmd.y;\n\t                break;\n\t            case 'Z':\n\t                prevX = startX;\n\t                prevY = startY;\n\t                break;\n\t            default:\n\t                throw new Error('Unexpected path command ' + cmd.type);\n\t        }\n\t    }\n\t    if (box.isEmpty()) {\n\t        box.addPoint(0, 0);\n\t    }\n\t    return box;\n\t};\n\n\t/**\n\t * Draw the path to a 2D context.\n\t * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.\n\t */\n\tPath.prototype.draw = function(ctx) {\n\t    ctx.beginPath();\n\t    for (var i = 0; i < this.commands.length; i += 1) {\n\t        var cmd = this.commands[i];\n\t        if (cmd.type === 'M') {\n\t            ctx.moveTo(cmd.x, cmd.y);\n\t        } else if (cmd.type === 'L') {\n\t            ctx.lineTo(cmd.x, cmd.y);\n\t        } else if (cmd.type === 'C') {\n\t            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n\t        } else if (cmd.type === 'Q') {\n\t            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);\n\t        } else if (cmd.type === 'Z') {\n\t            ctx.closePath();\n\t        }\n\t    }\n\n\t    if (this.fill) {\n\t        ctx.fillStyle = this.fill;\n\t        ctx.fill();\n\t    }\n\n\t    if (this.stroke) {\n\t        ctx.strokeStyle = this.stroke;\n\t        ctx.lineWidth = this.strokeWidth;\n\t        ctx.stroke();\n\t    }\n\t};\n\n\t/**\n\t * Convert the Path to a string of path data instructions\n\t * See http://www.w3.org/TR/SVG/paths.html#PathData\n\t * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n\t * @return {string}\n\t */\n\tPath.prototype.toPathData = function(decimalPlaces) {\n\t    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n\n\t    function floatToString(v) {\n\t        if (Math.round(v) === v) {\n\t            return '' + Math.round(v);\n\t        } else {\n\t            return v.toFixed(decimalPlaces);\n\t        }\n\t    }\n\n\t    function packValues() {\n\t        var arguments$1 = arguments;\n\n\t        var s = '';\n\t        for (var i = 0; i < arguments.length; i += 1) {\n\t            var v = arguments$1[i];\n\t            if (v >= 0 && i > 0) {\n\t                s += ' ';\n\t            }\n\n\t            s += floatToString(v);\n\t        }\n\n\t        return s;\n\t    }\n\n\t    var d = '';\n\t    for (var i = 0; i < this.commands.length; i += 1) {\n\t        var cmd = this.commands[i];\n\t        if (cmd.type === 'M') {\n\t            d += 'M' + packValues(cmd.x, cmd.y);\n\t        } else if (cmd.type === 'L') {\n\t            d += 'L' + packValues(cmd.x, cmd.y);\n\t        } else if (cmd.type === 'C') {\n\t            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n\t        } else if (cmd.type === 'Q') {\n\t            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n\t        } else if (cmd.type === 'Z') {\n\t            d += 'Z';\n\t        }\n\t    }\n\n\t    return d;\n\t};\n\n\t/**\n\t * Convert the path to an SVG <path> element, as a string.\n\t * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n\t * @return {string}\n\t */\n\tPath.prototype.toSVG = function(decimalPlaces) {\n\t    var svg = '<path d=\"';\n\t    svg += this.toPathData(decimalPlaces);\n\t    svg += '\"';\n\t    if (this.fill && this.fill !== 'black') {\n\t        if (this.fill === null) {\n\t            svg += ' fill=\"none\"';\n\t        } else {\n\t            svg += ' fill=\"' + this.fill + '\"';\n\t        }\n\t    }\n\n\t    if (this.stroke) {\n\t        svg += ' stroke=\"' + this.stroke + '\" stroke-width=\"' + this.strokeWidth + '\"';\n\t    }\n\n\t    svg += '/>';\n\t    return svg;\n\t};\n\n\t/**\n\t * Convert the path to a DOM element.\n\t * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n\t * @return {SVGPathElement}\n\t */\n\tPath.prototype.toDOMElement = function(decimalPlaces) {\n\t    var temporaryPath = this.toPathData(decimalPlaces);\n\t    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n\t    newPath.setAttribute('d', temporaryPath);\n\n\t    return newPath;\n\t};\n\n\t// Run-time checking of preconditions.\n\n\tfunction fail(message) {\n\t    throw new Error(message);\n\t}\n\n\t// Precondition function that checks if the given predicate is true.\n\t// If not, it will throw an error.\n\tfunction argument(predicate, message) {\n\t    if (!predicate) {\n\t        fail(message);\n\t    }\n\t}\n\tvar check = { fail: fail, argument: argument, assert: argument };\n\n\t// Data types used in the OpenType font file.\n\n\tvar LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15\n\tvar LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31\n\n\t/**\n\t * @exports opentype.decode\n\t * @class\n\t */\n\tvar decode = {};\n\t/**\n\t * @exports opentype.encode\n\t * @class\n\t */\n\tvar encode = {};\n\t/**\n\t * @exports opentype.sizeOf\n\t * @class\n\t */\n\tvar sizeOf = {};\n\n\t// Return a function that always returns the same value.\n\tfunction constant(v) {\n\t    return function() {\n\t        return v;\n\t    };\n\t}\n\n\t// OpenType data types //////////////////////////////////////////////////////\n\n\t/**\n\t * Convert an 8-bit unsigned integer to a list of 1 byte.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.BYTE = function(v) {\n\t    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');\n\t    return [v];\n\t};\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.BYTE = constant(1);\n\n\t/**\n\t * Convert a 8-bit signed integer to a list of 1 byte.\n\t * @param {string}\n\t * @returns {Array}\n\t */\n\tencode.CHAR = function(v) {\n\t    return [v.charCodeAt(0)];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.CHAR = constant(1);\n\n\t/**\n\t * Convert an ASCII string to a list of bytes.\n\t * @param {string}\n\t * @returns {Array}\n\t */\n\tencode.CHARARRAY = function(v) {\n\t    if (typeof v === 'undefined') {\n\t        v = '';\n\t        console.warn('Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.');\n\t    }\n\t    var b = [];\n\t    for (var i = 0; i < v.length; i += 1) {\n\t        b[i] = v.charCodeAt(i);\n\t    }\n\n\t    return b;\n\t};\n\n\t/**\n\t * @param {Array}\n\t * @returns {number}\n\t */\n\tsizeOf.CHARARRAY = function(v) {\n\t    if (typeof v === 'undefined') {\n\t        return 0;\n\t    }\n\t    return v.length;\n\t};\n\n\t/**\n\t * Convert a 16-bit unsigned integer to a list of 2 bytes.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.USHORT = function(v) {\n\t    return [(v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.USHORT = constant(2);\n\n\t/**\n\t * Convert a 16-bit signed integer to a list of 2 bytes.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.SHORT = function(v) {\n\t    // Two's complement\n\t    if (v >= LIMIT16) {\n\t        v = -(2 * LIMIT16 - v);\n\t    }\n\n\t    return [(v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.SHORT = constant(2);\n\n\t/**\n\t * Convert a 24-bit unsigned integer to a list of 3 bytes.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.UINT24 = function(v) {\n\t    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.UINT24 = constant(3);\n\n\t/**\n\t * Convert a 32-bit unsigned integer to a list of 4 bytes.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.ULONG = function(v) {\n\t    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.ULONG = constant(4);\n\n\t/**\n\t * Convert a 32-bit unsigned integer to a list of 4 bytes.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.LONG = function(v) {\n\t    // Two's complement\n\t    if (v >= LIMIT32) {\n\t        v = -(2 * LIMIT32 - v);\n\t    }\n\n\t    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.LONG = constant(4);\n\n\tencode.FIXED = encode.ULONG;\n\tsizeOf.FIXED = sizeOf.ULONG;\n\n\tencode.FWORD = encode.SHORT;\n\tsizeOf.FWORD = sizeOf.SHORT;\n\n\tencode.UFWORD = encode.USHORT;\n\tsizeOf.UFWORD = sizeOf.USHORT;\n\n\t/**\n\t * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.LONGDATETIME = function(v) {\n\t    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.LONGDATETIME = constant(8);\n\n\t/**\n\t * Convert a 4-char tag to a list of 4 bytes.\n\t * @param {string}\n\t * @returns {Array}\n\t */\n\tencode.TAG = function(v) {\n\t    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');\n\t    return [v.charCodeAt(0),\n\t            v.charCodeAt(1),\n\t            v.charCodeAt(2),\n\t            v.charCodeAt(3)];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.TAG = constant(4);\n\n\t// CFF data types ///////////////////////////////////////////////////////////\n\n\tencode.Card8 = encode.BYTE;\n\tsizeOf.Card8 = sizeOf.BYTE;\n\n\tencode.Card16 = encode.USHORT;\n\tsizeOf.Card16 = sizeOf.USHORT;\n\n\tencode.OffSize = encode.BYTE;\n\tsizeOf.OffSize = sizeOf.BYTE;\n\n\tencode.SID = encode.USHORT;\n\tsizeOf.SID = sizeOf.USHORT;\n\n\t// Convert a numeric operand or charstring number to a variable-size list of bytes.\n\t/**\n\t * Convert a numeric operand or charstring number to a variable-size list of bytes.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.NUMBER = function(v) {\n\t    if (v >= -107 && v <= 107) {\n\t        return [v + 139];\n\t    } else if (v >= 108 && v <= 1131) {\n\t        v = v - 108;\n\t        return [(v >> 8) + 247, v & 0xFF];\n\t    } else if (v >= -1131 && v <= -108) {\n\t        v = -v - 108;\n\t        return [(v >> 8) + 251, v & 0xFF];\n\t    } else if (v >= -32768 && v <= 32767) {\n\t        return encode.NUMBER16(v);\n\t    } else {\n\t        return encode.NUMBER32(v);\n\t    }\n\t};\n\n\t/**\n\t * @param {number}\n\t * @returns {number}\n\t */\n\tsizeOf.NUMBER = function(v) {\n\t    return encode.NUMBER(v).length;\n\t};\n\n\t/**\n\t * Convert a signed number between -32768 and +32767 to a three-byte value.\n\t * This ensures we always use three bytes, but is not the most compact format.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.NUMBER16 = function(v) {\n\t    return [28, (v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.NUMBER16 = constant(3);\n\n\t/**\n\t * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.\n\t * This is useful if you want to be sure you always use four bytes,\n\t * at the expense of wasting a few bytes for smaller numbers.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.NUMBER32 = function(v) {\n\t    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.NUMBER32 = constant(5);\n\n\t/**\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.REAL = function(v) {\n\t    var value = v.toString();\n\n\t    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)\n\t    // This code converts it back to a number without the epsilon.\n\t    var m = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(value);\n\t    if (m) {\n\t        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));\n\t        value = (Math.round(v * epsilon) / epsilon).toString();\n\t    }\n\n\t    var nibbles = '';\n\t    for (var i = 0, ii = value.length; i < ii; i += 1) {\n\t        var c = value[i];\n\t        if (c === 'e') {\n\t            nibbles += value[++i] === '-' ? 'c' : 'b';\n\t        } else if (c === '.') {\n\t            nibbles += 'a';\n\t        } else if (c === '-') {\n\t            nibbles += 'e';\n\t        } else {\n\t            nibbles += c;\n\t        }\n\t    }\n\n\t    nibbles += (nibbles.length & 1) ? 'f' : 'ff';\n\t    var out = [30];\n\t    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {\n\t        out.push(parseInt(nibbles.substr(i$1, 2), 16));\n\t    }\n\n\t    return out;\n\t};\n\n\t/**\n\t * @param {number}\n\t * @returns {number}\n\t */\n\tsizeOf.REAL = function(v) {\n\t    return encode.REAL(v).length;\n\t};\n\n\tencode.NAME = encode.CHARARRAY;\n\tsizeOf.NAME = sizeOf.CHARARRAY;\n\n\tencode.STRING = encode.CHARARRAY;\n\tsizeOf.STRING = sizeOf.CHARARRAY;\n\n\t/**\n\t * @param {DataView} data\n\t * @param {number} offset\n\t * @param {number} numBytes\n\t * @returns {string}\n\t */\n\tdecode.UTF8 = function(data, offset, numBytes) {\n\t    var codePoints = [];\n\t    var numChars = numBytes;\n\t    for (var j = 0; j < numChars; j++, offset += 1) {\n\t        codePoints[j] = data.getUint8(offset);\n\t    }\n\n\t    return String.fromCharCode.apply(null, codePoints);\n\t};\n\n\t/**\n\t * @param {DataView} data\n\t * @param {number} offset\n\t * @param {number} numBytes\n\t * @returns {string}\n\t */\n\tdecode.UTF16 = function(data, offset, numBytes) {\n\t    var codePoints = [];\n\t    var numChars = numBytes / 2;\n\t    for (var j = 0; j < numChars; j++, offset += 2) {\n\t        codePoints[j] = data.getUint16(offset);\n\t    }\n\n\t    return String.fromCharCode.apply(null, codePoints);\n\t};\n\n\t/**\n\t * Convert a JavaScript string to UTF16-BE.\n\t * @param {string}\n\t * @returns {Array}\n\t */\n\tencode.UTF16 = function(v) {\n\t    var b = [];\n\t    for (var i = 0; i < v.length; i += 1) {\n\t        var codepoint = v.charCodeAt(i);\n\t        b[b.length] = (codepoint >> 8) & 0xFF;\n\t        b[b.length] = codepoint & 0xFF;\n\t    }\n\n\t    return b;\n\t};\n\n\t/**\n\t * @param {string}\n\t * @returns {number}\n\t */\n\tsizeOf.UTF16 = function(v) {\n\t    return v.length * 2;\n\t};\n\n\t// Data for converting old eight-bit Macintosh encodings to Unicode.\n\t// This representation is optimized for decoding; encoding is slower\n\t// and needs more memory. The assumption is that all opentype.js users\n\t// want to open fonts, but saving a font will be comparatively rare\n\t// so it can be more expensive. Keyed by IANA character set name.\n\t//\n\t// Python script for generating these strings:\n\t//\n\t//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n\t//     print(s.encode('utf-8'))\n\t/**\n\t * @private\n\t */\n\tvar eightBitMacEncodings = {\n\t    'x-mac-croatian':  // Python: 'mac_croatian'\n\t    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +\n\t    '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',\n\t    'x-mac-cyrillic':  // Python: 'mac_cyrillic'\n\t    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +\n\t    'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',\n\t    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n\t    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +\n\t    'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',\n\t    'x-mac-greek':  // Python: 'mac_greek'\n\t    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +\n\t    'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\\u00AD',\n\t    'x-mac-icelandic':  // Python: 'mac_iceland'\n\t    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n\t    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n\t    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n\t    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +\n\t    'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',\n\t    'x-mac-ce':  // Python: 'mac_latin2'\n\t    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +\n\t    'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',\n\t    macintosh:  // Python: 'mac_roman'\n\t    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n\t    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n\t    'x-mac-romanian':  // Python: 'mac_romanian'\n\t    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +\n\t    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n\t    'x-mac-turkish':  // Python: 'mac_turkish'\n\t    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n\t    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'\n\t};\n\n\t/**\n\t * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n\t * string, or 'undefined' if the encoding is unsupported. For example, we do\n\t * not support Chinese, Japanese or Korean because these would need large\n\t * mapping tables.\n\t * @param {DataView} dataView\n\t * @param {number} offset\n\t * @param {number} dataLength\n\t * @param {string} encoding\n\t * @returns {string}\n\t */\n\tdecode.MACSTRING = function(dataView, offset, dataLength, encoding) {\n\t    var table = eightBitMacEncodings[encoding];\n\t    if (table === undefined) {\n\t        return undefined;\n\t    }\n\n\t    var result = '';\n\t    for (var i = 0; i < dataLength; i++) {\n\t        var c = dataView.getUint8(offset + i);\n\t        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n\t        // mapped to U+0000..U+007F; we only need to look up the others.\n\t        if (c <= 0x7F) {\n\t            result += String.fromCharCode(c);\n\t        } else {\n\t            result += table[c & 0x7F];\n\t        }\n\t    }\n\n\t    return result;\n\t};\n\n\t// Helper function for encode.MACSTRING. Returns a dictionary for mapping\n\t// Unicode character codes to their 8-bit MacOS equivalent. This table\n\t// is not exactly a super cheap data structure, but we do not care because\n\t// encoding Macintosh strings is only rarely needed in typical applications.\n\tvar macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();\n\tvar macEncodingCacheKeys;\n\tvar getMacEncodingTable = function (encoding) {\n\t    // Since we use encoding as a cache key for WeakMap, it has to be\n\t    // a String object and not a literal. And at least on NodeJS 2.10.1,\n\t    // WeakMap requires that the same String instance is passed for cache hits.\n\t    if (!macEncodingCacheKeys) {\n\t        macEncodingCacheKeys = {};\n\t        for (var e in eightBitMacEncodings) {\n\t            /*jshint -W053 */  // Suppress \"Do not use String as a constructor.\"\n\t            macEncodingCacheKeys[e] = new String(e);\n\t        }\n\t    }\n\n\t    var cacheKey = macEncodingCacheKeys[encoding];\n\t    if (cacheKey === undefined) {\n\t        return undefined;\n\t    }\n\n\t    // We can't do \"if (cache.has(key)) {return cache.get(key)}\" here:\n\t    // since garbage collection may run at any time, it could also kick in\n\t    // between the calls to cache.has() and cache.get(). In that case,\n\t    // we would return 'undefined' even though we do support the encoding.\n\t    if (macEncodingTableCache) {\n\t        var cachedTable = macEncodingTableCache.get(cacheKey);\n\t        if (cachedTable !== undefined) {\n\t            return cachedTable;\n\t        }\n\t    }\n\n\t    var decodingTable = eightBitMacEncodings[encoding];\n\t    if (decodingTable === undefined) {\n\t        return undefined;\n\t    }\n\n\t    var encodingTable = {};\n\t    for (var i = 0; i < decodingTable.length; i++) {\n\t        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;\n\t    }\n\n\t    if (macEncodingTableCache) {\n\t        macEncodingTableCache.set(cacheKey, encodingTable);\n\t    }\n\n\t    return encodingTable;\n\t};\n\n\t/**\n\t * Encodes an old-style Macintosh string. Returns a byte array upon success.\n\t * If the requested encoding is unsupported, or if the input string contains\n\t * a character that cannot be expressed in the encoding, the function returns\n\t * 'undefined'.\n\t * @param {string} str\n\t * @param {string} encoding\n\t * @returns {Array}\n\t */\n\tencode.MACSTRING = function(str, encoding) {\n\t    var table = getMacEncodingTable(encoding);\n\t    if (table === undefined) {\n\t        return undefined;\n\t    }\n\n\t    var result = [];\n\t    for (var i = 0; i < str.length; i++) {\n\t        var c = str.charCodeAt(i);\n\n\t        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n\t        // mapped to U+0000..U+007F; we only need to look up the others.\n\t        if (c >= 0x80) {\n\t            c = table[c];\n\t            if (c === undefined) {\n\t                // str contains a Unicode character that cannot be encoded\n\t                // in the requested encoding.\n\t                return undefined;\n\t            }\n\t        }\n\t        result[i] = c;\n\t        // result.push(c);\n\t    }\n\n\t    return result;\n\t};\n\n\t/**\n\t * @param {string} str\n\t * @param {string} encoding\n\t * @returns {number}\n\t */\n\tsizeOf.MACSTRING = function(str, encoding) {\n\t    var b = encode.MACSTRING(str, encoding);\n\t    if (b !== undefined) {\n\t        return b.length;\n\t    } else {\n\t        return 0;\n\t    }\n\t};\n\n\t// Helper for encode.VARDELTAS\n\tfunction isByteEncodable(value) {\n\t    return value >= -128 && value <= 127;\n\t}\n\n\t// Helper for encode.VARDELTAS\n\tfunction encodeVarDeltaRunAsZeroes(deltas, pos, result) {\n\t    var runLength = 0;\n\t    var numDeltas = deltas.length;\n\t    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {\n\t        ++pos;\n\t        ++runLength;\n\t    }\n\t    result.push(0x80 | (runLength - 1));\n\t    return pos;\n\t}\n\n\t// Helper for encode.VARDELTAS\n\tfunction encodeVarDeltaRunAsBytes(deltas, offset, result) {\n\t    var runLength = 0;\n\t    var numDeltas = deltas.length;\n\t    var pos = offset;\n\t    while (pos < numDeltas && runLength < 64) {\n\t        var value = deltas[pos];\n\t        if (!isByteEncodable(value)) {\n\t            break;\n\t        }\n\n\t        // Within a byte-encoded run of deltas, a single zero is best\n\t        // stored literally as 0x00 value. However, if we have two or\n\t        // more zeroes in a sequence, it is better to start a new run.\n\t        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]\n\t        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero\n\t        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)\n\t        // when starting a new run.\n\t        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {\n\t            break;\n\t        }\n\n\t        ++pos;\n\t        ++runLength;\n\t    }\n\t    result.push(runLength - 1);\n\t    for (var i = offset; i < pos; ++i) {\n\t        result.push((deltas[i] + 256) & 0xff);\n\t    }\n\t    return pos;\n\t}\n\n\t// Helper for encode.VARDELTAS\n\tfunction encodeVarDeltaRunAsWords(deltas, offset, result) {\n\t    var runLength = 0;\n\t    var numDeltas = deltas.length;\n\t    var pos = offset;\n\t    while (pos < numDeltas && runLength < 64) {\n\t        var value = deltas[pos];\n\n\t        // Within a word-encoded run of deltas, it is easiest to start\n\t        // a new run (with a different encoding) whenever we encounter\n\t        // a zero value. For example, the sequence [0x6666, 0, 0x7777]\n\t        // needs 7 bytes when storing the zero inside the current run\n\t        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a\n\t        // new run (40 66 66 80 40 77 77).\n\t        if (value === 0) {\n\t            break;\n\t        }\n\n\t        // Within a word-encoded run of deltas, a single value in the\n\t        // range (-128..127) should be encoded within the current run\n\t        // because it is more compact. For example, the sequence\n\t        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value\n\t        // literally (42 66 66 00 02 77 77), but 8 bytes when starting\n\t        // a new run (40 66 66 00 02 40 77 77).\n\t        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {\n\t            break;\n\t        }\n\n\t        ++pos;\n\t        ++runLength;\n\t    }\n\t    result.push(0x40 | (runLength - 1));\n\t    for (var i = offset; i < pos; ++i) {\n\t        var val = deltas[i];\n\t        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);\n\t    }\n\t    return pos;\n\t}\n\n\t/**\n\t * Encode a list of variation adjustment deltas.\n\t *\n\t * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.\n\t * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted\n\t * when generating instances of variation fonts.\n\t *\n\t * @see https://www.microsoft.com/typography/otspec/gvar.htm\n\t * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html\n\t * @param {Array}\n\t * @return {Array}\n\t */\n\tencode.VARDELTAS = function(deltas) {\n\t    var pos = 0;\n\t    var result = [];\n\t    while (pos < deltas.length) {\n\t        var value = deltas[pos];\n\t        if (value === 0) {\n\t            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);\n\t        } else if (value >= -128 && value <= 127) {\n\t            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);\n\t        } else {\n\t            pos = encodeVarDeltaRunAsWords(deltas, pos, result);\n\t        }\n\t    }\n\t    return result;\n\t};\n\n\t// Convert a list of values to a CFF INDEX structure.\n\t// The values should be objects containing name / type / value.\n\t/**\n\t * @param {Array} l\n\t * @returns {Array}\n\t */\n\tencode.INDEX = function(l) {\n\t    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,\n\t    //    i, v;\n\t    // Because we have to know which data type to use to encode the offsets,\n\t    // we have to go through the values twice: once to encode the data and\n\t    // calculate the offsets, then again to encode the offsets using the fitting data type.\n\t    var offset = 1; // First offset is always 1.\n\t    var offsets = [offset];\n\t    var data = [];\n\t    for (var i = 0; i < l.length; i += 1) {\n\t        var v = encode.OBJECT(l[i]);\n\t        Array.prototype.push.apply(data, v);\n\t        offset += v.length;\n\t        offsets.push(offset);\n\t    }\n\n\t    if (data.length === 0) {\n\t        return [0, 0];\n\t    }\n\n\t    var encodedOffsets = [];\n\t    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;\n\t    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];\n\t    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {\n\t        var encodedOffset = offsetEncoder(offsets[i$1]);\n\t        Array.prototype.push.apply(encodedOffsets, encodedOffset);\n\t    }\n\n\t    return Array.prototype.concat(encode.Card16(l.length),\n\t                           encode.OffSize(offSize),\n\t                           encodedOffsets,\n\t                           data);\n\t};\n\n\t/**\n\t * @param {Array}\n\t * @returns {number}\n\t */\n\tsizeOf.INDEX = function(v) {\n\t    return encode.INDEX(v).length;\n\t};\n\n\t/**\n\t * Convert an object to a CFF DICT structure.\n\t * The keys should be numeric.\n\t * The values should be objects containing name / type / value.\n\t * @param {Object} m\n\t * @returns {Array}\n\t */\n\tencode.DICT = function(m) {\n\t    var d = [];\n\t    var keys = Object.keys(m);\n\t    var length = keys.length;\n\n\t    for (var i = 0; i < length; i += 1) {\n\t        // Object.keys() return string keys, but our keys are always numeric.\n\t        var k = parseInt(keys[i], 0);\n\t        var v = m[k];\n\t        // Value comes before the key.\n\t        d = d.concat(encode.OPERAND(v.value, v.type));\n\t        d = d.concat(encode.OPERATOR(k));\n\t    }\n\n\t    return d;\n\t};\n\n\t/**\n\t * @param {Object}\n\t * @returns {number}\n\t */\n\tsizeOf.DICT = function(m) {\n\t    return encode.DICT(m).length;\n\t};\n\n\t/**\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.OPERATOR = function(v) {\n\t    if (v < 1200) {\n\t        return [v];\n\t    } else {\n\t        return [12, v - 1200];\n\t    }\n\t};\n\n\t/**\n\t * @param {Array} v\n\t * @param {string}\n\t * @returns {Array}\n\t */\n\tencode.OPERAND = function(v, type) {\n\t    var d = [];\n\t    if (Array.isArray(type)) {\n\t        for (var i = 0; i < type.length; i += 1) {\n\t            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);\n\t            d = d.concat(encode.OPERAND(v[i], type[i]));\n\t        }\n\t    } else {\n\t        if (type === 'SID') {\n\t            d = d.concat(encode.NUMBER(v));\n\t        } else if (type === 'offset') {\n\t            // We make it easy for ourselves and always encode offsets as\n\t            // 4 bytes. This makes offset calculation for the top dict easier.\n\t            d = d.concat(encode.NUMBER32(v));\n\t        } else if (type === 'number') {\n\t            d = d.concat(encode.NUMBER(v));\n\t        } else if (type === 'real') {\n\t            d = d.concat(encode.REAL(v));\n\t        } else {\n\t            throw new Error('Unknown operand type ' + type);\n\t            // FIXME Add support for booleans\n\t        }\n\t    }\n\n\t    return d;\n\t};\n\n\tencode.OP = encode.BYTE;\n\tsizeOf.OP = sizeOf.BYTE;\n\n\t// memoize charstring encoding using WeakMap if available\n\tvar wmm = typeof WeakMap === 'function' && new WeakMap();\n\n\t/**\n\t * Convert a list of CharString operations to bytes.\n\t * @param {Array}\n\t * @returns {Array}\n\t */\n\tencode.CHARSTRING = function(ops) {\n\t    // See encode.MACSTRING for why we don't do \"if (wmm && wmm.has(ops))\".\n\t    if (wmm) {\n\t        var cachedValue = wmm.get(ops);\n\t        if (cachedValue !== undefined) {\n\t            return cachedValue;\n\t        }\n\t    }\n\n\t    var d = [];\n\t    var length = ops.length;\n\n\t    for (var i = 0; i < length; i += 1) {\n\t        var op = ops[i];\n\t        d = d.concat(encode[op.type](op.value));\n\t    }\n\n\t    if (wmm) {\n\t        wmm.set(ops, d);\n\t    }\n\n\t    return d;\n\t};\n\n\t/**\n\t * @param {Array}\n\t * @returns {number}\n\t */\n\tsizeOf.CHARSTRING = function(ops) {\n\t    return encode.CHARSTRING(ops).length;\n\t};\n\n\t// Utility functions ////////////////////////////////////////////////////////\n\n\t/**\n\t * Convert an object containing name / type / value to bytes.\n\t * @param {Object}\n\t * @returns {Array}\n\t */\n\tencode.OBJECT = function(v) {\n\t    var encodingFunction = encode[v.type];\n\t    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);\n\t    return encodingFunction(v.value);\n\t};\n\n\t/**\n\t * @param {Object}\n\t * @returns {number}\n\t */\n\tsizeOf.OBJECT = function(v) {\n\t    var sizeOfFunction = sizeOf[v.type];\n\t    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);\n\t    return sizeOfFunction(v.value);\n\t};\n\n\t/**\n\t * Convert a table object to bytes.\n\t * A table contains a list of fields containing the metadata (name, type and default value).\n\t * The table itself has the field values set as attributes.\n\t * @param {opentype.Table}\n\t * @returns {Array}\n\t */\n\tencode.TABLE = function(table) {\n\t    var d = [];\n\t    var length = table.fields.length;\n\t    var subtables = [];\n\t    var subtableOffsets = [];\n\n\t    for (var i = 0; i < length; i += 1) {\n\t        var field = table.fields[i];\n\t        var encodingFunction = encode[field.type];\n\t        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');\n\t        var value = table[field.name];\n\t        if (value === undefined) {\n\t            value = field.value;\n\t        }\n\n\t        var bytes = encodingFunction(value);\n\n\t        if (field.type === 'TABLE') {\n\t            subtableOffsets.push(d.length);\n\t            d = d.concat([0, 0]);\n\t            subtables.push(bytes);\n\t        } else {\n\t            d = d.concat(bytes);\n\t        }\n\t    }\n\n\t    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {\n\t        var o = subtableOffsets[i$1];\n\t        var offset = d.length;\n\t        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');\n\t        d[o] = offset >> 8;\n\t        d[o + 1] = offset & 0xff;\n\t        d = d.concat(subtables[i$1]);\n\t    }\n\n\t    return d;\n\t};\n\n\t/**\n\t * @param {opentype.Table}\n\t * @returns {number}\n\t */\n\tsizeOf.TABLE = function(table) {\n\t    var numBytes = 0;\n\t    var length = table.fields.length;\n\n\t    for (var i = 0; i < length; i += 1) {\n\t        var field = table.fields[i];\n\t        var sizeOfFunction = sizeOf[field.type];\n\t        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');\n\t        var value = table[field.name];\n\t        if (value === undefined) {\n\t            value = field.value;\n\t        }\n\n\t        numBytes += sizeOfFunction(value);\n\n\t        // Subtables take 2 more bytes for offsets.\n\t        if (field.type === 'TABLE') {\n\t            numBytes += 2;\n\t        }\n\t    }\n\n\t    return numBytes;\n\t};\n\n\tencode.RECORD = encode.TABLE;\n\tsizeOf.RECORD = sizeOf.TABLE;\n\n\t// Merge in a list of bytes.\n\tencode.LITERAL = function(v) {\n\t    return v;\n\t};\n\n\tsizeOf.LITERAL = function(v) {\n\t    return v.length;\n\t};\n\n\t// Table metadata\n\n\t/**\n\t * @exports opentype.Table\n\t * @class\n\t * @param {string} tableName\n\t * @param {Array} fields\n\t * @param {Object} options\n\t * @constructor\n\t */\n\tfunction Table(tableName, fields, options) {\n\t    // For coverage tables with coverage format 2, we do not want to add the coverage data directly to the table object,\n\t    // as this will result in wrong encoding order of the coverage data on serialization to bytes.\n\t    // The fallback of using the field values directly when not present on the table is handled in types.encode.TABLE() already.\n\t    if (fields.length && (fields[0].name !== 'coverageFormat' || fields[0].value === 1)) {\n\t        for (var i = 0; i < fields.length; i += 1) {\n\t            var field = fields[i];\n\t            this[field.name] = field.value;\n\t        }\n\t    }\n\n\t    this.tableName = tableName;\n\t    this.fields = fields;\n\t    if (options) {\n\t        var optionKeys = Object.keys(options);\n\t        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {\n\t            var k = optionKeys[i$1];\n\t            var v = options[k];\n\t            if (this[k] !== undefined) {\n\t                this[k] = v;\n\t            }\n\t        }\n\t    }\n\t}\n\n\t/**\n\t * Encodes the table and returns an array of bytes\n\t * @return {Array}\n\t */\n\tTable.prototype.encode = function() {\n\t    return encode.TABLE(this);\n\t};\n\n\t/**\n\t * Get the size of the table.\n\t * @return {number}\n\t */\n\tTable.prototype.sizeOf = function() {\n\t    return sizeOf.TABLE(this);\n\t};\n\n\t/**\n\t * @private\n\t */\n\tfunction ushortList(itemName, list, count) {\n\t    if (count === undefined) {\n\t        count = list.length;\n\t    }\n\t    var fields = new Array(list.length + 1);\n\t    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n\t    for (var i = 0; i < list.length; i++) {\n\t        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};\n\t    }\n\t    return fields;\n\t}\n\n\t/**\n\t * @private\n\t */\n\tfunction tableList(itemName, records, itemCallback) {\n\t    var count = records.length;\n\t    var fields = new Array(count + 1);\n\t    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n\t    for (var i = 0; i < count; i++) {\n\t        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};\n\t    }\n\t    return fields;\n\t}\n\n\t/**\n\t * @private\n\t */\n\tfunction recordList(itemName, records, itemCallback) {\n\t    var count = records.length;\n\t    var fields = [];\n\t    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n\t    for (var i = 0; i < count; i++) {\n\t        fields = fields.concat(itemCallback(records[i], i));\n\t    }\n\t    return fields;\n\t}\n\n\t// Common Layout Tables\n\n\t/**\n\t * @exports opentype.Coverage\n\t * @class\n\t * @param {opentype.Table}\n\t * @constructor\n\t * @extends opentype.Table\n\t */\n\tfunction Coverage(coverageTable) {\n\t    if (coverageTable.format === 1) {\n\t        Table.call(this, 'coverageTable',\n\t            [{name: 'coverageFormat', type: 'USHORT', value: 1}]\n\t            .concat(ushortList('glyph', coverageTable.glyphs))\n\t        );\n\t    } else if (coverageTable.format === 2) {\n\t        Table.call(this, 'coverageTable',\n\t            [{name: 'coverageFormat', type: 'USHORT', value: 2}]\n\t            .concat(recordList('rangeRecord', coverageTable.ranges, function(RangeRecord) {\n\t                return [\n\t                    {name: 'startGlyphID', type: 'USHORT', value: RangeRecord.start},\n\t                    {name: 'endGlyphID', type: 'USHORT', value: RangeRecord.end},\n\t                    {name: 'startCoverageIndex', type: 'USHORT', value: RangeRecord.index} ];\n\t            }))\n\t        );\n\t    } else {\n\t        check.assert(false, 'Coverage format must be 1 or 2.');\n\t    }\n\t}\n\tCoverage.prototype = Object.create(Table.prototype);\n\tCoverage.prototype.constructor = Coverage;\n\n\tfunction ScriptList(scriptListTable) {\n\t    Table.call(this, 'scriptListTable',\n\t        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {\n\t            var script = scriptRecord.script;\n\t            var defaultLangSys = script.defaultLangSys;\n\t            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');\n\t            return [\n\t                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},\n\t                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [\n\t                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [\n\t                        {name: 'lookupOrder', type: 'USHORT', value: 0},\n\t                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]\n\t                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}\n\t                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {\n\t                        var langSys = langSysRecord.langSys;\n\t                        return [\n\t                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},\n\t                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [\n\t                                {name: 'lookupOrder', type: 'USHORT', value: 0},\n\t                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}\n\t                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}\n\t                        ];\n\t                    })))}\n\t            ];\n\t        })\n\t    );\n\t}\n\tScriptList.prototype = Object.create(Table.prototype);\n\tScriptList.prototype.constructor = ScriptList;\n\n\t/**\n\t * @exports opentype.FeatureList\n\t * @class\n\t * @param {opentype.Table}\n\t * @constructor\n\t * @extends opentype.Table\n\t */\n\tfunction FeatureList(featureListTable) {\n\t    Table.call(this, 'featureListTable',\n\t        recordList('featureRecord', featureListTable, function(featureRecord, i) {\n\t            var feature = featureRecord.feature;\n\t            return [\n\t                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},\n\t                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [\n\t                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}\n\t            ];\n\t        })\n\t    );\n\t}\n\tFeatureList.prototype = Object.create(Table.prototype);\n\tFeatureList.prototype.constructor = FeatureList;\n\n\t/**\n\t * @exports opentype.LookupList\n\t * @class\n\t * @param {opentype.Table}\n\t * @param {Object}\n\t * @constructor\n\t * @extends opentype.Table\n\t */\n\tfunction LookupList(lookupListTable, subtableMakers) {\n\t    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {\n\t        var subtableCallback = subtableMakers[lookupTable.lookupType];\n\t        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');\n\t        return new Table('lookupTable', [\n\t            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},\n\t            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}\n\t        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));\n\t    }));\n\t}\n\tLookupList.prototype = Object.create(Table.prototype);\n\tLookupList.prototype.constructor = LookupList;\n\n\t// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)\n\t// Don't use offsets inside Records (probable bug), only in Tables.\n\tvar table = {\n\t    Table: Table,\n\t    Record: Table,\n\t    Coverage: Coverage,\n\t    ScriptList: ScriptList,\n\t    FeatureList: FeatureList,\n\t    LookupList: LookupList,\n\t    ushortList: ushortList,\n\t    tableList: tableList,\n\t    recordList: recordList,\n\t};\n\n\t// Parsing utility functions\n\n\t// Retrieve an unsigned byte from the DataView.\n\tfunction getByte(dataView, offset) {\n\t    return dataView.getUint8(offset);\n\t}\n\n\t// Retrieve an unsigned 16-bit short from the DataView.\n\t// The value is stored in big endian.\n\tfunction getUShort(dataView, offset) {\n\t    return dataView.getUint16(offset, false);\n\t}\n\n\t// Retrieve a signed 16-bit short from the DataView.\n\t// The value is stored in big endian.\n\tfunction getShort(dataView, offset) {\n\t    return dataView.getInt16(offset, false);\n\t}\n\n\t// Retrieve an unsigned 32-bit long from the DataView.\n\t// The value is stored in big endian.\n\tfunction getULong(dataView, offset) {\n\t    return dataView.getUint32(offset, false);\n\t}\n\n\t// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n\t// The value is stored in big endian.\n\tfunction getFixed(dataView, offset) {\n\t    var decimal = dataView.getInt16(offset, false);\n\t    var fraction = dataView.getUint16(offset + 2, false);\n\t    return decimal + fraction / 65535;\n\t}\n\n\t// Retrieve a 4-character tag from the DataView.\n\t// Tags are used to identify tables.\n\tfunction getTag(dataView, offset) {\n\t    var tag = '';\n\t    for (var i = offset; i < offset + 4; i += 1) {\n\t        tag += String.fromCharCode(dataView.getInt8(i));\n\t    }\n\n\t    return tag;\n\t}\n\n\t// Retrieve an offset from the DataView.\n\t// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\n\tfunction getOffset(dataView, offset, offSize) {\n\t    var v = 0;\n\t    for (var i = 0; i < offSize; i += 1) {\n\t        v <<= 8;\n\t        v += dataView.getUint8(offset + i);\n\t    }\n\n\t    return v;\n\t}\n\n\t// Retrieve a number of bytes from start offset to the end offset from the DataView.\n\tfunction getBytes(dataView, startOffset, endOffset) {\n\t    var bytes = [];\n\t    for (var i = startOffset; i < endOffset; i += 1) {\n\t        bytes.push(dataView.getUint8(i));\n\t    }\n\n\t    return bytes;\n\t}\n\n\t// Convert the list of bytes to a string.\n\tfunction bytesToString(bytes) {\n\t    var s = '';\n\t    for (var i = 0; i < bytes.length; i += 1) {\n\t        s += String.fromCharCode(bytes[i]);\n\t    }\n\n\t    return s;\n\t}\n\n\tvar typeOffsets = {\n\t    byte: 1,\n\t    uShort: 2,\n\t    short: 2,\n\t    uLong: 4,\n\t    fixed: 4,\n\t    longDateTime: 8,\n\t    tag: 4\n\t};\n\n\t// A stateful parser that changes the offset whenever a value is retrieved.\n\t// The data is a DataView.\n\tfunction Parser(data, offset) {\n\t    this.data = data;\n\t    this.offset = offset;\n\t    this.relativeOffset = 0;\n\t}\n\n\tParser.prototype.parseByte = function() {\n\t    var v = this.data.getUint8(this.offset + this.relativeOffset);\n\t    this.relativeOffset += 1;\n\t    return v;\n\t};\n\n\tParser.prototype.parseChar = function() {\n\t    var v = this.data.getInt8(this.offset + this.relativeOffset);\n\t    this.relativeOffset += 1;\n\t    return v;\n\t};\n\n\tParser.prototype.parseCard8 = Parser.prototype.parseByte;\n\n\tParser.prototype.parseUShort = function() {\n\t    var v = this.data.getUint16(this.offset + this.relativeOffset);\n\t    this.relativeOffset += 2;\n\t    return v;\n\t};\n\n\tParser.prototype.parseCard16 = Parser.prototype.parseUShort;\n\tParser.prototype.parseSID = Parser.prototype.parseUShort;\n\tParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\n\tParser.prototype.parseShort = function() {\n\t    var v = this.data.getInt16(this.offset + this.relativeOffset);\n\t    this.relativeOffset += 2;\n\t    return v;\n\t};\n\n\tParser.prototype.parseF2Dot14 = function() {\n\t    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n\t    this.relativeOffset += 2;\n\t    return v;\n\t};\n\n\tParser.prototype.parseULong = function() {\n\t    var v = getULong(this.data, this.offset + this.relativeOffset);\n\t    this.relativeOffset += 4;\n\t    return v;\n\t};\n\n\tParser.prototype.parseOffset32 = Parser.prototype.parseULong;\n\n\tParser.prototype.parseFixed = function() {\n\t    var v = getFixed(this.data, this.offset + this.relativeOffset);\n\t    this.relativeOffset += 4;\n\t    return v;\n\t};\n\n\tParser.prototype.parseString = function(length) {\n\t    var dataView = this.data;\n\t    var offset = this.offset + this.relativeOffset;\n\t    var string = '';\n\t    this.relativeOffset += length;\n\t    for (var i = 0; i < length; i++) {\n\t        string += String.fromCharCode(dataView.getUint8(offset + i));\n\t    }\n\n\t    return string;\n\t};\n\n\tParser.prototype.parseTag = function() {\n\t    return this.parseString(4);\n\t};\n\n\t// LONGDATETIME is a 64-bit integer.\n\t// JavaScript and unix timestamps traditionally use 32 bits, so we\n\t// only take the last 32 bits.\n\t// + Since until 2038 those bits will be filled by zeros we can ignore them.\n\tParser.prototype.parseLongDateTime = function() {\n\t    var v = getULong(this.data, this.offset + this.relativeOffset + 4);\n\t    // Subtract seconds between 01/01/1904 and 01/01/1970\n\t    // to convert Apple Mac timestamp to Standard Unix timestamp\n\t    v -= 2082844800;\n\t    this.relativeOffset += 8;\n\t    return v;\n\t};\n\n\tParser.prototype.parseVersion = function(minorBase) {\n\t    var major = getUShort(this.data, this.offset + this.relativeOffset);\n\n\t    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n\t    // Default returns the correct number if minor = 0xN000 where N is 0-9\n\t    // Set minorBase to 1 for tables that use minor = N where N is 0-9\n\t    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n\t    this.relativeOffset += 4;\n\t    if (minorBase === undefined) { minorBase = 0x1000; }\n\t    return major + minor / minorBase / 10;\n\t};\n\n\tParser.prototype.skip = function(type, amount) {\n\t    if (amount === undefined) {\n\t        amount = 1;\n\t    }\n\n\t    this.relativeOffset += typeOffsets[type] * amount;\n\t};\n\n\t///// Parsing lists and records ///////////////////////////////\n\n\t// Parse a list of 32 bit unsigned integers.\n\tParser.prototype.parseULongList = function(count) {\n\t    if (count === undefined) { count = this.parseULong(); }\n\t    var offsets = new Array(count);\n\t    var dataView = this.data;\n\t    var offset = this.offset + this.relativeOffset;\n\t    for (var i = 0; i < count; i++) {\n\t        offsets[i] = dataView.getUint32(offset);\n\t        offset += 4;\n\t    }\n\n\t    this.relativeOffset += count * 4;\n\t    return offsets;\n\t};\n\n\t// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n\t// or provided as an argument.\n\tParser.prototype.parseOffset16List =\n\tParser.prototype.parseUShortList = function(count) {\n\t    if (count === undefined) { count = this.parseUShort(); }\n\t    var offsets = new Array(count);\n\t    var dataView = this.data;\n\t    var offset = this.offset + this.relativeOffset;\n\t    for (var i = 0; i < count; i++) {\n\t        offsets[i] = dataView.getUint16(offset);\n\t        offset += 2;\n\t    }\n\n\t    this.relativeOffset += count * 2;\n\t    return offsets;\n\t};\n\n\t// Parses a list of 16 bit signed integers.\n\tParser.prototype.parseShortList = function(count) {\n\t    var list = new Array(count);\n\t    var dataView = this.data;\n\t    var offset = this.offset + this.relativeOffset;\n\t    for (var i = 0; i < count; i++) {\n\t        list[i] = dataView.getInt16(offset);\n\t        offset += 2;\n\t    }\n\n\t    this.relativeOffset += count * 2;\n\t    return list;\n\t};\n\n\t// Parses a list of bytes.\n\tParser.prototype.parseByteList = function(count) {\n\t    var list = new Array(count);\n\t    var dataView = this.data;\n\t    var offset = this.offset + this.relativeOffset;\n\t    for (var i = 0; i < count; i++) {\n\t        list[i] = dataView.getUint8(offset++);\n\t    }\n\n\t    this.relativeOffset += count;\n\t    return list;\n\t};\n\n\t/**\n\t * Parse a list of items.\n\t * Record count is optional, if omitted it is read from the stream.\n\t * itemCallback is one of the Parser methods.\n\t */\n\tParser.prototype.parseList = function(count, itemCallback) {\n\t    if (!itemCallback) {\n\t        itemCallback = count;\n\t        count = this.parseUShort();\n\t    }\n\t    var list = new Array(count);\n\t    for (var i = 0; i < count; i++) {\n\t        list[i] = itemCallback.call(this);\n\t    }\n\t    return list;\n\t};\n\n\tParser.prototype.parseList32 = function(count, itemCallback) {\n\t    if (!itemCallback) {\n\t        itemCallback = count;\n\t        count = this.parseULong();\n\t    }\n\t    var list = new Array(count);\n\t    for (var i = 0; i < count; i++) {\n\t        list[i] = itemCallback.call(this);\n\t    }\n\t    return list;\n\t};\n\n\t/**\n\t * Parse a list of records.\n\t * Record count is optional, if omitted it is read from the stream.\n\t * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n\t */\n\tParser.prototype.parseRecordList = function(count, recordDescription) {\n\t    // If the count argument is absent, read it in the stream.\n\t    if (!recordDescription) {\n\t        recordDescription = count;\n\t        count = this.parseUShort();\n\t    }\n\t    var records = new Array(count);\n\t    var fields = Object.keys(recordDescription);\n\t    for (var i = 0; i < count; i++) {\n\t        var rec = {};\n\t        for (var j = 0; j < fields.length; j++) {\n\t            var fieldName = fields[j];\n\t            var fieldType = recordDescription[fieldName];\n\t            rec[fieldName] = fieldType.call(this);\n\t        }\n\t        records[i] = rec;\n\t    }\n\t    return records;\n\t};\n\n\tParser.prototype.parseRecordList32 = function(count, recordDescription) {\n\t    // If the count argument is absent, read it in the stream.\n\t    if (!recordDescription) {\n\t        recordDescription = count;\n\t        count = this.parseULong();\n\t    }\n\t    var records = new Array(count);\n\t    var fields = Object.keys(recordDescription);\n\t    for (var i = 0; i < count; i++) {\n\t        var rec = {};\n\t        for (var j = 0; j < fields.length; j++) {\n\t            var fieldName = fields[j];\n\t            var fieldType = recordDescription[fieldName];\n\t            rec[fieldName] = fieldType.call(this);\n\t        }\n\t        records[i] = rec;\n\t    }\n\t    return records;\n\t};\n\n\t// Parse a data structure into an object\n\t// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n\tParser.prototype.parseStruct = function(description) {\n\t    if (typeof description === 'function') {\n\t        return description.call(this);\n\t    } else {\n\t        var fields = Object.keys(description);\n\t        var struct = {};\n\t        for (var j = 0; j < fields.length; j++) {\n\t            var fieldName = fields[j];\n\t            var fieldType = description[fieldName];\n\t            struct[fieldName] = fieldType.call(this);\n\t        }\n\t        return struct;\n\t    }\n\t};\n\n\t/**\n\t * Parse a GPOS valueRecord\n\t * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n\t * valueFormat is optional, if omitted it is read from the stream.\n\t */\n\tParser.prototype.parseValueRecord = function(valueFormat) {\n\t    if (valueFormat === undefined) {\n\t        valueFormat = this.parseUShort();\n\t    }\n\t    if (valueFormat === 0) {\n\t        // valueFormat2 in kerning pairs is most often 0\n\t        // in this case return undefined instead of an empty object, to save space\n\t        return;\n\t    }\n\t    var valueRecord = {};\n\n\t    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }\n\t    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }\n\t    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }\n\t    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }\n\n\t    // Device table (non-variable font) / VariationIndex table (variable font) not supported\n\t    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls\n\t    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }\n\t    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }\n\t    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }\n\t    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }\n\n\t    return valueRecord;\n\t};\n\n\t/**\n\t * Parse a list of GPOS valueRecords\n\t * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n\t * valueFormat and valueCount are read from the stream.\n\t */\n\tParser.prototype.parseValueRecordList = function() {\n\t    var valueFormat = this.parseUShort();\n\t    var valueCount = this.parseUShort();\n\t    var values = new Array(valueCount);\n\t    for (var i = 0; i < valueCount; i++) {\n\t        values[i] = this.parseValueRecord(valueFormat);\n\t    }\n\t    return values;\n\t};\n\n\tParser.prototype.parsePointer = function(description) {\n\t    var structOffset = this.parseOffset16();\n\t    if (structOffset > 0) {\n\t        // NULL offset => return undefined\n\t        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n\t    }\n\t    return undefined;\n\t};\n\n\tParser.prototype.parsePointer32 = function(description) {\n\t    var structOffset = this.parseOffset32();\n\t    if (structOffset > 0) {\n\t        // NULL offset => return undefined\n\t        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n\t    }\n\t    return undefined;\n\t};\n\n\t/**\n\t * Parse a list of offsets to lists of 16-bit integers,\n\t * or a list of offsets to lists of offsets to any kind of items.\n\t * If itemCallback is not provided, a list of list of UShort is assumed.\n\t * If provided, itemCallback is called on each item and must parse the item.\n\t * See examples in tables/gsub.js\n\t */\n\tParser.prototype.parseListOfLists = function(itemCallback) {\n\t    var offsets = this.parseOffset16List();\n\t    var count = offsets.length;\n\t    var relativeOffset = this.relativeOffset;\n\t    var list = new Array(count);\n\t    for (var i = 0; i < count; i++) {\n\t        var start = offsets[i];\n\t        if (start === 0) {\n\t            // NULL offset\n\t            // Add i as owned property to list. Convenient with assert.\n\t            list[i] = undefined;\n\t            continue;\n\t        }\n\t        this.relativeOffset = start;\n\t        if (itemCallback) {\n\t            var subOffsets = this.parseOffset16List();\n\t            var subList = new Array(subOffsets.length);\n\t            for (var j = 0; j < subOffsets.length; j++) {\n\t                this.relativeOffset = start + subOffsets[j];\n\t                subList[j] = itemCallback.call(this);\n\t            }\n\t            list[i] = subList;\n\t        } else {\n\t            list[i] = this.parseUShortList();\n\t        }\n\t    }\n\t    this.relativeOffset = relativeOffset;\n\t    return list;\n\t};\n\n\t///// Complex tables parsing //////////////////////////////////\n\n\t// Parse a coverage table in a GSUB, GPOS or GDEF table.\n\t// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\t// parser.offset must point to the start of the table containing the coverage.\n\tParser.prototype.parseCoverage = function() {\n\t    var startOffset = this.offset + this.relativeOffset;\n\t    var format = this.parseUShort();\n\t    var count = this.parseUShort();\n\t    if (format === 1) {\n\t        return {\n\t            format: 1,\n\t            glyphs: this.parseUShortList(count)\n\t        };\n\t    } else if (format === 2) {\n\t        var ranges = new Array(count);\n\t        for (var i = 0; i < count; i++) {\n\t            ranges[i] = {\n\t                start: this.parseUShort(),\n\t                end: this.parseUShort(),\n\t                index: this.parseUShort()\n\t            };\n\t        }\n\t        return {\n\t            format: 2,\n\t            ranges: ranges\n\t        };\n\t    }\n\t    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');\n\t};\n\n\t// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n\t// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\tParser.prototype.parseClassDef = function() {\n\t    var startOffset = this.offset + this.relativeOffset;\n\t    var format = this.parseUShort();\n\t    if (format === 1) {\n\t        return {\n\t            format: 1,\n\t            startGlyph: this.parseUShort(),\n\t            classes: this.parseUShortList()\n\t        };\n\t    } else if (format === 2) {\n\t        return {\n\t            format: 2,\n\t            ranges: this.parseRecordList({\n\t                start: Parser.uShort,\n\t                end: Parser.uShort,\n\t                classId: Parser.uShort\n\t            })\n\t        };\n\t    }\n\t    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');\n\t};\n\n\t///// Static methods ///////////////////////////////////\n\t// These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\n\tParser.list = function(count, itemCallback) {\n\t    return function() {\n\t        return this.parseList(count, itemCallback);\n\t    };\n\t};\n\n\tParser.list32 = function(count, itemCallback) {\n\t    return function() {\n\t        return this.parseList32(count, itemCallback);\n\t    };\n\t};\n\n\tParser.recordList = function(count, recordDescription) {\n\t    return function() {\n\t        return this.parseRecordList(count, recordDescription);\n\t    };\n\t};\n\n\tParser.recordList32 = function(count, recordDescription) {\n\t    return function() {\n\t        return this.parseRecordList32(count, recordDescription);\n\t    };\n\t};\n\n\tParser.pointer = function(description) {\n\t    return function() {\n\t        return this.parsePointer(description);\n\t    };\n\t};\n\n\tParser.pointer32 = function(description) {\n\t    return function() {\n\t        return this.parsePointer32(description);\n\t    };\n\t};\n\n\tParser.tag = Parser.prototype.parseTag;\n\tParser.byte = Parser.prototype.parseByte;\n\tParser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\n\tParser.uShortList = Parser.prototype.parseUShortList;\n\tParser.uLong = Parser.offset32 = Parser.prototype.parseULong;\n\tParser.uLongList = Parser.prototype.parseULongList;\n\tParser.struct = Parser.prototype.parseStruct;\n\tParser.coverage = Parser.prototype.parseCoverage;\n\tParser.classDef = Parser.prototype.parseClassDef;\n\n\t///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n\t// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\n\tvar langSysTable = {\n\t    reserved: Parser.uShort,\n\t    reqFeatureIndex: Parser.uShort,\n\t    featureIndexes: Parser.uShortList\n\t};\n\n\tParser.prototype.parseScriptList = function() {\n\t    return this.parsePointer(Parser.recordList({\n\t        tag: Parser.tag,\n\t        script: Parser.pointer({\n\t            defaultLangSys: Parser.pointer(langSysTable),\n\t            langSysRecords: Parser.recordList({\n\t                tag: Parser.tag,\n\t                langSys: Parser.pointer(langSysTable)\n\t            })\n\t        })\n\t    })) || [];\n\t};\n\n\tParser.prototype.parseFeatureList = function() {\n\t    return this.parsePointer(Parser.recordList({\n\t        tag: Parser.tag,\n\t        feature: Parser.pointer({\n\t            featureParams: Parser.offset16,\n\t            lookupListIndexes: Parser.uShortList\n\t        })\n\t    })) || [];\n\t};\n\n\tParser.prototype.parseLookupList = function(lookupTableParsers) {\n\t    return this.parsePointer(Parser.list(Parser.pointer(function() {\n\t        var lookupType = this.parseUShort();\n\t        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');\n\t        var lookupFlag = this.parseUShort();\n\t        var useMarkFilteringSet = lookupFlag & 0x10;\n\t        return {\n\t            lookupType: lookupType,\n\t            lookupFlag: lookupFlag,\n\t            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n\t            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n\t        };\n\t    }))) || [];\n\t};\n\n\tParser.prototype.parseFeatureVariationsList = function() {\n\t    return this.parsePointer32(function() {\n\t        var majorVersion = this.parseUShort();\n\t        var minorVersion = this.parseUShort();\n\t        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');\n\t        var featureVariations = this.parseRecordList32({\n\t            conditionSetOffset: Parser.offset32,\n\t            featureTableSubstitutionOffset: Parser.offset32\n\t        });\n\t        return featureVariations;\n\t    }) || [];\n\t};\n\n\tvar parse = {\n\t    getByte: getByte,\n\t    getCard8: getByte,\n\t    getUShort: getUShort,\n\t    getCard16: getUShort,\n\t    getShort: getShort,\n\t    getULong: getULong,\n\t    getFixed: getFixed,\n\t    getTag: getTag,\n\t    getOffset: getOffset,\n\t    getBytes: getBytes,\n\t    bytesToString: bytesToString,\n\t    Parser: Parser,\n\t};\n\n\t// The `cmap` table stores the mappings from characters to glyphs.\n\n\tfunction parseCmapTableFormat12(cmap, p) {\n\t    //Skip reserved.\n\t    p.parseUShort();\n\n\t    // Length in bytes of the sub-tables.\n\t    cmap.length = p.parseULong();\n\t    cmap.language = p.parseULong();\n\n\t    var groupCount;\n\t    cmap.groupCount = groupCount = p.parseULong();\n\t    cmap.glyphIndexMap = {};\n\n\t    for (var i = 0; i < groupCount; i += 1) {\n\t        var startCharCode = p.parseULong();\n\t        var endCharCode = p.parseULong();\n\t        var startGlyphId = p.parseULong();\n\n\t        for (var c = startCharCode; c <= endCharCode; c += 1) {\n\t            cmap.glyphIndexMap[c] = startGlyphId;\n\t            startGlyphId++;\n\t        }\n\t    }\n\t}\n\n\tfunction parseCmapTableFormat4(cmap, p, data, start, offset) {\n\t    // Length in bytes of the sub-tables.\n\t    cmap.length = p.parseUShort();\n\t    cmap.language = p.parseUShort();\n\n\t    // segCount is stored x 2.\n\t    var segCount;\n\t    cmap.segCount = segCount = p.parseUShort() >> 1;\n\n\t    // Skip searchRange, entrySelector, rangeShift.\n\t    p.skip('uShort', 3);\n\n\t    // The \"unrolled\" mapping from character codes to glyph indices.\n\t    cmap.glyphIndexMap = {};\n\t    var endCountParser = new parse.Parser(data, start + offset + 14);\n\t    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);\n\t    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);\n\t    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);\n\t    var glyphIndexOffset = start + offset + 16 + segCount * 8;\n\t    for (var i = 0; i < segCount - 1; i += 1) {\n\t        var glyphIndex = (void 0);\n\t        var endCount = endCountParser.parseUShort();\n\t        var startCount = startCountParser.parseUShort();\n\t        var idDelta = idDeltaParser.parseShort();\n\t        var idRangeOffset = idRangeOffsetParser.parseUShort();\n\t        for (var c = startCount; c <= endCount; c += 1) {\n\t            if (idRangeOffset !== 0) {\n\t                // The idRangeOffset is relative to the current position in the idRangeOffset array.\n\t                // Take the current offset in the idRangeOffset array.\n\t                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);\n\n\t                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n\t                glyphIndexOffset += idRangeOffset;\n\n\t                // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n\t                glyphIndexOffset += (c - startCount) * 2;\n\t                glyphIndex = parse.getUShort(data, glyphIndexOffset);\n\t                if (glyphIndex !== 0) {\n\t                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;\n\t                }\n\t            } else {\n\t                glyphIndex = (c + idDelta) & 0xFFFF;\n\t            }\n\n\t            cmap.glyphIndexMap[c] = glyphIndex;\n\t        }\n\t    }\n\t}\n\n\t// Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n\t// There are many available formats, but we only support the Windows format 4 and 12.\n\t// This function returns a `CmapEncoding` object or null if no supported format could be found.\n\tfunction parseCmapTable(data, start) {\n\t    var cmap = {};\n\t    cmap.version = parse.getUShort(data, start);\n\t    check.argument(cmap.version === 0, 'cmap table version should be 0.');\n\n\t    // The cmap table can contain many sub-tables, each with their own format.\n\t    // We're only interested in a \"platform 0\" (Unicode format) and \"platform 3\" (Windows format) table.\n\t    cmap.numTables = parse.getUShort(data, start + 2);\n\t    var offset = -1;\n\t    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {\n\t        var platformId = parse.getUShort(data, start + 4 + (i * 8));\n\t        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);\n\t        if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||\n\t            (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {\n\t            offset = parse.getULong(data, start + 4 + (i * 8) + 4);\n\t            break;\n\t        }\n\t    }\n\n\t    if (offset === -1) {\n\t        // There is no cmap table in the font that we support.\n\t        throw new Error('No valid cmap sub-tables found.');\n\t    }\n\n\t    var p = new parse.Parser(data, start + offset);\n\t    cmap.format = p.parseUShort();\n\n\t    if (cmap.format === 12) {\n\t        parseCmapTableFormat12(cmap, p);\n\t    } else if (cmap.format === 4) {\n\t        parseCmapTableFormat4(cmap, p, data, start, offset);\n\t    } else {\n\t        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');\n\t    }\n\n\t    return cmap;\n\t}\n\n\tfunction addSegment(t, code, glyphIndex) {\n\t    t.segments.push({\n\t        end: code,\n\t        start: code,\n\t        delta: -(code - glyphIndex),\n\t        offset: 0,\n\t        glyphIndex: glyphIndex\n\t    });\n\t}\n\n\tfunction addTerminatorSegment(t) {\n\t    t.segments.push({\n\t        end: 0xFFFF,\n\t        start: 0xFFFF,\n\t        delta: 1,\n\t        offset: 0\n\t    });\n\t}\n\n\t// Make cmap table, format 4 by default, 12 if needed only\n\tfunction makeCmapTable(glyphs) {\n\t    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)\n\t    var isPlan0Only = true;\n\t    var i;\n\n\t    // Check if we need to add cmap format 12 or if format 4 only is fine\n\t    for (i = glyphs.length - 1; i > 0; i -= 1) {\n\t        var g = glyphs.get(i);\n\t        if (g.unicode > 65535) {\n\t            console.log('Adding CMAP format 12 (needed!)');\n\t            isPlan0Only = false;\n\t            break;\n\t        }\n\t    }\n\n\t    var cmapTable = [\n\t        {name: 'version', type: 'USHORT', value: 0},\n\t        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},\n\n\t        // CMAP 4 header\n\t        {name: 'platformID', type: 'USHORT', value: 3},\n\t        {name: 'encodingID', type: 'USHORT', value: 1},\n\t        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}\n\t    ];\n\n\t    if (!isPlan0Only)\n\t        { cmapTable = cmapTable.concat([\n\t            // CMAP 12 header\n\t            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere\n\t            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},\n\t            {name: 'cmap12Offset', type: 'ULONG', value: 0}\n\t        ]); }\n\n\t    cmapTable = cmapTable.concat([\n\t        // CMAP 4 Subtable\n\t        {name: 'format', type: 'USHORT', value: 4},\n\t        {name: 'cmap4Length', type: 'USHORT', value: 0},\n\t        {name: 'language', type: 'USHORT', value: 0},\n\t        {name: 'segCountX2', type: 'USHORT', value: 0},\n\t        {name: 'searchRange', type: 'USHORT', value: 0},\n\t        {name: 'entrySelector', type: 'USHORT', value: 0},\n\t        {name: 'rangeShift', type: 'USHORT', value: 0}\n\t    ]);\n\n\t    var t = new table.Table('cmap', cmapTable);\n\n\t    t.segments = [];\n\t    for (i = 0; i < glyphs.length; i += 1) {\n\t        var glyph = glyphs.get(i);\n\t        for (var j = 0; j < glyph.unicodes.length; j += 1) {\n\t            addSegment(t, glyph.unicodes[j], i);\n\t        }\n\n\t        t.segments = t.segments.sort(function (a, b) {\n\t            return a.start - b.start;\n\t        });\n\t    }\n\n\t    addTerminatorSegment(t);\n\n\t    var segCount = t.segments.length;\n\t    var segCountToRemove = 0;\n\n\t    // CMAP 4\n\t    // Set up parallel segment arrays.\n\t    var endCounts = [];\n\t    var startCounts = [];\n\t    var idDeltas = [];\n\t    var idRangeOffsets = [];\n\t    var glyphIds = [];\n\n\t    // CMAP 12\n\t    var cmap12Groups = [];\n\n\t    // Reminder this loop is not following the specification at 100%\n\t    // The specification -> find suites of characters and make a group\n\t    // Here we're doing one group for each letter\n\t    // Doing as the spec can save 8 times (or more) space\n\t    for (i = 0; i < segCount; i += 1) {\n\t        var segment = t.segments[i];\n\n\t        // CMAP 4\n\t        if (segment.end <= 65535 && segment.start <= 65535) {\n\t            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});\n\t            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});\n\t            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});\n\t            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});\n\t            if (segment.glyphId !== undefined) {\n\t                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});\n\t            }\n\t        } else {\n\t            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12\n\t            segCountToRemove += 1;\n\t        }\n\n\t        // CMAP 12\n\t        // Skip Terminator Segment\n\t        if (!isPlan0Only && segment.glyphIndex !== undefined) {\n\t            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});\n\t            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});\n\t            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});\n\t        }\n\t    }\n\n\t    // CMAP 4 Subtable\n\t    t.segCountX2 = (segCount - segCountToRemove) * 2;\n\t    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;\n\t    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);\n\t    t.rangeShift = t.segCountX2 - t.searchRange;\n\n\t    t.fields = t.fields.concat(endCounts);\n\t    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});\n\t    t.fields = t.fields.concat(startCounts);\n\t    t.fields = t.fields.concat(idDeltas);\n\t    t.fields = t.fields.concat(idRangeOffsets);\n\t    t.fields = t.fields.concat(glyphIds);\n\n\t    t.cmap4Length = 14 + // Subtable header\n\t        endCounts.length * 2 +\n\t        2 + // reservedPad\n\t        startCounts.length * 2 +\n\t        idDeltas.length * 2 +\n\t        idRangeOffsets.length * 2 +\n\t        glyphIds.length * 2;\n\n\t    if (!isPlan0Only) {\n\t        // CMAP 12 Subtable\n\t        var cmap12Length = 16 + // Subtable header\n\t            cmap12Groups.length * 4;\n\n\t        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;\n\t        t.fields = t.fields.concat([\n\t            {name: 'cmap12Format', type: 'USHORT', value: 12},\n\t            {name: 'cmap12Reserved', type: 'USHORT', value: 0},\n\t            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},\n\t            {name: 'cmap12Language', type: 'ULONG', value: 0},\n\t            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}\n\t        ]);\n\n\t        t.fields = t.fields.concat(cmap12Groups);\n\t    }\n\n\t    return t;\n\t}\n\n\tvar cmap = { parse: parseCmapTable, make: makeCmapTable };\n\n\t// Glyph encoding\n\n\tvar cffStandardStrings = [\n\t    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n\t    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n\t    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n\t    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n\t    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n\t    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',\n\t    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',\n\t    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',\n\t    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',\n\t    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',\n\t    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',\n\t    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',\n\t    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',\n\t    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',\n\t    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',\n\t    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',\n\t    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',\n\t    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',\n\t    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',\n\t    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',\n\t    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',\n\t    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',\n\t    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',\n\t    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',\n\t    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\n\t    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',\n\t    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n\t    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n\t    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n\t    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',\n\t    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',\n\t    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',\n\t    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',\n\t    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\n\t    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',\n\t    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',\n\t    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',\n\t    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',\n\t    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',\n\t    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',\n\t    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',\n\t    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];\n\n\tvar cffStandardEncoding = [\n\t    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n\t    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n\t    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n\t    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n\t    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n\t    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n\t    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',\n\t    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n\t    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',\n\t    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',\n\t    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',\n\t    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',\n\t    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',\n\t    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',\n\t    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',\n\t    'lslash', 'oslash', 'oe', 'germandbls'];\n\n\tvar cffExpertEncoding = [\n\t    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n\t    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',\n\t    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',\n\t    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\n\t    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',\n\t    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',\n\t    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',\n\t    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',\n\t    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n\t    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n\t    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n\t    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',\n\t    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n\t    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\n\t    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',\n\t    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',\n\t    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',\n\t    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n\t    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',\n\t    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',\n\t    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',\n\t    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',\n\t    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\n\t    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',\n\t    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\n\t    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];\n\n\tvar standardNames = [\n\t    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',\n\t    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',\n\t    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',\n\t    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n\t    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',\n\t    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n\t    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',\n\t    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',\n\t    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',\n\t    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',\n\t    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',\n\t    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',\n\t    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',\n\t    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',\n\t    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',\n\t    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',\n\t    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',\n\t    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',\n\t    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',\n\t    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',\n\t    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',\n\t    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',\n\t    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',\n\t    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',\n\t    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];\n\n\t/**\n\t * This is the encoding used for fonts created from scratch.\n\t * It loops through all glyphs and finds the appropriate unicode value.\n\t * Since it's linear time, other encodings will be faster.\n\t * @exports opentype.DefaultEncoding\n\t * @class\n\t * @constructor\n\t * @param {opentype.Font}\n\t */\n\tfunction DefaultEncoding(font) {\n\t    this.font = font;\n\t}\n\n\tDefaultEncoding.prototype.charToGlyphIndex = function(c) {\n\t    var code = c.codePointAt(0);\n\t    var glyphs = this.font.glyphs;\n\t    if (glyphs) {\n\t        for (var i = 0; i < glyphs.length; i += 1) {\n\t            var glyph = glyphs.get(i);\n\t            for (var j = 0; j < glyph.unicodes.length; j += 1) {\n\t                if (glyph.unicodes[j] === code) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t};\n\n\t/**\n\t * @exports opentype.CmapEncoding\n\t * @class\n\t * @constructor\n\t * @param {Object} cmap - a object with the cmap encoded data\n\t */\n\tfunction CmapEncoding(cmap) {\n\t    this.cmap = cmap;\n\t}\n\n\t/**\n\t * @param  {string} c - the character\n\t * @return {number} The glyph index.\n\t */\n\tCmapEncoding.prototype.charToGlyphIndex = function(c) {\n\t    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;\n\t};\n\n\t/**\n\t * @exports opentype.CffEncoding\n\t * @class\n\t * @constructor\n\t * @param {string} encoding - The encoding\n\t * @param {Array} charset - The character set.\n\t */\n\tfunction CffEncoding(encoding, charset) {\n\t    this.encoding = encoding;\n\t    this.charset = charset;\n\t}\n\n\t/**\n\t * @param  {string} s - The character\n\t * @return {number} The index.\n\t */\n\tCffEncoding.prototype.charToGlyphIndex = function(s) {\n\t    var code = s.codePointAt(0);\n\t    var charName = this.encoding[code];\n\t    return this.charset.indexOf(charName);\n\t};\n\n\t/**\n\t * @exports opentype.GlyphNames\n\t * @class\n\t * @constructor\n\t * @param {Object} post\n\t */\n\tfunction GlyphNames(post) {\n\t    switch (post.version) {\n\t        case 1:\n\t            this.names = standardNames.slice();\n\t            break;\n\t        case 2:\n\t            this.names = new Array(post.numberOfGlyphs);\n\t            for (var i = 0; i < post.numberOfGlyphs; i++) {\n\t                if (post.glyphNameIndex[i] < standardNames.length) {\n\t                    this.names[i] = standardNames[post.glyphNameIndex[i]];\n\t                } else {\n\t                    this.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];\n\t                }\n\t            }\n\n\t            break;\n\t        case 2.5:\n\t            this.names = new Array(post.numberOfGlyphs);\n\t            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n\t                this.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];\n\t            }\n\n\t            break;\n\t        case 3:\n\t            this.names = [];\n\t            break;\n\t        default:\n\t            this.names = [];\n\t            break;\n\t    }\n\t}\n\n\t/**\n\t * Gets the index of a glyph by name.\n\t * @param  {string} name - The glyph name\n\t * @return {number} The index\n\t */\n\tGlyphNames.prototype.nameToGlyphIndex = function(name) {\n\t    return this.names.indexOf(name);\n\t};\n\n\t/**\n\t * @param  {number} gid\n\t * @return {string}\n\t */\n\tGlyphNames.prototype.glyphIndexToName = function(gid) {\n\t    return this.names[gid];\n\t};\n\n\tfunction addGlyphNamesAll(font) {\n\t    var glyph;\n\t    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n\t    var charCodes = Object.keys(glyphIndexMap);\n\n\t    for (var i = 0; i < charCodes.length; i += 1) {\n\t        var c = charCodes[i];\n\t        var glyphIndex = glyphIndexMap[c];\n\t        glyph = font.glyphs.get(glyphIndex);\n\t        glyph.addUnicode(parseInt(c));\n\t    }\n\n\t    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {\n\t        glyph = font.glyphs.get(i$1);\n\t        if (font.cffEncoding) {\n\t            if (font.isCIDFont) {\n\t                glyph.name = 'gid' + i$1;\n\t            } else {\n\t                glyph.name = font.cffEncoding.charset[i$1];\n\t            }\n\t        } else if (font.glyphNames.names) {\n\t            glyph.name = font.glyphNames.glyphIndexToName(i$1);\n\t        }\n\t    }\n\t}\n\n\tfunction addGlyphNamesToUnicodeMap(font) {\n\t    font._IndexToUnicodeMap = {};\n\n\t    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n\t    var charCodes = Object.keys(glyphIndexMap);\n\n\t    for (var i = 0; i < charCodes.length; i += 1) {\n\t        var c = charCodes[i];\n\t        var glyphIndex = glyphIndexMap[c];\n\t        if (font._IndexToUnicodeMap[glyphIndex] === undefined) {\n\t            font._IndexToUnicodeMap[glyphIndex] = {\n\t                unicodes: [parseInt(c)]\n\t            };\n\t        } else {\n\t            font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));\n\t        }\n\t    }\n\t}\n\n\t/**\n\t * @alias opentype.addGlyphNames\n\t * @param {opentype.Font}\n\t * @param {Object}\n\t */\n\tfunction addGlyphNames(font, opt) {\n\t    if (opt.lowMemory) {\n\t        addGlyphNamesToUnicodeMap(font);\n\t    } else {\n\t        addGlyphNamesAll(font);\n\t    }\n\t}\n\n\t// Drawing utility functions.\n\n\t// Draw a line on the given context from point `x1,y1` to point `x2,y2`.\n\tfunction line(ctx, x1, y1, x2, y2) {\n\t    ctx.beginPath();\n\t    ctx.moveTo(x1, y1);\n\t    ctx.lineTo(x2, y2);\n\t    ctx.stroke();\n\t}\n\n\tvar draw = { line: line };\n\n\t// The Glyph object\n\t// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency\n\n\tfunction getPathDefinition(glyph, path) {\n\t    var _path = path || new Path();\n\t    return {\n\t        configurable: true,\n\n\t        get: function() {\n\t            if (typeof _path === 'function') {\n\t                _path = _path();\n\t            }\n\n\t            return _path;\n\t        },\n\n\t        set: function(p) {\n\t            _path = p;\n\t        }\n\t    };\n\t}\n\t/**\n\t * @typedef GlyphOptions\n\t * @type Object\n\t * @property {string} [name] - The glyph name\n\t * @property {number} [unicode]\n\t * @property {Array} [unicodes]\n\t * @property {number} [xMin]\n\t * @property {number} [yMin]\n\t * @property {number} [xMax]\n\t * @property {number} [yMax]\n\t * @property {number} [advanceWidth]\n\t */\n\n\t// A Glyph is an individual mark that often corresponds to a character.\n\t// Some glyphs, such as ligatures, are a combination of many characters.\n\t// Glyphs are the basic building blocks of a font.\n\t//\n\t// The `Glyph` class contains utility methods for drawing the path and its points.\n\t/**\n\t * @exports opentype.Glyph\n\t * @class\n\t * @param {GlyphOptions}\n\t * @constructor\n\t */\n\tfunction Glyph(options) {\n\t    // By putting all the code on a prototype function (which is only declared once)\n\t    // we reduce the memory requirements for larger fonts by some 2%\n\t    this.bindConstructorValues(options);\n\t}\n\n\t/**\n\t * @param  {GlyphOptions}\n\t */\n\tGlyph.prototype.bindConstructorValues = function(options) {\n\t    this.index = options.index || 0;\n\n\t    // These three values cannot be deferred for memory optimization:\n\t    this.name = options.name || null;\n\t    this.unicode = options.unicode || undefined;\n\t    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];\n\n\t    // But by binding these values only when necessary, we reduce can\n\t    // the memory requirements by almost 3% for larger fonts.\n\t    if ('xMin' in options) {\n\t        this.xMin = options.xMin;\n\t    }\n\n\t    if ('yMin' in options) {\n\t        this.yMin = options.yMin;\n\t    }\n\n\t    if ('xMax' in options) {\n\t        this.xMax = options.xMax;\n\t    }\n\n\t    if ('yMax' in options) {\n\t        this.yMax = options.yMax;\n\t    }\n\n\t    if ('advanceWidth' in options) {\n\t        this.advanceWidth = options.advanceWidth;\n\t    }\n\n\t    // The path for a glyph is the most memory intensive, and is bound as a value\n\t    // with a getter/setter to ensure we actually do path parsing only once the\n\t    // path is actually needed by anything.\n\t    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));\n\t};\n\n\t/**\n\t * @param {number}\n\t */\n\tGlyph.prototype.addUnicode = function(unicode) {\n\t    if (this.unicodes.length === 0) {\n\t        this.unicode = unicode;\n\t    }\n\n\t    this.unicodes.push(unicode);\n\t};\n\n\t/**\n\t * Calculate the minimum bounding box for this glyph.\n\t * @return {opentype.BoundingBox}\n\t */\n\tGlyph.prototype.getBoundingBox = function() {\n\t    return this.path.getBoundingBox();\n\t};\n\n\t/**\n\t * Convert the glyph to a Path we can draw on a drawing context.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {Object=} options - xScale, yScale to stretch the glyph.\n\t * @param  {opentype.Font} if hinting is to be used, the font\n\t * @return {opentype.Path}\n\t */\n\tGlyph.prototype.getPath = function(x, y, fontSize, options, font) {\n\t    x = x !== undefined ? x : 0;\n\t    y = y !== undefined ? y : 0;\n\t    fontSize = fontSize !== undefined ? fontSize : 72;\n\t    var commands;\n\t    var hPoints;\n\t    if (!options) { options = { }; }\n\t    var xScale = options.xScale;\n\t    var yScale = options.yScale;\n\n\t    if (options.hinting && font && font.hinting) {\n\t        // in case of hinting, the hinting engine takes care\n\t        // of scaling the points (not the path) before hinting.\n\t        hPoints = this.path && font.hinting.exec(this, fontSize);\n\t        // in case the hinting engine failed hPoints is undefined\n\t        // and thus reverts to plain rending\n\t    }\n\n\t    if (hPoints) {\n\t        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency\n\t        commands = font.hinting.getCommands(hPoints);\n\t        x = Math.round(x);\n\t        y = Math.round(y);\n\t        // TODO in case of hinting xyScaling is not yet supported\n\t        xScale = yScale = 1;\n\t    } else {\n\t        commands = this.path.commands;\n\t        var scale = 1 / (this.path.unitsPerEm || 1000) * fontSize;\n\t        if (xScale === undefined) { xScale = scale; }\n\t        if (yScale === undefined) { yScale = scale; }\n\t    }\n\n\t    var p = new Path();\n\t    for (var i = 0; i < commands.length; i += 1) {\n\t        var cmd = commands[i];\n\t        if (cmd.type === 'M') {\n\t            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n\t        } else if (cmd.type === 'L') {\n\t            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n\t        } else if (cmd.type === 'Q') {\n\t            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n\t                               x + (cmd.x * xScale), y + (-cmd.y * yScale));\n\t        } else if (cmd.type === 'C') {\n\t            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n\t                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),\n\t                      x + (cmd.x * xScale), y + (-cmd.y * yScale));\n\t        } else if (cmd.type === 'Z') {\n\t            p.closePath();\n\t        }\n\t    }\n\n\t    return p;\n\t};\n\n\t/**\n\t * Split the glyph into contours.\n\t * This function is here for backwards compatibility, and to\n\t * provide raw access to the TrueType glyph outlines.\n\t * @return {Array}\n\t */\n\tGlyph.prototype.getContours = function() {\n\t    if (this.points === undefined) {\n\t        return [];\n\t    }\n\n\t    var contours = [];\n\t    var currentContour = [];\n\t    for (var i = 0; i < this.points.length; i += 1) {\n\t        var pt = this.points[i];\n\t        currentContour.push(pt);\n\t        if (pt.lastPointOfContour) {\n\t            contours.push(currentContour);\n\t            currentContour = [];\n\t        }\n\t    }\n\n\t    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n\t    return contours;\n\t};\n\n\t/**\n\t * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n\t * @return {Object}\n\t */\n\tGlyph.prototype.getMetrics = function() {\n\t    var commands = this.path.commands;\n\t    var xCoords = [];\n\t    var yCoords = [];\n\t    for (var i = 0; i < commands.length; i += 1) {\n\t        var cmd = commands[i];\n\t        if (cmd.type !== 'Z') {\n\t            xCoords.push(cmd.x);\n\t            yCoords.push(cmd.y);\n\t        }\n\n\t        if (cmd.type === 'Q' || cmd.type === 'C') {\n\t            xCoords.push(cmd.x1);\n\t            yCoords.push(cmd.y1);\n\t        }\n\n\t        if (cmd.type === 'C') {\n\t            xCoords.push(cmd.x2);\n\t            yCoords.push(cmd.y2);\n\t        }\n\t    }\n\n\t    var metrics = {\n\t        xMin: Math.min.apply(null, xCoords),\n\t        yMin: Math.min.apply(null, yCoords),\n\t        xMax: Math.max.apply(null, xCoords),\n\t        yMax: Math.max.apply(null, yCoords),\n\t        leftSideBearing: this.leftSideBearing\n\t    };\n\n\t    if (!isFinite(metrics.xMin)) {\n\t        metrics.xMin = 0;\n\t    }\n\n\t    if (!isFinite(metrics.xMax)) {\n\t        metrics.xMax = this.advanceWidth;\n\t    }\n\n\t    if (!isFinite(metrics.yMin)) {\n\t        metrics.yMin = 0;\n\t    }\n\n\t    if (!isFinite(metrics.yMax)) {\n\t        metrics.yMax = 0;\n\t    }\n\n\t    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);\n\t    return metrics;\n\t};\n\n\t/**\n\t * Draw the glyph on the given context.\n\t * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {Object=} options - xScale, yScale to stretch the glyph.\n\t */\n\tGlyph.prototype.draw = function(ctx, x, y, fontSize, options) {\n\t    this.getPath(x, y, fontSize, options).draw(ctx);\n\t};\n\n\t/**\n\t * Draw the points of the glyph.\n\t * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n\t * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t */\n\tGlyph.prototype.drawPoints = function(ctx, x, y, fontSize) {\n\t    function drawCircles(l, x, y, scale) {\n\t        ctx.beginPath();\n\t        for (var j = 0; j < l.length; j += 1) {\n\t            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));\n\t            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, Math.PI * 2, false);\n\t        }\n\n\t        ctx.closePath();\n\t        ctx.fill();\n\t    }\n\n\t    x = x !== undefined ? x : 0;\n\t    y = y !== undefined ? y : 0;\n\t    fontSize = fontSize !== undefined ? fontSize : 24;\n\t    var scale = 1 / this.path.unitsPerEm * fontSize;\n\n\t    var blueCircles = [];\n\t    var redCircles = [];\n\t    var path = this.path;\n\t    for (var i = 0; i < path.commands.length; i += 1) {\n\t        var cmd = path.commands[i];\n\t        if (cmd.x !== undefined) {\n\t            blueCircles.push({x: cmd.x, y: -cmd.y});\n\t        }\n\n\t        if (cmd.x1 !== undefined) {\n\t            redCircles.push({x: cmd.x1, y: -cmd.y1});\n\t        }\n\n\t        if (cmd.x2 !== undefined) {\n\t            redCircles.push({x: cmd.x2, y: -cmd.y2});\n\t        }\n\t    }\n\n\t    ctx.fillStyle = 'blue';\n\t    drawCircles(blueCircles, x, y, scale);\n\t    ctx.fillStyle = 'red';\n\t    drawCircles(redCircles, x, y, scale);\n\t};\n\n\t/**\n\t * Draw lines indicating important font measurements.\n\t * Black lines indicate the origin of the coordinate system (point 0,0).\n\t * Blue lines indicate the glyph bounding box.\n\t * Green line indicates the advance width of the glyph.\n\t * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t */\n\tGlyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {\n\t    var scale;\n\t    x = x !== undefined ? x : 0;\n\t    y = y !== undefined ? y : 0;\n\t    fontSize = fontSize !== undefined ? fontSize : 24;\n\t    scale = 1 / this.path.unitsPerEm * fontSize;\n\t    ctx.lineWidth = 1;\n\n\t    // Draw the origin\n\t    ctx.strokeStyle = 'black';\n\t    draw.line(ctx, x, -10000, x, 10000);\n\t    draw.line(ctx, -10000, y, 10000, y);\n\n\t    // This code is here due to memory optimization: by not using\n\t    // defaults in the constructor, we save a notable amount of memory.\n\t    var xMin = this.xMin || 0;\n\t    var yMin = this.yMin || 0;\n\t    var xMax = this.xMax || 0;\n\t    var yMax = this.yMax || 0;\n\t    var advanceWidth = this.advanceWidth || 0;\n\n\t    // Draw the glyph box\n\t    ctx.strokeStyle = 'blue';\n\t    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);\n\t    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);\n\t    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));\n\t    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));\n\n\t    // Draw the advance width\n\t    ctx.strokeStyle = 'green';\n\t    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);\n\t};\n\n\t// The GlyphSet object\n\n\t// Define a property on the glyph that depends on the path being loaded.\n\tfunction defineDependentProperty(glyph, externalName, internalName) {\n\t    Object.defineProperty(glyph, externalName, {\n\t        get: function() {\n\t            // Request the path property to make sure the path is loaded.\n\t            glyph.path; // jshint ignore:line\n\t            return glyph[internalName];\n\t        },\n\t        set: function(newValue) {\n\t            glyph[internalName] = newValue;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t}\n\n\t/**\n\t * A GlyphSet represents all glyphs available in the font, but modelled using\n\t * a deferred glyph loader, for retrieving glyphs only once they are absolutely\n\t * necessary, to keep the memory footprint down.\n\t * @exports opentype.GlyphSet\n\t * @class\n\t * @param {opentype.Font}\n\t * @param {Array}\n\t */\n\tfunction GlyphSet(font, glyphs) {\n\t    this.font = font;\n\t    this.glyphs = {};\n\t    if (Array.isArray(glyphs)) {\n\t        for (var i = 0; i < glyphs.length; i++) {\n\t            var glyph = glyphs[i];\n\t            glyph.path.unitsPerEm = font.unitsPerEm;\n\t            this.glyphs[i] = glyph;\n\t        }\n\t    }\n\n\t    this.length = (glyphs && glyphs.length) || 0;\n\t}\n\n\t/**\n\t * @param  {number} index\n\t * @return {opentype.Glyph}\n\t */\n\tGlyphSet.prototype.get = function(index) {\n\t    // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.\n\t    if (this.glyphs[index] === undefined) {\n\t        this.font._push(index);\n\t        if (typeof this.glyphs[index] === 'function') {\n\t            this.glyphs[index] = this.glyphs[index]();\n\t        }\n\n\t        var glyph = this.glyphs[index];\n\t        var unicodeObj = this.font._IndexToUnicodeMap[index];\n\n\t        if (unicodeObj) {\n\t            for (var j = 0; j < unicodeObj.unicodes.length; j++)\n\t                { glyph.addUnicode(unicodeObj.unicodes[j]); }\n\t        }\n\n\t        if (this.font.cffEncoding) {\n\t            if (this.font.isCIDFont) {\n\t                glyph.name = 'gid' + index;\n\t            } else {\n\t                glyph.name = this.font.cffEncoding.charset[index];\n\t            }\n\t        } else if (this.font.glyphNames.names) {\n\t            glyph.name = this.font.glyphNames.glyphIndexToName(index);\n\t        }\n\n\t        this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;\n\t        this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;\n\t    } else {\n\t        if (typeof this.glyphs[index] === 'function') {\n\t            this.glyphs[index] = this.glyphs[index]();\n\t        }\n\t    }\n\n\t    return this.glyphs[index];\n\t};\n\n\t/**\n\t * @param  {number} index\n\t * @param  {Object}\n\t */\n\tGlyphSet.prototype.push = function(index, loader) {\n\t    this.glyphs[index] = loader;\n\t    this.length++;\n\t};\n\n\t/**\n\t * @alias opentype.glyphLoader\n\t * @param  {opentype.Font} font\n\t * @param  {number} index\n\t * @return {opentype.Glyph}\n\t */\n\tfunction glyphLoader(font, index) {\n\t    return new Glyph({index: index, font: font});\n\t}\n\n\t/**\n\t * Generate a stub glyph that can be filled with all metadata *except*\n\t * the \"points\" and \"path\" properties, which must be loaded only once\n\t * the glyph's path is actually requested for text shaping.\n\t * @alias opentype.ttfGlyphLoader\n\t * @param  {opentype.Font} font\n\t * @param  {number} index\n\t * @param  {Function} parseGlyph\n\t * @param  {Object} data\n\t * @param  {number} position\n\t * @param  {Function} buildPath\n\t * @return {opentype.Glyph}\n\t */\n\tfunction ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n\t    return function() {\n\t        var glyph = new Glyph({index: index, font: font});\n\n\t        glyph.path = function() {\n\t            parseGlyph(glyph, data, position);\n\t            var path = buildPath(font.glyphs, glyph);\n\t            path.unitsPerEm = font.unitsPerEm;\n\t            return path;\n\t        };\n\n\t        defineDependentProperty(glyph, 'xMin', '_xMin');\n\t        defineDependentProperty(glyph, 'xMax', '_xMax');\n\t        defineDependentProperty(glyph, 'yMin', '_yMin');\n\t        defineDependentProperty(glyph, 'yMax', '_yMax');\n\n\t        return glyph;\n\t    };\n\t}\n\t/**\n\t * @alias opentype.cffGlyphLoader\n\t * @param  {opentype.Font} font\n\t * @param  {number} index\n\t * @param  {Function} parseCFFCharstring\n\t * @param  {string} charstring\n\t * @return {opentype.Glyph}\n\t */\n\tfunction cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n\t    return function() {\n\t        var glyph = new Glyph({index: index, font: font});\n\n\t        glyph.path = function() {\n\t            var path = parseCFFCharstring(font, glyph, charstring);\n\t            path.unitsPerEm = font.unitsPerEm;\n\t            return path;\n\t        };\n\n\t        return glyph;\n\t    };\n\t}\n\n\tvar glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };\n\n\t// The `CFF` table contains the glyph outlines in PostScript format.\n\n\t// Custom equals function that can also check lists.\n\tfunction equals(a, b) {\n\t    if (a === b) {\n\t        return true;\n\t    } else if (Array.isArray(a) && Array.isArray(b)) {\n\t        if (a.length !== b.length) {\n\t            return false;\n\t        }\n\n\t        for (var i = 0; i < a.length; i += 1) {\n\t            if (!equals(a[i], b[i])) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    } else {\n\t        return false;\n\t    }\n\t}\n\n\t// Subroutines are encoded using the negative half of the number space.\n\t// See type 2 chapter 4.7 \"Subroutine operators\".\n\tfunction calcCFFSubroutineBias(subrs) {\n\t    var bias;\n\t    if (subrs.length < 1240) {\n\t        bias = 107;\n\t    } else if (subrs.length < 33900) {\n\t        bias = 1131;\n\t    } else {\n\t        bias = 32768;\n\t    }\n\n\t    return bias;\n\t}\n\n\t// Parse a `CFF` INDEX array.\n\t// An index array consists of a list of offsets, then a list of objects at those offsets.\n\tfunction parseCFFIndex(data, start, conversionFn) {\n\t    var offsets = [];\n\t    var objects = [];\n\t    var count = parse.getCard16(data, start);\n\t    var objectOffset;\n\t    var endOffset;\n\t    if (count !== 0) {\n\t        var offsetSize = parse.getByte(data, start + 2);\n\t        objectOffset = start + ((count + 1) * offsetSize) + 2;\n\t        var pos = start + 3;\n\t        for (var i = 0; i < count + 1; i += 1) {\n\t            offsets.push(parse.getOffset(data, pos, offsetSize));\n\t            pos += offsetSize;\n\t        }\n\n\t        // The total size of the index array is 4 header bytes + the value of the last offset.\n\t        endOffset = objectOffset + offsets[count];\n\t    } else {\n\t        endOffset = start + 2;\n\t    }\n\n\t    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {\n\t        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);\n\t        if (conversionFn) {\n\t            value = conversionFn(value);\n\t        }\n\n\t        objects.push(value);\n\t    }\n\n\t    return {objects: objects, startOffset: start, endOffset: endOffset};\n\t}\n\n\tfunction parseCFFIndexLowMemory(data, start) {\n\t    var offsets = [];\n\t    var count = parse.getCard16(data, start);\n\t    var objectOffset;\n\t    var endOffset;\n\t    if (count !== 0) {\n\t        var offsetSize = parse.getByte(data, start + 2);\n\t        objectOffset = start + ((count + 1) * offsetSize) + 2;\n\t        var pos = start + 3;\n\t        for (var i = 0; i < count + 1; i += 1) {\n\t            offsets.push(parse.getOffset(data, pos, offsetSize));\n\t            pos += offsetSize;\n\t        }\n\n\t        // The total size of the index array is 4 header bytes + the value of the last offset.\n\t        endOffset = objectOffset + offsets[count];\n\t    } else {\n\t        endOffset = start + 2;\n\t    }\n\n\t    return {offsets: offsets, startOffset: start, endOffset: endOffset};\n\t}\n\tfunction getCffIndexObject(i, offsets, data, start, conversionFn) {\n\t    var count = parse.getCard16(data, start);\n\t    var objectOffset = 0;\n\t    if (count !== 0) {\n\t        var offsetSize = parse.getByte(data, start + 2);\n\t        objectOffset = start + ((count + 1) * offsetSize) + 2;\n\t    }\n\n\t    var value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);\n\t    if (conversionFn) {\n\t        value = conversionFn(value);\n\t    }\n\t    return value;\n\t}\n\n\t// Parse a `CFF` DICT real value.\n\tfunction parseFloatOperand(parser) {\n\t    var s = '';\n\t    var eof = 15;\n\t    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\n\t    while (true) {\n\t        var b = parser.parseByte();\n\t        var n1 = b >> 4;\n\t        var n2 = b & 15;\n\n\t        if (n1 === eof) {\n\t            break;\n\t        }\n\n\t        s += lookup[n1];\n\n\t        if (n2 === eof) {\n\t            break;\n\t        }\n\n\t        s += lookup[n2];\n\t    }\n\n\t    return parseFloat(s);\n\t}\n\n\t// Parse a `CFF` DICT operand.\n\tfunction parseOperand(parser, b0) {\n\t    var b1;\n\t    var b2;\n\t    var b3;\n\t    var b4;\n\t    if (b0 === 28) {\n\t        b1 = parser.parseByte();\n\t        b2 = parser.parseByte();\n\t        return b1 << 8 | b2;\n\t    }\n\n\t    if (b0 === 29) {\n\t        b1 = parser.parseByte();\n\t        b2 = parser.parseByte();\n\t        b3 = parser.parseByte();\n\t        b4 = parser.parseByte();\n\t        return b1 << 24 | b2 << 16 | b3 << 8 | b4;\n\t    }\n\n\t    if (b0 === 30) {\n\t        return parseFloatOperand(parser);\n\t    }\n\n\t    if (b0 >= 32 && b0 <= 246) {\n\t        return b0 - 139;\n\t    }\n\n\t    if (b0 >= 247 && b0 <= 250) {\n\t        b1 = parser.parseByte();\n\t        return (b0 - 247) * 256 + b1 + 108;\n\t    }\n\n\t    if (b0 >= 251 && b0 <= 254) {\n\t        b1 = parser.parseByte();\n\t        return -(b0 - 251) * 256 - b1 - 108;\n\t    }\n\n\t    throw new Error('Invalid b0 ' + b0);\n\t}\n\n\t// Convert the entries returned by `parseDict` to a proper dictionary.\n\t// If a value is a list of one, it is unpacked.\n\tfunction entriesToObject(entries) {\n\t    var o = {};\n\t    for (var i = 0; i < entries.length; i += 1) {\n\t        var key = entries[i][0];\n\t        var values = entries[i][1];\n\t        var value = (void 0);\n\t        if (values.length === 1) {\n\t            value = values[0];\n\t        } else {\n\t            value = values;\n\t        }\n\n\t        if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n\t            throw new Error('Object ' + o + ' already has key ' + key);\n\t        }\n\n\t        o[key] = value;\n\t    }\n\n\t    return o;\n\t}\n\n\t// Parse a `CFF` DICT object.\n\t// A dictionary contains key-value pairs in a compact tokenized format.\n\tfunction parseCFFDict(data, start, size) {\n\t    start = start !== undefined ? start : 0;\n\t    var parser = new parse.Parser(data, start);\n\t    var entries = [];\n\t    var operands = [];\n\t    size = size !== undefined ? size : data.length;\n\n\t    while (parser.relativeOffset < size) {\n\t        var op = parser.parseByte();\n\n\t        // The first byte for each dict item distinguishes between operator (key) and operand (value).\n\t        // Values <= 21 are operators.\n\t        if (op <= 21) {\n\t            // Two-byte operators have an initial escape byte of 12.\n\t            if (op === 12) {\n\t                op = 1200 + parser.parseByte();\n\t            }\n\n\t            entries.push([op, operands]);\n\t            operands = [];\n\t        } else {\n\t            // Since the operands (values) come before the operators (keys), we store all operands in a list\n\t            // until we encounter an operator.\n\t            operands.push(parseOperand(parser, op));\n\t        }\n\t    }\n\n\t    return entriesToObject(entries);\n\t}\n\n\t// Given a String Index (SID), return the value of the string.\n\t// Strings below index 392 are standard CFF strings and are not encoded in the font.\n\tfunction getCFFString(strings, index) {\n\t    if (index <= 390) {\n\t        index = cffStandardStrings[index];\n\t    } else {\n\t        index = strings[index - 391];\n\t    }\n\n\t    return index;\n\t}\n\n\t// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n\t// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\n\tfunction interpretDict(dict, meta, strings) {\n\t    var newDict = {};\n\t    var value;\n\n\t    // Because we also want to include missing values, we start out from the meta list\n\t    // and lookup values in the dict.\n\t    for (var i = 0; i < meta.length; i += 1) {\n\t        var m = meta[i];\n\n\t        if (Array.isArray(m.type)) {\n\t            var values = [];\n\t            values.length = m.type.length;\n\t            for (var j = 0; j < m.type.length; j++) {\n\t                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n\t                if (value === undefined) {\n\t                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;\n\t                }\n\t                if (m.type[j] === 'SID') {\n\t                    value = getCFFString(strings, value);\n\t                }\n\t                values[j] = value;\n\t            }\n\t            newDict[m.name] = values;\n\t        } else {\n\t            value = dict[m.op];\n\t            if (value === undefined) {\n\t                value = m.value !== undefined ? m.value : null;\n\t            }\n\n\t            if (m.type === 'SID') {\n\t                value = getCFFString(strings, value);\n\t            }\n\t            newDict[m.name] = value;\n\t        }\n\t    }\n\n\t    return newDict;\n\t}\n\n\t// Parse the CFF header.\n\tfunction parseCFFHeader(data, start) {\n\t    var header = {};\n\t    header.formatMajor = parse.getCard8(data, start);\n\t    header.formatMinor = parse.getCard8(data, start + 1);\n\t    header.size = parse.getCard8(data, start + 2);\n\t    header.offsetSize = parse.getCard8(data, start + 3);\n\t    header.startOffset = start;\n\t    header.endOffset = start + 4;\n\t    return header;\n\t}\n\n\tvar TOP_DICT_META = [\n\t    {name: 'version', op: 0, type: 'SID'},\n\t    {name: 'notice', op: 1, type: 'SID'},\n\t    {name: 'copyright', op: 1200, type: 'SID'},\n\t    {name: 'fullName', op: 2, type: 'SID'},\n\t    {name: 'familyName', op: 3, type: 'SID'},\n\t    {name: 'weight', op: 4, type: 'SID'},\n\t    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},\n\t    {name: 'italicAngle', op: 1202, type: 'number', value: 0},\n\t    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},\n\t    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},\n\t    {name: 'paintType', op: 1205, type: 'number', value: 0},\n\t    {name: 'charstringType', op: 1206, type: 'number', value: 2},\n\t    {\n\t        name: 'fontMatrix',\n\t        op: 1207,\n\t        type: ['real', 'real', 'real', 'real', 'real', 'real'],\n\t        value: [0.001, 0, 0, 0.001, 0, 0]\n\t    },\n\t    {name: 'uniqueId', op: 13, type: 'number'},\n\t    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},\n\t    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},\n\t    {name: 'xuid', op: 14, type: [], value: null},\n\t    {name: 'charset', op: 15, type: 'offset', value: 0},\n\t    {name: 'encoding', op: 16, type: 'offset', value: 0},\n\t    {name: 'charStrings', op: 17, type: 'offset', value: 0},\n\t    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},\n\t    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},\n\t    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},\n\t    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},\n\t    {name: 'cidFontType', op: 1233, type: 'number', value: 0},\n\t    {name: 'cidCount', op: 1234, type: 'number', value: 8720},\n\t    {name: 'uidBase', op: 1235, type: 'number'},\n\t    {name: 'fdArray', op: 1236, type: 'offset'},\n\t    {name: 'fdSelect', op: 1237, type: 'offset'},\n\t    {name: 'fontName', op: 1238, type: 'SID'}\n\t];\n\n\tvar PRIVATE_DICT_META = [\n\t    {name: 'subrs', op: 19, type: 'offset', value: 0},\n\t    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},\n\t    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}\n\t];\n\n\t// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n\t// The top dictionary contains the essential metadata for the font, together with the private dictionary.\n\tfunction parseCFFTopDict(data, strings) {\n\t    var dict = parseCFFDict(data, 0, data.byteLength);\n\t    return interpretDict(dict, TOP_DICT_META, strings);\n\t}\n\n\t// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\n\tfunction parseCFFPrivateDict(data, start, size, strings) {\n\t    var dict = parseCFFDict(data, start, size);\n\t    return interpretDict(dict, PRIVATE_DICT_META, strings);\n\t}\n\n\t// Returns a list of \"Top DICT\"s found using an INDEX list.\n\t// Used to read both the usual high-level Top DICTs and also the FDArray\n\t// discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n\t// a Private DICT that is read and saved into the Top DICT.\n\t//\n\t// In addition to the expected/optional values as outlined in TOP_DICT_META\n\t// the following values might be saved into the Top DICT.\n\t//\n\t//    _subrs []        array of local CFF subroutines from Private DICT\n\t//    _subrsBias       bias value computed from number of subroutines\n\t//                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n\t//    _defaultWidthX   default widths for CFF characters\n\t//    _nominalWidthX   bias added to width embedded within glyph description\n\t//\n\t//    _privateDict     saved copy of parsed Private DICT from Top DICT\n\tfunction gatherCFFTopDicts(data, start, cffIndex, strings) {\n\t    var topDictArray = [];\n\t    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n\t        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);\n\t        var topDict = parseCFFTopDict(topDictData, strings);\n\t        topDict._subrs = [];\n\t        topDict._subrsBias = 0;\n\t        topDict._defaultWidthX = 0;\n\t        topDict._nominalWidthX = 0;\n\t        var privateSize = topDict.private[0];\n\t        var privateOffset = topDict.private[1];\n\t        if (privateSize !== 0 && privateOffset !== 0) {\n\t            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);\n\t            topDict._defaultWidthX = privateDict.defaultWidthX;\n\t            topDict._nominalWidthX = privateDict.nominalWidthX;\n\t            if (privateDict.subrs !== 0) {\n\t                var subrOffset = privateOffset + privateDict.subrs;\n\t                var subrIndex = parseCFFIndex(data, subrOffset + start);\n\t                topDict._subrs = subrIndex.objects;\n\t                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n\t            }\n\t            topDict._privateDict = privateDict;\n\t        }\n\t        topDictArray.push(topDict);\n\t    }\n\t    return topDictArray;\n\t}\n\n\t// Parse the CFF charset table, which contains internal names for all the glyphs.\n\t// This function will return a list of glyph names.\n\t// See Adobe TN #5176 chapter 13, \"Charsets\".\n\tfunction parseCFFCharset(data, start, nGlyphs, strings) {\n\t    var sid;\n\t    var count;\n\t    var parser = new parse.Parser(data, start);\n\n\t    // The .notdef glyph is not included, so subtract 1.\n\t    nGlyphs -= 1;\n\t    var charset = ['.notdef'];\n\n\t    var format = parser.parseCard8();\n\t    if (format === 0) {\n\t        for (var i = 0; i < nGlyphs; i += 1) {\n\t            sid = parser.parseSID();\n\t            charset.push(getCFFString(strings, sid));\n\t        }\n\t    } else if (format === 1) {\n\t        while (charset.length <= nGlyphs) {\n\t            sid = parser.parseSID();\n\t            count = parser.parseCard8();\n\t            for (var i$1 = 0; i$1 <= count; i$1 += 1) {\n\t                charset.push(getCFFString(strings, sid));\n\t                sid += 1;\n\t            }\n\t        }\n\t    } else if (format === 2) {\n\t        while (charset.length <= nGlyphs) {\n\t            sid = parser.parseSID();\n\t            count = parser.parseCard16();\n\t            for (var i$2 = 0; i$2 <= count; i$2 += 1) {\n\t                charset.push(getCFFString(strings, sid));\n\t                sid += 1;\n\t            }\n\t        }\n\t    } else {\n\t        throw new Error('Unknown charset format ' + format);\n\t    }\n\n\t    return charset;\n\t}\n\n\t// Parse the CFF encoding data. Only one encoding can be specified per font.\n\t// See Adobe TN #5176 chapter 12, \"Encodings\".\n\tfunction parseCFFEncoding(data, start, charset) {\n\t    var code;\n\t    var enc = {};\n\t    var parser = new parse.Parser(data, start);\n\t    var format = parser.parseCard8();\n\t    if (format === 0) {\n\t        var nCodes = parser.parseCard8();\n\t        for (var i = 0; i < nCodes; i += 1) {\n\t            code = parser.parseCard8();\n\t            enc[code] = i;\n\t        }\n\t    } else if (format === 1) {\n\t        var nRanges = parser.parseCard8();\n\t        code = 1;\n\t        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {\n\t            var first = parser.parseCard8();\n\t            var nLeft = parser.parseCard8();\n\t            for (var j = first; j <= first + nLeft; j += 1) {\n\t                enc[j] = code;\n\t                code += 1;\n\t            }\n\t        }\n\t    } else {\n\t        throw new Error('Unknown encoding format ' + format);\n\t    }\n\n\t    return new CffEncoding(enc, charset);\n\t}\n\n\t// Take in charstring code and return a Glyph object.\n\t// The encoding is described in the Type 2 Charstring Format\n\t// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\n\tfunction parseCFFCharstring(font, glyph, code) {\n\t    var c1x;\n\t    var c1y;\n\t    var c2x;\n\t    var c2y;\n\t    var p = new Path();\n\t    var stack = [];\n\t    var nStems = 0;\n\t    var haveWidth = false;\n\t    var open = false;\n\t    var x = 0;\n\t    var y = 0;\n\t    var subrs;\n\t    var subrsBias;\n\t    var defaultWidthX;\n\t    var nominalWidthX;\n\t    if (font.isCIDFont) {\n\t        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n\t        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n\t        subrs = fdDict._subrs;\n\t        subrsBias = fdDict._subrsBias;\n\t        defaultWidthX = fdDict._defaultWidthX;\n\t        nominalWidthX = fdDict._nominalWidthX;\n\t    } else {\n\t        subrs = font.tables.cff.topDict._subrs;\n\t        subrsBias = font.tables.cff.topDict._subrsBias;\n\t        defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n\t        nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n\t    }\n\t    var width = defaultWidthX;\n\n\t    function newContour(x, y) {\n\t        if (open) {\n\t            p.closePath();\n\t        }\n\n\t        p.moveTo(x, y);\n\t        open = true;\n\t    }\n\n\t    function parseStems() {\n\t        var hasWidthArg;\n\n\t        // The number of stem operators on the stack is always even.\n\t        // If the value is uneven, that means a width is specified.\n\t        hasWidthArg = stack.length % 2 !== 0;\n\t        if (hasWidthArg && !haveWidth) {\n\t            width = stack.shift() + nominalWidthX;\n\t        }\n\n\t        nStems += stack.length >> 1;\n\t        stack.length = 0;\n\t        haveWidth = true;\n\t    }\n\n\t    function parse(code) {\n\t        var b1;\n\t        var b2;\n\t        var b3;\n\t        var b4;\n\t        var codeIndex;\n\t        var subrCode;\n\t        var jpx;\n\t        var jpy;\n\t        var c3x;\n\t        var c3y;\n\t        var c4x;\n\t        var c4y;\n\n\t        var i = 0;\n\t        while (i < code.length) {\n\t            var v = code[i];\n\t            i += 1;\n\t            switch (v) {\n\t                case 1: // hstem\n\t                    parseStems();\n\t                    break;\n\t                case 3: // vstem\n\t                    parseStems();\n\t                    break;\n\t                case 4: // vmoveto\n\t                    if (stack.length > 1 && !haveWidth) {\n\t                        width = stack.shift() + nominalWidthX;\n\t                        haveWidth = true;\n\t                    }\n\n\t                    y += stack.pop();\n\t                    newContour(x, y);\n\t                    break;\n\t                case 5: // rlineto\n\t                    while (stack.length > 0) {\n\t                        x += stack.shift();\n\t                        y += stack.shift();\n\t                        p.lineTo(x, y);\n\t                    }\n\n\t                    break;\n\t                case 6: // hlineto\n\t                    while (stack.length > 0) {\n\t                        x += stack.shift();\n\t                        p.lineTo(x, y);\n\t                        if (stack.length === 0) {\n\t                            break;\n\t                        }\n\n\t                        y += stack.shift();\n\t                        p.lineTo(x, y);\n\t                    }\n\n\t                    break;\n\t                case 7: // vlineto\n\t                    while (stack.length > 0) {\n\t                        y += stack.shift();\n\t                        p.lineTo(x, y);\n\t                        if (stack.length === 0) {\n\t                            break;\n\t                        }\n\n\t                        x += stack.shift();\n\t                        p.lineTo(x, y);\n\t                    }\n\n\t                    break;\n\t                case 8: // rrcurveto\n\t                    while (stack.length > 0) {\n\t                        c1x = x + stack.shift();\n\t                        c1y = y + stack.shift();\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        x = c2x + stack.shift();\n\t                        y = c2y + stack.shift();\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    }\n\n\t                    break;\n\t                case 10: // callsubr\n\t                    codeIndex = stack.pop() + subrsBias;\n\t                    subrCode = subrs[codeIndex];\n\t                    if (subrCode) {\n\t                        parse(subrCode);\n\t                    }\n\n\t                    break;\n\t                case 11: // return\n\t                    return;\n\t                case 12: // flex operators\n\t                    v = code[i];\n\t                    i += 1;\n\t                    switch (v) {\n\t                        case 35: // flex\n\t                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n\t                            c1x = x   + stack.shift();    // dx1\n\t                            c1y = y   + stack.shift();    // dy1\n\t                            c2x = c1x + stack.shift();    // dx2\n\t                            c2y = c1y + stack.shift();    // dy2\n\t                            jpx = c2x + stack.shift();    // dx3\n\t                            jpy = c2y + stack.shift();    // dy3\n\t                            c3x = jpx + stack.shift();    // dx4\n\t                            c3y = jpy + stack.shift();    // dy4\n\t                            c4x = c3x + stack.shift();    // dx5\n\t                            c4y = c3y + stack.shift();    // dy5\n\t                            x = c4x   + stack.shift();    // dx6\n\t                            y = c4y   + stack.shift();    // dy6\n\t                            stack.shift();                // flex depth\n\t                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n\t                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n\t                            break;\n\t                        case 34: // hflex\n\t                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n\t                            c1x = x   + stack.shift();    // dx1\n\t                            c1y = y;                      // dy1\n\t                            c2x = c1x + stack.shift();    // dx2\n\t                            c2y = c1y + stack.shift();    // dy2\n\t                            jpx = c2x + stack.shift();    // dx3\n\t                            jpy = c2y;                    // dy3\n\t                            c3x = jpx + stack.shift();    // dx4\n\t                            c3y = c2y;                    // dy4\n\t                            c4x = c3x + stack.shift();    // dx5\n\t                            c4y = y;                      // dy5\n\t                            x = c4x + stack.shift();      // dx6\n\t                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n\t                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n\t                            break;\n\t                        case 36: // hflex1\n\t                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n\t                            c1x = x   + stack.shift();    // dx1\n\t                            c1y = y   + stack.shift();    // dy1\n\t                            c2x = c1x + stack.shift();    // dx2\n\t                            c2y = c1y + stack.shift();    // dy2\n\t                            jpx = c2x + stack.shift();    // dx3\n\t                            jpy = c2y;                    // dy3\n\t                            c3x = jpx + stack.shift();    // dx4\n\t                            c3y = c2y;                    // dy4\n\t                            c4x = c3x + stack.shift();    // dx5\n\t                            c4y = c3y + stack.shift();    // dy5\n\t                            x = c4x + stack.shift();      // dx6\n\t                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n\t                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n\t                            break;\n\t                        case 37: // flex1\n\t                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n\t                            c1x = x   + stack.shift();    // dx1\n\t                            c1y = y   + stack.shift();    // dy1\n\t                            c2x = c1x + stack.shift();    // dx2\n\t                            c2y = c1y + stack.shift();    // dy2\n\t                            jpx = c2x + stack.shift();    // dx3\n\t                            jpy = c2y + stack.shift();    // dy3\n\t                            c3x = jpx + stack.shift();    // dx4\n\t                            c3y = jpy + stack.shift();    // dy4\n\t                            c4x = c3x + stack.shift();    // dx5\n\t                            c4y = c3y + stack.shift();    // dy5\n\t                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n\t                                x = c4x + stack.shift();\n\t                            } else {\n\t                                y = c4y + stack.shift();\n\t                            }\n\n\t                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n\t                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n\t                            break;\n\t                        default:\n\t                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);\n\t                            stack.length = 0;\n\t                    }\n\t                    break;\n\t                case 14: // endchar\n\t                    if (stack.length > 0 && !haveWidth) {\n\t                        width = stack.shift() + nominalWidthX;\n\t                        haveWidth = true;\n\t                    }\n\n\t                    if (open) {\n\t                        p.closePath();\n\t                        open = false;\n\t                    }\n\n\t                    break;\n\t                case 18: // hstemhm\n\t                    parseStems();\n\t                    break;\n\t                case 19: // hintmask\n\t                case 20: // cntrmask\n\t                    parseStems();\n\t                    i += (nStems + 7) >> 3;\n\t                    break;\n\t                case 21: // rmoveto\n\t                    if (stack.length > 2 && !haveWidth) {\n\t                        width = stack.shift() + nominalWidthX;\n\t                        haveWidth = true;\n\t                    }\n\n\t                    y += stack.pop();\n\t                    x += stack.pop();\n\t                    newContour(x, y);\n\t                    break;\n\t                case 22: // hmoveto\n\t                    if (stack.length > 1 && !haveWidth) {\n\t                        width = stack.shift() + nominalWidthX;\n\t                        haveWidth = true;\n\t                    }\n\n\t                    x += stack.pop();\n\t                    newContour(x, y);\n\t                    break;\n\t                case 23: // vstemhm\n\t                    parseStems();\n\t                    break;\n\t                case 24: // rcurveline\n\t                    while (stack.length > 2) {\n\t                        c1x = x + stack.shift();\n\t                        c1y = y + stack.shift();\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        x = c2x + stack.shift();\n\t                        y = c2y + stack.shift();\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    }\n\n\t                    x += stack.shift();\n\t                    y += stack.shift();\n\t                    p.lineTo(x, y);\n\t                    break;\n\t                case 25: // rlinecurve\n\t                    while (stack.length > 6) {\n\t                        x += stack.shift();\n\t                        y += stack.shift();\n\t                        p.lineTo(x, y);\n\t                    }\n\n\t                    c1x = x + stack.shift();\n\t                    c1y = y + stack.shift();\n\t                    c2x = c1x + stack.shift();\n\t                    c2y = c1y + stack.shift();\n\t                    x = c2x + stack.shift();\n\t                    y = c2y + stack.shift();\n\t                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    break;\n\t                case 26: // vvcurveto\n\t                    if (stack.length % 2) {\n\t                        x += stack.shift();\n\t                    }\n\n\t                    while (stack.length > 0) {\n\t                        c1x = x;\n\t                        c1y = y + stack.shift();\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        x = c2x;\n\t                        y = c2y + stack.shift();\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    }\n\n\t                    break;\n\t                case 27: // hhcurveto\n\t                    if (stack.length % 2) {\n\t                        y += stack.shift();\n\t                    }\n\n\t                    while (stack.length > 0) {\n\t                        c1x = x + stack.shift();\n\t                        c1y = y;\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        x = c2x + stack.shift();\n\t                        y = c2y;\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    }\n\n\t                    break;\n\t                case 28: // shortint\n\t                    b1 = code[i];\n\t                    b2 = code[i + 1];\n\t                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);\n\t                    i += 2;\n\t                    break;\n\t                case 29: // callgsubr\n\t                    codeIndex = stack.pop() + font.gsubrsBias;\n\t                    subrCode = font.gsubrs[codeIndex];\n\t                    if (subrCode) {\n\t                        parse(subrCode);\n\t                    }\n\n\t                    break;\n\t                case 30: // vhcurveto\n\t                    while (stack.length > 0) {\n\t                        c1x = x;\n\t                        c1y = y + stack.shift();\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        x = c2x + stack.shift();\n\t                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                        if (stack.length === 0) {\n\t                            break;\n\t                        }\n\n\t                        c1x = x + stack.shift();\n\t                        c1y = y;\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        y = c2y + stack.shift();\n\t                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    }\n\n\t                    break;\n\t                case 31: // hvcurveto\n\t                    while (stack.length > 0) {\n\t                        c1x = x + stack.shift();\n\t                        c1y = y;\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        y = c2y + stack.shift();\n\t                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                        if (stack.length === 0) {\n\t                            break;\n\t                        }\n\n\t                        c1x = x;\n\t                        c1y = y + stack.shift();\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        x = c2x + stack.shift();\n\t                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    }\n\n\t                    break;\n\t                default:\n\t                    if (v < 32) {\n\t                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);\n\t                    } else if (v < 247) {\n\t                        stack.push(v - 139);\n\t                    } else if (v < 251) {\n\t                        b1 = code[i];\n\t                        i += 1;\n\t                        stack.push((v - 247) * 256 + b1 + 108);\n\t                    } else if (v < 255) {\n\t                        b1 = code[i];\n\t                        i += 1;\n\t                        stack.push(-(v - 251) * 256 - b1 - 108);\n\t                    } else {\n\t                        b1 = code[i];\n\t                        b2 = code[i + 1];\n\t                        b3 = code[i + 2];\n\t                        b4 = code[i + 3];\n\t                        i += 4;\n\t                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);\n\t                    }\n\t            }\n\t        }\n\t    }\n\n\t    parse(code);\n\n\t    glyph.advanceWidth = width;\n\t    return p;\n\t}\n\n\tfunction parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n\t    var fdSelect = [];\n\t    var fdIndex;\n\t    var parser = new parse.Parser(data, start);\n\t    var format = parser.parseCard8();\n\t    if (format === 0) {\n\t        // Simple list of nGlyphs elements\n\t        for (var iGid = 0; iGid < nGlyphs; iGid++) {\n\t            fdIndex = parser.parseCard8();\n\t            if (fdIndex >= fdArrayCount) {\n\t                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n\t            }\n\t            fdSelect.push(fdIndex);\n\t        }\n\t    } else if (format === 3) {\n\t        // Ranges\n\t        var nRanges = parser.parseCard16();\n\t        var first = parser.parseCard16();\n\t        if (first !== 0) {\n\t            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);\n\t        }\n\t        var next;\n\t        for (var iRange = 0; iRange < nRanges; iRange++) {\n\t            fdIndex = parser.parseCard8();\n\t            next = parser.parseCard16();\n\t            if (fdIndex >= fdArrayCount) {\n\t                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n\t            }\n\t            if (next > nGlyphs) {\n\t                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);\n\t            }\n\t            for (; first < next; first++) {\n\t                fdSelect.push(fdIndex);\n\t            }\n\t            first = next;\n\t        }\n\t        if (next !== nGlyphs) {\n\t            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);\n\t        }\n\t    } else {\n\t        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);\n\t    }\n\t    return fdSelect;\n\t}\n\n\t// Parse the `CFF` table, which contains the glyph outlines in PostScript format.\n\tfunction parseCFFTable(data, start, font, opt) {\n\t    font.tables.cff = {};\n\t    var header = parseCFFHeader(data, start);\n\t    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);\n\t    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n\t    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);\n\t    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n\t    font.gsubrs = globalSubrIndex.objects;\n\t    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n\n\t    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);\n\t    if (topDictArray.length !== 1) {\n\t        throw new Error('CFF table has too many fonts in \\'FontSet\\' - count of fonts NameIndex.length = ' + topDictArray.length);\n\t    }\n\n\t    var topDict = topDictArray[0];\n\t    font.tables.cff.topDict = topDict;\n\n\t    if (topDict._privateDict) {\n\t        font.defaultWidthX = topDict._privateDict.defaultWidthX;\n\t        font.nominalWidthX = topDict._privateDict.nominalWidthX;\n\t    }\n\n\t    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n\t        font.isCIDFont = true;\n\t    }\n\n\t    if (font.isCIDFont) {\n\t        var fdArrayOffset = topDict.fdArray;\n\t        var fdSelectOffset = topDict.fdSelect;\n\t        if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n\t            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');\n\t        }\n\t        fdArrayOffset += start;\n\t        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n\t        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);\n\t        topDict._fdArray = fdArray;\n\t        fdSelectOffset += start;\n\t        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);\n\t    }\n\n\t    var privateDictOffset = start + topDict.private[1];\n\t    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);\n\t    font.defaultWidthX = privateDict.defaultWidthX;\n\t    font.nominalWidthX = privateDict.nominalWidthX;\n\n\t    if (privateDict.subrs !== 0) {\n\t        var subrOffset = privateDictOffset + privateDict.subrs;\n\t        var subrIndex = parseCFFIndex(data, subrOffset);\n\t        font.subrs = subrIndex.objects;\n\t        font.subrsBias = calcCFFSubroutineBias(font.subrs);\n\t    } else {\n\t        font.subrs = [];\n\t        font.subrsBias = 0;\n\t    }\n\n\t    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n\t    var charStringsIndex;\n\t    if (opt.lowMemory) {\n\t        charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);\n\t        font.nGlyphs = charStringsIndex.offsets.length;\n\t    } else {\n\t        charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n\t        font.nGlyphs = charStringsIndex.objects.length;\n\t    }\n\n\t    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);\n\t    if (topDict.encoding === 0) {\n\t        // Standard encoding\n\t        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n\t    } else if (topDict.encoding === 1) {\n\t        // Expert encoding\n\t        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n\t    } else {\n\t        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);\n\t    }\n\n\t    // Prefer the CMAP encoding to the CFF encoding.\n\t    font.encoding = font.encoding || font.cffEncoding;\n\n\t    font.glyphs = new glyphset.GlyphSet(font);\n\t    if (opt.lowMemory) {\n\t        font._push = function(i) {\n\t            var charString = getCffIndexObject(i, charStringsIndex.offsets, data, start + topDict.charStrings);\n\t            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n\t        };\n\t    } else {\n\t        for (var i = 0; i < font.nGlyphs; i += 1) {\n\t            var charString = charStringsIndex.objects[i];\n\t            font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n\t        }\n\t    }\n\t}\n\n\t// Convert a string to a String ID (SID).\n\t// The list of strings is modified in place.\n\tfunction encodeString(s, strings) {\n\t    var sid;\n\n\t    // Is the string in the CFF standard strings?\n\t    var i = cffStandardStrings.indexOf(s);\n\t    if (i >= 0) {\n\t        sid = i;\n\t    }\n\n\t    // Is the string already in the string index?\n\t    i = strings.indexOf(s);\n\t    if (i >= 0) {\n\t        sid = i + cffStandardStrings.length;\n\t    } else {\n\t        sid = cffStandardStrings.length + strings.length;\n\t        strings.push(s);\n\t    }\n\n\t    return sid;\n\t}\n\n\tfunction makeHeader() {\n\t    return new table.Record('Header', [\n\t        {name: 'major', type: 'Card8', value: 1},\n\t        {name: 'minor', type: 'Card8', value: 0},\n\t        {name: 'hdrSize', type: 'Card8', value: 4},\n\t        {name: 'major', type: 'Card8', value: 1}\n\t    ]);\n\t}\n\n\tfunction makeNameIndex(fontNames) {\n\t    var t = new table.Record('Name INDEX', [\n\t        {name: 'names', type: 'INDEX', value: []}\n\t    ]);\n\t    t.names = [];\n\t    for (var i = 0; i < fontNames.length; i += 1) {\n\t        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});\n\t    }\n\n\t    return t;\n\t}\n\n\t// Given a dictionary's metadata, create a DICT structure.\n\tfunction makeDict(meta, attrs, strings) {\n\t    var m = {};\n\t    for (var i = 0; i < meta.length; i += 1) {\n\t        var entry = meta[i];\n\t        var value = attrs[entry.name];\n\t        if (value !== undefined && !equals(value, entry.value)) {\n\t            if (entry.type === 'SID') {\n\t                value = encodeString(value, strings);\n\t            }\n\n\t            m[entry.op] = {name: entry.name, type: entry.type, value: value};\n\t        }\n\t    }\n\n\t    return m;\n\t}\n\n\t// The Top DICT houses the global font attributes.\n\tfunction makeTopDict(attrs, strings) {\n\t    var t = new table.Record('Top DICT', [\n\t        {name: 'dict', type: 'DICT', value: {}}\n\t    ]);\n\t    t.dict = makeDict(TOP_DICT_META, attrs, strings);\n\t    return t;\n\t}\n\n\tfunction makeTopDictIndex(topDict) {\n\t    var t = new table.Record('Top DICT INDEX', [\n\t        {name: 'topDicts', type: 'INDEX', value: []}\n\t    ]);\n\t    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];\n\t    return t;\n\t}\n\n\tfunction makeStringIndex(strings) {\n\t    var t = new table.Record('String INDEX', [\n\t        {name: 'strings', type: 'INDEX', value: []}\n\t    ]);\n\t    t.strings = [];\n\t    for (var i = 0; i < strings.length; i += 1) {\n\t        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});\n\t    }\n\n\t    return t;\n\t}\n\n\tfunction makeGlobalSubrIndex() {\n\t    // Currently we don't use subroutines.\n\t    return new table.Record('Global Subr INDEX', [\n\t        {name: 'subrs', type: 'INDEX', value: []}\n\t    ]);\n\t}\n\n\tfunction makeCharsets(glyphNames, strings) {\n\t    var t = new table.Record('Charsets', [\n\t        {name: 'format', type: 'Card8', value: 0}\n\t    ]);\n\t    for (var i = 0; i < glyphNames.length; i += 1) {\n\t        var glyphName = glyphNames[i];\n\t        var glyphSID = encodeString(glyphName, strings);\n\t        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});\n\t    }\n\n\t    return t;\n\t}\n\n\tfunction glyphToOps(glyph) {\n\t    var ops = [];\n\t    var path = glyph.path;\n\t    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});\n\t    var x = 0;\n\t    var y = 0;\n\t    for (var i = 0; i < path.commands.length; i += 1) {\n\t        var dx = (void 0);\n\t        var dy = (void 0);\n\t        var cmd = path.commands[i];\n\t        if (cmd.type === 'Q') {\n\t            // CFF only supports bézier curves, so convert the quad to a bézier.\n\t            var _13 = 1 / 3;\n\t            var _23 = 2 / 3;\n\n\t            // We're going to create a new command so we don't change the original path.\n\t            // Since all coordinates are relative, we round() them ASAP to avoid propagating errors.\n\t            cmd = {\n\t                type: 'C',\n\t                x: cmd.x,\n\t                y: cmd.y,\n\t                x1: Math.round(_13 * x + _23 * cmd.x1),\n\t                y1: Math.round(_13 * y + _23 * cmd.y1),\n\t                x2: Math.round(_13 * cmd.x + _23 * cmd.x1),\n\t                y2: Math.round(_13 * cmd.y + _23 * cmd.y1)\n\t            };\n\t        }\n\n\t        if (cmd.type === 'M') {\n\t            dx = Math.round(cmd.x - x);\n\t            dy = Math.round(cmd.y - y);\n\t            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n\t            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n\t            ops.push({name: 'rmoveto', type: 'OP', value: 21});\n\t            x = Math.round(cmd.x);\n\t            y = Math.round(cmd.y);\n\t        } else if (cmd.type === 'L') {\n\t            dx = Math.round(cmd.x - x);\n\t            dy = Math.round(cmd.y - y);\n\t            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n\t            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n\t            ops.push({name: 'rlineto', type: 'OP', value: 5});\n\t            x = Math.round(cmd.x);\n\t            y = Math.round(cmd.y);\n\t        } else if (cmd.type === 'C') {\n\t            var dx1 = Math.round(cmd.x1 - x);\n\t            var dy1 = Math.round(cmd.y1 - y);\n\t            var dx2 = Math.round(cmd.x2 - cmd.x1);\n\t            var dy2 = Math.round(cmd.y2 - cmd.y1);\n\t            dx = Math.round(cmd.x - cmd.x2);\n\t            dy = Math.round(cmd.y - cmd.y2);\n\t            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});\n\t            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});\n\t            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});\n\t            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});\n\t            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n\t            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n\t            ops.push({name: 'rrcurveto', type: 'OP', value: 8});\n\t            x = Math.round(cmd.x);\n\t            y = Math.round(cmd.y);\n\t        }\n\n\t        // Contours are closed automatically.\n\t    }\n\n\t    ops.push({name: 'endchar', type: 'OP', value: 14});\n\t    return ops;\n\t}\n\n\tfunction makeCharStringsIndex(glyphs) {\n\t    var t = new table.Record('CharStrings INDEX', [\n\t        {name: 'charStrings', type: 'INDEX', value: []}\n\t    ]);\n\n\t    for (var i = 0; i < glyphs.length; i += 1) {\n\t        var glyph = glyphs.get(i);\n\t        var ops = glyphToOps(glyph);\n\t        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});\n\t    }\n\n\t    return t;\n\t}\n\n\tfunction makePrivateDict(attrs, strings) {\n\t    var t = new table.Record('Private DICT', [\n\t        {name: 'dict', type: 'DICT', value: {}}\n\t    ]);\n\t    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);\n\t    return t;\n\t}\n\n\tfunction makeCFFTable(glyphs, options) {\n\t    var t = new table.Table('CFF ', [\n\t        {name: 'header', type: 'RECORD'},\n\t        {name: 'nameIndex', type: 'RECORD'},\n\t        {name: 'topDictIndex', type: 'RECORD'},\n\t        {name: 'stringIndex', type: 'RECORD'},\n\t        {name: 'globalSubrIndex', type: 'RECORD'},\n\t        {name: 'charsets', type: 'RECORD'},\n\t        {name: 'charStringsIndex', type: 'RECORD'},\n\t        {name: 'privateDict', type: 'RECORD'}\n\t    ]);\n\n\t    var fontScale = 1 / options.unitsPerEm;\n\t    // We use non-zero values for the offsets so that the DICT encodes them.\n\t    // This is important because the size of the Top DICT plays a role in offset calculation,\n\t    // and the size shouldn't change after we've written correct offsets.\n\t    var attrs = {\n\t        version: options.version,\n\t        fullName: options.fullName,\n\t        familyName: options.familyName,\n\t        weight: options.weightName,\n\t        fontBBox: options.fontBBox || [0, 0, 0, 0],\n\t        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],\n\t        charset: 999,\n\t        encoding: 0,\n\t        charStrings: 999,\n\t        private: [0, 999]\n\t    };\n\n\t    var privateAttrs = {};\n\n\t    var glyphNames = [];\n\t    var glyph;\n\n\t    // Skip first glyph (.notdef)\n\t    for (var i = 1; i < glyphs.length; i += 1) {\n\t        glyph = glyphs.get(i);\n\t        glyphNames.push(glyph.name);\n\t    }\n\n\t    var strings = [];\n\n\t    t.header = makeHeader();\n\t    t.nameIndex = makeNameIndex([options.postScriptName]);\n\t    var topDict = makeTopDict(attrs, strings);\n\t    t.topDictIndex = makeTopDictIndex(topDict);\n\t    t.globalSubrIndex = makeGlobalSubrIndex();\n\t    t.charsets = makeCharsets(glyphNames, strings);\n\t    t.charStringsIndex = makeCharStringsIndex(glyphs);\n\t    t.privateDict = makePrivateDict(privateAttrs, strings);\n\n\t    // Needs to come at the end, to encode all custom strings used in the font.\n\t    t.stringIndex = makeStringIndex(strings);\n\n\t    var startOffset = t.header.sizeOf() +\n\t        t.nameIndex.sizeOf() +\n\t        t.topDictIndex.sizeOf() +\n\t        t.stringIndex.sizeOf() +\n\t        t.globalSubrIndex.sizeOf();\n\t    attrs.charset = startOffset;\n\n\t    // We use the CFF standard encoding; proper encoding will be handled in cmap.\n\t    attrs.encoding = 0;\n\t    attrs.charStrings = attrs.charset + t.charsets.sizeOf();\n\t    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();\n\n\t    // Recreate the Top DICT INDEX with the correct offsets.\n\t    topDict = makeTopDict(attrs, strings);\n\t    t.topDictIndex = makeTopDictIndex(topDict);\n\n\t    return t;\n\t}\n\n\tvar cff = { parse: parseCFFTable, make: makeCFFTable };\n\n\t// The `head` table contains global information about the font.\n\n\t// Parse the header `head` table\n\tfunction parseHeadTable(data, start) {\n\t    var head = {};\n\t    var p = new parse.Parser(data, start);\n\t    head.version = p.parseVersion();\n\t    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;\n\t    head.checkSumAdjustment = p.parseULong();\n\t    head.magicNumber = p.parseULong();\n\t    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');\n\t    head.flags = p.parseUShort();\n\t    head.unitsPerEm = p.parseUShort();\n\t    head.created = p.parseLongDateTime();\n\t    head.modified = p.parseLongDateTime();\n\t    head.xMin = p.parseShort();\n\t    head.yMin = p.parseShort();\n\t    head.xMax = p.parseShort();\n\t    head.yMax = p.parseShort();\n\t    head.macStyle = p.parseUShort();\n\t    head.lowestRecPPEM = p.parseUShort();\n\t    head.fontDirectionHint = p.parseShort();\n\t    head.indexToLocFormat = p.parseShort();\n\t    head.glyphDataFormat = p.parseShort();\n\t    return head;\n\t}\n\n\tfunction makeHeadTable(options) {\n\t    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970\n\t    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;\n\t    var createdTimestamp = timestamp;\n\n\t    if (options.createdTimestamp) {\n\t        createdTimestamp = options.createdTimestamp + 2082844800;\n\t    }\n\n\t    return new table.Table('head', [\n\t        {name: 'version', type: 'FIXED', value: 0x00010000},\n\t        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},\n\t        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},\n\t        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},\n\t        {name: 'flags', type: 'USHORT', value: 0},\n\t        {name: 'unitsPerEm', type: 'USHORT', value: 1000},\n\t        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},\n\t        {name: 'modified', type: 'LONGDATETIME', value: timestamp},\n\t        {name: 'xMin', type: 'SHORT', value: 0},\n\t        {name: 'yMin', type: 'SHORT', value: 0},\n\t        {name: 'xMax', type: 'SHORT', value: 0},\n\t        {name: 'yMax', type: 'SHORT', value: 0},\n\t        {name: 'macStyle', type: 'USHORT', value: 0},\n\t        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},\n\t        {name: 'fontDirectionHint', type: 'SHORT', value: 2},\n\t        {name: 'indexToLocFormat', type: 'SHORT', value: 0},\n\t        {name: 'glyphDataFormat', type: 'SHORT', value: 0}\n\t    ], options);\n\t}\n\n\tvar head = { parse: parseHeadTable, make: makeHeadTable };\n\n\t// The `hhea` table contains information for horizontal layout.\n\n\t// Parse the horizontal header `hhea` table\n\tfunction parseHheaTable(data, start) {\n\t    var hhea = {};\n\t    var p = new parse.Parser(data, start);\n\t    hhea.version = p.parseVersion();\n\t    hhea.ascender = p.parseShort();\n\t    hhea.descender = p.parseShort();\n\t    hhea.lineGap = p.parseShort();\n\t    hhea.advanceWidthMax = p.parseUShort();\n\t    hhea.minLeftSideBearing = p.parseShort();\n\t    hhea.minRightSideBearing = p.parseShort();\n\t    hhea.xMaxExtent = p.parseShort();\n\t    hhea.caretSlopeRise = p.parseShort();\n\t    hhea.caretSlopeRun = p.parseShort();\n\t    hhea.caretOffset = p.parseShort();\n\t    p.relativeOffset += 8;\n\t    hhea.metricDataFormat = p.parseShort();\n\t    hhea.numberOfHMetrics = p.parseUShort();\n\t    return hhea;\n\t}\n\n\tfunction makeHheaTable(options) {\n\t    return new table.Table('hhea', [\n\t        {name: 'version', type: 'FIXED', value: 0x00010000},\n\t        {name: 'ascender', type: 'FWORD', value: 0},\n\t        {name: 'descender', type: 'FWORD', value: 0},\n\t        {name: 'lineGap', type: 'FWORD', value: 0},\n\t        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},\n\t        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},\n\t        {name: 'minRightSideBearing', type: 'FWORD', value: 0},\n\t        {name: 'xMaxExtent', type: 'FWORD', value: 0},\n\t        {name: 'caretSlopeRise', type: 'SHORT', value: 1},\n\t        {name: 'caretSlopeRun', type: 'SHORT', value: 0},\n\t        {name: 'caretOffset', type: 'SHORT', value: 0},\n\t        {name: 'reserved1', type: 'SHORT', value: 0},\n\t        {name: 'reserved2', type: 'SHORT', value: 0},\n\t        {name: 'reserved3', type: 'SHORT', value: 0},\n\t        {name: 'reserved4', type: 'SHORT', value: 0},\n\t        {name: 'metricDataFormat', type: 'SHORT', value: 0},\n\t        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}\n\t    ], options);\n\t}\n\n\tvar hhea = { parse: parseHheaTable, make: makeHheaTable };\n\n\t// The `hmtx` table contains the horizontal metrics for all glyphs.\n\n\tfunction parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {\n\t    var advanceWidth;\n\t    var leftSideBearing;\n\t    var p = new parse.Parser(data, start);\n\t    for (var i = 0; i < numGlyphs; i += 1) {\n\t        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n\t        if (i < numMetrics) {\n\t            advanceWidth = p.parseUShort();\n\t            leftSideBearing = p.parseShort();\n\t        }\n\n\t        var glyph = glyphs.get(i);\n\t        glyph.advanceWidth = advanceWidth;\n\t        glyph.leftSideBearing = leftSideBearing;\n\t    }\n\t}\n\n\tfunction parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {\n\t    font._hmtxTableData = {};\n\n\t    var advanceWidth;\n\t    var leftSideBearing;\n\t    var p = new parse.Parser(data, start);\n\t    for (var i = 0; i < numGlyphs; i += 1) {\n\t        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n\t        if (i < numMetrics) {\n\t            advanceWidth = p.parseUShort();\n\t            leftSideBearing = p.parseShort();\n\t        }\n\n\t        font._hmtxTableData[i] = {\n\t            advanceWidth: advanceWidth,\n\t            leftSideBearing: leftSideBearing\n\t        };\n\t    }\n\t}\n\n\t// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n\t// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\n\tfunction parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {\n\t    if (opt.lowMemory)\n\t        { parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs); }\n\t    else\n\t        { parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs); }\n\t}\n\n\tfunction makeHmtxTable(glyphs) {\n\t    var t = new table.Table('hmtx', []);\n\t    for (var i = 0; i < glyphs.length; i += 1) {\n\t        var glyph = glyphs.get(i);\n\t        var advanceWidth = glyph.advanceWidth || 0;\n\t        var leftSideBearing = glyph.leftSideBearing || 0;\n\t        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});\n\t        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});\n\t    }\n\n\t    return t;\n\t}\n\n\tvar hmtx = { parse: parseHmtxTable, make: makeHmtxTable };\n\n\t// The `ltag` table stores IETF BCP-47 language tags. It allows supporting\n\n\tfunction makeLtagTable(tags) {\n\t    var result = new table.Table('ltag', [\n\t        {name: 'version', type: 'ULONG', value: 1},\n\t        {name: 'flags', type: 'ULONG', value: 0},\n\t        {name: 'numTags', type: 'ULONG', value: tags.length}\n\t    ]);\n\n\t    var stringPool = '';\n\t    var stringPoolOffset = 12 + tags.length * 4;\n\t    for (var i = 0; i < tags.length; ++i) {\n\t        var pos = stringPool.indexOf(tags[i]);\n\t        if (pos < 0) {\n\t            pos = stringPool.length;\n\t            stringPool += tags[i];\n\t        }\n\n\t        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});\n\t        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});\n\t    }\n\n\t    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n\t    return result;\n\t}\n\n\tfunction parseLtagTable(data, start) {\n\t    var p = new parse.Parser(data, start);\n\t    var tableVersion = p.parseULong();\n\t    check.argument(tableVersion === 1, 'Unsupported ltag table version.');\n\t    // The 'ltag' specification does not define any flags; skip the field.\n\t    p.skip('uLong', 1);\n\t    var numTags = p.parseULong();\n\n\t    var tags = [];\n\t    for (var i = 0; i < numTags; i++) {\n\t        var tag = '';\n\t        var offset = start + p.parseUShort();\n\t        var length = p.parseUShort();\n\t        for (var j = offset; j < offset + length; ++j) {\n\t            tag += String.fromCharCode(data.getInt8(j));\n\t        }\n\n\t        tags.push(tag);\n\t    }\n\n\t    return tags;\n\t}\n\n\tvar ltag = { make: makeLtagTable, parse: parseLtagTable };\n\n\t// The `maxp` table establishes the memory requirements for the font.\n\n\t// Parse the maximum profile `maxp` table.\n\tfunction parseMaxpTable(data, start) {\n\t    var maxp = {};\n\t    var p = new parse.Parser(data, start);\n\t    maxp.version = p.parseVersion();\n\t    maxp.numGlyphs = p.parseUShort();\n\t    if (maxp.version === 1.0) {\n\t        maxp.maxPoints = p.parseUShort();\n\t        maxp.maxContours = p.parseUShort();\n\t        maxp.maxCompositePoints = p.parseUShort();\n\t        maxp.maxCompositeContours = p.parseUShort();\n\t        maxp.maxZones = p.parseUShort();\n\t        maxp.maxTwilightPoints = p.parseUShort();\n\t        maxp.maxStorage = p.parseUShort();\n\t        maxp.maxFunctionDefs = p.parseUShort();\n\t        maxp.maxInstructionDefs = p.parseUShort();\n\t        maxp.maxStackElements = p.parseUShort();\n\t        maxp.maxSizeOfInstructions = p.parseUShort();\n\t        maxp.maxComponentElements = p.parseUShort();\n\t        maxp.maxComponentDepth = p.parseUShort();\n\t    }\n\n\t    return maxp;\n\t}\n\n\tfunction makeMaxpTable(numGlyphs) {\n\t    return new table.Table('maxp', [\n\t        {name: 'version', type: 'FIXED', value: 0x00005000},\n\t        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}\n\t    ]);\n\t}\n\n\tvar maxp = { parse: parseMaxpTable, make: makeMaxpTable };\n\n\t// The `name` naming table.\n\n\t// NameIDs for the name table.\n\tvar nameTableNames = [\n\t    'copyright',              // 0\n\t    'fontFamily',             // 1\n\t    'fontSubfamily',          // 2\n\t    'uniqueID',               // 3\n\t    'fullName',               // 4\n\t    'version',                // 5\n\t    'postScriptName',         // 6\n\t    'trademark',              // 7\n\t    'manufacturer',           // 8\n\t    'designer',               // 9\n\t    'description',            // 10\n\t    'manufacturerURL',        // 11\n\t    'designerURL',            // 12\n\t    'license',                // 13\n\t    'licenseURL',             // 14\n\t    'reserved',               // 15\n\t    'preferredFamily',        // 16\n\t    'preferredSubfamily',     // 17\n\t    'compatibleFullName',     // 18\n\t    'sampleText',             // 19\n\t    'postScriptFindFontName', // 20\n\t    'wwsFamily',              // 21\n\t    'wwsSubfamily'            // 22\n\t];\n\n\tvar macLanguages = {\n\t    0: 'en',\n\t    1: 'fr',\n\t    2: 'de',\n\t    3: 'it',\n\t    4: 'nl',\n\t    5: 'sv',\n\t    6: 'es',\n\t    7: 'da',\n\t    8: 'pt',\n\t    9: 'no',\n\t    10: 'he',\n\t    11: 'ja',\n\t    12: 'ar',\n\t    13: 'fi',\n\t    14: 'el',\n\t    15: 'is',\n\t    16: 'mt',\n\t    17: 'tr',\n\t    18: 'hr',\n\t    19: 'zh-Hant',\n\t    20: 'ur',\n\t    21: 'hi',\n\t    22: 'th',\n\t    23: 'ko',\n\t    24: 'lt',\n\t    25: 'pl',\n\t    26: 'hu',\n\t    27: 'es',\n\t    28: 'lv',\n\t    29: 'se',\n\t    30: 'fo',\n\t    31: 'fa',\n\t    32: 'ru',\n\t    33: 'zh',\n\t    34: 'nl-BE',\n\t    35: 'ga',\n\t    36: 'sq',\n\t    37: 'ro',\n\t    38: 'cz',\n\t    39: 'sk',\n\t    40: 'si',\n\t    41: 'yi',\n\t    42: 'sr',\n\t    43: 'mk',\n\t    44: 'bg',\n\t    45: 'uk',\n\t    46: 'be',\n\t    47: 'uz',\n\t    48: 'kk',\n\t    49: 'az-Cyrl',\n\t    50: 'az-Arab',\n\t    51: 'hy',\n\t    52: 'ka',\n\t    53: 'mo',\n\t    54: 'ky',\n\t    55: 'tg',\n\t    56: 'tk',\n\t    57: 'mn-CN',\n\t    58: 'mn',\n\t    59: 'ps',\n\t    60: 'ks',\n\t    61: 'ku',\n\t    62: 'sd',\n\t    63: 'bo',\n\t    64: 'ne',\n\t    65: 'sa',\n\t    66: 'mr',\n\t    67: 'bn',\n\t    68: 'as',\n\t    69: 'gu',\n\t    70: 'pa',\n\t    71: 'or',\n\t    72: 'ml',\n\t    73: 'kn',\n\t    74: 'ta',\n\t    75: 'te',\n\t    76: 'si',\n\t    77: 'my',\n\t    78: 'km',\n\t    79: 'lo',\n\t    80: 'vi',\n\t    81: 'id',\n\t    82: 'tl',\n\t    83: 'ms',\n\t    84: 'ms-Arab',\n\t    85: 'am',\n\t    86: 'ti',\n\t    87: 'om',\n\t    88: 'so',\n\t    89: 'sw',\n\t    90: 'rw',\n\t    91: 'rn',\n\t    92: 'ny',\n\t    93: 'mg',\n\t    94: 'eo',\n\t    128: 'cy',\n\t    129: 'eu',\n\t    130: 'ca',\n\t    131: 'la',\n\t    132: 'qu',\n\t    133: 'gn',\n\t    134: 'ay',\n\t    135: 'tt',\n\t    136: 'ug',\n\t    137: 'dz',\n\t    138: 'jv',\n\t    139: 'su',\n\t    140: 'gl',\n\t    141: 'af',\n\t    142: 'br',\n\t    143: 'iu',\n\t    144: 'gd',\n\t    145: 'gv',\n\t    146: 'ga',\n\t    147: 'to',\n\t    148: 'el-polyton',\n\t    149: 'kl',\n\t    150: 'az',\n\t    151: 'nn'\n\t};\n\n\t// MacOS language ID → MacOS script ID\n\t//\n\t// Note that the script ID is not sufficient to determine what encoding\n\t// to use in TrueType files. For some languages, MacOS used a modification\n\t// of a mainstream script. For example, an Icelandic name would be stored\n\t// with smRoman in the TrueType naming table, but the actual encoding\n\t// is a special Icelandic version of the normal Macintosh Roman encoding.\n\t// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal\n\t// Syllables but MacOS had run out of available script codes, so this was\n\t// done as a (pretty radical) \"modification\" of Ethiopic.\n\t//\n\t// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\n\tvar macLanguageToScript = {\n\t    0: 0,  // langEnglish → smRoman\n\t    1: 0,  // langFrench → smRoman\n\t    2: 0,  // langGerman → smRoman\n\t    3: 0,  // langItalian → smRoman\n\t    4: 0,  // langDutch → smRoman\n\t    5: 0,  // langSwedish → smRoman\n\t    6: 0,  // langSpanish → smRoman\n\t    7: 0,  // langDanish → smRoman\n\t    8: 0,  // langPortuguese → smRoman\n\t    9: 0,  // langNorwegian → smRoman\n\t    10: 5,  // langHebrew → smHebrew\n\t    11: 1,  // langJapanese → smJapanese\n\t    12: 4,  // langArabic → smArabic\n\t    13: 0,  // langFinnish → smRoman\n\t    14: 6,  // langGreek → smGreek\n\t    15: 0,  // langIcelandic → smRoman (modified)\n\t    16: 0,  // langMaltese → smRoman\n\t    17: 0,  // langTurkish → smRoman (modified)\n\t    18: 0,  // langCroatian → smRoman (modified)\n\t    19: 2,  // langTradChinese → smTradChinese\n\t    20: 4,  // langUrdu → smArabic\n\t    21: 9,  // langHindi → smDevanagari\n\t    22: 21,  // langThai → smThai\n\t    23: 3,  // langKorean → smKorean\n\t    24: 29,  // langLithuanian → smCentralEuroRoman\n\t    25: 29,  // langPolish → smCentralEuroRoman\n\t    26: 29,  // langHungarian → smCentralEuroRoman\n\t    27: 29,  // langEstonian → smCentralEuroRoman\n\t    28: 29,  // langLatvian → smCentralEuroRoman\n\t    29: 0,  // langSami → smRoman\n\t    30: 0,  // langFaroese → smRoman (modified)\n\t    31: 4,  // langFarsi → smArabic (modified)\n\t    32: 7,  // langRussian → smCyrillic\n\t    33: 25,  // langSimpChinese → smSimpChinese\n\t    34: 0,  // langFlemish → smRoman\n\t    35: 0,  // langIrishGaelic → smRoman (modified)\n\t    36: 0,  // langAlbanian → smRoman\n\t    37: 0,  // langRomanian → smRoman (modified)\n\t    38: 29,  // langCzech → smCentralEuroRoman\n\t    39: 29,  // langSlovak → smCentralEuroRoman\n\t    40: 0,  // langSlovenian → smRoman (modified)\n\t    41: 5,  // langYiddish → smHebrew\n\t    42: 7,  // langSerbian → smCyrillic\n\t    43: 7,  // langMacedonian → smCyrillic\n\t    44: 7,  // langBulgarian → smCyrillic\n\t    45: 7,  // langUkrainian → smCyrillic (modified)\n\t    46: 7,  // langByelorussian → smCyrillic\n\t    47: 7,  // langUzbek → smCyrillic\n\t    48: 7,  // langKazakh → smCyrillic\n\t    49: 7,  // langAzerbaijani → smCyrillic\n\t    50: 4,  // langAzerbaijanAr → smArabic\n\t    51: 24,  // langArmenian → smArmenian\n\t    52: 23,  // langGeorgian → smGeorgian\n\t    53: 7,  // langMoldavian → smCyrillic\n\t    54: 7,  // langKirghiz → smCyrillic\n\t    55: 7,  // langTajiki → smCyrillic\n\t    56: 7,  // langTurkmen → smCyrillic\n\t    57: 27,  // langMongolian → smMongolian\n\t    58: 7,  // langMongolianCyr → smCyrillic\n\t    59: 4,  // langPashto → smArabic\n\t    60: 4,  // langKurdish → smArabic\n\t    61: 4,  // langKashmiri → smArabic\n\t    62: 4,  // langSindhi → smArabic\n\t    63: 26,  // langTibetan → smTibetan\n\t    64: 9,  // langNepali → smDevanagari\n\t    65: 9,  // langSanskrit → smDevanagari\n\t    66: 9,  // langMarathi → smDevanagari\n\t    67: 13,  // langBengali → smBengali\n\t    68: 13,  // langAssamese → smBengali\n\t    69: 11,  // langGujarati → smGujarati\n\t    70: 10,  // langPunjabi → smGurmukhi\n\t    71: 12,  // langOriya → smOriya\n\t    72: 17,  // langMalayalam → smMalayalam\n\t    73: 16,  // langKannada → smKannada\n\t    74: 14,  // langTamil → smTamil\n\t    75: 15,  // langTelugu → smTelugu\n\t    76: 18,  // langSinhalese → smSinhalese\n\t    77: 19,  // langBurmese → smBurmese\n\t    78: 20,  // langKhmer → smKhmer\n\t    79: 22,  // langLao → smLao\n\t    80: 30,  // langVietnamese → smVietnamese\n\t    81: 0,  // langIndonesian → smRoman\n\t    82: 0,  // langTagalog → smRoman\n\t    83: 0,  // langMalayRoman → smRoman\n\t    84: 4,  // langMalayArabic → smArabic\n\t    85: 28,  // langAmharic → smEthiopic\n\t    86: 28,  // langTigrinya → smEthiopic\n\t    87: 28,  // langOromo → smEthiopic\n\t    88: 0,  // langSomali → smRoman\n\t    89: 0,  // langSwahili → smRoman\n\t    90: 0,  // langKinyarwanda → smRoman\n\t    91: 0,  // langRundi → smRoman\n\t    92: 0,  // langNyanja → smRoman\n\t    93: 0,  // langMalagasy → smRoman\n\t    94: 0,  // langEsperanto → smRoman\n\t    128: 0,  // langWelsh → smRoman (modified)\n\t    129: 0,  // langBasque → smRoman\n\t    130: 0,  // langCatalan → smRoman\n\t    131: 0,  // langLatin → smRoman\n\t    132: 0,  // langQuechua → smRoman\n\t    133: 0,  // langGuarani → smRoman\n\t    134: 0,  // langAymara → smRoman\n\t    135: 7,  // langTatar → smCyrillic\n\t    136: 4,  // langUighur → smArabic\n\t    137: 26,  // langDzongkha → smTibetan\n\t    138: 0,  // langJavaneseRom → smRoman\n\t    139: 0,  // langSundaneseRom → smRoman\n\t    140: 0,  // langGalician → smRoman\n\t    141: 0,  // langAfrikaans → smRoman\n\t    142: 0,  // langBreton → smRoman (modified)\n\t    143: 28,  // langInuktitut → smEthiopic (modified)\n\t    144: 0,  // langScottishGaelic → smRoman (modified)\n\t    145: 0,  // langManxGaelic → smRoman (modified)\n\t    146: 0,  // langIrishGaelicScript → smRoman (modified)\n\t    147: 0,  // langTongan → smRoman\n\t    148: 6,  // langGreekAncient → smRoman\n\t    149: 0,  // langGreenlandic → smRoman\n\t    150: 0,  // langAzerbaijanRoman → smRoman\n\t    151: 0   // langNynorsk → smRoman\n\t};\n\n\t// While Microsoft indicates a region/country for all its language\n\t// IDs, we omit the region code if it's equal to the \"most likely\n\t// region subtag\" according to Unicode CLDR. For scripts, we omit\n\t// the subtag if it is equal to the Suppress-Script entry in the\n\t// IANA language subtag registry for IETF BCP 47.\n\t//\n\t// For example, Microsoft states that its language code 0x041A is\n\t// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'\n\t// and not 'hr-HR' because Croatia is the default country for Croatian,\n\t// according to Unicode CLDR. As another example, Microsoft states\n\t// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform\n\t// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script\n\t// for the Croatian language, according to IANA.\n\t//\n\t// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html\n\t// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\n\tvar windowsLanguages = {\n\t    0x0436: 'af',\n\t    0x041C: 'sq',\n\t    0x0484: 'gsw',\n\t    0x045E: 'am',\n\t    0x1401: 'ar-DZ',\n\t    0x3C01: 'ar-BH',\n\t    0x0C01: 'ar',\n\t    0x0801: 'ar-IQ',\n\t    0x2C01: 'ar-JO',\n\t    0x3401: 'ar-KW',\n\t    0x3001: 'ar-LB',\n\t    0x1001: 'ar-LY',\n\t    0x1801: 'ary',\n\t    0x2001: 'ar-OM',\n\t    0x4001: 'ar-QA',\n\t    0x0401: 'ar-SA',\n\t    0x2801: 'ar-SY',\n\t    0x1C01: 'aeb',\n\t    0x3801: 'ar-AE',\n\t    0x2401: 'ar-YE',\n\t    0x042B: 'hy',\n\t    0x044D: 'as',\n\t    0x082C: 'az-Cyrl',\n\t    0x042C: 'az',\n\t    0x046D: 'ba',\n\t    0x042D: 'eu',\n\t    0x0423: 'be',\n\t    0x0845: 'bn',\n\t    0x0445: 'bn-IN',\n\t    0x201A: 'bs-Cyrl',\n\t    0x141A: 'bs',\n\t    0x047E: 'br',\n\t    0x0402: 'bg',\n\t    0x0403: 'ca',\n\t    0x0C04: 'zh-HK',\n\t    0x1404: 'zh-MO',\n\t    0x0804: 'zh',\n\t    0x1004: 'zh-SG',\n\t    0x0404: 'zh-TW',\n\t    0x0483: 'co',\n\t    0x041A: 'hr',\n\t    0x101A: 'hr-BA',\n\t    0x0405: 'cs',\n\t    0x0406: 'da',\n\t    0x048C: 'prs',\n\t    0x0465: 'dv',\n\t    0x0813: 'nl-BE',\n\t    0x0413: 'nl',\n\t    0x0C09: 'en-AU',\n\t    0x2809: 'en-BZ',\n\t    0x1009: 'en-CA',\n\t    0x2409: 'en-029',\n\t    0x4009: 'en-IN',\n\t    0x1809: 'en-IE',\n\t    0x2009: 'en-JM',\n\t    0x4409: 'en-MY',\n\t    0x1409: 'en-NZ',\n\t    0x3409: 'en-PH',\n\t    0x4809: 'en-SG',\n\t    0x1C09: 'en-ZA',\n\t    0x2C09: 'en-TT',\n\t    0x0809: 'en-GB',\n\t    0x0409: 'en',\n\t    0x3009: 'en-ZW',\n\t    0x0425: 'et',\n\t    0x0438: 'fo',\n\t    0x0464: 'fil',\n\t    0x040B: 'fi',\n\t    0x080C: 'fr-BE',\n\t    0x0C0C: 'fr-CA',\n\t    0x040C: 'fr',\n\t    0x140C: 'fr-LU',\n\t    0x180C: 'fr-MC',\n\t    0x100C: 'fr-CH',\n\t    0x0462: 'fy',\n\t    0x0456: 'gl',\n\t    0x0437: 'ka',\n\t    0x0C07: 'de-AT',\n\t    0x0407: 'de',\n\t    0x1407: 'de-LI',\n\t    0x1007: 'de-LU',\n\t    0x0807: 'de-CH',\n\t    0x0408: 'el',\n\t    0x046F: 'kl',\n\t    0x0447: 'gu',\n\t    0x0468: 'ha',\n\t    0x040D: 'he',\n\t    0x0439: 'hi',\n\t    0x040E: 'hu',\n\t    0x040F: 'is',\n\t    0x0470: 'ig',\n\t    0x0421: 'id',\n\t    0x045D: 'iu',\n\t    0x085D: 'iu-Latn',\n\t    0x083C: 'ga',\n\t    0x0434: 'xh',\n\t    0x0435: 'zu',\n\t    0x0410: 'it',\n\t    0x0810: 'it-CH',\n\t    0x0411: 'ja',\n\t    0x044B: 'kn',\n\t    0x043F: 'kk',\n\t    0x0453: 'km',\n\t    0x0486: 'quc',\n\t    0x0487: 'rw',\n\t    0x0441: 'sw',\n\t    0x0457: 'kok',\n\t    0x0412: 'ko',\n\t    0x0440: 'ky',\n\t    0x0454: 'lo',\n\t    0x0426: 'lv',\n\t    0x0427: 'lt',\n\t    0x082E: 'dsb',\n\t    0x046E: 'lb',\n\t    0x042F: 'mk',\n\t    0x083E: 'ms-BN',\n\t    0x043E: 'ms',\n\t    0x044C: 'ml',\n\t    0x043A: 'mt',\n\t    0x0481: 'mi',\n\t    0x047A: 'arn',\n\t    0x044E: 'mr',\n\t    0x047C: 'moh',\n\t    0x0450: 'mn',\n\t    0x0850: 'mn-CN',\n\t    0x0461: 'ne',\n\t    0x0414: 'nb',\n\t    0x0814: 'nn',\n\t    0x0482: 'oc',\n\t    0x0448: 'or',\n\t    0x0463: 'ps',\n\t    0x0415: 'pl',\n\t    0x0416: 'pt',\n\t    0x0816: 'pt-PT',\n\t    0x0446: 'pa',\n\t    0x046B: 'qu-BO',\n\t    0x086B: 'qu-EC',\n\t    0x0C6B: 'qu',\n\t    0x0418: 'ro',\n\t    0x0417: 'rm',\n\t    0x0419: 'ru',\n\t    0x243B: 'smn',\n\t    0x103B: 'smj-NO',\n\t    0x143B: 'smj',\n\t    0x0C3B: 'se-FI',\n\t    0x043B: 'se',\n\t    0x083B: 'se-SE',\n\t    0x203B: 'sms',\n\t    0x183B: 'sma-NO',\n\t    0x1C3B: 'sms',\n\t    0x044F: 'sa',\n\t    0x1C1A: 'sr-Cyrl-BA',\n\t    0x0C1A: 'sr',\n\t    0x181A: 'sr-Latn-BA',\n\t    0x081A: 'sr-Latn',\n\t    0x046C: 'nso',\n\t    0x0432: 'tn',\n\t    0x045B: 'si',\n\t    0x041B: 'sk',\n\t    0x0424: 'sl',\n\t    0x2C0A: 'es-AR',\n\t    0x400A: 'es-BO',\n\t    0x340A: 'es-CL',\n\t    0x240A: 'es-CO',\n\t    0x140A: 'es-CR',\n\t    0x1C0A: 'es-DO',\n\t    0x300A: 'es-EC',\n\t    0x440A: 'es-SV',\n\t    0x100A: 'es-GT',\n\t    0x480A: 'es-HN',\n\t    0x080A: 'es-MX',\n\t    0x4C0A: 'es-NI',\n\t    0x180A: 'es-PA',\n\t    0x3C0A: 'es-PY',\n\t    0x280A: 'es-PE',\n\t    0x500A: 'es-PR',\n\n\t    // Microsoft has defined two different language codes for\n\t    // “Spanish with modern sorting” and “Spanish with traditional\n\t    // sorting”. This makes sense for collation APIs, and it would be\n\t    // possible to express this in BCP 47 language tags via Unicode\n\t    // extensions (eg., es-u-co-trad is Spanish with traditional\n\t    // sorting). However, for storing names in fonts, the distinction\n\t    // does not make sense, so we give “es” in both cases.\n\t    0x0C0A: 'es',\n\t    0x040A: 'es',\n\n\t    0x540A: 'es-US',\n\t    0x380A: 'es-UY',\n\t    0x200A: 'es-VE',\n\t    0x081D: 'sv-FI',\n\t    0x041D: 'sv',\n\t    0x045A: 'syr',\n\t    0x0428: 'tg',\n\t    0x085F: 'tzm',\n\t    0x0449: 'ta',\n\t    0x0444: 'tt',\n\t    0x044A: 'te',\n\t    0x041E: 'th',\n\t    0x0451: 'bo',\n\t    0x041F: 'tr',\n\t    0x0442: 'tk',\n\t    0x0480: 'ug',\n\t    0x0422: 'uk',\n\t    0x042E: 'hsb',\n\t    0x0420: 'ur',\n\t    0x0843: 'uz-Cyrl',\n\t    0x0443: 'uz',\n\t    0x042A: 'vi',\n\t    0x0452: 'cy',\n\t    0x0488: 'wo',\n\t    0x0485: 'sah',\n\t    0x0478: 'ii',\n\t    0x046A: 'yo'\n\t};\n\n\t// Returns a IETF BCP 47 language code, for example 'zh-Hant'\n\t// for 'Chinese in the traditional script'.\n\tfunction getLanguageCode(platformID, languageID, ltag) {\n\t    switch (platformID) {\n\t        case 0:  // Unicode\n\t            if (languageID === 0xFFFF) {\n\t                return 'und';\n\t            } else if (ltag) {\n\t                return ltag[languageID];\n\t            }\n\n\t            break;\n\n\t        case 1:  // Macintosh\n\t            return macLanguages[languageID];\n\n\t        case 3:  // Windows\n\t            return windowsLanguages[languageID];\n\t    }\n\n\t    return undefined;\n\t}\n\n\tvar utf16 = 'utf-16';\n\n\t// MacOS script ID → encoding. This table stores the default case,\n\t// which can be overridden by macLanguageEncodings.\n\tvar macScriptEncodings = {\n\t    0: 'macintosh',           // smRoman\n\t    1: 'x-mac-japanese',      // smJapanese\n\t    2: 'x-mac-chinesetrad',   // smTradChinese\n\t    3: 'x-mac-korean',        // smKorean\n\t    6: 'x-mac-greek',         // smGreek\n\t    7: 'x-mac-cyrillic',      // smCyrillic\n\t    9: 'x-mac-devanagai',     // smDevanagari\n\t    10: 'x-mac-gurmukhi',     // smGurmukhi\n\t    11: 'x-mac-gujarati',     // smGujarati\n\t    12: 'x-mac-oriya',        // smOriya\n\t    13: 'x-mac-bengali',      // smBengali\n\t    14: 'x-mac-tamil',        // smTamil\n\t    15: 'x-mac-telugu',       // smTelugu\n\t    16: 'x-mac-kannada',      // smKannada\n\t    17: 'x-mac-malayalam',    // smMalayalam\n\t    18: 'x-mac-sinhalese',    // smSinhalese\n\t    19: 'x-mac-burmese',      // smBurmese\n\t    20: 'x-mac-khmer',        // smKhmer\n\t    21: 'x-mac-thai',         // smThai\n\t    22: 'x-mac-lao',          // smLao\n\t    23: 'x-mac-georgian',     // smGeorgian\n\t    24: 'x-mac-armenian',     // smArmenian\n\t    25: 'x-mac-chinesesimp',  // smSimpChinese\n\t    26: 'x-mac-tibetan',      // smTibetan\n\t    27: 'x-mac-mongolian',    // smMongolian\n\t    28: 'x-mac-ethiopic',     // smEthiopic\n\t    29: 'x-mac-ce',           // smCentralEuroRoman\n\t    30: 'x-mac-vietnamese',   // smVietnamese\n\t    31: 'x-mac-extarabic'     // smExtArabic\n\t};\n\n\t// MacOS language ID → encoding. This table stores the exceptional\n\t// cases, which override macScriptEncodings. For writing MacOS naming\n\t// tables, we need to emit a MacOS script ID. Therefore, we cannot\n\t// merge macScriptEncodings into macLanguageEncodings.\n\t//\n\t// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\n\tvar macLanguageEncodings = {\n\t    15: 'x-mac-icelandic',    // langIcelandic\n\t    17: 'x-mac-turkish',      // langTurkish\n\t    18: 'x-mac-croatian',     // langCroatian\n\t    24: 'x-mac-ce',           // langLithuanian\n\t    25: 'x-mac-ce',           // langPolish\n\t    26: 'x-mac-ce',           // langHungarian\n\t    27: 'x-mac-ce',           // langEstonian\n\t    28: 'x-mac-ce',           // langLatvian\n\t    30: 'x-mac-icelandic',    // langFaroese\n\t    37: 'x-mac-romanian',     // langRomanian\n\t    38: 'x-mac-ce',           // langCzech\n\t    39: 'x-mac-ce',           // langSlovak\n\t    40: 'x-mac-ce',           // langSlovenian\n\t    143: 'x-mac-inuit',       // langInuktitut\n\t    146: 'x-mac-gaelic'       // langIrishGaelicScript\n\t};\n\n\tfunction getEncoding(platformID, encodingID, languageID) {\n\t    switch (platformID) {\n\t        case 0:  // Unicode\n\t            return utf16;\n\n\t        case 1:  // Apple Macintosh\n\t            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];\n\n\t        case 3:  // Microsoft Windows\n\t            if (encodingID === 1 || encodingID === 10) {\n\t                return utf16;\n\t            }\n\n\t            break;\n\t    }\n\n\t    return undefined;\n\t}\n\n\t// Parse the naming `name` table.\n\t// FIXME: Format 1 additional fields are not supported yet.\n\t// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].\n\tfunction parseNameTable(data, start, ltag) {\n\t    var name = {};\n\t    var p = new parse.Parser(data, start);\n\t    var format = p.parseUShort();\n\t    var count = p.parseUShort();\n\t    var stringOffset = p.offset + p.parseUShort();\n\t    for (var i = 0; i < count; i++) {\n\t        var platformID = p.parseUShort();\n\t        var encodingID = p.parseUShort();\n\t        var languageID = p.parseUShort();\n\t        var nameID = p.parseUShort();\n\t        var property = nameTableNames[nameID] || nameID;\n\t        var byteLength = p.parseUShort();\n\t        var offset = p.parseUShort();\n\t        var language = getLanguageCode(platformID, languageID, ltag);\n\t        var encoding = getEncoding(platformID, encodingID, languageID);\n\t        if (encoding !== undefined && language !== undefined) {\n\t            var text = (void 0);\n\t            if (encoding === utf16) {\n\t                text = decode.UTF16(data, stringOffset + offset, byteLength);\n\t            } else {\n\t                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);\n\t            }\n\n\t            if (text) {\n\t                var translations = name[property];\n\t                if (translations === undefined) {\n\t                    translations = name[property] = {};\n\t                }\n\n\t                translations[language] = text;\n\t            }\n\t        }\n\t    }\n\n\t    var langTagCount = 0;\n\t    if (format === 1) {\n\t        // FIXME: Also handle Microsoft's 'name' table 1.\n\t        langTagCount = p.parseUShort();\n\t    }\n\n\t    return name;\n\t}\n\n\t// {23: 'foo'} → {'foo': 23}\n\t// ['bar', 'baz'] → {'bar': 0, 'baz': 1}\n\tfunction reverseDict(dict) {\n\t    var result = {};\n\t    for (var key in dict) {\n\t        result[dict[key]] = parseInt(key);\n\t    }\n\n\t    return result;\n\t}\n\n\tfunction makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {\n\t    return new table.Record('NameRecord', [\n\t        {name: 'platformID', type: 'USHORT', value: platformID},\n\t        {name: 'encodingID', type: 'USHORT', value: encodingID},\n\t        {name: 'languageID', type: 'USHORT', value: languageID},\n\t        {name: 'nameID', type: 'USHORT', value: nameID},\n\t        {name: 'length', type: 'USHORT', value: length},\n\t        {name: 'offset', type: 'USHORT', value: offset}\n\t    ]);\n\t}\n\n\t// Finds the position of needle in haystack, or -1 if not there.\n\t// Like String.indexOf(), but for arrays.\n\tfunction findSubArray(needle, haystack) {\n\t    var needleLength = needle.length;\n\t    var limit = haystack.length - needleLength + 1;\n\n\t    loop:\n\t    for (var pos = 0; pos < limit; pos++) {\n\t        for (; pos < limit; pos++) {\n\t            for (var k = 0; k < needleLength; k++) {\n\t                if (haystack[pos + k] !== needle[k]) {\n\t                    continue loop;\n\t                }\n\t            }\n\n\t            return pos;\n\t        }\n\t    }\n\n\t    return -1;\n\t}\n\n\tfunction addStringToPool(s, pool) {\n\t    var offset = findSubArray(s, pool);\n\t    if (offset < 0) {\n\t        offset = pool.length;\n\t        var i = 0;\n\t        var len = s.length;\n\t        for (; i < len; ++i) {\n\t            pool.push(s[i]);\n\t        }\n\n\t    }\n\n\t    return offset;\n\t}\n\n\tfunction makeNameTable(names, ltag) {\n\t    var nameID;\n\t    var nameIDs = [];\n\n\t    var namesWithNumericKeys = {};\n\t    var nameTableIds = reverseDict(nameTableNames);\n\t    for (var key in names) {\n\t        var id = nameTableIds[key];\n\t        if (id === undefined) {\n\t            id = key;\n\t        }\n\n\t        nameID = parseInt(id);\n\n\t        if (isNaN(nameID)) {\n\t            throw new Error('Name table entry \"' + key + '\" does not exist, see nameTableNames for complete list.');\n\t        }\n\n\t        namesWithNumericKeys[nameID] = names[key];\n\t        nameIDs.push(nameID);\n\t    }\n\n\t    var macLanguageIds = reverseDict(macLanguages);\n\t    var windowsLanguageIds = reverseDict(windowsLanguages);\n\n\t    var nameRecords = [];\n\t    var stringPool = [];\n\n\t    for (var i = 0; i < nameIDs.length; i++) {\n\t        nameID = nameIDs[i];\n\t        var translations = namesWithNumericKeys[nameID];\n\t        for (var lang in translations) {\n\t            var text = translations[lang];\n\n\t            // For MacOS, we try to emit the name in the form that was introduced\n\t            // in the initial version of the TrueType spec (in the late 1980s).\n\t            // However, this can fail for various reasons: the requested BCP 47\n\t            // language code might not have an old-style Mac equivalent;\n\t            // we might not have a codec for the needed character encoding;\n\t            // or the name might contain characters that cannot be expressed\n\t            // in the old-style Macintosh encoding. In case of failure, we emit\n\t            // the name in a more modern fashion (Unicode encoding with BCP 47\n\t            // language tags) that is recognized by MacOS 10.5, released in 2009.\n\t            // If fonts were only read by operating systems, we could simply\n\t            // emit all names in the modern form; this would be much easier.\n\t            // However, there are many applications and libraries that read\n\t            // 'name' tables directly, and these will usually only recognize\n\t            // the ancient form (silently skipping the unrecognized names).\n\t            var macPlatform = 1;  // Macintosh\n\t            var macLanguage = macLanguageIds[lang];\n\t            var macScript = macLanguageToScript[macLanguage];\n\t            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);\n\t            var macName = encode.MACSTRING(text, macEncoding);\n\t            if (macName === undefined) {\n\t                macPlatform = 0;  // Unicode\n\t                macLanguage = ltag.indexOf(lang);\n\t                if (macLanguage < 0) {\n\t                    macLanguage = ltag.length;\n\t                    ltag.push(lang);\n\t                }\n\n\t                macScript = 4;  // Unicode 2.0 and later\n\t                macName = encode.UTF16(text);\n\t            }\n\n\t            var macNameOffset = addStringToPool(macName, stringPool);\n\t            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,\n\t                                            nameID, macName.length, macNameOffset));\n\n\t            var winLanguage = windowsLanguageIds[lang];\n\t            if (winLanguage !== undefined) {\n\t                var winName = encode.UTF16(text);\n\t                var winNameOffset = addStringToPool(winName, stringPool);\n\t                nameRecords.push(makeNameRecord(3, 1, winLanguage,\n\t                                                nameID, winName.length, winNameOffset));\n\t            }\n\t        }\n\t    }\n\n\t    nameRecords.sort(function(a, b) {\n\t        return ((a.platformID - b.platformID) ||\n\t                (a.encodingID - b.encodingID) ||\n\t                (a.languageID - b.languageID) ||\n\t                (a.nameID - b.nameID));\n\t    });\n\n\t    var t = new table.Table('name', [\n\t        {name: 'format', type: 'USHORT', value: 0},\n\t        {name: 'count', type: 'USHORT', value: nameRecords.length},\n\t        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}\n\t    ]);\n\n\t    for (var r = 0; r < nameRecords.length; r++) {\n\t        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});\n\t    }\n\n\t    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});\n\t    return t;\n\t}\n\n\tvar _name = { parse: parseNameTable, make: makeNameTable };\n\n\t// The `OS/2` table contains metrics required in OpenType fonts.\n\n\tvar unicodeRanges = [\n\t    {begin: 0x0000, end: 0x007F}, // Basic Latin\n\t    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement\n\t    {begin: 0x0100, end: 0x017F}, // Latin Extended-A\n\t    {begin: 0x0180, end: 0x024F}, // Latin Extended-B\n\t    {begin: 0x0250, end: 0x02AF}, // IPA Extensions\n\t    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters\n\t    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks\n\t    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic\n\t    {begin: 0x2C80, end: 0x2CFF}, // Coptic\n\t    {begin: 0x0400, end: 0x04FF}, // Cyrillic\n\t    {begin: 0x0530, end: 0x058F}, // Armenian\n\t    {begin: 0x0590, end: 0x05FF}, // Hebrew\n\t    {begin: 0xA500, end: 0xA63F}, // Vai\n\t    {begin: 0x0600, end: 0x06FF}, // Arabic\n\t    {begin: 0x07C0, end: 0x07FF}, // NKo\n\t    {begin: 0x0900, end: 0x097F}, // Devanagari\n\t    {begin: 0x0980, end: 0x09FF}, // Bengali\n\t    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi\n\t    {begin: 0x0A80, end: 0x0AFF}, // Gujarati\n\t    {begin: 0x0B00, end: 0x0B7F}, // Oriya\n\t    {begin: 0x0B80, end: 0x0BFF}, // Tamil\n\t    {begin: 0x0C00, end: 0x0C7F}, // Telugu\n\t    {begin: 0x0C80, end: 0x0CFF}, // Kannada\n\t    {begin: 0x0D00, end: 0x0D7F}, // Malayalam\n\t    {begin: 0x0E00, end: 0x0E7F}, // Thai\n\t    {begin: 0x0E80, end: 0x0EFF}, // Lao\n\t    {begin: 0x10A0, end: 0x10FF}, // Georgian\n\t    {begin: 0x1B00, end: 0x1B7F}, // Balinese\n\t    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo\n\t    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional\n\t    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended\n\t    {begin: 0x2000, end: 0x206F}, // General Punctuation\n\t    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts\n\t    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol\n\t    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols\n\t    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols\n\t    {begin: 0x2150, end: 0x218F}, // Number Forms\n\t    {begin: 0x2190, end: 0x21FF}, // Arrows\n\t    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators\n\t    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical\n\t    {begin: 0x2400, end: 0x243F}, // Control Pictures\n\t    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition\n\t    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics\n\t    {begin: 0x2500, end: 0x257F}, // Box Drawing\n\t    {begin: 0x2580, end: 0x259F}, // Block Elements\n\t    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes\n\t    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols\n\t    {begin: 0x2700, end: 0x27BF}, // Dingbats\n\t    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation\n\t    {begin: 0x3040, end: 0x309F}, // Hiragana\n\t    {begin: 0x30A0, end: 0x30FF}, // Katakana\n\t    {begin: 0x3100, end: 0x312F}, // Bopomofo\n\t    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo\n\t    {begin: 0xA840, end: 0xA87F}, // Phags-pa\n\t    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months\n\t    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility\n\t    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables\n\t    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *\n\t    {begin: 0x10900, end: 0x1091F}, // Phoenicia\n\t    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs\n\t    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)\n\t    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes\n\t    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms\n\t    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A\n\t    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks\n\t    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms\n\t    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants\n\t    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B\n\t    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms\n\t    {begin: 0xFFF0, end: 0xFFFF}, // Specials\n\t    {begin: 0x0F00, end: 0x0FFF}, // Tibetan\n\t    {begin: 0x0700, end: 0x074F}, // Syriac\n\t    {begin: 0x0780, end: 0x07BF}, // Thaana\n\t    {begin: 0x0D80, end: 0x0DFF}, // Sinhala\n\t    {begin: 0x1000, end: 0x109F}, // Myanmar\n\t    {begin: 0x1200, end: 0x137F}, // Ethiopic\n\t    {begin: 0x13A0, end: 0x13FF}, // Cherokee\n\t    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics\n\t    {begin: 0x1680, end: 0x169F}, // Ogham\n\t    {begin: 0x16A0, end: 0x16FF}, // Runic\n\t    {begin: 0x1780, end: 0x17FF}, // Khmer\n\t    {begin: 0x1800, end: 0x18AF}, // Mongolian\n\t    {begin: 0x2800, end: 0x28FF}, // Braille Patterns\n\t    {begin: 0xA000, end: 0xA48F}, // Yi Syllables\n\t    {begin: 0x1700, end: 0x171F}, // Tagalog\n\t    {begin: 0x10300, end: 0x1032F}, // Old Italic\n\t    {begin: 0x10330, end: 0x1034F}, // Gothic\n\t    {begin: 0x10400, end: 0x1044F}, // Deseret\n\t    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols\n\t    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols\n\t    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)\n\t    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors\n\t    {begin: 0xE0000, end: 0xE007F}, // Tags\n\t    {begin: 0x1900, end: 0x194F}, // Limbu\n\t    {begin: 0x1950, end: 0x197F}, // Tai Le\n\t    {begin: 0x1980, end: 0x19DF}, // New Tai Lue\n\t    {begin: 0x1A00, end: 0x1A1F}, // Buginese\n\t    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic\n\t    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh\n\t    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols\n\t    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri\n\t    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary\n\t    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers\n\t    {begin: 0x10380, end: 0x1039F}, // Ugaritic\n\t    {begin: 0x103A0, end: 0x103DF}, // Old Persian\n\t    {begin: 0x10450, end: 0x1047F}, // Shavian\n\t    {begin: 0x10480, end: 0x104AF}, // Osmanya\n\t    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary\n\t    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi\n\t    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols\n\t    {begin: 0x12000, end: 0x123FF}, // Cuneiform\n\t    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals\n\t    {begin: 0x1B80, end: 0x1BBF}, // Sundanese\n\t    {begin: 0x1C00, end: 0x1C4F}, // Lepcha\n\t    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki\n\t    {begin: 0xA880, end: 0xA8DF}, // Saurashtra\n\t    {begin: 0xA900, end: 0xA92F}, // Kayah Li\n\t    {begin: 0xA930, end: 0xA95F}, // Rejang\n\t    {begin: 0xAA00, end: 0xAA5F}, // Cham\n\t    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols\n\t    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc\n\t    {begin: 0x102A0, end: 0x102DF}, // Carian\n\t    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles\n\t];\n\n\tfunction getUnicodeRange(unicode) {\n\t    for (var i = 0; i < unicodeRanges.length; i += 1) {\n\t        var range = unicodeRanges[i];\n\t        if (unicode >= range.begin && unicode < range.end) {\n\t            return i;\n\t        }\n\t    }\n\n\t    return -1;\n\t}\n\n\t// Parse the OS/2 and Windows metrics `OS/2` table\n\tfunction parseOS2Table(data, start) {\n\t    var os2 = {};\n\t    var p = new parse.Parser(data, start);\n\t    os2.version = p.parseUShort();\n\t    os2.xAvgCharWidth = p.parseShort();\n\t    os2.usWeightClass = p.parseUShort();\n\t    os2.usWidthClass = p.parseUShort();\n\t    os2.fsType = p.parseUShort();\n\t    os2.ySubscriptXSize = p.parseShort();\n\t    os2.ySubscriptYSize = p.parseShort();\n\t    os2.ySubscriptXOffset = p.parseShort();\n\t    os2.ySubscriptYOffset = p.parseShort();\n\t    os2.ySuperscriptXSize = p.parseShort();\n\t    os2.ySuperscriptYSize = p.parseShort();\n\t    os2.ySuperscriptXOffset = p.parseShort();\n\t    os2.ySuperscriptYOffset = p.parseShort();\n\t    os2.yStrikeoutSize = p.parseShort();\n\t    os2.yStrikeoutPosition = p.parseShort();\n\t    os2.sFamilyClass = p.parseShort();\n\t    os2.panose = [];\n\t    for (var i = 0; i < 10; i++) {\n\t        os2.panose[i] = p.parseByte();\n\t    }\n\n\t    os2.ulUnicodeRange1 = p.parseULong();\n\t    os2.ulUnicodeRange2 = p.parseULong();\n\t    os2.ulUnicodeRange3 = p.parseULong();\n\t    os2.ulUnicodeRange4 = p.parseULong();\n\t    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());\n\t    os2.fsSelection = p.parseUShort();\n\t    os2.usFirstCharIndex = p.parseUShort();\n\t    os2.usLastCharIndex = p.parseUShort();\n\t    os2.sTypoAscender = p.parseShort();\n\t    os2.sTypoDescender = p.parseShort();\n\t    os2.sTypoLineGap = p.parseShort();\n\t    os2.usWinAscent = p.parseUShort();\n\t    os2.usWinDescent = p.parseUShort();\n\t    if (os2.version >= 1) {\n\t        os2.ulCodePageRange1 = p.parseULong();\n\t        os2.ulCodePageRange2 = p.parseULong();\n\t    }\n\n\t    if (os2.version >= 2) {\n\t        os2.sxHeight = p.parseShort();\n\t        os2.sCapHeight = p.parseShort();\n\t        os2.usDefaultChar = p.parseUShort();\n\t        os2.usBreakChar = p.parseUShort();\n\t        os2.usMaxContent = p.parseUShort();\n\t    }\n\n\t    return os2;\n\t}\n\n\tfunction makeOS2Table(options) {\n\t    return new table.Table('OS/2', [\n\t        {name: 'version', type: 'USHORT', value: 0x0003},\n\t        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},\n\t        {name: 'usWeightClass', type: 'USHORT', value: 0},\n\t        {name: 'usWidthClass', type: 'USHORT', value: 0},\n\t        {name: 'fsType', type: 'USHORT', value: 0},\n\t        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},\n\t        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},\n\t        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},\n\t        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},\n\t        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},\n\t        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},\n\t        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},\n\t        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},\n\t        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},\n\t        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},\n\t        {name: 'sFamilyClass', type: 'SHORT', value: 0},\n\t        {name: 'bFamilyType', type: 'BYTE', value: 0},\n\t        {name: 'bSerifStyle', type: 'BYTE', value: 0},\n\t        {name: 'bWeight', type: 'BYTE', value: 0},\n\t        {name: 'bProportion', type: 'BYTE', value: 0},\n\t        {name: 'bContrast', type: 'BYTE', value: 0},\n\t        {name: 'bStrokeVariation', type: 'BYTE', value: 0},\n\t        {name: 'bArmStyle', type: 'BYTE', value: 0},\n\t        {name: 'bLetterform', type: 'BYTE', value: 0},\n\t        {name: 'bMidline', type: 'BYTE', value: 0},\n\t        {name: 'bXHeight', type: 'BYTE', value: 0},\n\t        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},\n\t        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},\n\t        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},\n\t        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},\n\t        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},\n\t        {name: 'fsSelection', type: 'USHORT', value: 0},\n\t        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},\n\t        {name: 'usLastCharIndex', type: 'USHORT', value: 0},\n\t        {name: 'sTypoAscender', type: 'SHORT', value: 0},\n\t        {name: 'sTypoDescender', type: 'SHORT', value: 0},\n\t        {name: 'sTypoLineGap', type: 'SHORT', value: 0},\n\t        {name: 'usWinAscent', type: 'USHORT', value: 0},\n\t        {name: 'usWinDescent', type: 'USHORT', value: 0},\n\t        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},\n\t        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},\n\t        {name: 'sxHeight', type: 'SHORT', value: 0},\n\t        {name: 'sCapHeight', type: 'SHORT', value: 0},\n\t        {name: 'usDefaultChar', type: 'USHORT', value: 0},\n\t        {name: 'usBreakChar', type: 'USHORT', value: 0},\n\t        {name: 'usMaxContext', type: 'USHORT', value: 0}\n\t    ], options);\n\t}\n\n\tvar os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };\n\n\t// The `post` table stores additional PostScript information, such as glyph names.\n\n\t// Parse the PostScript `post` table\n\tfunction parsePostTable(data, start) {\n\t    var post = {};\n\t    var p = new parse.Parser(data, start);\n\t    post.version = p.parseVersion();\n\t    post.italicAngle = p.parseFixed();\n\t    post.underlinePosition = p.parseShort();\n\t    post.underlineThickness = p.parseShort();\n\t    post.isFixedPitch = p.parseULong();\n\t    post.minMemType42 = p.parseULong();\n\t    post.maxMemType42 = p.parseULong();\n\t    post.minMemType1 = p.parseULong();\n\t    post.maxMemType1 = p.parseULong();\n\t    switch (post.version) {\n\t        case 1:\n\t            post.names = standardNames.slice();\n\t            break;\n\t        case 2:\n\t            post.numberOfGlyphs = p.parseUShort();\n\t            post.glyphNameIndex = new Array(post.numberOfGlyphs);\n\t            for (var i = 0; i < post.numberOfGlyphs; i++) {\n\t                post.glyphNameIndex[i] = p.parseUShort();\n\t            }\n\n\t            post.names = [];\n\t            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n\t                if (post.glyphNameIndex[i$1] >= standardNames.length) {\n\t                    var nameLength = p.parseChar();\n\t                    post.names.push(p.parseString(nameLength));\n\t                }\n\t            }\n\n\t            break;\n\t        case 2.5:\n\t            post.numberOfGlyphs = p.parseUShort();\n\t            post.offset = new Array(post.numberOfGlyphs);\n\t            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {\n\t                post.offset[i$2] = p.parseChar();\n\t            }\n\n\t            break;\n\t    }\n\t    return post;\n\t}\n\n\tfunction makePostTable() {\n\t    return new table.Table('post', [\n\t        {name: 'version', type: 'FIXED', value: 0x00030000},\n\t        {name: 'italicAngle', type: 'FIXED', value: 0},\n\t        {name: 'underlinePosition', type: 'FWORD', value: 0},\n\t        {name: 'underlineThickness', type: 'FWORD', value: 0},\n\t        {name: 'isFixedPitch', type: 'ULONG', value: 0},\n\t        {name: 'minMemType42', type: 'ULONG', value: 0},\n\t        {name: 'maxMemType42', type: 'ULONG', value: 0},\n\t        {name: 'minMemType1', type: 'ULONG', value: 0},\n\t        {name: 'maxMemType1', type: 'ULONG', value: 0}\n\t    ]);\n\t}\n\n\tvar post = { parse: parsePostTable, make: makePostTable };\n\n\t// The `GSUB` table contains ligatures, among other things.\n\n\tvar subtableParsers = new Array(9);         // subtableParsers[0] is unused\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS\n\tsubtableParsers[1] = function parseLookup1() {\n\t    var start = this.offset + this.relativeOffset;\n\t    var substFormat = this.parseUShort();\n\t    if (substFormat === 1) {\n\t        return {\n\t            substFormat: 1,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            deltaGlyphId: this.parseUShort()\n\t        };\n\t    } else if (substFormat === 2) {\n\t        return {\n\t            substFormat: 2,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            substitute: this.parseOffset16List()\n\t        };\n\t    }\n\t    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS\n\tsubtableParsers[2] = function parseLookup2() {\n\t    var substFormat = this.parseUShort();\n\t    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');\n\t    return {\n\t        substFormat: substFormat,\n\t        coverage: this.parsePointer(Parser.coverage),\n\t        sequences: this.parseListOfLists()\n\t    };\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS\n\tsubtableParsers[3] = function parseLookup3() {\n\t    var substFormat = this.parseUShort();\n\t    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');\n\t    return {\n\t        substFormat: substFormat,\n\t        coverage: this.parsePointer(Parser.coverage),\n\t        alternateSets: this.parseListOfLists()\n\t    };\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS\n\tsubtableParsers[4] = function parseLookup4() {\n\t    var substFormat = this.parseUShort();\n\t    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');\n\t    return {\n\t        substFormat: substFormat,\n\t        coverage: this.parsePointer(Parser.coverage),\n\t        ligatureSets: this.parseListOfLists(function() {\n\t            return {\n\t                ligGlyph: this.parseUShort(),\n\t                components: this.parseUShortList(this.parseUShort() - 1)\n\t            };\n\t        })\n\t    };\n\t};\n\n\tvar lookupRecordDesc = {\n\t    sequenceIndex: Parser.uShort,\n\t    lookupListIndex: Parser.uShort\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF\n\tsubtableParsers[5] = function parseLookup5() {\n\t    var start = this.offset + this.relativeOffset;\n\t    var substFormat = this.parseUShort();\n\n\t    if (substFormat === 1) {\n\t        return {\n\t            substFormat: substFormat,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            ruleSets: this.parseListOfLists(function() {\n\t                var glyphCount = this.parseUShort();\n\t                var substCount = this.parseUShort();\n\t                return {\n\t                    input: this.parseUShortList(glyphCount - 1),\n\t                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n\t                };\n\t            })\n\t        };\n\t    } else if (substFormat === 2) {\n\t        return {\n\t            substFormat: substFormat,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            classDef: this.parsePointer(Parser.classDef),\n\t            classSets: this.parseListOfLists(function() {\n\t                var glyphCount = this.parseUShort();\n\t                var substCount = this.parseUShort();\n\t                return {\n\t                    classes: this.parseUShortList(glyphCount - 1),\n\t                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n\t                };\n\t            })\n\t        };\n\t    } else if (substFormat === 3) {\n\t        var glyphCount = this.parseUShort();\n\t        var substCount = this.parseUShort();\n\t        return {\n\t            substFormat: substFormat,\n\t            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),\n\t            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n\t        };\n\t    }\n\t    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC\n\tsubtableParsers[6] = function parseLookup6() {\n\t    var start = this.offset + this.relativeOffset;\n\t    var substFormat = this.parseUShort();\n\t    if (substFormat === 1) {\n\t        return {\n\t            substFormat: 1,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            chainRuleSets: this.parseListOfLists(function() {\n\t                return {\n\t                    backtrack: this.parseUShortList(),\n\t                    input: this.parseUShortList(this.parseShort() - 1),\n\t                    lookahead: this.parseUShortList(),\n\t                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n\t                };\n\t            })\n\t        };\n\t    } else if (substFormat === 2) {\n\t        return {\n\t            substFormat: 2,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            backtrackClassDef: this.parsePointer(Parser.classDef),\n\t            inputClassDef: this.parsePointer(Parser.classDef),\n\t            lookaheadClassDef: this.parsePointer(Parser.classDef),\n\t            chainClassSet: this.parseListOfLists(function() {\n\t                return {\n\t                    backtrack: this.parseUShortList(),\n\t                    input: this.parseUShortList(this.parseShort() - 1),\n\t                    lookahead: this.parseUShortList(),\n\t                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n\t                };\n\t            })\n\t        };\n\t    } else if (substFormat === 3) {\n\t        return {\n\t            substFormat: 3,\n\t            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n\t            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n\t            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n\t            lookupRecords: this.parseRecordList(lookupRecordDesc)\n\t        };\n\t    }\n\t    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES\n\tsubtableParsers[7] = function parseLookup7() {\n\t    // Extension Substitution subtable\n\t    var substFormat = this.parseUShort();\n\t    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');\n\t    var extensionLookupType = this.parseUShort();\n\t    var extensionParser = new Parser(this.data, this.offset + this.parseULong());\n\t    return {\n\t        substFormat: 1,\n\t        lookupType: extensionLookupType,\n\t        extension: subtableParsers[extensionLookupType].call(extensionParser)\n\t    };\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS\n\tsubtableParsers[8] = function parseLookup8() {\n\t    var substFormat = this.parseUShort();\n\t    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');\n\t    return {\n\t        substFormat: substFormat,\n\t        coverage: this.parsePointer(Parser.coverage),\n\t        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n\t        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n\t        substitutes: this.parseUShortList()\n\t    };\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/gsub.htm\n\tfunction parseGsubTable(data, start) {\n\t    start = start || 0;\n\t    var p = new Parser(data, start);\n\t    var tableVersion = p.parseVersion(1);\n\t    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');\n\t    if (tableVersion === 1) {\n\t        return {\n\t            version: tableVersion,\n\t            scripts: p.parseScriptList(),\n\t            features: p.parseFeatureList(),\n\t            lookups: p.parseLookupList(subtableParsers)\n\t        };\n\t    } else {\n\t        return {\n\t            version: tableVersion,\n\t            scripts: p.parseScriptList(),\n\t            features: p.parseFeatureList(),\n\t            lookups: p.parseLookupList(subtableParsers),\n\t            variations: p.parseFeatureVariationsList()\n\t        };\n\t    }\n\n\t}\n\n\t// GSUB Writing //////////////////////////////////////////////\n\tvar subtableMakers = new Array(9);\n\n\tsubtableMakers[1] = function makeLookup1(subtable) {\n\t    if (subtable.substFormat === 1) {\n\t        return new table.Table('substitutionTable', [\n\t            {name: 'substFormat', type: 'USHORT', value: 1},\n\t            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},\n\t            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}\n\t        ]);\n\t    } else {\n\t        return new table.Table('substitutionTable', [\n\t            {name: 'substFormat', type: 'USHORT', value: 2},\n\t            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n\t        ].concat(table.ushortList('substitute', subtable.substitute)));\n\t    }\n\t};\n\n\tsubtableMakers[2] = function makeLookup2(subtable) {\n\t    check.assert(subtable.substFormat === 1, 'Lookup type 2 substFormat must be 1.');\n\t    return new table.Table('substitutionTable', [\n\t        {name: 'substFormat', type: 'USHORT', value: 1},\n\t        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n\t    ].concat(table.tableList('seqSet', subtable.sequences, function(sequenceSet) {\n\t        return new table.Table('sequenceSetTable', table.ushortList('sequence', sequenceSet));\n\t    })));\n\t};\n\n\tsubtableMakers[3] = function makeLookup3(subtable) {\n\t    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');\n\t    return new table.Table('substitutionTable', [\n\t        {name: 'substFormat', type: 'USHORT', value: 1},\n\t        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n\t    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {\n\t        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));\n\t    })));\n\t};\n\n\tsubtableMakers[4] = function makeLookup4(subtable) {\n\t    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');\n\t    return new table.Table('substitutionTable', [\n\t        {name: 'substFormat', type: 'USHORT', value: 1},\n\t        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n\t    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {\n\t        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {\n\t            return new table.Table('ligatureTable',\n\t                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]\n\t                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))\n\t            );\n\t        }));\n\t    })));\n\t};\n\n\tsubtableMakers[6] = function makeLookup6(subtable) {\n\t    if (subtable.substFormat === 1) {\n\t        var returnTable = new table.Table('chainContextTable', [\n\t            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat},\n\t            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n\t        ].concat(table.tableList('chainRuleSet', subtable.chainRuleSets, function(chainRuleSet) {\n\t            return new table.Table('chainRuleSetTable', table.tableList('chainRule', chainRuleSet, function(chainRule) {\n\t                var tableData = table.ushortList('backtrackGlyph', chainRule.backtrack, chainRule.backtrack.length)\n\t                    .concat(table.ushortList('inputGlyph', chainRule.input, chainRule.input.length + 1))\n\t                    .concat(table.ushortList('lookaheadGlyph', chainRule.lookahead, chainRule.lookahead.length))\n\t                    .concat(table.ushortList('substitution', [], chainRule.lookupRecords.length));\n\n\t                chainRule.lookupRecords.forEach(function (record, i) {\n\t                    tableData = tableData\n\t                        .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})\n\t                        .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});\n\t                });\n\t                return new table.Table('chainRuleTable', tableData);\n\t            }));\n\t        })));\n\t        return returnTable;\n\t    } else if (subtable.substFormat === 2) {\n\t        check.assert(false, 'lookup type 6 format 2 is not yet supported.');\n\t    } else if (subtable.substFormat === 3) {\n\t        var tableData = [\n\t            {name: 'substFormat', type: 'USHORT', value: subtable.substFormat} ];\n\n\t        tableData.push({name: 'backtrackGlyphCount', type: 'USHORT', value: subtable.backtrackCoverage.length});\n\t        subtable.backtrackCoverage.forEach(function (coverage, i) {\n\t            tableData.push({name: 'backtrackCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n\t        });\n\t        tableData.push({name: 'inputGlyphCount', type: 'USHORT', value: subtable.inputCoverage.length});\n\t        subtable.inputCoverage.forEach(function (coverage, i) {\n\t            tableData.push({name: 'inputCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n\t        });\n\t        tableData.push({name: 'lookaheadGlyphCount', type: 'USHORT', value: subtable.lookaheadCoverage.length});\n\t        subtable.lookaheadCoverage.forEach(function (coverage, i) {\n\t            tableData.push({name: 'lookaheadCoverage' + i, type: 'TABLE', value: new table.Coverage(coverage)});\n\t        });\n\n\t        tableData.push({name: 'substitutionCount', type: 'USHORT', value: subtable.lookupRecords.length});\n\t        subtable.lookupRecords.forEach(function (record, i) {\n\t            tableData = tableData\n\t                .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})\n\t                .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});\n\t        });\n\n\t        var returnTable$1 = new table.Table('chainContextTable', tableData);\n\n\t        return returnTable$1;\n\t    }\n\n\t    check.assert(false, 'lookup type 6 format must be 1, 2 or 3.');\n\t};\n\n\tfunction makeGsubTable(gsub) {\n\t    return new table.Table('GSUB', [\n\t        {name: 'version', type: 'ULONG', value: 0x10000},\n\t        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},\n\t        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},\n\t        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}\n\t    ]);\n\t}\n\n\tvar gsub = { parse: parseGsubTable, make: makeGsubTable };\n\n\t// The `GPOS` table contains kerning pairs, among other things.\n\n\t// Parse the metadata `meta` table.\n\t// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html\n\tfunction parseMetaTable(data, start) {\n\t    var p = new parse.Parser(data, start);\n\t    var tableVersion = p.parseULong();\n\t    check.argument(tableVersion === 1, 'Unsupported META table version.');\n\t    p.parseULong(); // flags - currently unused and set to 0\n\t    p.parseULong(); // tableOffset\n\t    var numDataMaps = p.parseULong();\n\n\t    var tags = {};\n\t    for (var i = 0; i < numDataMaps; i++) {\n\t        var tag = p.parseTag();\n\t        var dataOffset = p.parseULong();\n\t        var dataLength = p.parseULong();\n\t        var text = decode.UTF8(data, start + dataOffset, dataLength);\n\n\t        tags[tag] = text;\n\t    }\n\t    return tags;\n\t}\n\n\tfunction makeMetaTable(tags) {\n\t    var numTags = Object.keys(tags).length;\n\t    var stringPool = '';\n\t    var stringPoolOffset = 16 + numTags * 12;\n\n\t    var result = new table.Table('meta', [\n\t        {name: 'version', type: 'ULONG', value: 1},\n\t        {name: 'flags', type: 'ULONG', value: 0},\n\t        {name: 'offset', type: 'ULONG', value: stringPoolOffset},\n\t        {name: 'numTags', type: 'ULONG', value: numTags}\n\t    ]);\n\n\t    for (var tag in tags) {\n\t        var pos = stringPool.length;\n\t        stringPool += tags[tag];\n\n\t        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});\n\t        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});\n\t        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});\n\t    }\n\n\t    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n\n\t    return result;\n\t}\n\n\tvar meta = { parse: parseMetaTable, make: makeMetaTable };\n\n\t// The `sfnt` wrapper provides organization for the tables in the font.\n\n\tfunction log2(v) {\n\t    return Math.log(v) / Math.log(2) | 0;\n\t}\n\n\tfunction computeCheckSum(bytes) {\n\t    while (bytes.length % 4 !== 0) {\n\t        bytes.push(0);\n\t    }\n\n\t    var sum = 0;\n\t    for (var i = 0; i < bytes.length; i += 4) {\n\t        sum += (bytes[i] << 24) +\n\t            (bytes[i + 1] << 16) +\n\t            (bytes[i + 2] << 8) +\n\t            (bytes[i + 3]);\n\t    }\n\n\t    sum %= Math.pow(2, 32);\n\t    return sum;\n\t}\n\n\tfunction makeTableRecord(tag, checkSum, offset, length) {\n\t    return new table.Record('Table Record', [\n\t        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},\n\t        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},\n\t        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},\n\t        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}\n\t    ]);\n\t}\n\n\tfunction makeSfntTable(tables) {\n\t    var sfnt = new table.Table('sfnt', [\n\t        {name: 'version', type: 'TAG', value: 'OTTO'},\n\t        {name: 'numTables', type: 'USHORT', value: 0},\n\t        {name: 'searchRange', type: 'USHORT', value: 0},\n\t        {name: 'entrySelector', type: 'USHORT', value: 0},\n\t        {name: 'rangeShift', type: 'USHORT', value: 0}\n\t    ]);\n\t    sfnt.tables = tables;\n\t    sfnt.numTables = tables.length;\n\t    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));\n\t    sfnt.searchRange = 16 * highestPowerOf2;\n\t    sfnt.entrySelector = log2(highestPowerOf2);\n\t    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;\n\n\t    var recordFields = [];\n\t    var tableFields = [];\n\n\t    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);\n\t    while (offset % 4 !== 0) {\n\t        offset += 1;\n\t        tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n\t    }\n\n\t    for (var i = 0; i < tables.length; i += 1) {\n\t        var t = tables[i];\n\t        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');\n\t        var tableLength = t.sizeOf();\n\t        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);\n\t        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});\n\t        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});\n\t        offset += tableLength;\n\t        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');\n\t        while (offset % 4 !== 0) {\n\t            offset += 1;\n\t            tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n\t        }\n\t    }\n\n\t    // Table records need to be sorted alphabetically.\n\t    recordFields.sort(function(r1, r2) {\n\t        if (r1.value.tag > r2.value.tag) {\n\t            return 1;\n\t        } else {\n\t            return -1;\n\t        }\n\t    });\n\n\t    sfnt.fields = sfnt.fields.concat(recordFields);\n\t    sfnt.fields = sfnt.fields.concat(tableFields);\n\t    return sfnt;\n\t}\n\n\t// Get the metrics for a character. If the string has more than one character\n\t// this function returns metrics for the first available character.\n\t// You can provide optional fallback metrics if no characters are available.\n\tfunction metricsForChar(font, chars, notFoundMetrics) {\n\t    for (var i = 0; i < chars.length; i += 1) {\n\t        var glyphIndex = font.charToGlyphIndex(chars[i]);\n\t        if (glyphIndex > 0) {\n\t            var glyph = font.glyphs.get(glyphIndex);\n\t            return glyph.getMetrics();\n\t        }\n\t    }\n\n\t    return notFoundMetrics;\n\t}\n\n\tfunction average(vs) {\n\t    var sum = 0;\n\t    for (var i = 0; i < vs.length; i += 1) {\n\t        sum += vs[i];\n\t    }\n\n\t    return sum / vs.length;\n\t}\n\n\t// Convert the font object to a SFNT data structure.\n\t// This structure contains all the necessary tables and metadata to create a binary OTF file.\n\tfunction fontToSfntTable(font) {\n\t    var xMins = [];\n\t    var yMins = [];\n\t    var xMaxs = [];\n\t    var yMaxs = [];\n\t    var advanceWidths = [];\n\t    var leftSideBearings = [];\n\t    var rightSideBearings = [];\n\t    var firstCharIndex;\n\t    var lastCharIndex = 0;\n\t    var ulUnicodeRange1 = 0;\n\t    var ulUnicodeRange2 = 0;\n\t    var ulUnicodeRange3 = 0;\n\t    var ulUnicodeRange4 = 0;\n\n\t    for (var i = 0; i < font.glyphs.length; i += 1) {\n\t        var glyph = font.glyphs.get(i);\n\t        var unicode = glyph.unicode | 0;\n\n\t        if (isNaN(glyph.advanceWidth)) {\n\t            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');\n\t        }\n\n\t        if (firstCharIndex > unicode || firstCharIndex === undefined) {\n\t            // ignore .notdef char\n\t            if (unicode > 0) {\n\t                firstCharIndex = unicode;\n\t            }\n\t        }\n\n\t        if (lastCharIndex < unicode) {\n\t            lastCharIndex = unicode;\n\t        }\n\n\t        var position = os2.getUnicodeRange(unicode);\n\t        if (position < 32) {\n\t            ulUnicodeRange1 |= 1 << position;\n\t        } else if (position < 64) {\n\t            ulUnicodeRange2 |= 1 << position - 32;\n\t        } else if (position < 96) {\n\t            ulUnicodeRange3 |= 1 << position - 64;\n\t        } else if (position < 123) {\n\t            ulUnicodeRange4 |= 1 << position - 96;\n\t        } else {\n\t            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');\n\t        }\n\t        // Skip non-important characters.\n\t        if (glyph.name === '.notdef') { continue; }\n\t        var metrics = glyph.getMetrics();\n\t        xMins.push(metrics.xMin);\n\t        yMins.push(metrics.yMin);\n\t        xMaxs.push(metrics.xMax);\n\t        yMaxs.push(metrics.yMax);\n\t        leftSideBearings.push(metrics.leftSideBearing);\n\t        rightSideBearings.push(metrics.rightSideBearing);\n\t        advanceWidths.push(glyph.advanceWidth);\n\t    }\n\n\t    var globals = {\n\t        xMin: Math.min.apply(null, xMins),\n\t        yMin: Math.min.apply(null, yMins),\n\t        xMax: Math.max.apply(null, xMaxs),\n\t        yMax: Math.max.apply(null, yMaxs),\n\t        advanceWidthMax: Math.max.apply(null, advanceWidths),\n\t        advanceWidthAvg: average(advanceWidths),\n\t        minLeftSideBearing: Math.min.apply(null, leftSideBearings),\n\t        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),\n\t        minRightSideBearing: Math.min.apply(null, rightSideBearings)\n\t    };\n\t    globals.ascender = font.ascender;\n\t    globals.descender = font.descender;\n\n\t    var headTable = head.make({\n\t        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)\n\t        unitsPerEm: font.unitsPerEm,\n\t        xMin: globals.xMin,\n\t        yMin: globals.yMin,\n\t        xMax: globals.xMax,\n\t        yMax: globals.yMax,\n\t        lowestRecPPEM: 3,\n\t        createdTimestamp: font.createdTimestamp\n\t    });\n\n\t    var hheaTable = hhea.make({\n\t        ascender: globals.ascender,\n\t        descender: globals.descender,\n\t        advanceWidthMax: globals.advanceWidthMax,\n\t        minLeftSideBearing: globals.minLeftSideBearing,\n\t        minRightSideBearing: globals.minRightSideBearing,\n\t        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),\n\t        numberOfHMetrics: font.glyphs.length\n\t    });\n\n\t    var maxpTable = maxp.make(font.glyphs.length);\n\n\t    var os2Table = os2.make(Object.assign({\n\t        xAvgCharWidth: Math.round(globals.advanceWidthAvg),\n\t        usFirstCharIndex: firstCharIndex,\n\t        usLastCharIndex: lastCharIndex,\n\t        ulUnicodeRange1: ulUnicodeRange1,\n\t        ulUnicodeRange2: ulUnicodeRange2,\n\t        ulUnicodeRange3: ulUnicodeRange3,\n\t        ulUnicodeRange4: ulUnicodeRange4,\n\t        // See http://typophile.com/node/13081 for more info on vertical metrics.\n\t        // We get metrics for typical characters (such as \"x\" for xHeight).\n\t        // We provide some fallback characters if characters are unavailable: their\n\t        // ordering was chosen experimentally.\n\t        sTypoAscender: globals.ascender,\n\t        sTypoDescender: globals.descender,\n\t        sTypoLineGap: 0,\n\t        usWinAscent: globals.yMax,\n\t        usWinDescent: Math.abs(globals.yMin),\n\t        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now\n\t        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,\n\t        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,\n\t        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.\n\t        usBreakChar: font.hasChar(' ') ? 32 : 0, // Use space as the break character, if available.\n\t    }, font.tables.os2));\n\n\t    var hmtxTable = hmtx.make(font.glyphs);\n\t    var cmapTable = cmap.make(font.glyphs);\n\n\t    var englishFamilyName = font.getEnglishName('fontFamily');\n\t    var englishStyleName = font.getEnglishName('fontSubfamily');\n\t    var englishFullName = englishFamilyName + ' ' + englishStyleName;\n\t    var postScriptName = font.getEnglishName('postScriptName');\n\t    if (!postScriptName) {\n\t        postScriptName = englishFamilyName.replace(/\\s/g, '') + '-' + englishStyleName;\n\t    }\n\n\t    var names = {};\n\t    for (var n in font.names) {\n\t        names[n] = font.names[n];\n\t    }\n\n\t    if (!names.uniqueID) {\n\t        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};\n\t    }\n\n\t    if (!names.postScriptName) {\n\t        names.postScriptName = {en: postScriptName};\n\t    }\n\n\t    if (!names.preferredFamily) {\n\t        names.preferredFamily = font.names.fontFamily;\n\t    }\n\n\t    if (!names.preferredSubfamily) {\n\t        names.preferredSubfamily = font.names.fontSubfamily;\n\t    }\n\n\t    var languageTags = [];\n\t    var nameTable = _name.make(names, languageTags);\n\t    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);\n\n\t    var postTable = post.make();\n\t    var cffTable = cff.make(font.glyphs, {\n\t        version: font.getEnglishName('version'),\n\t        fullName: englishFullName,\n\t        familyName: englishFamilyName,\n\t        weightName: englishStyleName,\n\t        postScriptName: postScriptName,\n\t        unitsPerEm: font.unitsPerEm,\n\t        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]\n\t    });\n\n\t    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;\n\n\t    // The order does not matter because makeSfntTable() will sort them.\n\t    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];\n\t    if (ltagTable) {\n\t        tables.push(ltagTable);\n\t    }\n\t    // Optional tables\n\t    if (font.tables.gsub) {\n\t        tables.push(gsub.make(font.tables.gsub));\n\t    }\n\t    if (metaTable) {\n\t        tables.push(metaTable);\n\t    }\n\n\t    var sfntTable = makeSfntTable(tables);\n\n\t    // Compute the font's checkSum and store it in head.checkSumAdjustment.\n\t    var bytes = sfntTable.encode();\n\t    var checkSum = computeCheckSum(bytes);\n\t    var tableFields = sfntTable.fields;\n\t    var checkSumAdjusted = false;\n\t    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {\n\t        if (tableFields[i$1].name === 'head table') {\n\t            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;\n\t            checkSumAdjusted = true;\n\t            break;\n\t        }\n\t    }\n\n\t    if (!checkSumAdjusted) {\n\t        throw new Error('Could not find head table with checkSum to adjust.');\n\t    }\n\n\t    return sfntTable;\n\t}\n\n\tvar sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };\n\n\t// The Layout object is the prototype of Substitution objects, and provides\n\n\tfunction searchTag(arr, tag) {\n\t    /* jshint bitwise: false */\n\t    var imin = 0;\n\t    var imax = arr.length - 1;\n\t    while (imin <= imax) {\n\t        var imid = (imin + imax) >>> 1;\n\t        var val = arr[imid].tag;\n\t        if (val === tag) {\n\t            return imid;\n\t        } else if (val < tag) {\n\t            imin = imid + 1;\n\t        } else { imax = imid - 1; }\n\t    }\n\t    // Not found: return -1-insertion point\n\t    return -imin - 1;\n\t}\n\n\tfunction binSearch(arr, value) {\n\t    /* jshint bitwise: false */\n\t    var imin = 0;\n\t    var imax = arr.length - 1;\n\t    while (imin <= imax) {\n\t        var imid = (imin + imax) >>> 1;\n\t        var val = arr[imid];\n\t        if (val === value) {\n\t            return imid;\n\t        } else if (val < value) {\n\t            imin = imid + 1;\n\t        } else { imax = imid - 1; }\n\t    }\n\t    // Not found: return -1-insertion point\n\t    return -imin - 1;\n\t}\n\n\t// binary search in a list of ranges (coverage, class definition)\n\tfunction searchRange(ranges, value) {\n\t    // jshint bitwise: false\n\t    var range;\n\t    var imin = 0;\n\t    var imax = ranges.length - 1;\n\t    while (imin <= imax) {\n\t        var imid = (imin + imax) >>> 1;\n\t        range = ranges[imid];\n\t        var start = range.start;\n\t        if (start === value) {\n\t            return range;\n\t        } else if (start < value) {\n\t            imin = imid + 1;\n\t        } else { imax = imid - 1; }\n\t    }\n\t    if (imin > 0) {\n\t        range = ranges[imin - 1];\n\t        if (value > range.end) { return 0; }\n\t        return range;\n\t    }\n\t}\n\n\t/**\n\t * @exports opentype.Layout\n\t * @class\n\t */\n\tfunction Layout(font, tableName) {\n\t    this.font = font;\n\t    this.tableName = tableName;\n\t}\n\n\tLayout.prototype = {\n\n\t    /**\n\t     * Binary search an object by \"tag\" property\n\t     * @instance\n\t     * @function searchTag\n\t     * @memberof opentype.Layout\n\t     * @param  {Array} arr\n\t     * @param  {string} tag\n\t     * @return {number}\n\t     */\n\t    searchTag: searchTag,\n\n\t    /**\n\t     * Binary search in a list of numbers\n\t     * @instance\n\t     * @function binSearch\n\t     * @memberof opentype.Layout\n\t     * @param  {Array} arr\n\t     * @param  {number} value\n\t     * @return {number}\n\t     */\n\t    binSearch: binSearch,\n\n\t    /**\n\t     * Get or create the Layout table (GSUB, GPOS etc).\n\t     * @param  {boolean} create - Whether to create a new one.\n\t     * @return {Object} The GSUB or GPOS table.\n\t     */\n\t    getTable: function(create) {\n\t        var layout = this.font.tables[this.tableName];\n\t        if (!layout && create) {\n\t            layout = this.font.tables[this.tableName] = this.createDefaultTable();\n\t        }\n\t        return layout;\n\t    },\n\n\t    /**\n\t     * Returns all scripts in the substitution table.\n\t     * @instance\n\t     * @return {Array}\n\t     */\n\t    getScriptNames: function() {\n\t        var layout = this.getTable();\n\t        if (!layout) { return []; }\n\t        return layout.scripts.map(function(script) {\n\t            return script.tag;\n\t        });\n\t    },\n\n\t    /**\n\t     * Returns the best bet for a script name.\n\t     * Returns 'DFLT' if it exists.\n\t     * If not, returns 'latn' if it exists.\n\t     * If neither exist, returns undefined.\n\t     */\n\t    getDefaultScriptName: function() {\n\t        var layout = this.getTable();\n\t        if (!layout) { return; }\n\t        var hasLatn = false;\n\t        for (var i = 0; i < layout.scripts.length; i++) {\n\t            var name = layout.scripts[i].tag;\n\t            if (name === 'DFLT') { return name; }\n\t            if (name === 'latn') { hasLatn = true; }\n\t        }\n\t        if (hasLatn) { return 'latn'; }\n\t    },\n\n\t    /**\n\t     * Returns all LangSysRecords in the given script.\n\t     * @instance\n\t     * @param {string} [script='DFLT']\n\t     * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n\t     * @return {Object} An object with tag and script properties.\n\t     */\n\t    getScriptTable: function(script, create) {\n\t        var layout = this.getTable(create);\n\t        if (layout) {\n\t            script = script || 'DFLT';\n\t            var scripts = layout.scripts;\n\t            var pos = searchTag(layout.scripts, script);\n\t            if (pos >= 0) {\n\t                return scripts[pos].script;\n\t            } else if (create) {\n\t                var scr = {\n\t                    tag: script,\n\t                    script: {\n\t                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},\n\t                        langSysRecords: []\n\t                    }\n\t                };\n\t                scripts.splice(-1 - pos, 0, scr);\n\t                return scr.script;\n\t            }\n\t        }\n\t    },\n\n\t    /**\n\t     * Returns a language system table\n\t     * @instance\n\t     * @param {string} [script='DFLT']\n\t     * @param {string} [language='dlft']\n\t     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n\t     * @return {Object}\n\t     */\n\t    getLangSysTable: function(script, language, create) {\n\t        var scriptTable = this.getScriptTable(script, create);\n\t        if (scriptTable) {\n\t            if (!language || language === 'dflt' || language === 'DFLT') {\n\t                return scriptTable.defaultLangSys;\n\t            }\n\t            var pos = searchTag(scriptTable.langSysRecords, language);\n\t            if (pos >= 0) {\n\t                return scriptTable.langSysRecords[pos].langSys;\n\t            } else if (create) {\n\t                var langSysRecord = {\n\t                    tag: language,\n\t                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}\n\t                };\n\t                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n\t                return langSysRecord.langSys;\n\t            }\n\t        }\n\t    },\n\n\t    /**\n\t     * Get a specific feature table.\n\t     * @instance\n\t     * @param {string} [script='DFLT']\n\t     * @param {string} [language='dlft']\n\t     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n\t     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n\t     * @return {Object}\n\t     */\n\t    getFeatureTable: function(script, language, feature, create) {\n\t        var langSysTable = this.getLangSysTable(script, language, create);\n\t        if (langSysTable) {\n\t            var featureRecord;\n\t            var featIndexes = langSysTable.featureIndexes;\n\t            var allFeatures = this.font.tables[this.tableName].features;\n\t            // The FeatureIndex array of indices is in arbitrary order,\n\t            // even if allFeatures is sorted alphabetically by feature tag.\n\t            for (var i = 0; i < featIndexes.length; i++) {\n\t                featureRecord = allFeatures[featIndexes[i]];\n\t                if (featureRecord.tag === feature) {\n\t                    return featureRecord.feature;\n\t                }\n\t            }\n\t            if (create) {\n\t                var index = allFeatures.length;\n\t                // Automatic ordering of features would require to shift feature indexes in the script list.\n\t                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');\n\t                featureRecord = {\n\t                    tag: feature,\n\t                    feature: { params: 0, lookupListIndexes: [] }\n\t                };\n\t                allFeatures.push(featureRecord);\n\t                featIndexes.push(index);\n\t                return featureRecord.feature;\n\t            }\n\t        }\n\t    },\n\n\t    /**\n\t     * Get the lookup tables of a given type for a script/language/feature.\n\t     * @instance\n\t     * @param {string} [script='DFLT']\n\t     * @param {string} [language='dlft']\n\t     * @param {string} feature - 4-letter feature code\n\t     * @param {number} lookupType - 1 to 9\n\t     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n\t     * @return {Object[]}\n\t     */\n\t    getLookupTables: function(script, language, feature, lookupType, create) {\n\t        var featureTable = this.getFeatureTable(script, language, feature, create);\n\t        var tables = [];\n\t        if (featureTable) {\n\t            var lookupTable;\n\t            var lookupListIndexes = featureTable.lookupListIndexes;\n\t            var allLookups = this.font.tables[this.tableName].lookups;\n\t            // lookupListIndexes are in no particular order, so use naive search.\n\t            for (var i = 0; i < lookupListIndexes.length; i++) {\n\t                lookupTable = allLookups[lookupListIndexes[i]];\n\t                if (lookupTable.lookupType === lookupType) {\n\t                    tables.push(lookupTable);\n\t                }\n\t            }\n\t            if (tables.length === 0 && create) {\n\t                lookupTable = {\n\t                    lookupType: lookupType,\n\t                    lookupFlag: 0,\n\t                    subtables: [],\n\t                    markFilteringSet: undefined\n\t                };\n\t                var index = allLookups.length;\n\t                allLookups.push(lookupTable);\n\t                lookupListIndexes.push(index);\n\t                return [lookupTable];\n\t            }\n\t        }\n\t        return tables;\n\t    },\n\n\t    /**\n\t     * Find a glyph in a class definition table\n\t     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table\n\t     * @param {object} classDefTable - an OpenType Layout class definition table\n\t     * @param {number} glyphIndex - the index of the glyph to find\n\t     * @returns {number} -1 if not found\n\t     */\n\t    getGlyphClass: function(classDefTable, glyphIndex) {\n\t        switch (classDefTable.format) {\n\t            case 1:\n\t                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {\n\t                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];\n\t                }\n\t                return 0;\n\t            case 2:\n\t                var range = searchRange(classDefTable.ranges, glyphIndex);\n\t                return range ? range.classId : 0;\n\t        }\n\t    },\n\n\t    /**\n\t     * Find a glyph in a coverage table\n\t     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table\n\t     * @param {object} coverageTable - an OpenType Layout coverage table\n\t     * @param {number} glyphIndex - the index of the glyph to find\n\t     * @returns {number} -1 if not found\n\t     */\n\t    getCoverageIndex: function(coverageTable, glyphIndex) {\n\t        switch (coverageTable.format) {\n\t            case 1:\n\t                var index = binSearch(coverageTable.glyphs, glyphIndex);\n\t                return index >= 0 ? index : -1;\n\t            case 2:\n\t                var range = searchRange(coverageTable.ranges, glyphIndex);\n\t                return range ? range.index + glyphIndex - range.start : -1;\n\t        }\n\t    },\n\n\t    /**\n\t     * Returns the list of glyph indexes of a coverage table.\n\t     * Format 1: the list is stored raw\n\t     * Format 2: compact list as range records.\n\t     * @instance\n\t     * @param  {Object} coverageTable\n\t     * @return {Array}\n\t     */\n\t    expandCoverage: function(coverageTable) {\n\t        if (coverageTable.format === 1) {\n\t            return coverageTable.glyphs;\n\t        } else {\n\t            var glyphs = [];\n\t            var ranges = coverageTable.ranges;\n\t            for (var i = 0; i < ranges.length; i++) {\n\t                var range = ranges[i];\n\t                var start = range.start;\n\t                var end = range.end;\n\t                for (var j = start; j <= end; j++) {\n\t                    glyphs.push(j);\n\t                }\n\t            }\n\t            return glyphs;\n\t        }\n\t    }\n\n\t};\n\n\t// The Position object provides utility methods to manipulate\n\n\t/**\n\t * @exports opentype.Position\n\t * @class\n\t * @extends opentype.Layout\n\t * @param {opentype.Font}\n\t * @constructor\n\t */\n\tfunction Position(font) {\n\t    Layout.call(this, font, 'gpos');\n\t}\n\n\tPosition.prototype = Layout.prototype;\n\n\t/**\n\t * Init some data for faster and easier access later.\n\t */\n\tPosition.prototype.init = function() {\n\t    var script = this.getDefaultScriptName();\n\t    this.defaultKerningTables = this.getKerningTables(script);\n\t};\n\n\t/**\n\t * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.\n\t *\n\t * @param {integer} leftIndex - left glyph index\n\t * @param {integer} rightIndex - right glyph index\n\t * @returns {integer}\n\t */\n\tPosition.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {\n\t    for (var i = 0; i < kerningLookups.length; i++) {\n\t        var subtables = kerningLookups[i].subtables;\n\t        for (var j = 0; j < subtables.length; j++) {\n\t            var subtable = subtables[j];\n\t            var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);\n\t            if (covIndex < 0) { continue; }\n\t            switch (subtable.posFormat) {\n\t                case 1:\n\t                    // Search Pair Adjustment Positioning Format 1\n\t                    var pairSet = subtable.pairSets[covIndex];\n\t                    for (var k = 0; k < pairSet.length; k++) {\n\t                        var pair = pairSet[k];\n\t                        if (pair.secondGlyph === rightIndex) {\n\t                            return pair.value1 && pair.value1.xAdvance || 0;\n\t                        }\n\t                    }\n\t                    break;      // left glyph found, not right glyph - try next subtable\n\t                case 2:\n\t                    // Search Pair Adjustment Positioning Format 2\n\t                    var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);\n\t                    var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);\n\t                    var pair$1 = subtable.classRecords[class1][class2];\n\t                    return pair$1.value1 && pair$1.value1.xAdvance || 0;\n\t            }\n\t        }\n\t    }\n\t    return 0;\n\t};\n\n\t/**\n\t * List all kerning lookup tables.\n\t *\n\t * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value\n\t * @param {string} [language='dflt']\n\t * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)\n\t */\n\tPosition.prototype.getKerningTables = function(script, language) {\n\t    if (this.font.tables.gpos) {\n\t        return this.getLookupTables(script, language, 'kern', 2);\n\t    }\n\t};\n\n\t// The Substitution object provides utility methods to manipulate\n\n\t/**\n\t * @exports opentype.Substitution\n\t * @class\n\t * @extends opentype.Layout\n\t * @param {opentype.Font}\n\t * @constructor\n\t */\n\tfunction Substitution(font) {\n\t    Layout.call(this, font, 'gsub');\n\t}\n\n\t// Check if 2 arrays of primitives are equal.\n\tfunction arraysEqual(ar1, ar2) {\n\t    var n = ar1.length;\n\t    if (n !== ar2.length) { return false; }\n\t    for (var i = 0; i < n; i++) {\n\t        if (ar1[i] !== ar2[i]) { return false; }\n\t    }\n\t    return true;\n\t}\n\n\t// Find the first subtable of a lookup table in a particular format.\n\tfunction getSubstFormat(lookupTable, format, defaultSubtable) {\n\t    var subtables = lookupTable.subtables;\n\t    for (var i = 0; i < subtables.length; i++) {\n\t        var subtable = subtables[i];\n\t        if (subtable.substFormat === format) {\n\t            return subtable;\n\t        }\n\t    }\n\t    if (defaultSubtable) {\n\t        subtables.push(defaultSubtable);\n\t        return defaultSubtable;\n\t    }\n\t    return undefined;\n\t}\n\n\tSubstitution.prototype = Layout.prototype;\n\n\t/**\n\t * Create a default GSUB table.\n\t * @return {Object} gsub - The GSUB table.\n\t */\n\tSubstitution.prototype.createDefaultTable = function() {\n\t    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.\n\t    return {\n\t        version: 1,\n\t        scripts: [{\n\t            tag: 'DFLT',\n\t            script: {\n\t                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },\n\t                langSysRecords: []\n\t            }\n\t        }],\n\t        features: [],\n\t        lookups: []\n\t    };\n\t};\n\n\t/**\n\t * List all single substitutions (lookup type 1) for a given script, language, and feature.\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)\n\t * @return {Array} substitutions - The list of substitutions.\n\t */\n\tSubstitution.prototype.getSingle = function(feature, script, language) {\n\t    var substitutions = [];\n\t    var lookupTables = this.getLookupTables(script, language, feature, 1);\n\t    for (var idx = 0; idx < lookupTables.length; idx++) {\n\t        var subtables = lookupTables[idx].subtables;\n\t        for (var i = 0; i < subtables.length; i++) {\n\t            var subtable = subtables[i];\n\t            var glyphs = this.expandCoverage(subtable.coverage);\n\t            var j = (void 0);\n\t            if (subtable.substFormat === 1) {\n\t                var delta = subtable.deltaGlyphId;\n\t                for (j = 0; j < glyphs.length; j++) {\n\t                    var glyph = glyphs[j];\n\t                    substitutions.push({ sub: glyph, by: glyph + delta });\n\t                }\n\t            } else {\n\t                var substitute = subtable.substitute;\n\t                for (j = 0; j < glyphs.length; j++) {\n\t                    substitutions.push({ sub: glyphs[j], by: substitute[j] });\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return substitutions;\n\t};\n\n\t/**\n\t * List all multiple substitutions (lookup type 2) for a given script, language, and feature.\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t * @param {string} feature - 4-character feature name ('ccmp', 'stch')\n\t * @return {Array} substitutions - The list of substitutions.\n\t */\n\tSubstitution.prototype.getMultiple = function(feature, script, language) {\n\t    var substitutions = [];\n\t    var lookupTables = this.getLookupTables(script, language, feature, 2);\n\t    for (var idx = 0; idx < lookupTables.length; idx++) {\n\t        var subtables = lookupTables[idx].subtables;\n\t        for (var i = 0; i < subtables.length; i++) {\n\t            var subtable = subtables[i];\n\t            var glyphs = this.expandCoverage(subtable.coverage);\n\t            var j = (void 0);\n\n\t            for (j = 0; j < glyphs.length; j++) {\n\t                var glyph = glyphs[j];\n\t                var replacements = subtable.sequences[j];\n\t                substitutions.push({ sub: glyph, by: replacements });\n\t            }\n\t        }\n\t    }\n\t    return substitutions;\n\t};\n\n\t/**\n\t * List all alternates (lookup type 3) for a given script, language, and feature.\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t * @param {string} feature - 4-character feature name ('aalt', 'salt'...)\n\t * @return {Array} alternates - The list of alternates\n\t */\n\tSubstitution.prototype.getAlternates = function(feature, script, language) {\n\t    var alternates = [];\n\t    var lookupTables = this.getLookupTables(script, language, feature, 3);\n\t    for (var idx = 0; idx < lookupTables.length; idx++) {\n\t        var subtables = lookupTables[idx].subtables;\n\t        for (var i = 0; i < subtables.length; i++) {\n\t            var subtable = subtables[i];\n\t            var glyphs = this.expandCoverage(subtable.coverage);\n\t            var alternateSets = subtable.alternateSets;\n\t            for (var j = 0; j < glyphs.length; j++) {\n\t                alternates.push({ sub: glyphs[j], by: alternateSets[j] });\n\t            }\n\t        }\n\t    }\n\t    return alternates;\n\t};\n\n\t/**\n\t * List all ligatures (lookup type 4) for a given script, language, and feature.\n\t * The result is an array of ligature objects like { sub: [ids], by: id }\n\t * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t * @return {Array} ligatures - The list of ligatures.\n\t */\n\tSubstitution.prototype.getLigatures = function(feature, script, language) {\n\t    var ligatures = [];\n\t    var lookupTables = this.getLookupTables(script, language, feature, 4);\n\t    for (var idx = 0; idx < lookupTables.length; idx++) {\n\t        var subtables = lookupTables[idx].subtables;\n\t        for (var i = 0; i < subtables.length; i++) {\n\t            var subtable = subtables[i];\n\t            var glyphs = this.expandCoverage(subtable.coverage);\n\t            var ligatureSets = subtable.ligatureSets;\n\t            for (var j = 0; j < glyphs.length; j++) {\n\t                var startGlyph = glyphs[j];\n\t                var ligSet = ligatureSets[j];\n\t                for (var k = 0; k < ligSet.length; k++) {\n\t                    var lig = ligSet[k];\n\t                    ligatures.push({\n\t                        sub: [startGlyph].concat(lig.components),\n\t                        by: lig.ligGlyph\n\t                    });\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return ligatures;\n\t};\n\n\t/**\n\t * Add or modify a single substitution (lookup type 1)\n\t * Format 2, more flexible, is always used.\n\t * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n\t * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t */\n\tSubstitution.prototype.addSingle = function(feature, substitution, script, language) {\n\t    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];\n\t    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1\n\t        substFormat: 2,\n\t        coverage: {format: 1, glyphs: []},\n\t        substitute: []\n\t    });\n\t    check.assert(subtable.coverage.format === 1, 'Single: unable to modify coverage table format ' + subtable.coverage.format);\n\t    var coverageGlyph = substitution.sub;\n\t    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n\t    if (pos < 0) {\n\t        pos = -1 - pos;\n\t        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n\t        subtable.substitute.splice(pos, 0, 0);\n\t    }\n\t    subtable.substitute[pos] = substitution.by;\n\t};\n\n\t/**\n\t * Add or modify a multiple substitution (lookup type 2)\n\t * @param {string} feature - 4-letter feature name ('ccmp', 'stch')\n\t * @param {Object} substitution - { sub: id, by: [id] } for format 2.\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t */\n\tSubstitution.prototype.addMultiple = function(feature, substitution, script, language) {\n\t    check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: \"by\" must be an array of two or more ids');\n\t    var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0];\n\t    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 2 subtable, format 1, coverage format 1\n\t        substFormat: 1,\n\t        coverage: {format: 1, glyphs: []},\n\t        sequences: []\n\t    });\n\t    check.assert(subtable.coverage.format === 1, 'Multiple: unable to modify coverage table format ' + subtable.coverage.format);\n\t    var coverageGlyph = substitution.sub;\n\t    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n\t    if (pos < 0) {\n\t        pos = -1 - pos;\n\t        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n\t        subtable.sequences.splice(pos, 0, 0);\n\t    }\n\t    subtable.sequences[pos] = substitution.by;\n\t};\n\n\t/**\n\t * Add or modify an alternate substitution (lookup type 3)\n\t * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n\t * @param {Object} substitution - { sub: id, by: [ids] }\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t */\n\tSubstitution.prototype.addAlternate = function(feature, substitution, script, language) {\n\t    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];\n\t    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1\n\t        substFormat: 1,\n\t        coverage: {format: 1, glyphs: []},\n\t        alternateSets: []\n\t    });\n\t    check.assert(subtable.coverage.format === 1, 'Alternate: unable to modify coverage table format ' + subtable.coverage.format);\n\t    var coverageGlyph = substitution.sub;\n\t    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n\t    if (pos < 0) {\n\t        pos = -1 - pos;\n\t        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n\t        subtable.alternateSets.splice(pos, 0, 0);\n\t    }\n\t    subtable.alternateSets[pos] = substitution.by;\n\t};\n\n\t/**\n\t * Add a ligature (lookup type 4)\n\t * Ligatures with more components must be stored ahead of those with fewer components in order to be found\n\t * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n\t * @param {Object} ligature - { sub: [ids], by: id }\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t */\n\tSubstitution.prototype.addLigature = function(feature, ligature, script, language) {\n\t    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];\n\t    var subtable = lookupTable.subtables[0];\n\t    if (!subtable) {\n\t        subtable = {                // lookup type 4 subtable, format 1, coverage format 1\n\t            substFormat: 1,\n\t            coverage: { format: 1, glyphs: [] },\n\t            ligatureSets: []\n\t        };\n\t        lookupTable.subtables[0] = subtable;\n\t    }\n\t    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);\n\t    var coverageGlyph = ligature.sub[0];\n\t    var ligComponents = ligature.sub.slice(1);\n\t    var ligatureTable = {\n\t        ligGlyph: ligature.by,\n\t        components: ligComponents\n\t    };\n\t    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n\t    if (pos >= 0) {\n\t        // ligatureSet already exists\n\t        var ligatureSet = subtable.ligatureSets[pos];\n\t        for (var i = 0; i < ligatureSet.length; i++) {\n\t            // If ligature already exists, return.\n\t            if (arraysEqual(ligatureSet[i].components, ligComponents)) {\n\t                return;\n\t            }\n\t        }\n\t        // ligature does not exist: add it.\n\t        ligatureSet.push(ligatureTable);\n\t    } else {\n\t        // Create a new ligatureSet and add coverage for the first glyph.\n\t        pos = -1 - pos;\n\t        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n\t        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);\n\t    }\n\t};\n\n\t/**\n\t * List all feature data for a given script and language.\n\t * @param {string} feature - 4-letter feature name\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t * @return {Array} substitutions - The list of substitutions.\n\t */\n\tSubstitution.prototype.getFeature = function(feature, script, language) {\n\t    if (/ss\\d\\d/.test(feature)) {\n\t        // ss01 - ss20\n\t        return this.getSingle(feature, script, language);\n\t    }\n\t    switch (feature) {\n\t        case 'aalt':\n\t        case 'salt':\n\t            return this.getSingle(feature, script, language)\n\t                    .concat(this.getAlternates(feature, script, language));\n\t        case 'dlig':\n\t        case 'liga':\n\t        case 'rlig':\n\t            return this.getLigatures(feature, script, language);\n\t        case 'ccmp':\n\t            return this.getMultiple(feature, script, language)\n\t                .concat(this.getLigatures(feature, script, language));\n\t        case 'stch':\n\t            return this.getMultiple(feature, script, language);\n\t    }\n\t    return undefined;\n\t};\n\n\t/**\n\t * Add a substitution to a feature for a given script and language.\n\t * @param {string} feature - 4-letter feature name\n\t * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t */\n\tSubstitution.prototype.add = function(feature, sub, script, language) {\n\t    if (/ss\\d\\d/.test(feature)) {\n\t        // ss01 - ss20\n\t        return this.addSingle(feature, sub, script, language);\n\t    }\n\t    switch (feature) {\n\t        case 'aalt':\n\t        case 'salt':\n\t            if (typeof sub.by === 'number') {\n\t                return this.addSingle(feature, sub, script, language);\n\t            }\n\t            return this.addAlternate(feature, sub, script, language);\n\t        case 'dlig':\n\t        case 'liga':\n\t        case 'rlig':\n\t            return this.addLigature(feature, sub, script, language);\n\t        case 'ccmp':\n\t            if (sub.by instanceof Array) {\n\t                return this.addMultiple(feature, sub, script, language);\n\t            }\n\t            return this.addLigature(feature, sub, script, language);\n\t    }\n\t    return undefined;\n\t};\n\n\tfunction isBrowser() {\n\t    return typeof window !== 'undefined';\n\t}\n\n\tfunction nodeBufferToArrayBuffer(buffer) {\n\t    var ab = new ArrayBuffer(buffer.length);\n\t    var view = new Uint8Array(ab);\n\t    for (var i = 0; i < buffer.length; ++i) {\n\t        view[i] = buffer[i];\n\t    }\n\n\t    return ab;\n\t}\n\n\tfunction arrayBufferToNodeBuffer(ab) {\n\t    var buffer = new Buffer(ab.byteLength);\n\t    var view = new Uint8Array(ab);\n\t    for (var i = 0; i < buffer.length; ++i) {\n\t        buffer[i] = view[i];\n\t    }\n\n\t    return buffer;\n\t}\n\n\tfunction checkArgument(expression, message) {\n\t    if (!expression) {\n\t        throw message;\n\t    }\n\t}\n\n\t// The `glyf` table describes the glyphs in TrueType outline format.\n\n\t// Parse the coordinate data for a glyph.\n\tfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n\t    var v;\n\t    if ((flag & shortVectorBitMask) > 0) {\n\t        // The coordinate is 1 byte long.\n\t        v = p.parseByte();\n\t        // The `same` bit is re-used for short values to signify the sign of the value.\n\t        if ((flag & sameBitMask) === 0) {\n\t            v = -v;\n\t        }\n\n\t        v = previousValue + v;\n\t    } else {\n\t        //  The coordinate is 2 bytes long.\n\t        // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n\t        if ((flag & sameBitMask) > 0) {\n\t            v = previousValue;\n\t        } else {\n\t            // Parse the coordinate as a signed 16-bit delta value.\n\t            v = previousValue + p.parseShort();\n\t        }\n\t    }\n\n\t    return v;\n\t}\n\n\t// Parse a TrueType glyph.\n\tfunction parseGlyph(glyph, data, start) {\n\t    var p = new parse.Parser(data, start);\n\t    glyph.numberOfContours = p.parseShort();\n\t    glyph._xMin = p.parseShort();\n\t    glyph._yMin = p.parseShort();\n\t    glyph._xMax = p.parseShort();\n\t    glyph._yMax = p.parseShort();\n\t    var flags;\n\t    var flag;\n\n\t    if (glyph.numberOfContours > 0) {\n\t        // This glyph is not a composite.\n\t        var endPointIndices = glyph.endPointIndices = [];\n\t        for (var i = 0; i < glyph.numberOfContours; i += 1) {\n\t            endPointIndices.push(p.parseUShort());\n\t        }\n\n\t        glyph.instructionLength = p.parseUShort();\n\t        glyph.instructions = [];\n\t        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {\n\t            glyph.instructions.push(p.parseByte());\n\t        }\n\n\t        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n\t        flags = [];\n\t        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {\n\t            flag = p.parseByte();\n\t            flags.push(flag);\n\t            // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n\t            if ((flag & 8) > 0) {\n\t                var repeatCount = p.parseByte();\n\t                for (var j = 0; j < repeatCount; j += 1) {\n\t                    flags.push(flag);\n\t                    i$2 += 1;\n\t                }\n\t            }\n\t        }\n\n\t        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n\t        if (endPointIndices.length > 0) {\n\t            var points = [];\n\t            var point;\n\t            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n\t            if (numberOfCoordinates > 0) {\n\t                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {\n\t                    flag = flags[i$3];\n\t                    point = {};\n\t                    point.onCurve = !!(flag & 1);\n\t                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;\n\t                    points.push(point);\n\t                }\n\n\t                var px = 0;\n\t                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {\n\t                    flag = flags[i$4];\n\t                    point = points[i$4];\n\t                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n\t                    px = point.x;\n\t                }\n\n\t                var py = 0;\n\t                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {\n\t                    flag = flags[i$5];\n\t                    point = points[i$5];\n\t                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n\t                    py = point.y;\n\t                }\n\t            }\n\n\t            glyph.points = points;\n\t        } else {\n\t            glyph.points = [];\n\t        }\n\t    } else if (glyph.numberOfContours === 0) {\n\t        glyph.points = [];\n\t    } else {\n\t        glyph.isComposite = true;\n\t        glyph.points = [];\n\t        glyph.components = [];\n\t        var moreComponents = true;\n\t        while (moreComponents) {\n\t            flags = p.parseUShort();\n\t            var component = {\n\t                glyphIndex: p.parseUShort(),\n\t                xScale: 1,\n\t                scale01: 0,\n\t                scale10: 0,\n\t                yScale: 1,\n\t                dx: 0,\n\t                dy: 0\n\t            };\n\t            if ((flags & 1) > 0) {\n\t                // The arguments are words\n\t                if ((flags & 2) > 0) {\n\t                    // values are offset\n\t                    component.dx = p.parseShort();\n\t                    component.dy = p.parseShort();\n\t                } else {\n\t                    // values are matched points\n\t                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];\n\t                }\n\n\t            } else {\n\t                // The arguments are bytes\n\t                if ((flags & 2) > 0) {\n\t                    // values are offset\n\t                    component.dx = p.parseChar();\n\t                    component.dy = p.parseChar();\n\t                } else {\n\t                    // values are matched points\n\t                    component.matchedPoints = [p.parseByte(), p.parseByte()];\n\t                }\n\t            }\n\n\t            if ((flags & 8) > 0) {\n\t                // We have a scale\n\t                component.xScale = component.yScale = p.parseF2Dot14();\n\t            } else if ((flags & 64) > 0) {\n\t                // We have an X / Y scale\n\t                component.xScale = p.parseF2Dot14();\n\t                component.yScale = p.parseF2Dot14();\n\t            } else if ((flags & 128) > 0) {\n\t                // We have a 2x2 transformation\n\t                component.xScale = p.parseF2Dot14();\n\t                component.scale01 = p.parseF2Dot14();\n\t                component.scale10 = p.parseF2Dot14();\n\t                component.yScale = p.parseF2Dot14();\n\t            }\n\n\t            glyph.components.push(component);\n\t            moreComponents = !!(flags & 32);\n\t        }\n\t        if (flags & 0x100) {\n\t            // We have instructions\n\t            glyph.instructionLength = p.parseUShort();\n\t            glyph.instructions = [];\n\t            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {\n\t                glyph.instructions.push(p.parseByte());\n\t            }\n\t        }\n\t    }\n\t}\n\n\t// Transform an array of points and return a new array.\n\tfunction transformPoints(points, transform) {\n\t    var newPoints = [];\n\t    for (var i = 0; i < points.length; i += 1) {\n\t        var pt = points[i];\n\t        var newPt = {\n\t            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n\t            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n\t            onCurve: pt.onCurve,\n\t            lastPointOfContour: pt.lastPointOfContour\n\t        };\n\t        newPoints.push(newPt);\n\t    }\n\n\t    return newPoints;\n\t}\n\n\tfunction getContours(points) {\n\t    var contours = [];\n\t    var currentContour = [];\n\t    for (var i = 0; i < points.length; i += 1) {\n\t        var pt = points[i];\n\t        currentContour.push(pt);\n\t        if (pt.lastPointOfContour) {\n\t            contours.push(currentContour);\n\t            currentContour = [];\n\t        }\n\t    }\n\n\t    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n\t    return contours;\n\t}\n\n\t// Convert the TrueType glyph outline to a Path.\n\tfunction getPath(points) {\n\t    var p = new Path();\n\t    if (!points) {\n\t        return p;\n\t    }\n\n\t    var contours = getContours(points);\n\n\t    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n\t        var contour = contours[contourIndex];\n\n\t        var prev = null;\n\t        var curr = contour[contour.length - 1];\n\t        var next = contour[0];\n\n\t        if (curr.onCurve) {\n\t            p.moveTo(curr.x, curr.y);\n\t        } else {\n\t            if (next.onCurve) {\n\t                p.moveTo(next.x, next.y);\n\t            } else {\n\t                // If both first and last points are off-curve, start at their middle.\n\t                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};\n\t                p.moveTo(start.x, start.y);\n\t            }\n\t        }\n\n\t        for (var i = 0; i < contour.length; ++i) {\n\t            prev = curr;\n\t            curr = next;\n\t            next = contour[(i + 1) % contour.length];\n\n\t            if (curr.onCurve) {\n\t                // This is a straight line.\n\t                p.lineTo(curr.x, curr.y);\n\t            } else {\n\t                var prev2 = prev;\n\t                var next2 = next;\n\n\t                if (!prev.onCurve) {\n\t                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };\n\t                }\n\n\t                if (!next.onCurve) {\n\t                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };\n\t                }\n\n\t                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n\t            }\n\t        }\n\n\t        p.closePath();\n\t    }\n\t    return p;\n\t}\n\n\tfunction buildPath(glyphs, glyph) {\n\t    if (glyph.isComposite) {\n\t        for (var j = 0; j < glyph.components.length; j += 1) {\n\t            var component = glyph.components[j];\n\t            var componentGlyph = glyphs.get(component.glyphIndex);\n\t            // Force the ttfGlyphLoader to parse the glyph.\n\t            componentGlyph.getPath();\n\t            if (componentGlyph.points) {\n\t                var transformedPoints = (void 0);\n\t                if (component.matchedPoints === undefined) {\n\t                    // component positioned by offset\n\t                    transformedPoints = transformPoints(componentGlyph.points, component);\n\t                } else {\n\t                    // component positioned by matched points\n\t                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||\n\t                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {\n\t                        throw Error('Matched points out of range in ' + glyph.name);\n\t                    }\n\t                    var firstPt = glyph.points[component.matchedPoints[0]];\n\t                    var secondPt = componentGlyph.points[component.matchedPoints[1]];\n\t                    var transform = {\n\t                        xScale: component.xScale, scale01: component.scale01,\n\t                        scale10: component.scale10, yScale: component.yScale,\n\t                        dx: 0, dy: 0\n\t                    };\n\t                    secondPt = transformPoints([secondPt], transform)[0];\n\t                    transform.dx = firstPt.x - secondPt.x;\n\t                    transform.dy = firstPt.y - secondPt.y;\n\t                    transformedPoints = transformPoints(componentGlyph.points, transform);\n\t                }\n\t                glyph.points = glyph.points.concat(transformedPoints);\n\t            }\n\t        }\n\t    }\n\n\t    return getPath(glyph.points);\n\t}\n\n\tfunction parseGlyfTableAll(data, start, loca, font) {\n\t    var glyphs = new glyphset.GlyphSet(font);\n\n\t    // The last element of the loca table is invalid.\n\t    for (var i = 0; i < loca.length - 1; i += 1) {\n\t        var offset = loca[i];\n\t        var nextOffset = loca[i + 1];\n\t        if (offset !== nextOffset) {\n\t            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n\t        } else {\n\t            glyphs.push(i, glyphset.glyphLoader(font, i));\n\t        }\n\t    }\n\n\t    return glyphs;\n\t}\n\n\tfunction parseGlyfTableOnLowMemory(data, start, loca, font) {\n\t    var glyphs = new glyphset.GlyphSet(font);\n\n\t    font._push = function(i) {\n\t        var offset = loca[i];\n\t        var nextOffset = loca[i + 1];\n\t        if (offset !== nextOffset) {\n\t            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n\t        } else {\n\t            glyphs.push(i, glyphset.glyphLoader(font, i));\n\t        }\n\t    };\n\n\t    return glyphs;\n\t}\n\n\t// Parse all the glyphs according to the offsets from the `loca` table.\n\tfunction parseGlyfTable(data, start, loca, font, opt) {\n\t    if (opt.lowMemory)\n\t        { return parseGlyfTableOnLowMemory(data, start, loca, font); }\n\t    else\n\t        { return parseGlyfTableAll(data, start, loca, font); }\n\t}\n\n\tvar glyf = { getPath: getPath, parse: parseGlyfTable};\n\n\t/* A TrueType font hinting interpreter.\n\t*\n\t* (c) 2017 Axel Kittenberger\n\t*\n\t* This interpreter has been implemented according to this documentation:\n\t* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n\t*\n\t* According to the documentation F24DOT6 values are used for pixels.\n\t* That means calculation is 1/64 pixel accurate and uses integer operations.\n\t* However, Javascript has floating point operations by default and only\n\t* those are available. One could make a case to simulate the 1/64 accuracy\n\t* exactly by truncating after every division operation\n\t* (for example with << 0) to get pixel exactly results as other TrueType\n\t* implementations. It may make sense since some fonts are pixel optimized\n\t* by hand using DELTAP instructions. The current implementation doesn't\n\t* and rather uses full floating point precision.\n\t*\n\t* xScale, yScale and rotation is currently ignored.\n\t*\n\t* A few non-trivial instructions are missing as I didn't encounter yet\n\t* a font that used them to test a possible implementation.\n\t*\n\t* Some fonts seem to use undocumented features regarding the twilight zone.\n\t* Only some of them are implemented as they were encountered.\n\t*\n\t* The exports.DEBUG statements are removed on the minified distribution file.\n\t*/\n\n\tvar instructionTable;\n\tvar exec;\n\tvar execGlyph;\n\tvar execComponent;\n\n\t/*\n\t* Creates a hinting object.\n\t*\n\t* There ought to be exactly one\n\t* for each truetype font that is used for hinting.\n\t*/\n\tfunction Hinting(font) {\n\t    // the font this hinting object is for\n\t    this.font = font;\n\n\t    this.getCommands = function (hPoints) {\n\t        return glyf.getPath(hPoints).commands;\n\t    };\n\n\t    // cached states\n\t    this._fpgmState  =\n\t    this._prepState  =\n\t        undefined;\n\n\t    // errorState\n\t    // 0 ... all okay\n\t    // 1 ... had an error in a glyf,\n\t    //       continue working but stop spamming\n\t    //       the console\n\t    // 2 ... error at prep, stop hinting at this ppem\n\t    // 3 ... error at fpeg, stop hinting for this font at all\n\t    this._errorState = 0;\n\t}\n\n\t/*\n\t* Not rounding.\n\t*/\n\tfunction roundOff(v) {\n\t    return v;\n\t}\n\n\t/*\n\t* Rounding to grid.\n\t*/\n\tfunction roundToGrid(v) {\n\t    //Rounding in TT is supposed to \"symmetrical around zero\"\n\t    return Math.sign(v) * Math.round(Math.abs(v));\n\t}\n\n\t/*\n\t* Rounding to double grid.\n\t*/\n\tfunction roundToDoubleGrid(v) {\n\t    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n\t}\n\n\t/*\n\t* Rounding to half grid.\n\t*/\n\tfunction roundToHalfGrid(v) {\n\t    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n\t}\n\n\t/*\n\t* Rounding to up to grid.\n\t*/\n\tfunction roundUpToGrid(v) {\n\t    return Math.sign(v) * Math.ceil(Math.abs(v));\n\t}\n\n\t/*\n\t* Rounding to down to grid.\n\t*/\n\tfunction roundDownToGrid(v) {\n\t    return Math.sign(v) * Math.floor(Math.abs(v));\n\t}\n\n\t/*\n\t* Super rounding.\n\t*/\n\tvar roundSuper = function (v) {\n\t    var period = this.srPeriod;\n\t    var phase = this.srPhase;\n\t    var threshold = this.srThreshold;\n\t    var sign = 1;\n\n\t    if (v < 0) {\n\t        v = -v;\n\t        sign = -1;\n\t    }\n\n\t    v += threshold - phase;\n\n\t    v = Math.trunc(v / period) * period;\n\n\t    v += phase;\n\n\t    // according to http://xgridfit.sourceforge.net/round.html\n\t    if (v < 0) { return phase * sign; }\n\n\t    return v * sign;\n\t};\n\n\t/*\n\t* Unit vector of x-axis.\n\t*/\n\tvar xUnitVector = {\n\t    x: 1,\n\n\t    y: 0,\n\n\t    axis: 'x',\n\n\t    // Gets the projected distance between two points.\n\t    // o1/o2 ... if true, respective original position is used.\n\t    distance: function (p1, p2, o1, o2) {\n\t        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n\t    },\n\n\t    // Moves point p so the moved position has the same relative\n\t    // position to the moved positions of rp1 and rp2 than the\n\t    // original positions had.\n\t    //\n\t    // See APPENDIX on INTERPOLATE at the bottom of this file.\n\t    interpolate: function (p, rp1, rp2, pv) {\n\t        var do1;\n\t        var do2;\n\t        var doa1;\n\t        var doa2;\n\t        var dm1;\n\t        var dm2;\n\t        var dt;\n\n\t        if (!pv || pv === this) {\n\t            do1 = p.xo - rp1.xo;\n\t            do2 = p.xo - rp2.xo;\n\t            dm1 = rp1.x - rp1.xo;\n\t            dm2 = rp2.x - rp2.xo;\n\t            doa1 = Math.abs(do1);\n\t            doa2 = Math.abs(do2);\n\t            dt = doa1 + doa2;\n\n\t            if (dt === 0) {\n\t                p.x = p.xo + (dm1 + dm2) / 2;\n\t                return;\n\t            }\n\n\t            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n\t            return;\n\t        }\n\n\t        do1 = pv.distance(p, rp1, true, true);\n\t        do2 = pv.distance(p, rp2, true, true);\n\t        dm1 = pv.distance(rp1, rp1, false, true);\n\t        dm2 = pv.distance(rp2, rp2, false, true);\n\t        doa1 = Math.abs(do1);\n\t        doa2 = Math.abs(do2);\n\t        dt = doa1 + doa2;\n\n\t        if (dt === 0) {\n\t            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n\t            return;\n\t        }\n\n\t        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n\t    },\n\n\t    // Slope of line normal to this\n\t    normalSlope: Number.NEGATIVE_INFINITY,\n\n\t    // Sets the point 'p' relative to point 'rp'\n\t    // by the distance 'd'.\n\t    //\n\t    // See APPENDIX on SETRELATIVE at the bottom of this file.\n\t    //\n\t    // p   ... point to set\n\t    // rp  ... reference point\n\t    // d   ... distance on projection vector\n\t    // pv  ... projection vector (undefined = this)\n\t    // org ... if true, uses the original position of rp as reference.\n\t    setRelative: function (p, rp, d, pv, org) {\n\t        if (!pv || pv === this) {\n\t            p.x = (org ? rp.xo : rp.x) + d;\n\t            return;\n\t        }\n\n\t        var rpx = org ? rp.xo : rp.x;\n\t        var rpy = org ? rp.yo : rp.y;\n\t        var rpdx = rpx + d * pv.x;\n\t        var rpdy = rpy + d * pv.y;\n\n\t        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n\t    },\n\n\t    // Slope of vector line.\n\t    slope: 0,\n\n\t    // Touches the point p.\n\t    touch: function (p) {\n\t        p.xTouched = true;\n\t    },\n\n\t    // Tests if a point p is touched.\n\t    touched: function (p) {\n\t        return p.xTouched;\n\t    },\n\n\t    // Untouches the point p.\n\t    untouch: function (p) {\n\t        p.xTouched = false;\n\t    }\n\t};\n\n\t/*\n\t* Unit vector of y-axis.\n\t*/\n\tvar yUnitVector = {\n\t    x: 0,\n\n\t    y: 1,\n\n\t    axis: 'y',\n\n\t    // Gets the projected distance between two points.\n\t    // o1/o2 ... if true, respective original position is used.\n\t    distance: function (p1, p2, o1, o2) {\n\t        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n\t    },\n\n\t    // Moves point p so the moved position has the same relative\n\t    // position to the moved positions of rp1 and rp2 than the\n\t    // original positions had.\n\t    //\n\t    // See APPENDIX on INTERPOLATE at the bottom of this file.\n\t    interpolate: function (p, rp1, rp2, pv) {\n\t        var do1;\n\t        var do2;\n\t        var doa1;\n\t        var doa2;\n\t        var dm1;\n\t        var dm2;\n\t        var dt;\n\n\t        if (!pv || pv === this) {\n\t            do1 = p.yo - rp1.yo;\n\t            do2 = p.yo - rp2.yo;\n\t            dm1 = rp1.y - rp1.yo;\n\t            dm2 = rp2.y - rp2.yo;\n\t            doa1 = Math.abs(do1);\n\t            doa2 = Math.abs(do2);\n\t            dt = doa1 + doa2;\n\n\t            if (dt === 0) {\n\t                p.y = p.yo + (dm1 + dm2) / 2;\n\t                return;\n\t            }\n\n\t            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n\t            return;\n\t        }\n\n\t        do1 = pv.distance(p, rp1, true, true);\n\t        do2 = pv.distance(p, rp2, true, true);\n\t        dm1 = pv.distance(rp1, rp1, false, true);\n\t        dm2 = pv.distance(rp2, rp2, false, true);\n\t        doa1 = Math.abs(do1);\n\t        doa2 = Math.abs(do2);\n\t        dt = doa1 + doa2;\n\n\t        if (dt === 0) {\n\t            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n\t            return;\n\t        }\n\n\t        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n\t    },\n\n\t    // Slope of line normal to this.\n\t    normalSlope: 0,\n\n\t    // Sets the point 'p' relative to point 'rp'\n\t    // by the distance 'd'\n\t    //\n\t    // See APPENDIX on SETRELATIVE at the bottom of this file.\n\t    //\n\t    // p   ... point to set\n\t    // rp  ... reference point\n\t    // d   ... distance on projection vector\n\t    // pv  ... projection vector (undefined = this)\n\t    // org ... if true, uses the original position of rp as reference.\n\t    setRelative: function (p, rp, d, pv, org) {\n\t        if (!pv || pv === this) {\n\t            p.y = (org ? rp.yo : rp.y) + d;\n\t            return;\n\t        }\n\n\t        var rpx = org ? rp.xo : rp.x;\n\t        var rpy = org ? rp.yo : rp.y;\n\t        var rpdx = rpx + d * pv.x;\n\t        var rpdy = rpy + d * pv.y;\n\n\t        p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n\t    },\n\n\t    // Slope of vector line.\n\t    slope: Number.POSITIVE_INFINITY,\n\n\t    // Touches the point p.\n\t    touch: function (p) {\n\t        p.yTouched = true;\n\t    },\n\n\t    // Tests if a point p is touched.\n\t    touched: function (p) {\n\t        return p.yTouched;\n\t    },\n\n\t    // Untouches the point p.\n\t    untouch: function (p) {\n\t        p.yTouched = false;\n\t    }\n\t};\n\n\tObject.freeze(xUnitVector);\n\tObject.freeze(yUnitVector);\n\n\t/*\n\t* Creates a unit vector that is not x- or y-axis.\n\t*/\n\tfunction UnitVector(x, y) {\n\t    this.x = x;\n\t    this.y = y;\n\t    this.axis = undefined;\n\t    this.slope = y / x;\n\t    this.normalSlope = -x / y;\n\t    Object.freeze(this);\n\t}\n\n\t/*\n\t* Gets the projected distance between two points.\n\t* o1/o2 ... if true, respective original position is used.\n\t*/\n\tUnitVector.prototype.distance = function(p1, p2, o1, o2) {\n\t    return (\n\t        this.x * xUnitVector.distance(p1, p2, o1, o2) +\n\t        this.y * yUnitVector.distance(p1, p2, o1, o2)\n\t    );\n\t};\n\n\t/*\n\t* Moves point p so the moved position has the same relative\n\t* position to the moved positions of rp1 and rp2 than the\n\t* original positions had.\n\t*\n\t* See APPENDIX on INTERPOLATE at the bottom of this file.\n\t*/\n\tUnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {\n\t    var dm1;\n\t    var dm2;\n\t    var do1;\n\t    var do2;\n\t    var doa1;\n\t    var doa2;\n\t    var dt;\n\n\t    do1 = pv.distance(p, rp1, true, true);\n\t    do2 = pv.distance(p, rp2, true, true);\n\t    dm1 = pv.distance(rp1, rp1, false, true);\n\t    dm2 = pv.distance(rp2, rp2, false, true);\n\t    doa1 = Math.abs(do1);\n\t    doa2 = Math.abs(do2);\n\t    dt = doa1 + doa2;\n\n\t    if (dt === 0) {\n\t        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n\t        return;\n\t    }\n\n\t    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n\t};\n\n\t/*\n\t* Sets the point 'p' relative to point 'rp'\n\t* by the distance 'd'\n\t*\n\t* See APPENDIX on SETRELATIVE at the bottom of this file.\n\t*\n\t* p   ...  point to set\n\t* rp  ... reference point\n\t* d   ... distance on projection vector\n\t* pv  ... projection vector (undefined = this)\n\t* org ... if true, uses the original position of rp as reference.\n\t*/\n\tUnitVector.prototype.setRelative = function(p, rp, d, pv, org) {\n\t    pv = pv || this;\n\n\t    var rpx = org ? rp.xo : rp.x;\n\t    var rpy = org ? rp.yo : rp.y;\n\t    var rpdx = rpx + d * pv.x;\n\t    var rpdy = rpy + d * pv.y;\n\n\t    var pvns = pv.normalSlope;\n\t    var fvs = this.slope;\n\n\t    var px = p.x;\n\t    var py = p.y;\n\n\t    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n\t    p.y = fvs * (p.x - px) + py;\n\t};\n\n\t/*\n\t* Touches the point p.\n\t*/\n\tUnitVector.prototype.touch = function(p) {\n\t    p.xTouched = true;\n\t    p.yTouched = true;\n\t};\n\n\t/*\n\t* Returns a unit vector with x/y coordinates.\n\t*/\n\tfunction getUnitVector(x, y) {\n\t    var d = Math.sqrt(x * x + y * y);\n\n\t    x /= d;\n\t    y /= d;\n\n\t    if (x === 1 && y === 0) { return xUnitVector; }\n\t    else if (x === 0 && y === 1) { return yUnitVector; }\n\t    else { return new UnitVector(x, y); }\n\t}\n\n\t/*\n\t* Creates a point in the hinting engine.\n\t*/\n\tfunction HPoint(\n\t    x,\n\t    y,\n\t    lastPointOfContour,\n\t    onCurve\n\t) {\n\t    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n\t    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n\n\t    this.lastPointOfContour = lastPointOfContour;\n\t    this.onCurve = onCurve;\n\t    this.prevPointOnContour = undefined;\n\t    this.nextPointOnContour = undefined;\n\t    this.xTouched = false;\n\t    this.yTouched = false;\n\n\t    Object.preventExtensions(this);\n\t}\n\n\t/*\n\t* Returns the next touched point on the contour.\n\t*\n\t* v  ... unit vector to test touch axis.\n\t*/\n\tHPoint.prototype.nextTouched = function(v) {\n\t    var p = this.nextPointOnContour;\n\n\t    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }\n\n\t    return p;\n\t};\n\n\t/*\n\t* Returns the previous touched point on the contour\n\t*\n\t* v  ... unit vector to test touch axis.\n\t*/\n\tHPoint.prototype.prevTouched = function(v) {\n\t    var p = this.prevPointOnContour;\n\n\t    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }\n\n\t    return p;\n\t};\n\n\t/*\n\t* The zero point.\n\t*/\n\tvar HPZero = Object.freeze(new HPoint(0, 0));\n\n\t/*\n\t* The default state of the interpreter.\n\t*\n\t* Note: Freezing the defaultState and then deriving from it\n\t* makes the V8 Javascript engine going awkward,\n\t* so this is avoided, albeit the defaultState shouldn't\n\t* ever change.\n\t*/\n\tvar defaultState = {\n\t    cvCutIn: 17 / 16,    // control value cut in\n\t    deltaBase: 9,\n\t    deltaShift: 0.125,\n\t    loop: 1,             // loops some instructions\n\t    minDis: 1,           // minimum distance\n\t    autoFlip: true\n\t};\n\n\t/*\n\t* The current state of the interpreter.\n\t*\n\t* env  ... 'fpgm' or 'prep' or 'glyf'\n\t* prog ... the program\n\t*/\n\tfunction State(env, prog) {\n\t    this.env = env;\n\t    this.stack = [];\n\t    this.prog = prog;\n\n\t    switch (env) {\n\t        case 'glyf' :\n\t            this.zp0 = this.zp1 = this.zp2 = 1;\n\t            this.rp0 = this.rp1 = this.rp2 = 0;\n\t            /* fall through */\n\t        case 'prep' :\n\t            this.fv = this.pv = this.dpv = xUnitVector;\n\t            this.round = roundToGrid;\n\t    }\n\t}\n\n\t/*\n\t* Executes a glyph program.\n\t*\n\t* This does the hinting for each glyph.\n\t*\n\t* Returns an array of moved points.\n\t*\n\t* glyph: the glyph to hint\n\t* ppem: the size the glyph is rendered for\n\t*/\n\tHinting.prototype.exec = function(glyph, ppem) {\n\t    if (typeof ppem !== 'number') {\n\t        throw new Error('Point size is not a number!');\n\t    }\n\n\t    // Received a fatal error, don't do any hinting anymore.\n\t    if (this._errorState > 2) { return; }\n\n\t    var font = this.font;\n\t    var prepState = this._prepState;\n\n\t    if (!prepState || prepState.ppem !== ppem) {\n\t        var fpgmState = this._fpgmState;\n\n\t        if (!fpgmState) {\n\t            // Executes the fpgm state.\n\t            // This is used by fonts to define functions.\n\t            State.prototype = defaultState;\n\n\t            fpgmState =\n\t            this._fpgmState =\n\t                new State('fpgm', font.tables.fpgm);\n\n\t            fpgmState.funcs = [ ];\n\t            fpgmState.font = font;\n\n\t            if (exports.DEBUG) {\n\t                console.log('---EXEC FPGM---');\n\t                fpgmState.step = -1;\n\t            }\n\n\t            try {\n\t                exec(fpgmState);\n\t            } catch (e) {\n\t                console.log('Hinting error in FPGM:' + e);\n\t                this._errorState = 3;\n\t                return;\n\t            }\n\t        }\n\n\t        // Executes the prep program for this ppem setting.\n\t        // This is used by fonts to set cvt values\n\t        // depending on to be rendered font size.\n\n\t        State.prototype = fpgmState;\n\t        prepState =\n\t        this._prepState =\n\t            new State('prep', font.tables.prep);\n\n\t        prepState.ppem = ppem;\n\n\t        // Creates a copy of the cvt table\n\t        // and scales it to the current ppem setting.\n\t        var oCvt = font.tables.cvt;\n\t        if (oCvt) {\n\t            var cvt = prepState.cvt = new Array(oCvt.length);\n\t            var scale = ppem / font.unitsPerEm;\n\t            for (var c = 0; c < oCvt.length; c++) {\n\t                cvt[c] = oCvt[c] * scale;\n\t            }\n\t        } else {\n\t            prepState.cvt = [];\n\t        }\n\n\t        if (exports.DEBUG) {\n\t            console.log('---EXEC PREP---');\n\t            prepState.step = -1;\n\t        }\n\n\t        try {\n\t            exec(prepState);\n\t        } catch (e) {\n\t            if (this._errorState < 2) {\n\t                console.log('Hinting error in PREP:' + e);\n\t            }\n\t            this._errorState = 2;\n\t        }\n\t    }\n\n\t    if (this._errorState > 1) { return; }\n\n\t    try {\n\t        return execGlyph(glyph, prepState);\n\t    } catch (e) {\n\t        if (this._errorState < 1) {\n\t            console.log('Hinting error:' + e);\n\t            console.log('Note: further hinting errors are silenced');\n\t        }\n\t        this._errorState = 1;\n\t        return undefined;\n\t    }\n\t};\n\n\t/*\n\t* Executes the hinting program for a glyph.\n\t*/\n\texecGlyph = function(glyph, prepState) {\n\t    // original point positions\n\t    var xScale = prepState.ppem / prepState.font.unitsPerEm;\n\t    var yScale = xScale;\n\t    var components = glyph.components;\n\t    var contours;\n\t    var gZone;\n\t    var state;\n\n\t    State.prototype = prepState;\n\t    if (!components) {\n\t        state = new State('glyf', glyph.instructions);\n\t        if (exports.DEBUG) {\n\t            console.log('---EXEC GLYPH---');\n\t            state.step = -1;\n\t        }\n\t        execComponent(glyph, state, xScale, yScale);\n\t        gZone = state.gZone;\n\t    } else {\n\t        var font = prepState.font;\n\t        gZone = [];\n\t        contours = [];\n\t        for (var i = 0; i < components.length; i++) {\n\t            var c = components[i];\n\t            var cg = font.glyphs.get(c.glyphIndex);\n\n\t            state = new State('glyf', cg.instructions);\n\n\t            if (exports.DEBUG) {\n\t                console.log('---EXEC COMP ' + i + '---');\n\t                state.step = -1;\n\t            }\n\n\t            execComponent(cg, state, xScale, yScale);\n\t            // appends the computed points to the result array\n\t            // post processes the component points\n\t            var dx = Math.round(c.dx * xScale);\n\t            var dy = Math.round(c.dy * yScale);\n\t            var gz = state.gZone;\n\t            var cc = state.contours;\n\t            for (var pi = 0; pi < gz.length; pi++) {\n\t                var p = gz[pi];\n\t                p.xTouched = p.yTouched = false;\n\t                p.xo = p.x = p.x + dx;\n\t                p.yo = p.y = p.y + dy;\n\t            }\n\n\t            var gLen = gZone.length;\n\t            gZone.push.apply(gZone, gz);\n\t            for (var j = 0; j < cc.length; j++) {\n\t                contours.push(cc[j] + gLen);\n\t            }\n\t        }\n\n\t        if (glyph.instructions && !state.inhibitGridFit) {\n\t            // the composite has instructions on its own\n\t            state = new State('glyf', glyph.instructions);\n\n\t            state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n\n\t            state.contours = contours;\n\n\t            // note: HPZero cannot be used here, since\n\t            //       the point might be modified\n\t            gZone.push(\n\t                new HPoint(0, 0),\n\t                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n\t            );\n\n\t            if (exports.DEBUG) {\n\t                console.log('---EXEC COMPOSITE---');\n\t                state.step = -1;\n\t            }\n\n\t            exec(state);\n\n\t            gZone.length -= 2;\n\t        }\n\t    }\n\n\t    return gZone;\n\t};\n\n\t/*\n\t* Executes the hinting program for a component of a multi-component glyph\n\t* or of the glyph itself for a non-component glyph.\n\t*/\n\texecComponent = function(glyph, state, xScale, yScale)\n\t{\n\t    var points = glyph.points || [];\n\t    var pLen = points.length;\n\t    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n\t    var contours = state.contours = [];\n\n\t    // Scales the original points and\n\t    // makes copies for the hinted points.\n\t    var cp; // current point\n\t    for (var i = 0; i < pLen; i++) {\n\t        cp = points[i];\n\n\t        gZone[i] = new HPoint(\n\t            cp.x * xScale,\n\t            cp.y * yScale,\n\t            cp.lastPointOfContour,\n\t            cp.onCurve\n\t        );\n\t    }\n\n\t    // Chain links the contours.\n\t    var sp; // start point\n\t    var np; // next point\n\n\t    for (var i$1 = 0; i$1 < pLen; i$1++) {\n\t        cp = gZone[i$1];\n\n\t        if (!sp) {\n\t            sp = cp;\n\t            contours.push(i$1);\n\t        }\n\n\t        if (cp.lastPointOfContour) {\n\t            cp.nextPointOnContour = sp;\n\t            sp.prevPointOnContour = cp;\n\t            sp = undefined;\n\t        } else {\n\t            np = gZone[i$1 + 1];\n\t            cp.nextPointOnContour = np;\n\t            np.prevPointOnContour = cp;\n\t        }\n\t    }\n\n\t    if (state.inhibitGridFit) { return; }\n\n\t    if (exports.DEBUG) {\n\t        console.log('PROCESSING GLYPH', state.stack);\n\t        for (var i$2 = 0; i$2 < pLen; i$2++) {\n\t            console.log(i$2, gZone[i$2].x, gZone[i$2].y);\n\t        }\n\t    }\n\n\t    gZone.push(\n\t        new HPoint(0, 0),\n\t        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n\t    );\n\n\t    exec(state);\n\n\t    // Removes the extra points.\n\t    gZone.length -= 2;\n\n\t    if (exports.DEBUG) {\n\t        console.log('FINISHED GLYPH', state.stack);\n\t        for (var i$3 = 0; i$3 < pLen; i$3++) {\n\t            console.log(i$3, gZone[i$3].x, gZone[i$3].y);\n\t        }\n\t    }\n\t};\n\n\t/*\n\t* Executes the program loaded in state.\n\t*/\n\texec = function(state) {\n\t    var prog = state.prog;\n\n\t    if (!prog) { return; }\n\n\t    var pLen = prog.length;\n\t    var ins;\n\n\t    for (state.ip = 0; state.ip < pLen; state.ip++) {\n\t        if (exports.DEBUG) { state.step++; }\n\t        ins = instructionTable[prog[state.ip]];\n\n\t        if (!ins) {\n\t            throw new Error(\n\t                'unknown instruction: 0x' +\n\t                Number(prog[state.ip]).toString(16)\n\t            );\n\t        }\n\n\t        ins(state);\n\n\t        // very extensive debugging for each step\n\t        /*\n\t        if (exports.DEBUG) {\n\t            var da;\n\t            if (state.gZone) {\n\t                da = [];\n\t                for (let i = 0; i < state.gZone.length; i++)\n\t                {\n\t                    da.push(i + ' ' +\n\t                        state.gZone[i].x * 64 + ' ' +\n\t                        state.gZone[i].y * 64 + ' ' +\n\t                        (state.gZone[i].xTouched ? 'x' : '') +\n\t                        (state.gZone[i].yTouched ? 'y' : '')\n\t                    );\n\t                }\n\t                console.log('GZ', da);\n\t            }\n\n\t            if (state.tZone) {\n\t                da = [];\n\t                for (let i = 0; i < state.tZone.length; i++) {\n\t                    da.push(i + ' ' +\n\t                        state.tZone[i].x * 64 + ' ' +\n\t                        state.tZone[i].y * 64 + ' ' +\n\t                        (state.tZone[i].xTouched ? 'x' : '') +\n\t                        (state.tZone[i].yTouched ? 'y' : '')\n\t                    );\n\t                }\n\t                console.log('TZ', da);\n\t            }\n\n\t            if (state.stack.length > 10) {\n\t                console.log(\n\t                    state.stack.length,\n\t                    '...', state.stack.slice(state.stack.length - 10)\n\t                );\n\t            } else {\n\t                console.log(state.stack.length, state.stack);\n\t            }\n\t        }\n\t        */\n\t    }\n\t};\n\n\t/*\n\t* Initializes the twilight zone.\n\t*\n\t* This is only done if a SZPx instruction\n\t* refers to the twilight zone.\n\t*/\n\tfunction initTZone(state)\n\t{\n\t    var tZone = state.tZone = new Array(state.gZone.length);\n\n\t    // no idea if this is actually correct...\n\t    for (var i = 0; i < tZone.length; i++)\n\t    {\n\t        tZone[i] = new HPoint(0, 0);\n\t    }\n\t}\n\n\t/*\n\t* Skips the instruction pointer ahead over an IF/ELSE block.\n\t* handleElse .. if true breaks on matching ELSE\n\t*/\n\tfunction skip(state, handleElse)\n\t{\n\t    var prog = state.prog;\n\t    var ip = state.ip;\n\t    var nesting = 1;\n\t    var ins;\n\n\t    do {\n\t        ins = prog[++ip];\n\t        if (ins === 0x58) // IF\n\t            { nesting++; }\n\t        else if (ins === 0x59) // EIF\n\t            { nesting--; }\n\t        else if (ins === 0x40) // NPUSHB\n\t            { ip += prog[ip + 1] + 1; }\n\t        else if (ins === 0x41) // NPUSHW\n\t            { ip += 2 * prog[ip + 1] + 1; }\n\t        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB\n\t            { ip += ins - 0xB0 + 1; }\n\t        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW\n\t            { ip += (ins - 0xB8 + 1) * 2; }\n\t        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE\n\t            { break; }\n\t    } while (nesting > 0);\n\n\t    state.ip = ip;\n\t}\n\n\t/*----------------------------------------------------------*\n\t*          And then a lot of instructions...                *\n\t*----------------------------------------------------------*/\n\n\t// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n\t// 0x00-0x01\n\tfunction SVTCA(v, state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }\n\n\t    state.fv = state.pv = state.dpv = v;\n\t}\n\n\t// SPVTCA[a] Set Projection Vector to Coordinate Axis\n\t// 0x02-0x03\n\tfunction SPVTCA(v, state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }\n\n\t    state.pv = state.dpv = v;\n\t}\n\n\t// SFVTCA[a] Set Freedom Vector to Coordinate Axis\n\t// 0x04-0x05\n\tfunction SFVTCA(v, state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }\n\n\t    state.fv = v;\n\t}\n\n\t// SPVTL[a] Set Projection Vector To Line\n\t// 0x06-0x07\n\tfunction SPVTL(a, state) {\n\t    var stack = state.stack;\n\t    var p2i = stack.pop();\n\t    var p1i = stack.pop();\n\t    var p2 = state.z2[p2i];\n\t    var p1 = state.z1[p1i];\n\n\t    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }\n\n\t    var dx;\n\t    var dy;\n\n\t    if (!a) {\n\t        dx = p1.x - p2.x;\n\t        dy = p1.y - p2.y;\n\t    } else {\n\t        dx = p2.y - p1.y;\n\t        dy = p1.x - p2.x;\n\t    }\n\n\t    state.pv = state.dpv = getUnitVector(dx, dy);\n\t}\n\n\t// SFVTL[a] Set Freedom Vector To Line\n\t// 0x08-0x09\n\tfunction SFVTL(a, state) {\n\t    var stack = state.stack;\n\t    var p2i = stack.pop();\n\t    var p1i = stack.pop();\n\t    var p2 = state.z2[p2i];\n\t    var p1 = state.z1[p1i];\n\n\t    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }\n\n\t    var dx;\n\t    var dy;\n\n\t    if (!a) {\n\t        dx = p1.x - p2.x;\n\t        dy = p1.y - p2.y;\n\t    } else {\n\t        dx = p2.y - p1.y;\n\t        dy = p1.x - p2.x;\n\t    }\n\n\t    state.fv = getUnitVector(dx, dy);\n\t}\n\n\t// SPVFS[] Set Projection Vector From Stack\n\t// 0x0A\n\tfunction SPVFS(state) {\n\t    var stack = state.stack;\n\t    var y = stack.pop();\n\t    var x = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n\t    state.pv = state.dpv = getUnitVector(x, y);\n\t}\n\n\t// SFVFS[] Set Freedom Vector From Stack\n\t// 0x0B\n\tfunction SFVFS(state) {\n\t    var stack = state.stack;\n\t    var y = stack.pop();\n\t    var x = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n\t    state.fv = getUnitVector(x, y);\n\t}\n\n\t// GPV[] Get Projection Vector\n\t// 0x0C\n\tfunction GPV(state) {\n\t    var stack = state.stack;\n\t    var pv = state.pv;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }\n\n\t    stack.push(pv.x * 0x4000);\n\t    stack.push(pv.y * 0x4000);\n\t}\n\n\t// GFV[] Get Freedom Vector\n\t// 0x0C\n\tfunction GFV(state) {\n\t    var stack = state.stack;\n\t    var fv = state.fv;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }\n\n\t    stack.push(fv.x * 0x4000);\n\t    stack.push(fv.y * 0x4000);\n\t}\n\n\t// SFVTPV[] Set Freedom Vector To Projection Vector\n\t// 0x0E\n\tfunction SFVTPV(state) {\n\t    state.fv = state.pv;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }\n\t}\n\n\t// ISECT[] moves point p to the InterSECTion of two lines\n\t// 0x0F\n\tfunction ISECT(state)\n\t{\n\t    var stack = state.stack;\n\t    var pa0i = stack.pop();\n\t    var pa1i = stack.pop();\n\t    var pb0i = stack.pop();\n\t    var pb1i = stack.pop();\n\t    var pi = stack.pop();\n\t    var z0 = state.z0;\n\t    var z1 = state.z1;\n\t    var pa0 = z0[pa0i];\n\t    var pa1 = z0[pa1i];\n\t    var pb0 = z1[pb0i];\n\t    var pb1 = z1[pb1i];\n\t    var p = state.z2[pi];\n\n\t    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }\n\n\t    // math from\n\t    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n\t    var x1 = pa0.x;\n\t    var y1 = pa0.y;\n\t    var x2 = pa1.x;\n\t    var y2 = pa1.y;\n\t    var x3 = pb0.x;\n\t    var y3 = pb0.y;\n\t    var x4 = pb1.x;\n\t    var y4 = pb1.y;\n\n\t    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\t    var f1 = x1 * y2 - y1 * x2;\n\t    var f2 = x3 * y4 - y3 * x4;\n\n\t    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n\t    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n\t}\n\n\t// SRP0[] Set Reference Point 0\n\t// 0x10\n\tfunction SRP0(state) {\n\t    state.rp0 = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }\n\t}\n\n\t// SRP1[] Set Reference Point 1\n\t// 0x11\n\tfunction SRP1(state) {\n\t    state.rp1 = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }\n\t}\n\n\t// SRP1[] Set Reference Point 2\n\t// 0x12\n\tfunction SRP2(state) {\n\t    state.rp2 = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }\n\t}\n\n\t// SZP0[] Set Zone Pointer 0\n\t// 0x13\n\tfunction SZP0(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }\n\n\t    state.zp0 = n;\n\n\t    switch (n) {\n\t        case 0:\n\t            if (!state.tZone) { initTZone(state); }\n\t            state.z0 = state.tZone;\n\t            break;\n\t        case 1 :\n\t            state.z0 = state.gZone;\n\t            break;\n\t        default :\n\t            throw new Error('Invalid zone pointer');\n\t    }\n\t}\n\n\t// SZP1[] Set Zone Pointer 1\n\t// 0x14\n\tfunction SZP1(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }\n\n\t    state.zp1 = n;\n\n\t    switch (n) {\n\t        case 0:\n\t            if (!state.tZone) { initTZone(state); }\n\t            state.z1 = state.tZone;\n\t            break;\n\t        case 1 :\n\t            state.z1 = state.gZone;\n\t            break;\n\t        default :\n\t            throw new Error('Invalid zone pointer');\n\t    }\n\t}\n\n\t// SZP2[] Set Zone Pointer 2\n\t// 0x15\n\tfunction SZP2(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }\n\n\t    state.zp2 = n;\n\n\t    switch (n) {\n\t        case 0:\n\t            if (!state.tZone) { initTZone(state); }\n\t            state.z2 = state.tZone;\n\t            break;\n\t        case 1 :\n\t            state.z2 = state.gZone;\n\t            break;\n\t        default :\n\t            throw new Error('Invalid zone pointer');\n\t    }\n\t}\n\n\t// SZPS[] Set Zone PointerS\n\t// 0x16\n\tfunction SZPS(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }\n\n\t    state.zp0 = state.zp1 = state.zp2 = n;\n\n\t    switch (n) {\n\t        case 0:\n\t            if (!state.tZone) { initTZone(state); }\n\t            state.z0 = state.z1 = state.z2 = state.tZone;\n\t            break;\n\t        case 1 :\n\t            state.z0 = state.z1 = state.z2 = state.gZone;\n\t            break;\n\t        default :\n\t            throw new Error('Invalid zone pointer');\n\t    }\n\t}\n\n\t// SLOOP[] Set LOOP variable\n\t// 0x17\n\tfunction SLOOP(state) {\n\t    state.loop = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }\n\t}\n\n\t// RTG[] Round To Grid\n\t// 0x18\n\tfunction RTG(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }\n\n\t    state.round = roundToGrid;\n\t}\n\n\t// RTHG[] Round To Half Grid\n\t// 0x19\n\tfunction RTHG(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }\n\n\t    state.round = roundToHalfGrid;\n\t}\n\n\t// SMD[] Set Minimum Distance\n\t// 0x1A\n\tfunction SMD(state) {\n\t    var d = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }\n\n\t    state.minDis = d / 0x40;\n\t}\n\n\t// ELSE[] ELSE clause\n\t// 0x1B\n\tfunction ELSE(state) {\n\t    // This instruction has been reached by executing a then branch\n\t    // so it just skips ahead until matching EIF.\n\t    //\n\t    // In case the IF was negative the IF[] instruction already\n\t    // skipped forward over the ELSE[]\n\n\t    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }\n\n\t    skip(state, false);\n\t}\n\n\t// JMPR[] JuMP Relative\n\t// 0x1C\n\tfunction JMPR(state) {\n\t    var o = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }\n\n\t    // A jump by 1 would do nothing.\n\t    state.ip += o - 1;\n\t}\n\n\t// SCVTCI[] Set Control Value Table Cut-In\n\t// 0x1D\n\tfunction SCVTCI(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }\n\n\t    state.cvCutIn = n / 0x40;\n\t}\n\n\t// DUP[] DUPlicate top stack element\n\t// 0x20\n\tfunction DUP(state) {\n\t    var stack = state.stack;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }\n\n\t    stack.push(stack[stack.length - 1]);\n\t}\n\n\t// POP[] POP top stack element\n\t// 0x21\n\tfunction POP(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }\n\n\t    state.stack.pop();\n\t}\n\n\t// CLEAR[] CLEAR the stack\n\t// 0x22\n\tfunction CLEAR(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }\n\n\t    state.stack.length = 0;\n\t}\n\n\t// SWAP[] SWAP the top two elements on the stack\n\t// 0x23\n\tfunction SWAP(state) {\n\t    var stack = state.stack;\n\n\t    var a = stack.pop();\n\t    var b = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }\n\n\t    stack.push(a);\n\t    stack.push(b);\n\t}\n\n\t// DEPTH[] DEPTH of the stack\n\t// 0x24\n\tfunction DEPTH(state) {\n\t    var stack = state.stack;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }\n\n\t    stack.push(stack.length);\n\t}\n\n\t// LOOPCALL[] LOOPCALL function\n\t// 0x2A\n\tfunction LOOPCALL(state) {\n\t    var stack = state.stack;\n\t    var fn = stack.pop();\n\t    var c = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }\n\n\t    // saves callers program\n\t    var cip = state.ip;\n\t    var cprog = state.prog;\n\n\t    state.prog = state.funcs[fn];\n\n\t    // executes the function\n\t    for (var i = 0; i < c; i++) {\n\t        exec(state);\n\n\t        if (exports.DEBUG) { console.log(\n\t            ++state.step,\n\t            i + 1 < c ? 'next loopcall' : 'done loopcall',\n\t            i\n\t        ); }\n\t    }\n\n\t    // restores the callers program\n\t    state.ip = cip;\n\t    state.prog = cprog;\n\t}\n\n\t// CALL[] CALL function\n\t// 0x2B\n\tfunction CALL(state) {\n\t    var fn = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }\n\n\t    // saves callers program\n\t    var cip = state.ip;\n\t    var cprog = state.prog;\n\n\t    state.prog = state.funcs[fn];\n\n\t    // executes the function\n\t    exec(state);\n\n\t    // restores the callers program\n\t    state.ip = cip;\n\t    state.prog = cprog;\n\n\t    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }\n\t}\n\n\t// CINDEX[] Copy the INDEXed element to the top of the stack\n\t// 0x25\n\tfunction CINDEX(state) {\n\t    var stack = state.stack;\n\t    var k = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }\n\n\t    // In case of k == 1, it copies the last element after popping\n\t    // thus stack.length - k.\n\t    stack.push(stack[stack.length - k]);\n\t}\n\n\t// MINDEX[] Move the INDEXed element to the top of the stack\n\t// 0x26\n\tfunction MINDEX(state) {\n\t    var stack = state.stack;\n\t    var k = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }\n\n\t    stack.push(stack.splice(stack.length - k, 1)[0]);\n\t}\n\n\t// FDEF[] Function DEFinition\n\t// 0x2C\n\tfunction FDEF(state) {\n\t    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }\n\t    var stack = state.stack;\n\t    var prog = state.prog;\n\t    var ip = state.ip;\n\n\t    var fn = stack.pop();\n\t    var ipBegin = ip;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }\n\n\t    while (prog[++ip] !== 0x2D){ }\n\n\t    state.ip = ip;\n\t    state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n\t}\n\n\t// MDAP[a] Move Direct Absolute Point\n\t// 0x2E-0x2F\n\tfunction MDAP(round, state) {\n\t    var pi = state.stack.pop();\n\t    var p = state.z0[pi];\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }\n\n\t    var d = pv.distance(p, HPZero);\n\n\t    if (round) { d = state.round(d); }\n\n\t    fv.setRelative(p, HPZero, d, pv);\n\t    fv.touch(p);\n\n\t    state.rp0 = state.rp1 = pi;\n\t}\n\n\t// IUP[a] Interpolate Untouched Points through the outline\n\t// 0x30\n\tfunction IUP(v, state) {\n\t    var z2 = state.z2;\n\t    var pLen = z2.length - 2;\n\t    var cp;\n\t    var pp;\n\t    var np;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }\n\n\t    for (var i = 0; i < pLen; i++) {\n\t        cp = z2[i]; // current point\n\n\t        // if this point has been touched go on\n\t        if (v.touched(cp)) { continue; }\n\n\t        pp = cp.prevTouched(v);\n\n\t        // no point on the contour has been touched?\n\t        if (pp === cp) { continue; }\n\n\t        np = cp.nextTouched(v);\n\n\t        if (pp === np) {\n\t            // only one point on the contour has been touched\n\t            // so simply moves the point like that\n\n\t            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n\t        }\n\n\t        v.interpolate(cp, pp, np, v);\n\t    }\n\t}\n\n\t// SHP[] SHift Point using reference point\n\t// 0x32-0x33\n\tfunction SHP(a, state) {\n\t    var stack = state.stack;\n\t    var rpi = a ? state.rp1 : state.rp2;\n\t    var rp = (a ? state.z0 : state.z1)[rpi];\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\t    var loop = state.loop;\n\t    var z2 = state.z2;\n\n\t    while (loop--)\n\t    {\n\t        var pi = stack.pop();\n\t        var p = z2[pi];\n\n\t        var d = pv.distance(rp, rp, false, true);\n\t        fv.setRelative(p, p, d, pv);\n\t        fv.touch(p);\n\n\t        if (exports.DEBUG) {\n\t            console.log(\n\t                state.step,\n\t                (state.loop > 1 ?\n\t                   'loop ' + (state.loop - loop) + ': ' :\n\t                   ''\n\t                ) +\n\t                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi\n\t            );\n\t        }\n\t    }\n\n\t    state.loop = 1;\n\t}\n\n\t// SHC[] SHift Contour using reference point\n\t// 0x36-0x37\n\tfunction SHC(a, state) {\n\t    var stack = state.stack;\n\t    var rpi = a ? state.rp1 : state.rp2;\n\t    var rp = (a ? state.z0 : state.z1)[rpi];\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\t    var ci = stack.pop();\n\t    var sp = state.z2[state.contours[ci]];\n\t    var p = sp;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }\n\n\t    var d = pv.distance(rp, rp, false, true);\n\n\t    do {\n\t        if (p !== rp) { fv.setRelative(p, p, d, pv); }\n\t        p = p.nextPointOnContour;\n\t    } while (p !== sp);\n\t}\n\n\t// SHZ[] SHift Zone using reference point\n\t// 0x36-0x37\n\tfunction SHZ(a, state) {\n\t    var stack = state.stack;\n\t    var rpi = a ? state.rp1 : state.rp2;\n\t    var rp = (a ? state.z0 : state.z1)[rpi];\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\n\t    var e = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }\n\n\t    var z;\n\t    switch (e) {\n\t        case 0 : z = state.tZone; break;\n\t        case 1 : z = state.gZone; break;\n\t        default : throw new Error('Invalid zone');\n\t    }\n\n\t    var p;\n\t    var d = pv.distance(rp, rp, false, true);\n\t    var pLen = z.length - 2;\n\t    for (var i = 0; i < pLen; i++)\n\t    {\n\t        p = z[i];\n\t        fv.setRelative(p, p, d, pv);\n\t        //if (p !== rp) fv.setRelative(p, p, d, pv);\n\t    }\n\t}\n\n\t// SHPIX[] SHift point by a PIXel amount\n\t// 0x38\n\tfunction SHPIX(state) {\n\t    var stack = state.stack;\n\t    var loop = state.loop;\n\t    var fv = state.fv;\n\t    var d = stack.pop() / 0x40;\n\t    var z2 = state.z2;\n\n\t    while (loop--) {\n\t        var pi = stack.pop();\n\t        var p = z2[pi];\n\n\t        if (exports.DEBUG) {\n\t            console.log(\n\t                state.step,\n\t                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n\t                'SHPIX[]', pi, d\n\t            );\n\t        }\n\n\t        fv.setRelative(p, p, d);\n\t        fv.touch(p);\n\t    }\n\n\t    state.loop = 1;\n\t}\n\n\t// IP[] Interpolate Point\n\t// 0x39\n\tfunction IP(state) {\n\t    var stack = state.stack;\n\t    var rp1i = state.rp1;\n\t    var rp2i = state.rp2;\n\t    var loop = state.loop;\n\t    var rp1 = state.z0[rp1i];\n\t    var rp2 = state.z1[rp2i];\n\t    var fv = state.fv;\n\t    var pv = state.dpv;\n\t    var z2 = state.z2;\n\n\t    while (loop--) {\n\t        var pi = stack.pop();\n\t        var p = z2[pi];\n\n\t        if (exports.DEBUG) {\n\t            console.log(\n\t                state.step,\n\t                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n\t                'IP[]', pi, rp1i, '<->', rp2i\n\t            );\n\t        }\n\n\t        fv.interpolate(p, rp1, rp2, pv);\n\n\t        fv.touch(p);\n\t    }\n\n\t    state.loop = 1;\n\t}\n\n\t// MSIRP[a] Move Stack Indirect Relative Point\n\t// 0x3A-0x3B\n\tfunction MSIRP(a, state) {\n\t    var stack = state.stack;\n\t    var d = stack.pop() / 64;\n\t    var pi = stack.pop();\n\t    var p = state.z1[pi];\n\t    var rp0 = state.z0[state.rp0];\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\n\t    fv.setRelative(p, rp0, d, pv);\n\t    fv.touch(p);\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }\n\n\t    state.rp1 = state.rp0;\n\t    state.rp2 = pi;\n\t    if (a) { state.rp0 = pi; }\n\t}\n\n\t// ALIGNRP[] Align to reference point.\n\t// 0x3C\n\tfunction ALIGNRP(state) {\n\t    var stack = state.stack;\n\t    var rp0i = state.rp0;\n\t    var rp0 = state.z0[rp0i];\n\t    var loop = state.loop;\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\t    var z1 = state.z1;\n\n\t    while (loop--) {\n\t        var pi = stack.pop();\n\t        var p = z1[pi];\n\n\t        if (exports.DEBUG) {\n\t            console.log(\n\t                state.step,\n\t                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n\t                'ALIGNRP[]', pi\n\t            );\n\t        }\n\n\t        fv.setRelative(p, rp0, 0, pv);\n\t        fv.touch(p);\n\t    }\n\n\t    state.loop = 1;\n\t}\n\n\t// RTG[] Round To Double Grid\n\t// 0x3D\n\tfunction RTDG(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }\n\n\t    state.round = roundToDoubleGrid;\n\t}\n\n\t// MIAP[a] Move Indirect Absolute Point\n\t// 0x3E-0x3F\n\tfunction MIAP(round, state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\t    var pi = stack.pop();\n\t    var p = state.z0[pi];\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\t    var cv = state.cvt[n];\n\n\t    if (exports.DEBUG) {\n\t        console.log(\n\t            state.step,\n\t            'MIAP[' + round + ']',\n\t            n, '(', cv, ')', pi\n\t        );\n\t    }\n\n\t    var d = pv.distance(p, HPZero);\n\n\t    if (round) {\n\t        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n\n\t        d = state.round(d);\n\t    }\n\n\t    fv.setRelative(p, HPZero, d, pv);\n\n\t    if (state.zp0 === 0) {\n\t        p.xo = p.x;\n\t        p.yo = p.y;\n\t    }\n\n\t    fv.touch(p);\n\n\t    state.rp0 = state.rp1 = pi;\n\t}\n\n\t// NPUSB[] PUSH N Bytes\n\t// 0x40\n\tfunction NPUSHB(state) {\n\t    var prog = state.prog;\n\t    var ip = state.ip;\n\t    var stack = state.stack;\n\n\t    var n = prog[++ip];\n\n\t    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }\n\n\t    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n\t    state.ip = ip;\n\t}\n\n\t// NPUSHW[] PUSH N Words\n\t// 0x41\n\tfunction NPUSHW(state) {\n\t    var ip = state.ip;\n\t    var prog = state.prog;\n\t    var stack = state.stack;\n\t    var n = prog[++ip];\n\n\t    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }\n\n\t    for (var i = 0; i < n; i++) {\n\t        var w = (prog[++ip] << 8) | prog[++ip];\n\t        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n\t        stack.push(w);\n\t    }\n\n\t    state.ip = ip;\n\t}\n\n\t// WS[] Write Store\n\t// 0x42\n\tfunction WS(state) {\n\t    var stack = state.stack;\n\t    var store = state.store;\n\n\t    if (!store) { store = state.store = []; }\n\n\t    var v = stack.pop();\n\t    var l = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }\n\n\t    store[l] = v;\n\t}\n\n\t// RS[] Read Store\n\t// 0x43\n\tfunction RS(state) {\n\t    var stack = state.stack;\n\t    var store = state.store;\n\n\t    var l = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'RS', l); }\n\n\t    var v = (store && store[l]) || 0;\n\n\t    stack.push(v);\n\t}\n\n\t// WCVTP[] Write Control Value Table in Pixel units\n\t// 0x44\n\tfunction WCVTP(state) {\n\t    var stack = state.stack;\n\n\t    var v = stack.pop();\n\t    var l = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }\n\n\t    state.cvt[l] = v / 0x40;\n\t}\n\n\t// RCVT[] Read Control Value Table entry\n\t// 0x45\n\tfunction RCVT(state) {\n\t    var stack = state.stack;\n\t    var cvte = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }\n\n\t    stack.push(state.cvt[cvte] * 0x40);\n\t}\n\n\t// GC[] Get Coordinate projected onto the projection vector\n\t// 0x46-0x47\n\tfunction GC(a, state) {\n\t    var stack = state.stack;\n\t    var pi = stack.pop();\n\t    var p = state.z2[pi];\n\n\t    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }\n\n\t    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n\t}\n\n\t// MD[a] Measure Distance\n\t// 0x49-0x4A\n\tfunction MD(a, state) {\n\t    var stack = state.stack;\n\t    var pi2 = stack.pop();\n\t    var pi1 = stack.pop();\n\t    var p2 = state.z1[pi2];\n\t    var p1 = state.z0[pi1];\n\t    var d = state.dpv.distance(p1, p2, a, a);\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }\n\n\t    state.stack.push(Math.round(d * 64));\n\t}\n\n\t// MPPEM[] Measure Pixels Per EM\n\t// 0x4B\n\tfunction MPPEM(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }\n\t    state.stack.push(state.ppem);\n\t}\n\n\t// FLIPON[] set the auto FLIP Boolean to ON\n\t// 0x4D\n\tfunction FLIPON(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }\n\t    state.autoFlip = true;\n\t}\n\n\t// LT[] Less Than\n\t// 0x50\n\tfunction LT(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }\n\n\t    stack.push(e1 < e2 ? 1 : 0);\n\t}\n\n\t// LTEQ[] Less Than or EQual\n\t// 0x53\n\tfunction LTEQ(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }\n\n\t    stack.push(e1 <= e2 ? 1 : 0);\n\t}\n\n\t// GTEQ[] Greater Than\n\t// 0x52\n\tfunction GT(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }\n\n\t    stack.push(e1 > e2 ? 1 : 0);\n\t}\n\n\t// GTEQ[] Greater Than or EQual\n\t// 0x53\n\tfunction GTEQ(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }\n\n\t    stack.push(e1 >= e2 ? 1 : 0);\n\t}\n\n\t// EQ[] EQual\n\t// 0x54\n\tfunction EQ(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }\n\n\t    stack.push(e2 === e1 ? 1 : 0);\n\t}\n\n\t// NEQ[] Not EQual\n\t// 0x55\n\tfunction NEQ(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }\n\n\t    stack.push(e2 !== e1 ? 1 : 0);\n\t}\n\n\t// ODD[] ODD\n\t// 0x56\n\tfunction ODD(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }\n\n\t    stack.push(Math.trunc(n) % 2 ? 1 : 0);\n\t}\n\n\t// EVEN[] EVEN\n\t// 0x57\n\tfunction EVEN(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }\n\n\t    stack.push(Math.trunc(n) % 2 ? 0 : 1);\n\t}\n\n\t// IF[] IF test\n\t// 0x58\n\tfunction IF(state) {\n\t    var test = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }\n\n\t    // if test is true it just continues\n\t    // if not the ip is skipped until matching ELSE or EIF\n\t    if (!test) {\n\t        skip(state, true);\n\n\t        if (exports.DEBUG) { console.log(state.step,  'EIF[]'); }\n\t    }\n\t}\n\n\t// EIF[] End IF\n\t// 0x59\n\tfunction EIF(state) {\n\t    // this can be reached normally when\n\t    // executing an else branch.\n\t    // -> just ignore it\n\n\t    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }\n\t}\n\n\t// AND[] logical AND\n\t// 0x5A\n\tfunction AND(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }\n\n\t    stack.push(e2 && e1 ? 1 : 0);\n\t}\n\n\t// OR[] logical OR\n\t// 0x5B\n\tfunction OR(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }\n\n\t    stack.push(e2 || e1 ? 1 : 0);\n\t}\n\n\t// NOT[] logical NOT\n\t// 0x5C\n\tfunction NOT(state) {\n\t    var stack = state.stack;\n\t    var e = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }\n\n\t    stack.push(e ? 0 : 1);\n\t}\n\n\t// DELTAP1[] DELTA exception P1\n\t// DELTAP2[] DELTA exception P2\n\t// DELTAP3[] DELTA exception P3\n\t// 0x5D, 0x71, 0x72\n\tfunction DELTAP123(b, state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\t    var ppem = state.ppem;\n\t    var base = state.deltaBase + (b - 1) * 16;\n\t    var ds = state.deltaShift;\n\t    var z0 = state.z0;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }\n\n\t    for (var i = 0; i < n; i++) {\n\t        var pi = stack.pop();\n\t        var arg = stack.pop();\n\t        var appem = base + ((arg & 0xF0) >> 4);\n\t        if (appem !== ppem) { continue; }\n\n\t        var mag = (arg & 0x0F) - 8;\n\t        if (mag >= 0) { mag++; }\n\t        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }\n\n\t        var p = z0[pi];\n\t        fv.setRelative(p, p, mag * ds, pv);\n\t    }\n\t}\n\n\t// SDB[] Set Delta Base in the graphics state\n\t// 0x5E\n\tfunction SDB(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }\n\n\t    state.deltaBase = n;\n\t}\n\n\t// SDS[] Set Delta Shift in the graphics state\n\t// 0x5F\n\tfunction SDS(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }\n\n\t    state.deltaShift = Math.pow(0.5, n);\n\t}\n\n\t// ADD[] ADD\n\t// 0x60\n\tfunction ADD(state) {\n\t    var stack = state.stack;\n\t    var n2 = stack.pop();\n\t    var n1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }\n\n\t    stack.push(n1 + n2);\n\t}\n\n\t// SUB[] SUB\n\t// 0x61\n\tfunction SUB(state) {\n\t    var stack = state.stack;\n\t    var n2 = stack.pop();\n\t    var n1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }\n\n\t    stack.push(n1 - n2);\n\t}\n\n\t// DIV[] DIV\n\t// 0x62\n\tfunction DIV(state) {\n\t    var stack = state.stack;\n\t    var n2 = stack.pop();\n\t    var n1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }\n\n\t    stack.push(n1 * 64 / n2);\n\t}\n\n\t// MUL[] MUL\n\t// 0x63\n\tfunction MUL(state) {\n\t    var stack = state.stack;\n\t    var n2 = stack.pop();\n\t    var n1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }\n\n\t    stack.push(n1 * n2 / 64);\n\t}\n\n\t// ABS[] ABSolute value\n\t// 0x64\n\tfunction ABS(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }\n\n\t    stack.push(Math.abs(n));\n\t}\n\n\t// NEG[] NEGate\n\t// 0x65\n\tfunction NEG(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }\n\n\t    stack.push(-n);\n\t}\n\n\t// FLOOR[] FLOOR\n\t// 0x66\n\tfunction FLOOR(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }\n\n\t    stack.push(Math.floor(n / 0x40) * 0x40);\n\t}\n\n\t// CEILING[] CEILING\n\t// 0x67\n\tfunction CEILING(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }\n\n\t    stack.push(Math.ceil(n / 0x40) * 0x40);\n\t}\n\n\t// ROUND[ab] ROUND value\n\t// 0x68-0x6B\n\tfunction ROUND(dt, state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }\n\n\t    stack.push(state.round(n / 0x40) * 0x40);\n\t}\n\n\t// WCVTF[] Write Control Value Table in Funits\n\t// 0x70\n\tfunction WCVTF(state) {\n\t    var stack = state.stack;\n\t    var v = stack.pop();\n\t    var l = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }\n\n\t    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n\t}\n\n\t// DELTAC1[] DELTA exception C1\n\t// DELTAC2[] DELTA exception C2\n\t// DELTAC3[] DELTA exception C3\n\t// 0x73, 0x74, 0x75\n\tfunction DELTAC123(b, state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\t    var ppem = state.ppem;\n\t    var base = state.deltaBase + (b - 1) * 16;\n\t    var ds = state.deltaShift;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }\n\n\t    for (var i = 0; i < n; i++) {\n\t        var c = stack.pop();\n\t        var arg = stack.pop();\n\t        var appem = base + ((arg & 0xF0) >> 4);\n\t        if (appem !== ppem) { continue; }\n\n\t        var mag = (arg & 0x0F) - 8;\n\t        if (mag >= 0) { mag++; }\n\n\t        var delta = mag * ds;\n\n\t        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }\n\n\t        state.cvt[c] += delta;\n\t    }\n\t}\n\n\t// SROUND[] Super ROUND\n\t// 0x76\n\tfunction SROUND(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }\n\n\t    state.round = roundSuper;\n\n\t    var period;\n\n\t    switch (n & 0xC0) {\n\t        case 0x00:\n\t            period = 0.5;\n\t            break;\n\t        case 0x40:\n\t            period = 1;\n\t            break;\n\t        case 0x80:\n\t            period = 2;\n\t            break;\n\t        default:\n\t            throw new Error('invalid SROUND value');\n\t    }\n\n\t    state.srPeriod = period;\n\n\t    switch (n & 0x30) {\n\t        case 0x00:\n\t            state.srPhase = 0;\n\t            break;\n\t        case 0x10:\n\t            state.srPhase = 0.25 * period;\n\t            break;\n\t        case 0x20:\n\t            state.srPhase = 0.5  * period;\n\t            break;\n\t        case 0x30:\n\t            state.srPhase = 0.75 * period;\n\t            break;\n\t        default: throw new Error('invalid SROUND value');\n\t    }\n\n\t    n &= 0x0F;\n\n\t    if (n === 0) { state.srThreshold = 0; }\n\t    else { state.srThreshold = (n / 8 - 0.5) * period; }\n\t}\n\n\t// S45ROUND[] Super ROUND 45 degrees\n\t// 0x77\n\tfunction S45ROUND(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }\n\n\t    state.round = roundSuper;\n\n\t    var period;\n\n\t    switch (n & 0xC0) {\n\t        case 0x00:\n\t            period = Math.sqrt(2) / 2;\n\t            break;\n\t        case 0x40:\n\t            period = Math.sqrt(2);\n\t            break;\n\t        case 0x80:\n\t            period = 2 * Math.sqrt(2);\n\t            break;\n\t        default:\n\t            throw new Error('invalid S45ROUND value');\n\t    }\n\n\t    state.srPeriod = period;\n\n\t    switch (n & 0x30) {\n\t        case 0x00:\n\t            state.srPhase = 0;\n\t            break;\n\t        case 0x10:\n\t            state.srPhase = 0.25 * period;\n\t            break;\n\t        case 0x20:\n\t            state.srPhase = 0.5  * period;\n\t            break;\n\t        case 0x30:\n\t            state.srPhase = 0.75 * period;\n\t            break;\n\t        default:\n\t            throw new Error('invalid S45ROUND value');\n\t    }\n\n\t    n &= 0x0F;\n\n\t    if (n === 0) { state.srThreshold = 0; }\n\t    else { state.srThreshold = (n / 8 - 0.5) * period; }\n\t}\n\n\t// ROFF[] Round Off\n\t// 0x7A\n\tfunction ROFF(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }\n\n\t    state.round = roundOff;\n\t}\n\n\t// RUTG[] Round Up To Grid\n\t// 0x7C\n\tfunction RUTG(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }\n\n\t    state.round = roundUpToGrid;\n\t}\n\n\t// RDTG[] Round Down To Grid\n\t// 0x7D\n\tfunction RDTG(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }\n\n\t    state.round = roundDownToGrid;\n\t}\n\n\t// SCANCTRL[] SCAN conversion ConTRoL\n\t// 0x85\n\tfunction SCANCTRL(state) {\n\t    var n = state.stack.pop();\n\n\t    // ignored by opentype.js\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }\n\t}\n\n\t// SDPVTL[a] Set Dual Projection Vector To Line\n\t// 0x86-0x87\n\tfunction SDPVTL(a, state) {\n\t    var stack = state.stack;\n\t    var p2i = stack.pop();\n\t    var p1i = stack.pop();\n\t    var p2 = state.z2[p2i];\n\t    var p1 = state.z1[p1i];\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }\n\n\t    var dx;\n\t    var dy;\n\n\t    if (!a) {\n\t        dx = p1.x - p2.x;\n\t        dy = p1.y - p2.y;\n\t    } else {\n\t        dx = p2.y - p1.y;\n\t        dy = p1.x - p2.x;\n\t    }\n\n\t    state.dpv = getUnitVector(dx, dy);\n\t}\n\n\t// GETINFO[] GET INFOrmation\n\t// 0x88\n\tfunction GETINFO(state) {\n\t    var stack = state.stack;\n\t    var sel = stack.pop();\n\t    var r = 0;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }\n\n\t    // v35 as in no subpixel hinting\n\t    if (sel & 0x01) { r = 35; }\n\n\t    // TODO rotation and stretch currently not supported\n\t    // and thus those GETINFO are always 0.\n\n\t    // opentype.js is always gray scaling\n\t    if (sel & 0x20) { r |= 0x1000; }\n\n\t    stack.push(r);\n\t}\n\n\t// ROLL[] ROLL the top three stack elements\n\t// 0x8A\n\tfunction ROLL(state) {\n\t    var stack = state.stack;\n\t    var a = stack.pop();\n\t    var b = stack.pop();\n\t    var c = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }\n\n\t    stack.push(b);\n\t    stack.push(a);\n\t    stack.push(c);\n\t}\n\n\t// MAX[] MAXimum of top two stack elements\n\t// 0x8B\n\tfunction MAX(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }\n\n\t    stack.push(Math.max(e1, e2));\n\t}\n\n\t// MIN[] MINimum of top two stack elements\n\t// 0x8C\n\tfunction MIN(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }\n\n\t    stack.push(Math.min(e1, e2));\n\t}\n\n\t// SCANTYPE[] SCANTYPE\n\t// 0x8D\n\tfunction SCANTYPE(state) {\n\t    var n = state.stack.pop();\n\t    // ignored by opentype.js\n\t    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }\n\t}\n\n\t// INSTCTRL[] INSTCTRL\n\t// 0x8D\n\tfunction INSTCTRL(state) {\n\t    var s = state.stack.pop();\n\t    var v = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }\n\n\t    switch (s) {\n\t        case 1 : state.inhibitGridFit = !!v; return;\n\t        case 2 : state.ignoreCvt = !!v; return;\n\t        default: throw new Error('invalid INSTCTRL[] selector');\n\t    }\n\t}\n\n\t// PUSHB[abc] PUSH Bytes\n\t// 0xB0-0xB7\n\tfunction PUSHB(n, state) {\n\t    var stack = state.stack;\n\t    var prog = state.prog;\n\t    var ip = state.ip;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }\n\n\t    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n\t    state.ip = ip;\n\t}\n\n\t// PUSHW[abc] PUSH Words\n\t// 0xB8-0xBF\n\tfunction PUSHW(n, state) {\n\t    var ip = state.ip;\n\t    var prog = state.prog;\n\t    var stack = state.stack;\n\n\t    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }\n\n\t    for (var i = 0; i < n; i++) {\n\t        var w = (prog[++ip] << 8) | prog[++ip];\n\t        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n\t        stack.push(w);\n\t    }\n\n\t    state.ip = ip;\n\t}\n\n\t// MDRP[abcde] Move Direct Relative Point\n\t// 0xD0-0xEF\n\t// (if indirect is 0)\n\t//\n\t// and\n\t//\n\t// MIRP[abcde] Move Indirect Relative Point\n\t// 0xE0-0xFF\n\t// (if indirect is 1)\n\n\tfunction MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n\t    var stack = state.stack;\n\t    var cvte = indirect && stack.pop();\n\t    var pi = stack.pop();\n\t    var rp0i = state.rp0;\n\t    var rp = state.z0[rp0i];\n\t    var p = state.z1[pi];\n\n\t    var md = state.minDis;\n\t    var fv = state.fv;\n\t    var pv = state.dpv;\n\t    var od; // original distance\n\t    var d; // moving distance\n\t    var sign; // sign of distance\n\t    var cv;\n\n\t    d = od = pv.distance(p, rp, true, true);\n\t    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n\n\t    // TODO consider autoFlip\n\t    d = Math.abs(d);\n\n\t    if (indirect) {\n\t        cv = state.cvt[cvte];\n\n\t        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n\t    }\n\n\t    if (keepD && d < md) { d = md; }\n\n\t    if (ro) { d = state.round(d); }\n\n\t    fv.setRelative(p, rp, sign * d, pv);\n\t    fv.touch(p);\n\n\t    if (exports.DEBUG) {\n\t        console.log(\n\t            state.step,\n\t            (indirect ? 'MIRP[' : 'MDRP[') +\n\t            (setRp0 ? 'M' : 'm') +\n\t            (keepD ? '>' : '_') +\n\t            (ro ? 'R' : '_') +\n\t            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +\n\t            ']',\n\t            indirect ?\n\t                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :\n\t                '',\n\t            pi,\n\t            '(d =', od, '->', sign * d, ')'\n\t        );\n\t    }\n\n\t    state.rp1 = state.rp0;\n\t    state.rp2 = pi;\n\t    if (setRp0) { state.rp0 = pi; }\n\t}\n\n\t/*\n\t* The instruction table.\n\t*/\n\tinstructionTable = [\n\t    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),\n\t    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),\n\t    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),\n\t    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),\n\t    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),\n\t    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),\n\t    /* 0x06 */ SPVTL.bind(undefined, 0),\n\t    /* 0x07 */ SPVTL.bind(undefined, 1),\n\t    /* 0x08 */ SFVTL.bind(undefined, 0),\n\t    /* 0x09 */ SFVTL.bind(undefined, 1),\n\t    /* 0x0A */ SPVFS,\n\t    /* 0x0B */ SFVFS,\n\t    /* 0x0C */ GPV,\n\t    /* 0x0D */ GFV,\n\t    /* 0x0E */ SFVTPV,\n\t    /* 0x0F */ ISECT,\n\t    /* 0x10 */ SRP0,\n\t    /* 0x11 */ SRP1,\n\t    /* 0x12 */ SRP2,\n\t    /* 0x13 */ SZP0,\n\t    /* 0x14 */ SZP1,\n\t    /* 0x15 */ SZP2,\n\t    /* 0x16 */ SZPS,\n\t    /* 0x17 */ SLOOP,\n\t    /* 0x18 */ RTG,\n\t    /* 0x19 */ RTHG,\n\t    /* 0x1A */ SMD,\n\t    /* 0x1B */ ELSE,\n\t    /* 0x1C */ JMPR,\n\t    /* 0x1D */ SCVTCI,\n\t    /* 0x1E */ undefined,   // TODO SSWCI\n\t    /* 0x1F */ undefined,   // TODO SSW\n\t    /* 0x20 */ DUP,\n\t    /* 0x21 */ POP,\n\t    /* 0x22 */ CLEAR,\n\t    /* 0x23 */ SWAP,\n\t    /* 0x24 */ DEPTH,\n\t    /* 0x25 */ CINDEX,\n\t    /* 0x26 */ MINDEX,\n\t    /* 0x27 */ undefined,   // TODO ALIGNPTS\n\t    /* 0x28 */ undefined,\n\t    /* 0x29 */ undefined,   // TODO UTP\n\t    /* 0x2A */ LOOPCALL,\n\t    /* 0x2B */ CALL,\n\t    /* 0x2C */ FDEF,\n\t    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)\n\t    /* 0x2E */ MDAP.bind(undefined, 0),\n\t    /* 0x2F */ MDAP.bind(undefined, 1),\n\t    /* 0x30 */ IUP.bind(undefined, yUnitVector),\n\t    /* 0x31 */ IUP.bind(undefined, xUnitVector),\n\t    /* 0x32 */ SHP.bind(undefined, 0),\n\t    /* 0x33 */ SHP.bind(undefined, 1),\n\t    /* 0x34 */ SHC.bind(undefined, 0),\n\t    /* 0x35 */ SHC.bind(undefined, 1),\n\t    /* 0x36 */ SHZ.bind(undefined, 0),\n\t    /* 0x37 */ SHZ.bind(undefined, 1),\n\t    /* 0x38 */ SHPIX,\n\t    /* 0x39 */ IP,\n\t    /* 0x3A */ MSIRP.bind(undefined, 0),\n\t    /* 0x3B */ MSIRP.bind(undefined, 1),\n\t    /* 0x3C */ ALIGNRP,\n\t    /* 0x3D */ RTDG,\n\t    /* 0x3E */ MIAP.bind(undefined, 0),\n\t    /* 0x3F */ MIAP.bind(undefined, 1),\n\t    /* 0x40 */ NPUSHB,\n\t    /* 0x41 */ NPUSHW,\n\t    /* 0x42 */ WS,\n\t    /* 0x43 */ RS,\n\t    /* 0x44 */ WCVTP,\n\t    /* 0x45 */ RCVT,\n\t    /* 0x46 */ GC.bind(undefined, 0),\n\t    /* 0x47 */ GC.bind(undefined, 1),\n\t    /* 0x48 */ undefined,   // TODO SCFS\n\t    /* 0x49 */ MD.bind(undefined, 0),\n\t    /* 0x4A */ MD.bind(undefined, 1),\n\t    /* 0x4B */ MPPEM,\n\t    /* 0x4C */ undefined,   // TODO MPS\n\t    /* 0x4D */ FLIPON,\n\t    /* 0x4E */ undefined,   // TODO FLIPOFF\n\t    /* 0x4F */ undefined,   // TODO DEBUG\n\t    /* 0x50 */ LT,\n\t    /* 0x51 */ LTEQ,\n\t    /* 0x52 */ GT,\n\t    /* 0x53 */ GTEQ,\n\t    /* 0x54 */ EQ,\n\t    /* 0x55 */ NEQ,\n\t    /* 0x56 */ ODD,\n\t    /* 0x57 */ EVEN,\n\t    /* 0x58 */ IF,\n\t    /* 0x59 */ EIF,\n\t    /* 0x5A */ AND,\n\t    /* 0x5B */ OR,\n\t    /* 0x5C */ NOT,\n\t    /* 0x5D */ DELTAP123.bind(undefined, 1),\n\t    /* 0x5E */ SDB,\n\t    /* 0x5F */ SDS,\n\t    /* 0x60 */ ADD,\n\t    /* 0x61 */ SUB,\n\t    /* 0x62 */ DIV,\n\t    /* 0x63 */ MUL,\n\t    /* 0x64 */ ABS,\n\t    /* 0x65 */ NEG,\n\t    /* 0x66 */ FLOOR,\n\t    /* 0x67 */ CEILING,\n\t    /* 0x68 */ ROUND.bind(undefined, 0),\n\t    /* 0x69 */ ROUND.bind(undefined, 1),\n\t    /* 0x6A */ ROUND.bind(undefined, 2),\n\t    /* 0x6B */ ROUND.bind(undefined, 3),\n\t    /* 0x6C */ undefined,   // TODO NROUND[ab]\n\t    /* 0x6D */ undefined,   // TODO NROUND[ab]\n\t    /* 0x6E */ undefined,   // TODO NROUND[ab]\n\t    /* 0x6F */ undefined,   // TODO NROUND[ab]\n\t    /* 0x70 */ WCVTF,\n\t    /* 0x71 */ DELTAP123.bind(undefined, 2),\n\t    /* 0x72 */ DELTAP123.bind(undefined, 3),\n\t    /* 0x73 */ DELTAC123.bind(undefined, 1),\n\t    /* 0x74 */ DELTAC123.bind(undefined, 2),\n\t    /* 0x75 */ DELTAC123.bind(undefined, 3),\n\t    /* 0x76 */ SROUND,\n\t    /* 0x77 */ S45ROUND,\n\t    /* 0x78 */ undefined,   // TODO JROT[]\n\t    /* 0x79 */ undefined,   // TODO JROF[]\n\t    /* 0x7A */ ROFF,\n\t    /* 0x7B */ undefined,\n\t    /* 0x7C */ RUTG,\n\t    /* 0x7D */ RDTG,\n\t    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though\n\t    /* 0x7F */ POP, // actually AA, supposed to do only a pop though\n\t    /* 0x80 */ undefined,   // TODO FLIPPT\n\t    /* 0x81 */ undefined,   // TODO FLIPRGON\n\t    /* 0x82 */ undefined,   // TODO FLIPRGOFF\n\t    /* 0x83 */ undefined,\n\t    /* 0x84 */ undefined,\n\t    /* 0x85 */ SCANCTRL,\n\t    /* 0x86 */ SDPVTL.bind(undefined, 0),\n\t    /* 0x87 */ SDPVTL.bind(undefined, 1),\n\t    /* 0x88 */ GETINFO,\n\t    /* 0x89 */ undefined,   // TODO IDEF\n\t    /* 0x8A */ ROLL,\n\t    /* 0x8B */ MAX,\n\t    /* 0x8C */ MIN,\n\t    /* 0x8D */ SCANTYPE,\n\t    /* 0x8E */ INSTCTRL,\n\t    /* 0x8F */ undefined,\n\t    /* 0x90 */ undefined,\n\t    /* 0x91 */ undefined,\n\t    /* 0x92 */ undefined,\n\t    /* 0x93 */ undefined,\n\t    /* 0x94 */ undefined,\n\t    /* 0x95 */ undefined,\n\t    /* 0x96 */ undefined,\n\t    /* 0x97 */ undefined,\n\t    /* 0x98 */ undefined,\n\t    /* 0x99 */ undefined,\n\t    /* 0x9A */ undefined,\n\t    /* 0x9B */ undefined,\n\t    /* 0x9C */ undefined,\n\t    /* 0x9D */ undefined,\n\t    /* 0x9E */ undefined,\n\t    /* 0x9F */ undefined,\n\t    /* 0xA0 */ undefined,\n\t    /* 0xA1 */ undefined,\n\t    /* 0xA2 */ undefined,\n\t    /* 0xA3 */ undefined,\n\t    /* 0xA4 */ undefined,\n\t    /* 0xA5 */ undefined,\n\t    /* 0xA6 */ undefined,\n\t    /* 0xA7 */ undefined,\n\t    /* 0xA8 */ undefined,\n\t    /* 0xA9 */ undefined,\n\t    /* 0xAA */ undefined,\n\t    /* 0xAB */ undefined,\n\t    /* 0xAC */ undefined,\n\t    /* 0xAD */ undefined,\n\t    /* 0xAE */ undefined,\n\t    /* 0xAF */ undefined,\n\t    /* 0xB0 */ PUSHB.bind(undefined, 1),\n\t    /* 0xB1 */ PUSHB.bind(undefined, 2),\n\t    /* 0xB2 */ PUSHB.bind(undefined, 3),\n\t    /* 0xB3 */ PUSHB.bind(undefined, 4),\n\t    /* 0xB4 */ PUSHB.bind(undefined, 5),\n\t    /* 0xB5 */ PUSHB.bind(undefined, 6),\n\t    /* 0xB6 */ PUSHB.bind(undefined, 7),\n\t    /* 0xB7 */ PUSHB.bind(undefined, 8),\n\t    /* 0xB8 */ PUSHW.bind(undefined, 1),\n\t    /* 0xB9 */ PUSHW.bind(undefined, 2),\n\t    /* 0xBA */ PUSHW.bind(undefined, 3),\n\t    /* 0xBB */ PUSHW.bind(undefined, 4),\n\t    /* 0xBC */ PUSHW.bind(undefined, 5),\n\t    /* 0xBD */ PUSHW.bind(undefined, 6),\n\t    /* 0xBE */ PUSHW.bind(undefined, 7),\n\t    /* 0xBF */ PUSHW.bind(undefined, 8),\n\t    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n\t    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n\t    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n\t    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n\t    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n\t    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n\t    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n\t    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n\t    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n\t    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n\t    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n\t    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n\t    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n\t    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n\t    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n\t    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n\t    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n\t    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n\t    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n\t    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n\t    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n\t    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n\t    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n\t    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n\t    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n\t    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n\t    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n\t    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n\t    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n\t    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n\t    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n\t    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n\t    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n\t    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n\t    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n\t    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n\t    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n\t    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n\t    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n\t    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n\t    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n\t    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n\t    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n\t    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n\t    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n\t    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n\t    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n\t    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n\t    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n\t    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n\t    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n\t    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n\t    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n\t    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n\t    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n\t    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n\t    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n\t    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n\t    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n\t    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n\t    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n\t    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n\t    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n\t    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)\n\t];\n\n\t/*****************************\n\t  Mathematical Considerations\n\t******************************\n\n\tfv ... refers to freedom vector\n\tpv ... refers to projection vector\n\trp ... refers to reference point\n\tp  ... refers to to point being operated on\n\td  ... refers to distance\n\n\tSETRELATIVE:\n\t============\n\n\tcase freedom vector == x-axis:\n\t------------------------------\n\n\t                        (pv)\n\t                     .-'\n\t              rpd .-'\n\t               .-*\n\t          d .-'90°'\n\t         .-'       '\n\t      .-'           '\n\t   *-'               ' b\n\t  rp                  '\n\t                       '\n\t                        '\n\t            p *----------*-------------- (fv)\n\t                          pm\n\n\t  rpdx = rpx + d * pv.x\n\t  rpdy = rpy + d * pv.y\n\n\t  equation of line b\n\n\t   y - rpdy = pvns * (x- rpdx)\n\n\t   y = p.y\n\n\t   x = rpdx + ( p.y - rpdy ) / pvns\n\n\n\tcase freedom vector == y-axis:\n\t------------------------------\n\n\t    * pm\n\t    |\\\n\t    | \\\n\t    |  \\\n\t    |   \\\n\t    |    \\\n\t    |     \\\n\t    |      \\\n\t    |       \\\n\t    |        \\\n\t    |         \\ b\n\t    |          \\\n\t    |           \\\n\t    |            \\    .-' (pv)\n\t    |         90° \\.-'\n\t    |           .-'* rpd\n\t    |        .-'\n\t    *     *-'  d\n\t    p     rp\n\n\t  rpdx = rpx + d * pv.x\n\t  rpdy = rpy + d * pv.y\n\n\t  equation of line b:\n\t           pvns ... normal slope to pv\n\n\t   y - rpdy = pvns * (x - rpdx)\n\n\t   x = p.x\n\n\t   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\n\tgeneric case:\n\t-------------\n\n\n\t                              .'(fv)\n\t                            .'\n\t                          .* pm\n\t                        .' !\n\t                      .'    .\n\t                    .'      !\n\t                  .'         . b\n\t                .'           !\n\t               *              .\n\t              p               !\n\t                         90°   .    ... (pv)\n\t                           ...-*-'''\n\t                  ...---'''    rpd\n\t         ...---'''   d\n\t   *--'''\n\t  rp\n\n\t    rpdx = rpx + d * pv.x\n\t    rpdy = rpy + d * pv.y\n\n\t equation of line b:\n\t    pvns... normal slope to pv\n\n\t    y - rpdy = pvns * (x - rpdx)\n\n\t equation of freedom vector line:\n\t    fvs ... slope of freedom vector (=fy/fx)\n\n\t    y - py = fvs * (x - px)\n\n\n\t  on pm both equations are true for same x/y\n\n\t    y - rpdy = pvns * (x - rpdx)\n\n\t    y - py = fvs * (x - px)\n\n\t  form to y and set equal:\n\n\t    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n\t  expand:\n\n\t    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n\t  switch:\n\n\t    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n\t  solve for x:\n\n\t    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n\t          fvs * px - pvns * rpdx + rpdy - py\n\t    x =  -----------------------------------\n\t                 fvs - pvns\n\n\t  and:\n\n\t    y = fvs * (x - px) + py\n\n\n\n\tINTERPOLATE:\n\t============\n\n\tExamples of point interpolation.\n\n\tThe weight of the movement of the reference point gets bigger\n\tthe further the other reference point is away, thus the safest\n\toption (that is avoiding 0/0 divisions) is to weight the\n\toriginal distance of the other point by the sum of both distances.\n\n\tIf the sum of both distances is 0, then move the point by the\n\tarithmetic average of the movement of both reference points.\n\n\n\n\n\t           (+6)\n\t    rp1o *---->*rp1\n\t         .     .                          (+12)\n\t         .     .                  rp2o *---------->* rp2\n\t         .     .                       .           .\n\t         .     .                       .           .\n\t         .    10          20           .           .\n\t         |.........|...................|           .\n\t               .   .                               .\n\t               .   . (+8)                          .\n\t                po *------>*p                      .\n\t               .           .                       .\n\t               .    12     .          24           .\n\t               |...........|.......................|\n\t                                  36\n\n\n\t-------\n\n\n\n\t           (+10)\n\t    rp1o *-------->*rp1\n\t         .         .                      (-10)\n\t         .         .              rp2 *<---------* rpo2\n\t         .         .                   .         .\n\t         .         .                   .         .\n\t         .    10   .          30       .         .\n\t         |.........|.............................|\n\t                   .                   .\n\t                   . (+5)              .\n\t                po *--->* p            .\n\t                   .    .              .\n\t                   .    .   20         .\n\t                   |....|..............|\n\t                     5        15\n\n\n\t-------\n\n\n\t           (+10)\n\t    rp1o *-------->*rp1\n\t         .         .\n\t         .         .\n\t    rp2o *-------->*rp2\n\n\n\t                               (+10)\n\t                          po *-------->* p\n\n\t-------\n\n\n\t           (+10)\n\t    rp1o *-------->*rp1\n\t         .         .\n\t         .         .(+30)\n\t    rp2o *---------------------------->*rp2\n\n\n\t                                        (+25)\n\t                          po *----------------------->* p\n\n\n\n\tvim: set ts=4 sw=4 expandtab:\n\t*****/\n\n\t/**\n\t * Converts a string into a list of tokens.\n\t */\n\n\t/**\n\t * Create a new token\n\t * @param {string} char a single char\n\t */\n\tfunction Token(char) {\n\t    this.char = char;\n\t    this.state = {};\n\t    this.activeState = null;\n\t}\n\n\t/**\n\t * Create a new context range\n\t * @param {number} startIndex range start index\n\t * @param {number} endOffset range end index offset\n\t * @param {string} contextName owner context name\n\t */\n\tfunction ContextRange(startIndex, endOffset, contextName) {\n\t    this.contextName = contextName;\n\t    this.startIndex = startIndex;\n\t    this.endOffset = endOffset;\n\t}\n\n\t/**\n\t * Check context start and end\n\t * @param {string} contextName a unique context name\n\t * @param {function} checkStart a predicate function the indicates a context's start\n\t * @param {function} checkEnd a predicate function the indicates a context's end\n\t */\n\tfunction ContextChecker(contextName, checkStart, checkEnd) {\n\t    this.contextName = contextName;\n\t    this.openRange = null;\n\t    this.ranges = [];\n\t    this.checkStart = checkStart;\n\t    this.checkEnd = checkEnd;\n\t}\n\n\t/**\n\t * @typedef ContextParams\n\t * @type Object\n\t * @property {array} context context items\n\t * @property {number} currentIndex current item index\n\t */\n\n\t/**\n\t * Create a context params\n\t * @param {array} context a list of items\n\t * @param {number} currentIndex current item index\n\t */\n\tfunction ContextParams(context, currentIndex) {\n\t    this.context = context;\n\t    this.index = currentIndex;\n\t    this.length = context.length;\n\t    this.current = context[currentIndex];\n\t    this.backtrack = context.slice(0, currentIndex);\n\t    this.lookahead = context.slice(currentIndex + 1);\n\t}\n\n\t/**\n\t * Create an event instance\n\t * @param {string} eventId event unique id\n\t */\n\tfunction Event(eventId) {\n\t    this.eventId = eventId;\n\t    this.subscribers = [];\n\t}\n\n\t/**\n\t * Initialize a core events and auto subscribe required event handlers\n\t * @param {any} events an object that enlists core events handlers\n\t */\n\tfunction initializeCoreEvents(events) {\n\t    var this$1 = this;\n\n\t    var coreEvents = [\n\t        'start', 'end', 'next', 'newToken', 'contextStart',\n\t        'contextEnd', 'insertToken', 'removeToken', 'removeRange',\n\t        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'\n\t    ];\n\n\t    coreEvents.forEach(function (eventId) {\n\t        Object.defineProperty(this$1.events, eventId, {\n\t            value: new Event(eventId)\n\t        });\n\t    });\n\n\t    if (!!events) {\n\t        coreEvents.forEach(function (eventId) {\n\t            var event = events[eventId];\n\t            if (typeof event === 'function') {\n\t                this$1.events[eventId].subscribe(event);\n\t            }\n\t        });\n\t    }\n\t    var requiresContextUpdate = [\n\t        'insertToken', 'removeToken', 'removeRange',\n\t        'replaceToken', 'replaceRange', 'composeRUD'\n\t    ];\n\t    requiresContextUpdate.forEach(function (eventId) {\n\t        this$1.events[eventId].subscribe(\n\t            this$1.updateContextsRanges\n\t        );\n\t    });\n\t}\n\n\t/**\n\t * Converts a string into a list of tokens\n\t * @param {any} events tokenizer core events\n\t */\n\tfunction Tokenizer(events) {\n\t    this.tokens = [];\n\t    this.registeredContexts = {};\n\t    this.contextCheckers = [];\n\t    this.events = {};\n\t    this.registeredModifiers = [];\n\n\t    initializeCoreEvents.call(this, events);\n\t}\n\n\t/**\n\t * Sets the state of a token, usually called by a state modifier.\n\t * @param {string} key state item key\n\t * @param {any} value state item value\n\t */\n\tToken.prototype.setState = function(key, value) {\n\t    this.state[key] = value;\n\t    this.activeState = { key: key, value: this.state[key] };\n\t    return this.activeState;\n\t};\n\n\tToken.prototype.getState = function (stateId) {\n\t    return this.state[stateId] || null;\n\t};\n\n\t/**\n\t * Checks if an index exists in the tokens list.\n\t * @param {number} index token index\n\t */\n\tTokenizer.prototype.inboundIndex = function(index) {\n\t    return index >= 0 && index < this.tokens.length;\n\t};\n\n\t/**\n\t * Compose and apply a list of operations (replace, update, delete)\n\t * @param {array} RUDs replace, update and delete operations\n\t * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)\n\t */\n\tTokenizer.prototype.composeRUD = function (RUDs) {\n\t    var this$1 = this;\n\n\t    var silent = true;\n\t    var state = RUDs.map(function (RUD) { return (\n\t        this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))\n\t    ); });\n\t    var hasFAILObject = function (obj) { return (\n\t        typeof obj === 'object' &&\n\t        obj.hasOwnProperty('FAIL')\n\t    ); };\n\t    if (state.every(hasFAILObject)) {\n\t        return {\n\t            FAIL: \"composeRUD: one or more operations hasn't completed successfully\",\n\t            report: state.filter(hasFAILObject)\n\t        };\n\t    }\n\t    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);\n\t};\n\n\t/**\n\t * Replace a range of tokens with a list of tokens\n\t * @param {number} startIndex range start index\n\t * @param {number} offset range offset\n\t * @param {token} tokens a list of tokens to replace\n\t * @param {boolean} silent dispatch events and update context ranges\n\t */\n\tTokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {\n\t    offset = offset !== null ? offset : this.tokens.length;\n\t    var isTokenType = tokens.every(function (token) { return token instanceof Token; });\n\t    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {\n\t        var replaced = this.tokens.splice.apply(\n\t            this.tokens, [startIndex, offset].concat(tokens)\n\t        );\n\t        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }\n\t        return [replaced, tokens];\n\t    } else {\n\t        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };\n\t    }\n\t};\n\n\t/**\n\t * Replace a token with another token\n\t * @param {number} index token index\n\t * @param {token} token a token to replace\n\t * @param {boolean} silent dispatch events and update context ranges\n\t */\n\tTokenizer.prototype.replaceToken = function (index, token, silent) {\n\t    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {\n\t        var replaced = this.tokens.splice(index, 1, token);\n\t        if (!silent) { this.dispatch('replaceToken', [index, token]); }\n\t        return [replaced[0], token];\n\t    } else {\n\t        return { FAIL: 'replaceToken: invalid token or index.' };\n\t    }\n\t};\n\n\t/**\n\t * Removes a range of tokens\n\t * @param {number} startIndex range start index\n\t * @param {number} offset range offset\n\t * @param {boolean} silent dispatch events and update context ranges\n\t */\n\tTokenizer.prototype.removeRange = function(startIndex, offset, silent) {\n\t    offset = !isNaN(offset) ? offset : this.tokens.length;\n\t    var tokens = this.tokens.splice(startIndex, offset);\n\t    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }\n\t    return tokens;\n\t};\n\n\t/**\n\t * Remove a token at a certain index\n\t * @param {number} index token index\n\t * @param {boolean} silent dispatch events and update context ranges\n\t */\n\tTokenizer.prototype.removeToken = function(index, silent) {\n\t    if (!isNaN(index) && this.inboundIndex(index)) {\n\t        var token = this.tokens.splice(index, 1);\n\t        if (!silent) { this.dispatch('removeToken', [token, index]); }\n\t        return token;\n\t    } else {\n\t        return { FAIL: 'removeToken: invalid token index.' };\n\t    }\n\t};\n\n\t/**\n\t * Insert a list of tokens at a certain index\n\t * @param {array} tokens a list of tokens to insert\n\t * @param {number} index insert the list of tokens at index\n\t * @param {boolean} silent dispatch events and update context ranges\n\t */\n\tTokenizer.prototype.insertToken = function (tokens, index, silent) {\n\t    var tokenType = tokens.every(\n\t        function (token) { return token instanceof Token; }\n\t    );\n\t    if (tokenType) {\n\t        this.tokens.splice.apply(\n\t            this.tokens, [index, 0].concat(tokens)\n\t        );\n\t        if (!silent) { this.dispatch('insertToken', [tokens, index]); }\n\t        return tokens;\n\t    } else {\n\t        return { FAIL: 'insertToken: invalid token(s).' };\n\t    }\n\t};\n\n\t/**\n\t * A state modifier that is called on 'newToken' event\n\t * @param {string} modifierId state modifier id\n\t * @param {function} condition a predicate function that returns true or false\n\t * @param {function} modifier a function to update token state\n\t */\n\tTokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {\n\t    this.events.newToken.subscribe(function(token, contextParams) {\n\t        var conditionParams = [token, contextParams];\n\t        var canApplyModifier = (\n\t            condition === null ||\n\t            condition.apply(this, conditionParams) === true\n\t        );\n\t        var modifierParams = [token, contextParams];\n\t        if (canApplyModifier) {\n\t            var newStateValue = modifier.apply(this, modifierParams);\n\t            token.setState(modifierId, newStateValue);\n\t        }\n\t    });\n\t    this.registeredModifiers.push(modifierId);\n\t};\n\n\t/**\n\t * Subscribe a handler to an event\n\t * @param {function} eventHandler an event handler function\n\t */\n\tEvent.prototype.subscribe = function (eventHandler) {\n\t    if (typeof eventHandler === 'function') {\n\t        return ((this.subscribers.push(eventHandler)) - 1);\n\t    } else {\n\t        return { FAIL: (\"invalid '\" + (this.eventId) + \"' event handler\")};\n\t    }\n\t};\n\n\t/**\n\t * Unsubscribe an event handler\n\t * @param {string} subsId subscription id\n\t */\n\tEvent.prototype.unsubscribe = function (subsId) {\n\t    this.subscribers.splice(subsId, 1);\n\t};\n\n\t/**\n\t * Sets context params current value index\n\t * @param {number} index context params current value index\n\t */\n\tContextParams.prototype.setCurrentIndex = function(index) {\n\t    this.index = index;\n\t    this.current = this.context[index];\n\t    this.backtrack = this.context.slice(0, index);\n\t    this.lookahead = this.context.slice(index + 1);\n\t};\n\n\t/**\n\t * Get an item at an offset from the current value\n\t * example (current value is 3):\n\t *  1    2   [3]   4    5   |   items values\n\t * -2   -1    0    1    2   |   offset values\n\t * @param {number} offset an offset from current value index\n\t */\n\tContextParams.prototype.get = function (offset) {\n\t    switch (true) {\n\t        case (offset === 0):\n\t            return this.current;\n\t        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):\n\t            return this.backtrack.slice(offset)[0];\n\t        case (offset > 0 && offset <= this.lookahead.length):\n\t            return this.lookahead[offset - 1];\n\t        default:\n\t            return null;\n\t    }\n\t};\n\n\t/**\n\t * Converts a context range into a string value\n\t * @param {contextRange} range a context range\n\t */\n\tTokenizer.prototype.rangeToText = function (range) {\n\t    if (range instanceof ContextRange) {\n\t        return (\n\t            this.getRangeTokens(range)\n\t                .map(function (token) { return token.char; }).join('')\n\t        );\n\t    }\n\t};\n\n\t/**\n\t * Converts all tokens into a string\n\t */\n\tTokenizer.prototype.getText = function () {\n\t    return this.tokens.map(function (token) { return token.char; }).join('');\n\t};\n\n\t/**\n\t * Get a context by name\n\t * @param {string} contextName context name to get\n\t */\n\tTokenizer.prototype.getContext = function (contextName) {\n\t    var context = this.registeredContexts[contextName];\n\t    return !!context ? context : null;\n\t};\n\n\t/**\n\t * Subscribes a new event handler to an event\n\t * @param {string} eventName event name to subscribe to\n\t * @param {function} eventHandler a function to be invoked on event\n\t */\n\tTokenizer.prototype.on = function(eventName, eventHandler) {\n\t    var event = this.events[eventName];\n\t    if (!!event) {\n\t        return event.subscribe(eventHandler);\n\t    } else {\n\t        return null;\n\t    }\n\t};\n\n\t/**\n\t * Dispatches an event\n\t * @param {string} eventName event name\n\t * @param {any} args event handler arguments\n\t */\n\tTokenizer.prototype.dispatch = function(eventName, args) {\n\t    var this$1 = this;\n\n\t    var event = this.events[eventName];\n\t    if (event instanceof Event) {\n\t        event.subscribers.forEach(function (subscriber) {\n\t            subscriber.apply(this$1, args || []);\n\t        });\n\t    }\n\t};\n\n\t/**\n\t * Register a new context checker\n\t * @param {string} contextName a unique context name\n\t * @param {function} contextStartCheck a predicate function that returns true on context start\n\t * @param {function} contextEndCheck  a predicate function that returns true on context end\n\t * TODO: call tokenize on registration to update context ranges with the new context.\n\t */\n\tTokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {\n\t    if (!!this.getContext(contextName)) { return {\n\t        FAIL:\n\t        (\"context name '\" + contextName + \"' is already registered.\")\n\t    }; }\n\t    if (typeof contextStartCheck !== 'function') { return {\n\t        FAIL:\n\t        \"missing context start check.\"\n\t    }; }\n\t    if (typeof contextEndCheck !== 'function') { return {\n\t        FAIL:\n\t        \"missing context end check.\"\n\t    }; }\n\t    var contextCheckers = new ContextChecker(\n\t        contextName, contextStartCheck, contextEndCheck\n\t    );\n\t    this.registeredContexts[contextName] = contextCheckers;\n\t    this.contextCheckers.push(contextCheckers);\n\t    return contextCheckers;\n\t};\n\n\t/**\n\t * Gets a context range tokens\n\t * @param {contextRange} range a context range\n\t */\n\tTokenizer.prototype.getRangeTokens = function(range) {\n\t    var endIndex = range.startIndex + range.endOffset;\n\t    return [].concat(\n\t        this.tokens\n\t            .slice(range.startIndex, endIndex)\n\t    );\n\t};\n\n\t/**\n\t * Gets the ranges of a context\n\t * @param {string} contextName context name\n\t */\n\tTokenizer.prototype.getContextRanges = function(contextName) {\n\t    var context = this.getContext(contextName);\n\t    if (!!context) {\n\t        return context.ranges;\n\t    } else {\n\t        return { FAIL: (\"context checker '\" + contextName + \"' is not registered.\") };\n\t    }\n\t};\n\n\t/**\n\t * Resets context ranges to run context update\n\t */\n\tTokenizer.prototype.resetContextsRanges = function () {\n\t    var registeredContexts = this.registeredContexts;\n\t    for (var contextName in registeredContexts) {\n\t        if (registeredContexts.hasOwnProperty(contextName)) {\n\t            var context = registeredContexts[contextName];\n\t            context.ranges = [];\n\t        }\n\t    }\n\t};\n\n\t/**\n\t * Updates context ranges\n\t */\n\tTokenizer.prototype.updateContextsRanges = function () {\n\t    this.resetContextsRanges();\n\t    var chars = this.tokens.map(function (token) { return token.char; });\n\t    for (var i = 0; i < chars.length; i++) {\n\t        var contextParams = new ContextParams(chars, i);\n\t        this.runContextCheck(contextParams);\n\t    }\n\t    this.dispatch('updateContextsRanges', [this.registeredContexts]);\n\t};\n\n\t/**\n\t * Sets the end offset of an open range\n\t * @param {number} offset range end offset\n\t * @param {string} contextName context name\n\t */\n\tTokenizer.prototype.setEndOffset = function (offset, contextName) {\n\t    var startIndex = this.getContext(contextName).openRange.startIndex;\n\t    var range = new ContextRange(startIndex, offset, contextName);\n\t    var ranges = this.getContext(contextName).ranges;\n\t    range.rangeId = contextName + \".\" + (ranges.length);\n\t    ranges.push(range);\n\t    this.getContext(contextName).openRange = null;\n\t    return range;\n\t};\n\n\t/**\n\t * Runs a context check on the current context\n\t * @param {contextParams} contextParams current context params\n\t */\n\tTokenizer.prototype.runContextCheck = function(contextParams) {\n\t    var this$1 = this;\n\n\t    var index = contextParams.index;\n\t    this.contextCheckers.forEach(function (contextChecker) {\n\t        var contextName = contextChecker.contextName;\n\t        var openRange = this$1.getContext(contextName).openRange;\n\t        if (!openRange && contextChecker.checkStart(contextParams)) {\n\t            openRange = new ContextRange(index, null, contextName);\n\t            this$1.getContext(contextName).openRange = openRange;\n\t            this$1.dispatch('contextStart', [contextName, index]);\n\t        }\n\t        if (!!openRange && contextChecker.checkEnd(contextParams)) {\n\t            var offset = (index - openRange.startIndex) + 1;\n\t            var range = this$1.setEndOffset(offset, contextName);\n\t            this$1.dispatch('contextEnd', [contextName, range]);\n\t        }\n\t    });\n\t};\n\n\t/**\n\t * Converts a text into a list of tokens\n\t * @param {string} text a text to tokenize\n\t */\n\tTokenizer.prototype.tokenize = function (text) {\n\t    this.tokens = [];\n\t    this.resetContextsRanges();\n\t    var chars = Array.from(text);\n\t    this.dispatch('start');\n\t    for (var i = 0; i < chars.length; i++) {\n\t        var char = chars[i];\n\t        var contextParams = new ContextParams(chars, i);\n\t        this.dispatch('next', [contextParams]);\n\t        this.runContextCheck(contextParams);\n\t        var token = new Token(char);\n\t        this.tokens.push(token);\n\t        this.dispatch('newToken', [token, contextParams]);\n\t    }\n\t    this.dispatch('end', [this.tokens]);\n\t    return this.tokens;\n\t};\n\n\t// ╭─┄┄┄────────────────────────┄─────────────────────────────────────────────╮\n\t// ┊ Character Class Assertions ┊ Checks if a char belongs to a certain class ┊\n\t// ╰─╾──────────────────────────┄─────────────────────────────────────────────╯\n\t// jscs:disable maximumLineLength\n\t/**\n\t * Check if a char is Arabic\n\t * @param {string} c a single char\n\t */\n\tfunction isArabicChar(c) {\n\t    return /[\\u0600-\\u065F\\u066A-\\u06D2\\u06FA-\\u06FF]/.test(c);\n\t}\n\n\t/**\n\t * Check if a char is an isolated arabic char\n\t * @param {string} c a single char\n\t */\n\tfunction isIsolatedArabicChar(char) {\n\t    return /[\\u0630\\u0690\\u0621\\u0631\\u0661\\u0671\\u0622\\u0632\\u0672\\u0692\\u06C2\\u0623\\u0673\\u0693\\u06C3\\u0624\\u0694\\u06C4\\u0625\\u0675\\u0695\\u06C5\\u06E5\\u0676\\u0696\\u06C6\\u0627\\u0677\\u0697\\u06C7\\u0648\\u0688\\u0698\\u06C8\\u0689\\u0699\\u06C9\\u068A\\u06CA\\u066B\\u068B\\u06CB\\u068C\\u068D\\u06CD\\u06FD\\u068E\\u06EE\\u06FE\\u062F\\u068F\\u06CF\\u06EF]/.test(char);\n\t}\n\n\t/**\n\t * Check if a char is an Arabic Tashkeel char\n\t * @param {string} c a single char\n\t */\n\tfunction isTashkeelArabicChar(char) {\n\t    return /[\\u0600-\\u0605\\u060C-\\u060E\\u0610-\\u061B\\u061E\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED]/.test(char);\n\t}\n\n\t/**\n\t * Check if a char is Latin\n\t * @param {string} c a single char\n\t */\n\tfunction isLatinChar(c) {\n\t    return /[A-z]/.test(c);\n\t}\n\n\t/**\n\t * Check if a char is whitespace char\n\t * @param {string} c a single char\n\t */\n\tfunction isWhiteSpace(c) {\n\t    return /\\s/.test(c);\n\t}\n\n\t/**\n\t * Query a feature by some of it's properties to lookup a glyph substitution.\n\t */\n\n\t/**\n\t * Create feature query instance\n\t * @param {Font} font opentype font instance\n\t */\n\tfunction FeatureQuery(font) {\n\t    this.font = font;\n\t    this.features = {};\n\t}\n\n\t/**\n\t * @typedef SubstitutionAction\n\t * @type Object\n\t * @property {number} id substitution type\n\t * @property {string} tag feature tag\n\t * @property {any} substitution substitution value(s)\n\t */\n\n\t/**\n\t * Create a substitution action instance\n\t * @param {SubstitutionAction} action\n\t */\n\tfunction SubstitutionAction(action) {\n\t    this.id = action.id;\n\t    this.tag = action.tag;\n\t    this.substitution = action.substitution;\n\t}\n\n\t/**\n\t * Lookup a coverage table\n\t * @param {number} glyphIndex glyph index\n\t * @param {CoverageTable} coverage coverage table\n\t */\n\tfunction lookupCoverage(glyphIndex, coverage) {\n\t    if (!glyphIndex) { return -1; }\n\t    switch (coverage.format) {\n\t        case 1:\n\t            return coverage.glyphs.indexOf(glyphIndex);\n\n\t        case 2:\n\t            var ranges = coverage.ranges;\n\t            for (var i = 0; i < ranges.length; i++) {\n\t                var range = ranges[i];\n\t                if (glyphIndex >= range.start && glyphIndex <= range.end) {\n\t                    var offset = glyphIndex - range.start;\n\t                    return range.index + offset;\n\t                }\n\t            }\n\t            break;\n\t        default:\n\t            return -1; // not found\n\t    }\n\t    return -1;\n\t}\n\n\t/**\n\t * Handle a single substitution - format 1\n\t * @param {ContextParams} contextParams context params to lookup\n\t */\n\tfunction singleSubstitutionFormat1(glyphIndex, subtable) {\n\t    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n\t    if (substituteIndex === -1) { return null; }\n\t    return glyphIndex + subtable.deltaGlyphId;\n\t}\n\n\t/**\n\t * Handle a single substitution - format 2\n\t * @param {ContextParams} contextParams context params to lookup\n\t */\n\tfunction singleSubstitutionFormat2(glyphIndex, subtable) {\n\t    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n\t    if (substituteIndex === -1) { return null; }\n\t    return subtable.substitute[substituteIndex];\n\t}\n\n\t/**\n\t * Lookup a list of coverage tables\n\t * @param {any} coverageList a list of coverage tables\n\t * @param {ContextParams} contextParams context params to lookup\n\t */\n\tfunction lookupCoverageList(coverageList, contextParams) {\n\t    var lookupList = [];\n\t    for (var i = 0; i < coverageList.length; i++) {\n\t        var coverage = coverageList[i];\n\t        var glyphIndex = contextParams.current;\n\t        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;\n\t        var lookupIndex = lookupCoverage(glyphIndex, coverage);\n\t        if (lookupIndex !== -1) {\n\t            lookupList.push(lookupIndex);\n\t        }\n\t    }\n\t    if (lookupList.length !== coverageList.length) { return -1; }\n\t    return lookupList;\n\t}\n\n\t/**\n\t * Handle chaining context substitution - format 3\n\t * @param {ContextParams} contextParams context params to lookup\n\t */\n\tfunction chainingSubstitutionFormat3(contextParams, subtable) {\n\t    var lookupsCount = (\n\t        subtable.inputCoverage.length +\n\t        subtable.lookaheadCoverage.length +\n\t        subtable.backtrackCoverage.length\n\t    );\n\t    if (contextParams.context.length < lookupsCount) { return []; }\n\t    // INPUT LOOKUP //\n\t    var inputLookups = lookupCoverageList(\n\t        subtable.inputCoverage, contextParams\n\t    );\n\t    if (inputLookups === -1) { return []; }\n\t    // LOOKAHEAD LOOKUP //\n\t    var lookaheadOffset = subtable.inputCoverage.length - 1;\n\t    if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) { return []; }\n\t    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);\n\t    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {\n\t        lookaheadContext.shift();\n\t    }\n\t    var lookaheadParams = new ContextParams(lookaheadContext, 0);\n\t    var lookaheadLookups = lookupCoverageList(\n\t        subtable.lookaheadCoverage, lookaheadParams\n\t    );\n\t    // BACKTRACK LOOKUP //\n\t    var backtrackContext = [].concat(contextParams.backtrack);\n\t    backtrackContext.reverse();\n\t    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {\n\t        backtrackContext.shift();\n\t    }\n\t    if (backtrackContext.length < subtable.backtrackCoverage.length) { return []; }\n\t    var backtrackParams = new ContextParams(backtrackContext, 0);\n\t    var backtrackLookups = lookupCoverageList(\n\t        subtable.backtrackCoverage, backtrackParams\n\t    );\n\t    var contextRulesMatch = (\n\t        inputLookups.length === subtable.inputCoverage.length &&\n\t        lookaheadLookups.length === subtable.lookaheadCoverage.length &&\n\t        backtrackLookups.length === subtable.backtrackCoverage.length\n\t    );\n\t    var substitutions = [];\n\t    if (contextRulesMatch) {\n\t        for (var i = 0; i < subtable.lookupRecords.length; i++) {\n\t            var lookupRecord = subtable.lookupRecords[i];\n\t            var lookupListIndex = lookupRecord.lookupListIndex;\n\t            var lookupTable = this.getLookupByIndex(lookupListIndex);\n\t            for (var s = 0; s < lookupTable.subtables.length; s++) {\n\t                var subtable$1 = lookupTable.subtables[s];\n\t                var lookup = this.getLookupMethod(lookupTable, subtable$1);\n\t                var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);\n\t                if (substitutionType === '12') {\n\t                    for (var n = 0; n < inputLookups.length; n++) {\n\t                        var glyphIndex = contextParams.get(n);\n\t                        var substitution = lookup(glyphIndex);\n\t                        if (substitution) { substitutions.push(substitution); }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return substitutions;\n\t}\n\n\t/**\n\t * Handle ligature substitution - format 1\n\t * @param {ContextParams} contextParams context params to lookup\n\t */\n\tfunction ligatureSubstitutionFormat1(contextParams, subtable) {\n\t    // COVERAGE LOOKUP //\n\t    var glyphIndex = contextParams.current;\n\t    var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);\n\t    if (ligSetIndex === -1) { return null; }\n\t    // COMPONENTS LOOKUP\n\t    // (!) note, components are ordered in the written direction.\n\t    var ligature;\n\t    var ligatureSet = subtable.ligatureSets[ligSetIndex];\n\t    for (var s = 0; s < ligatureSet.length; s++) {\n\t        ligature = ligatureSet[s];\n\t        for (var l = 0; l < ligature.components.length; l++) {\n\t            var lookaheadItem = contextParams.lookahead[l];\n\t            var component = ligature.components[l];\n\t            if (lookaheadItem !== component) { break; }\n\t            if (l === ligature.components.length - 1) { return ligature; }\n\t        }\n\t    }\n\t    return null;\n\t}\n\n\t/**\n\t * Handle decomposition substitution - format 1\n\t * @param {number} glyphIndex glyph index\n\t * @param {any} subtable subtable\n\t */\n\tfunction decompositionSubstitutionFormat1(glyphIndex, subtable) {\n\t    var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);\n\t    if (substituteIndex === -1) { return null; }\n\t    return subtable.sequences[substituteIndex];\n\t}\n\n\t/**\n\t * Get default script features indexes\n\t */\n\tFeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {\n\t    var scripts = this.font.tables.gsub.scripts;\n\t    for (var s = 0; s < scripts.length; s++) {\n\t        var script = scripts[s];\n\t        if (script.tag === 'DFLT') { return (\n\t            script.script.defaultLangSys.featureIndexes\n\t        ); }\n\t    }\n\t    return [];\n\t};\n\n\t/**\n\t * Get feature indexes of a specific script\n\t * @param {string} scriptTag script tag\n\t */\n\tFeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {\n\t    var tables = this.font.tables;\n\t    if (!tables.gsub) { return []; }\n\t    if (!scriptTag) { return this.getDefaultScriptFeaturesIndexes(); }\n\t    var scripts = this.font.tables.gsub.scripts;\n\t    for (var i = 0; i < scripts.length; i++) {\n\t        var script = scripts[i];\n\t        if (script.tag === scriptTag && script.script.defaultLangSys) {\n\t            return script.script.defaultLangSys.featureIndexes;\n\t        } else {\n\t            var langSysRecords = script.langSysRecords;\n\t            if (!!langSysRecords) {\n\t                for (var j = 0; j < langSysRecords.length; j++) {\n\t                    var langSysRecord = langSysRecords[j];\n\t                    if (langSysRecord.tag === scriptTag) {\n\t                        var langSys = langSysRecord.langSys;\n\t                        return langSys.featureIndexes;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return this.getDefaultScriptFeaturesIndexes();\n\t};\n\n\t/**\n\t * Map a feature tag to a gsub feature\n\t * @param {any} features gsub features\n\t * @param {string} scriptTag script tag\n\t */\n\tFeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {\n\t    var tags = {};\n\t    for (var i = 0; i < features.length; i++) {\n\t        var tag = features[i].tag;\n\t        var feature = features[i].feature;\n\t        tags[tag] = feature;\n\t    }\n\t    this.features[scriptTag].tags = tags;\n\t};\n\n\t/**\n\t * Get features of a specific script\n\t * @param {string} scriptTag script tag\n\t */\n\tFeatureQuery.prototype.getScriptFeatures = function (scriptTag) {\n\t    var features = this.features[scriptTag];\n\t    if (this.features.hasOwnProperty(scriptTag)) { return features; }\n\t    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);\n\t    if (!featuresIndexes) { return null; }\n\t    var gsub = this.font.tables.gsub;\n\t    features = featuresIndexes.map(function (index) { return gsub.features[index]; });\n\t    this.features[scriptTag] = features;\n\t    this.mapTagsToFeatures(features, scriptTag);\n\t    return features;\n\t};\n\n\t/**\n\t * Get substitution type\n\t * @param {any} lookupTable lookup table\n\t * @param {any} subtable subtable\n\t */\n\tFeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {\n\t    var lookupType = lookupTable.lookupType.toString();\n\t    var substFormat = subtable.substFormat.toString();\n\t    return lookupType + substFormat;\n\t};\n\n\t/**\n\t * Get lookup method\n\t * @param {any} lookupTable lookup table\n\t * @param {any} subtable subtable\n\t */\n\tFeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {\n\t    var this$1 = this;\n\n\t    var substitutionType = this.getSubstitutionType(lookupTable, subtable);\n\t    switch (substitutionType) {\n\t        case '11':\n\t            return function (glyphIndex) { return singleSubstitutionFormat1.apply(\n\t                this$1, [glyphIndex, subtable]\n\t            ); };\n\t        case '12':\n\t            return function (glyphIndex) { return singleSubstitutionFormat2.apply(\n\t                this$1, [glyphIndex, subtable]\n\t            ); };\n\t        case '63':\n\t            return function (contextParams) { return chainingSubstitutionFormat3.apply(\n\t                this$1, [contextParams, subtable]\n\t            ); };\n\t        case '41':\n\t            return function (contextParams) { return ligatureSubstitutionFormat1.apply(\n\t                this$1, [contextParams, subtable]\n\t            ); };\n\t        case '21':\n\t            return function (glyphIndex) { return decompositionSubstitutionFormat1.apply(\n\t                this$1, [glyphIndex, subtable]\n\t            ); };\n\t        default:\n\t            throw new Error(\n\t                \"lookupType: \" + (lookupTable.lookupType) + \" - \" +\n\t                \"substFormat: \" + (subtable.substFormat) + \" \" +\n\t                \"is not yet supported\"\n\t            );\n\t    }\n\t};\n\n\t/**\n\t * [ LOOKUP TYPES ]\n\t * -------------------------------\n\t * Single                        1;\n\t * Multiple                      2;\n\t * Alternate                     3;\n\t * Ligature                      4;\n\t * Context                       5;\n\t * ChainingContext               6;\n\t * ExtensionSubstitution         7;\n\t * ReverseChainingContext        8;\n\t * -------------------------------\n\t *\n\t */\n\n\t/**\n\t * @typedef FQuery\n\t * @type Object\n\t * @param {string} tag feature tag\n\t * @param {string} script feature script\n\t * @param {ContextParams} contextParams context params\n\t */\n\n\t/**\n\t * Lookup a feature using a query parameters\n\t * @param {FQuery} query feature query\n\t */\n\tFeatureQuery.prototype.lookupFeature = function (query) {\n\t    var contextParams = query.contextParams;\n\t    var currentIndex = contextParams.index;\n\t    var feature = this.getFeature({\n\t        tag: query.tag, script: query.script\n\t    });\n\t    if (!feature) { return new Error(\n\t        \"font '\" + (this.font.names.fullName.en) + \"' \" +\n\t        \"doesn't support feature '\" + (query.tag) + \"' \" +\n\t        \"for script '\" + (query.script) + \"'.\"\n\t    ); }\n\t    var lookups = this.getFeatureLookups(feature);\n\t    var substitutions = [].concat(contextParams.context);\n\t    for (var l = 0; l < lookups.length; l++) {\n\t        var lookupTable = lookups[l];\n\t        var subtables = this.getLookupSubtables(lookupTable);\n\t        for (var s = 0; s < subtables.length; s++) {\n\t            var subtable = subtables[s];\n\t            var substType = this.getSubstitutionType(lookupTable, subtable);\n\t            var lookup = this.getLookupMethod(lookupTable, subtable);\n\t            var substitution = (void 0);\n\t            switch (substType) {\n\t                case '11':\n\t                    substitution = lookup(contextParams.current);\n\t                    if (substitution) {\n\t                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n\t                            id: 11, tag: query.tag, substitution: substitution\n\t                        }));\n\t                    }\n\t                    break;\n\t                case '12':\n\t                    substitution = lookup(contextParams.current);\n\t                    if (substitution) {\n\t                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n\t                            id: 12, tag: query.tag, substitution: substitution\n\t                        }));\n\t                    }\n\t                    break;\n\t                case '63':\n\t                    substitution = lookup(contextParams);\n\t                    if (Array.isArray(substitution) && substitution.length) {\n\t                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n\t                            id: 63, tag: query.tag, substitution: substitution\n\t                        }));\n\t                    }\n\t                    break;\n\t                case '41':\n\t                    substitution = lookup(contextParams);\n\t                    if (substitution) {\n\t                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n\t                            id: 41, tag: query.tag, substitution: substitution\n\t                        }));\n\t                    }\n\t                    break;\n\t                case '21':\n\t                    substitution = lookup(contextParams.current);\n\t                    if (substitution) {\n\t                        substitutions.splice(currentIndex, 1, new SubstitutionAction({\n\t                            id: 21, tag: query.tag, substitution: substitution\n\t                        }));\n\t                    }\n\t                    break;\n\t            }\n\t            contextParams = new ContextParams(substitutions, currentIndex);\n\t            if (Array.isArray(substitution) && !substitution.length) { continue; }\n\t            substitution = null;\n\t        }\n\t    }\n\t    return substitutions.length ? substitutions : null;\n\t};\n\n\t/**\n\t * Checks if a font supports a specific features\n\t * @param {FQuery} query feature query object\n\t */\n\tFeatureQuery.prototype.supports = function (query) {\n\t    if (!query.script) { return false; }\n\t    this.getScriptFeatures(query.script);\n\t    var supportedScript = this.features.hasOwnProperty(query.script);\n\t    if (!query.tag) { return supportedScript; }\n\t    var supportedFeature = (\n\t        this.features[query.script].some(function (feature) { return feature.tag === query.tag; })\n\t    );\n\t    return supportedScript && supportedFeature;\n\t};\n\n\t/**\n\t * Get lookup table subtables\n\t * @param {any} lookupTable lookup table\n\t */\n\tFeatureQuery.prototype.getLookupSubtables = function (lookupTable) {\n\t    return lookupTable.subtables || null;\n\t};\n\n\t/**\n\t * Get lookup table by index\n\t * @param {number} index lookup table index\n\t */\n\tFeatureQuery.prototype.getLookupByIndex = function (index) {\n\t    var lookups = this.font.tables.gsub.lookups;\n\t    return lookups[index] || null;\n\t};\n\n\t/**\n\t * Get lookup tables for a feature\n\t * @param {string} feature\n\t */\n\tFeatureQuery.prototype.getFeatureLookups = function (feature) {\n\t    // TODO: memoize\n\t    return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));\n\t};\n\n\t/**\n\t * Query a feature by it's properties\n\t * @param {any} query an object that describes the properties of a query\n\t */\n\tFeatureQuery.prototype.getFeature = function getFeature(query) {\n\t    if (!this.font) { return { FAIL: \"No font was found\"}; }\n\t    if (!this.features.hasOwnProperty(query.script)) {\n\t        this.getScriptFeatures(query.script);\n\t    }\n\t    var scriptFeatures = this.features[query.script];\n\t    if (!scriptFeatures) { return (\n\t        { FAIL: (\"No feature for script \" + (query.script))}\n\t    ); }\n\t    if (!scriptFeatures.tags[query.tag]) { return null; }\n\t    return this.features[query.script].tags[query.tag];\n\t};\n\n\t/**\n\t * Arabic word context checkers\n\t */\n\n\tfunction arabicWordStartCheck(contextParams) {\n\t    var char = contextParams.current;\n\t    var prevChar = contextParams.get(-1);\n\t    return (\n\t        // ? arabic first char\n\t        (prevChar === null && isArabicChar(char)) ||\n\t        // ? arabic char preceded with a non arabic char\n\t        (!isArabicChar(prevChar) && isArabicChar(char))\n\t    );\n\t}\n\n\tfunction arabicWordEndCheck(contextParams) {\n\t    var nextChar = contextParams.get(1);\n\t    return (\n\t        // ? last arabic char\n\t        (nextChar === null) ||\n\t        // ? next char is not arabic\n\t        (!isArabicChar(nextChar))\n\t    );\n\t}\n\n\tvar arabicWordCheck = {\n\t    startCheck: arabicWordStartCheck,\n\t    endCheck: arabicWordEndCheck\n\t};\n\n\t/**\n\t * Arabic sentence context checkers\n\t */\n\n\tfunction arabicSentenceStartCheck(contextParams) {\n\t    var char = contextParams.current;\n\t    var prevChar = contextParams.get(-1);\n\t    return (\n\t        // ? an arabic char preceded with a non arabic char\n\t        (isArabicChar(char) || isTashkeelArabicChar(char)) &&\n\t        !isArabicChar(prevChar)\n\t    );\n\t}\n\n\tfunction arabicSentenceEndCheck(contextParams) {\n\t    var nextChar = contextParams.get(1);\n\t    switch (true) {\n\t        case nextChar === null:\n\t            return true;\n\t        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):\n\t            var nextIsWhitespace = isWhiteSpace(nextChar);\n\t            if (!nextIsWhitespace) { return true; }\n\t            if (nextIsWhitespace) {\n\t                var arabicCharAhead = false;\n\t                arabicCharAhead = (\n\t                    contextParams.lookahead.some(\n\t                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }\n\t                    )\n\t                );\n\t                if (!arabicCharAhead) { return true; }\n\t            }\n\t            break;\n\t        default:\n\t            return false;\n\t    }\n\t}\n\n\tvar arabicSentenceCheck = {\n\t    startCheck: arabicSentenceStartCheck,\n\t    endCheck: arabicSentenceEndCheck\n\t};\n\n\t/**\n\t * Apply single substitution format 1\n\t * @param {Array} substitutions substitutions\n\t * @param {any} tokens a list of tokens\n\t * @param {number} index token index\n\t */\n\tfunction singleSubstitutionFormat1$1(action, tokens, index) {\n\t    tokens[index].setState(action.tag, action.substitution);\n\t}\n\n\t/**\n\t * Apply single substitution format 2\n\t * @param {Array} substitutions substitutions\n\t * @param {any} tokens a list of tokens\n\t * @param {number} index token index\n\t */\n\tfunction singleSubstitutionFormat2$1(action, tokens, index) {\n\t    tokens[index].setState(action.tag, action.substitution);\n\t}\n\n\t/**\n\t * Apply chaining context substitution format 3\n\t * @param {Array} substitutions substitutions\n\t * @param {any} tokens a list of tokens\n\t * @param {number} index token index\n\t */\n\tfunction chainingSubstitutionFormat3$1(action, tokens, index) {\n\t    action.substitution.forEach(function (subst, offset) {\n\t        var token = tokens[index + offset];\n\t        token.setState(action.tag, subst);\n\t    });\n\t}\n\n\t/**\n\t * Apply ligature substitution format 1\n\t * @param {Array} substitutions substitutions\n\t * @param {any} tokens a list of tokens\n\t * @param {number} index token index\n\t */\n\tfunction ligatureSubstitutionFormat1$1(action, tokens, index) {\n\t    var token = tokens[index];\n\t    token.setState(action.tag, action.substitution.ligGlyph);\n\t    var compsCount = action.substitution.components.length;\n\t    for (var i = 0; i < compsCount; i++) {\n\t        token = tokens[index + i + 1];\n\t        token.setState('deleted', true);\n\t    }\n\t}\n\n\t/**\n\t * Supported substitutions\n\t */\n\tvar SUBSTITUTIONS = {\n\t    11: singleSubstitutionFormat1$1,\n\t    12: singleSubstitutionFormat2$1,\n\t    63: chainingSubstitutionFormat3$1,\n\t    41: ligatureSubstitutionFormat1$1\n\t};\n\n\t/**\n\t * Apply substitutions to a list of tokens\n\t * @param {Array} substitutions substitutions\n\t * @param {any} tokens a list of tokens\n\t * @param {number} index token index\n\t */\n\tfunction applySubstitution(action, tokens, index) {\n\t    if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {\n\t        SUBSTITUTIONS[action.id](action, tokens, index);\n\t    }\n\t}\n\n\t/**\n\t * Apply Arabic presentation forms to a range of tokens\n\t */\n\n\t/**\n\t * Check if a char can be connected to it's preceding char\n\t * @param {ContextParams} charContextParams context params of a char\n\t */\n\tfunction willConnectPrev(charContextParams) {\n\t    var backtrack = [].concat(charContextParams.backtrack);\n\t    for (var i = backtrack.length - 1; i >= 0; i--) {\n\t        var prevChar = backtrack[i];\n\t        var isolated = isIsolatedArabicChar(prevChar);\n\t        var tashkeel = isTashkeelArabicChar(prevChar);\n\t        if (!isolated && !tashkeel) { return true; }\n\t        if (isolated) { return false; }\n\t    }\n\t    return false;\n\t}\n\n\t/**\n\t * Check if a char can be connected to it's proceeding char\n\t * @param {ContextParams} charContextParams context params of a char\n\t */\n\tfunction willConnectNext(charContextParams) {\n\t    if (isIsolatedArabicChar(charContextParams.current)) { return false; }\n\t    for (var i = 0; i < charContextParams.lookahead.length; i++) {\n\t        var nextChar = charContextParams.lookahead[i];\n\t        var tashkeel = isTashkeelArabicChar(nextChar);\n\t        if (!tashkeel) { return true; }\n\t    }\n\t    return false;\n\t}\n\n\t/**\n\t * Apply arabic presentation forms to a list of tokens\n\t * @param {ContextRange} range a range of tokens\n\t */\n\tfunction arabicPresentationForms(range) {\n\t    var this$1 = this;\n\n\t    var script = 'arab';\n\t    var tags = this.featuresTags[script];\n\t    var tokens = this.tokenizer.getRangeTokens(range);\n\t    if (tokens.length === 1) { return; }\n\t    var contextParams = new ContextParams(\n\t        tokens.map(function (token) { return token.getState('glyphIndex'); }\n\t    ), 0);\n\t    var charContextParams = new ContextParams(\n\t        tokens.map(function (token) { return token.char; }\n\t    ), 0);\n\t    tokens.forEach(function (token, index) {\n\t        if (isTashkeelArabicChar(token.char)) { return; }\n\t        contextParams.setCurrentIndex(index);\n\t        charContextParams.setCurrentIndex(index);\n\t        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)\n\t        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }\n\t        if (willConnectNext(charContextParams)) { CONNECT |= 2; }\n\t        var tag;\n\t        switch (CONNECT) {\n\t            case 1: (tag = 'fina'); break;\n\t            case 2: (tag = 'init'); break;\n\t            case 3: (tag = 'medi'); break;\n\t        }\n\t        if (tags.indexOf(tag) === -1) { return; }\n\t        var substitutions = this$1.query.lookupFeature({\n\t            tag: tag, script: script, contextParams: contextParams\n\t        });\n\t        if (substitutions instanceof Error) { return console.info(substitutions.message); }\n\t        substitutions.forEach(function (action, index) {\n\t            if (action instanceof SubstitutionAction) {\n\t                applySubstitution(action, tokens, index);\n\t                contextParams.context[index] = action.substitution;\n\t            }\n\t        });\n\t    });\n\t}\n\n\t/**\n\t * Apply Arabic required ligatures feature to a range of tokens\n\t */\n\n\t/**\n\t * Update context params\n\t * @param {any} tokens a list of tokens\n\t * @param {number} index current item index\n\t */\n\tfunction getContextParams(tokens, index) {\n\t    var context = tokens.map(function (token) { return token.activeState.value; });\n\t    return new ContextParams(context, index || 0);\n\t}\n\n\t/**\n\t * Apply Arabic required ligatures to a context range\n\t * @param {ContextRange} range a range of tokens\n\t */\n\tfunction arabicRequiredLigatures(range) {\n\t    var this$1 = this;\n\n\t    var script = 'arab';\n\t    var tokens = this.tokenizer.getRangeTokens(range);\n\t    var contextParams = getContextParams(tokens);\n\t    contextParams.context.forEach(function (glyphIndex, index) {\n\t        contextParams.setCurrentIndex(index);\n\t        var substitutions = this$1.query.lookupFeature({\n\t            tag: 'rlig', script: script, contextParams: contextParams\n\t        });\n\t        if (substitutions.length) {\n\t            substitutions.forEach(\n\t                function (action) { return applySubstitution(action, tokens, index); }\n\t            );\n\t            contextParams = getContextParams(tokens);\n\t        }\n\t    });\n\t}\n\n\t/**\n\t * Latin word context checkers\n\t */\n\n\tfunction latinWordStartCheck(contextParams) {\n\t    var char = contextParams.current;\n\t    var prevChar = contextParams.get(-1);\n\t    return (\n\t        // ? latin first char\n\t        (prevChar === null && isLatinChar(char)) ||\n\t        // ? latin char preceded with a non latin char\n\t        (!isLatinChar(prevChar) && isLatinChar(char))\n\t    );\n\t}\n\n\tfunction latinWordEndCheck(contextParams) {\n\t    var nextChar = contextParams.get(1);\n\t    return (\n\t        // ? last latin char\n\t        (nextChar === null) ||\n\t        // ? next char is not latin\n\t        (!isLatinChar(nextChar))\n\t    );\n\t}\n\n\tvar latinWordCheck = {\n\t    startCheck: latinWordStartCheck,\n\t    endCheck: latinWordEndCheck\n\t};\n\n\t/**\n\t * Apply Latin ligature feature to a range of tokens\n\t */\n\n\t/**\n\t * Update context params\n\t * @param {any} tokens a list of tokens\n\t * @param {number} index current item index\n\t */\n\tfunction getContextParams$1(tokens, index) {\n\t    var context = tokens.map(function (token) { return token.activeState.value; });\n\t    return new ContextParams(context, index || 0);\n\t}\n\n\t/**\n\t * Apply Arabic required ligatures to a context range\n\t * @param {ContextRange} range a range of tokens\n\t */\n\tfunction latinLigature(range) {\n\t    var this$1 = this;\n\n\t    var script = 'latn';\n\t    var tokens = this.tokenizer.getRangeTokens(range);\n\t    var contextParams = getContextParams$1(tokens);\n\t    contextParams.context.forEach(function (glyphIndex, index) {\n\t        contextParams.setCurrentIndex(index);\n\t        var substitutions = this$1.query.lookupFeature({\n\t            tag: 'liga', script: script, contextParams: contextParams\n\t        });\n\t        if (substitutions.length) {\n\t            substitutions.forEach(\n\t                function (action) { return applySubstitution(action, tokens, index); }\n\t            );\n\t            contextParams = getContextParams$1(tokens);\n\t        }\n\t    });\n\t}\n\n\t/**\n\t * Infer bidirectional properties for a given text and apply\n\t * the corresponding layout rules.\n\t */\n\n\t/**\n\t * Create Bidi. features\n\t * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'\n\t */\n\tfunction Bidi(baseDir) {\n\t    this.baseDir = baseDir || 'ltr';\n\t    this.tokenizer = new Tokenizer();\n\t    this.featuresTags = {};\n\t}\n\n\t/**\n\t * Sets Bidi text\n\t * @param {string} text a text input\n\t */\n\tBidi.prototype.setText = function (text) {\n\t    this.text = text;\n\t};\n\n\t/**\n\t * Store essential context checks:\n\t * arabic word check for applying gsub features\n\t * arabic sentence check for adjusting arabic layout\n\t */\n\tBidi.prototype.contextChecks = ({\n\t    latinWordCheck: latinWordCheck,\n\t    arabicWordCheck: arabicWordCheck,\n\t    arabicSentenceCheck: arabicSentenceCheck\n\t});\n\n\t/**\n\t * Register arabic word check\n\t */\n\tfunction registerContextChecker(checkId) {\n\t    var check = this.contextChecks[(checkId + \"Check\")];\n\t    return this.tokenizer.registerContextChecker(\n\t        checkId, check.startCheck, check.endCheck\n\t    );\n\t}\n\n\t/**\n\t * Perform pre tokenization procedure then\n\t * tokenize text input\n\t */\n\tfunction tokenizeText() {\n\t    registerContextChecker.call(this, 'latinWord');\n\t    registerContextChecker.call(this, 'arabicWord');\n\t    registerContextChecker.call(this, 'arabicSentence');\n\t    return this.tokenizer.tokenize(this.text);\n\t}\n\n\t/**\n\t * Reverse arabic sentence layout\n\t * TODO: check base dir before applying adjustments - priority low\n\t */\n\tfunction reverseArabicSentences() {\n\t    var this$1 = this;\n\n\t    var ranges = this.tokenizer.getContextRanges('arabicSentence');\n\t    ranges.forEach(function (range) {\n\t        var rangeTokens = this$1.tokenizer.getRangeTokens(range);\n\t        this$1.tokenizer.replaceRange(\n\t            range.startIndex,\n\t            range.endOffset,\n\t            rangeTokens.reverse()\n\t        );\n\t    });\n\t}\n\n\t/**\n\t * Register supported features tags\n\t * @param {script} script script tag\n\t * @param {Array} tags features tags list\n\t */\n\tBidi.prototype.registerFeatures = function (script, tags) {\n\t    var this$1 = this;\n\n\t    var supportedTags = tags.filter(\n\t        function (tag) { return this$1.query.supports({script: script, tag: tag}); }\n\t    );\n\t    if (!this.featuresTags.hasOwnProperty(script)) {\n\t        this.featuresTags[script] = supportedTags;\n\t    } else {\n\t        this.featuresTags[script] =\n\t        this.featuresTags[script].concat(supportedTags);\n\t    }\n\t};\n\n\t/**\n\t * Apply GSUB features\n\t * @param {Array} tagsList a list of features tags\n\t * @param {string} script a script tag\n\t * @param {Font} font opentype font instance\n\t */\n\tBidi.prototype.applyFeatures = function (font, features) {\n\t    if (!font) { throw new Error(\n\t        'No valid font was provided to apply features'\n\t    ); }\n\t    if (!this.query) { this.query = new FeatureQuery(font); }\n\t    for (var f = 0; f < features.length; f++) {\n\t        var feature = features[f];\n\t        if (!this.query.supports({script: feature.script})) { continue; }\n\t        this.registerFeatures(feature.script, feature.tags);\n\t    }\n\t};\n\n\t/**\n\t * Register a state modifier\n\t * @param {string} modifierId state modifier id\n\t * @param {function} condition a predicate function that returns true or false\n\t * @param {function} modifier a modifier function to set token state\n\t */\n\tBidi.prototype.registerModifier = function (modifierId, condition, modifier) {\n\t    this.tokenizer.registerModifier(modifierId, condition, modifier);\n\t};\n\n\t/**\n\t * Check if 'glyphIndex' is registered\n\t */\n\tfunction checkGlyphIndexStatus() {\n\t    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {\n\t        throw new Error(\n\t            'glyphIndex modifier is required to apply ' +\n\t            'arabic presentation features.'\n\t        );\n\t    }\n\t}\n\n\t/**\n\t * Apply arabic presentation forms features\n\t */\n\tfunction applyArabicPresentationForms() {\n\t    var this$1 = this;\n\n\t    var script = 'arab';\n\t    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n\t    checkGlyphIndexStatus.call(this);\n\t    var ranges = this.tokenizer.getContextRanges('arabicWord');\n\t    ranges.forEach(function (range) {\n\t        arabicPresentationForms.call(this$1, range);\n\t    });\n\t}\n\n\t/**\n\t * Apply required arabic ligatures\n\t */\n\tfunction applyArabicRequireLigatures() {\n\t    var this$1 = this;\n\n\t    var script = 'arab';\n\t    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n\t    var tags = this.featuresTags[script];\n\t    if (tags.indexOf('rlig') === -1) { return; }\n\t    checkGlyphIndexStatus.call(this);\n\t    var ranges = this.tokenizer.getContextRanges('arabicWord');\n\t    ranges.forEach(function (range) {\n\t        arabicRequiredLigatures.call(this$1, range);\n\t    });\n\t}\n\n\t/**\n\t * Apply required arabic ligatures\n\t */\n\tfunction applyLatinLigatures() {\n\t    var this$1 = this;\n\n\t    var script = 'latn';\n\t    if (!this.featuresTags.hasOwnProperty(script)) { return; }\n\t    var tags = this.featuresTags[script];\n\t    if (tags.indexOf('liga') === -1) { return; }\n\t    checkGlyphIndexStatus.call(this);\n\t    var ranges = this.tokenizer.getContextRanges('latinWord');\n\t    ranges.forEach(function (range) {\n\t        latinLigature.call(this$1, range);\n\t    });\n\t}\n\n\t/**\n\t * Check if a context is registered\n\t * @param {string} contextId context id\n\t */\n\tBidi.prototype.checkContextReady = function (contextId) {\n\t    return !!this.tokenizer.getContext(contextId);\n\t};\n\n\t/**\n\t * Apply features to registered contexts\n\t */\n\tBidi.prototype.applyFeaturesToContexts = function () {\n\t    if (this.checkContextReady('arabicWord')) {\n\t        applyArabicPresentationForms.call(this);\n\t        applyArabicRequireLigatures.call(this);\n\t    }\n\t    if (this.checkContextReady('latinWord')) {\n\t        applyLatinLigatures.call(this);\n\t    }\n\t    if (this.checkContextReady('arabicSentence')) {\n\t        reverseArabicSentences.call(this);\n\t    }\n\t};\n\n\t/**\n\t * process text input\n\t * @param {string} text an input text\n\t */\n\tBidi.prototype.processText = function(text) {\n\t    if (!this.text || this.text !== text) {\n\t        this.setText(text);\n\t        tokenizeText.call(this);\n\t        this.applyFeaturesToContexts();\n\t    }\n\t};\n\n\t/**\n\t * Process a string of text to identify and adjust\n\t * bidirectional text entities.\n\t * @param {string} text input text\n\t */\n\tBidi.prototype.getBidiText = function (text) {\n\t    this.processText(text);\n\t    return this.tokenizer.getText();\n\t};\n\n\t/**\n\t * Get the current state index of each token\n\t * @param {text} text an input text\n\t */\n\tBidi.prototype.getTextGlyphs = function (text) {\n\t    this.processText(text);\n\t    var indexes = [];\n\t    for (var i = 0; i < this.tokenizer.tokens.length; i++) {\n\t        var token = this.tokenizer.tokens[i];\n\t        if (token.state.deleted) { continue; }\n\t        var index = token.activeState.value;\n\t        indexes.push(Array.isArray(index) ? index[0] : index);\n\t    }\n\t    return indexes;\n\t};\n\n\t// The Font object\n\n\t/**\n\t * @typedef FontOptions\n\t * @type Object\n\t * @property {Boolean} empty - whether to create a new empty font\n\t * @property {string} familyName\n\t * @property {string} styleName\n\t * @property {string=} fullName\n\t * @property {string=} postScriptName\n\t * @property {string=} designer\n\t * @property {string=} designerURL\n\t * @property {string=} manufacturer\n\t * @property {string=} manufacturerURL\n\t * @property {string=} license\n\t * @property {string=} licenseURL\n\t * @property {string=} version\n\t * @property {string=} description\n\t * @property {string=} copyright\n\t * @property {string=} trademark\n\t * @property {Number} unitsPerEm\n\t * @property {Number} ascender\n\t * @property {Number} descender\n\t * @property {Number} createdTimestamp\n\t * @property {string=} weightClass\n\t * @property {string=} widthClass\n\t * @property {string=} fsSelection\n\t */\n\n\t/**\n\t * A Font represents a loaded OpenType font file.\n\t * It contains a set of glyphs and methods to draw text on a drawing context,\n\t * or to get a path representing the text.\n\t * @exports opentype.Font\n\t * @class\n\t * @param {FontOptions}\n\t * @constructor\n\t */\n\tfunction Font(options) {\n\t    options = options || {};\n\t    options.tables = options.tables || {};\n\n\t    if (!options.empty) {\n\t        // Check that we've provided the minimum set of names.\n\t        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');\n\t        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');\n\t        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');\n\t        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');\n\t        checkArgument(options.descender <= 0, 'When creating a new Font object, negative descender value is required.');\n\n\t        // OS X will complain if the names are empty, so we put a single space everywhere by default.\n\t        this.names = {\n\t            fontFamily: {en: options.familyName || ' '},\n\t            fontSubfamily: {en: options.styleName || ' '},\n\t            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},\n\t            // postScriptName may not contain any whitespace\n\t            postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\\s/g, '')},\n\t            designer: {en: options.designer || ' '},\n\t            designerURL: {en: options.designerURL || ' '},\n\t            manufacturer: {en: options.manufacturer || ' '},\n\t            manufacturerURL: {en: options.manufacturerURL || ' '},\n\t            license: {en: options.license || ' '},\n\t            licenseURL: {en: options.licenseURL || ' '},\n\t            version: {en: options.version || 'Version 0.1'},\n\t            description: {en: options.description || ' '},\n\t            copyright: {en: options.copyright || ' '},\n\t            trademark: {en: options.trademark || ' '}\n\t        };\n\t        this.unitsPerEm = options.unitsPerEm || 1000;\n\t        this.ascender = options.ascender;\n\t        this.descender = options.descender;\n\t        this.createdTimestamp = options.createdTimestamp;\n\t        this.tables = Object.assign(options.tables, {\n\t            os2: Object.assign({\n\t                usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,\n\t                usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,\n\t                fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR,\n\t            }, options.tables.os2)\n\t        });\n\t    }\n\n\t    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n\t    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n\t    this.encoding = new DefaultEncoding(this);\n\t    this.position = new Position(this);\n\t    this.substitution = new Substitution(this);\n\t    this.tables = this.tables || {};\n\n\t    // needed for low memory mode only.\n\t    this._push = null;\n\t    this._hmtxTableData = {};\n\n\t    Object.defineProperty(this, 'hinting', {\n\t        get: function() {\n\t            if (this._hinting) { return this._hinting; }\n\t            if (this.outlinesFormat === 'truetype') {\n\t                return (this._hinting = new Hinting(this));\n\t            }\n\t        }\n\t    });\n\t}\n\n\t/**\n\t * Check if the font has a glyph for the given character.\n\t * @param  {string}\n\t * @return {Boolean}\n\t */\n\tFont.prototype.hasChar = function(c) {\n\t    return this.encoding.charToGlyphIndex(c) !== null;\n\t};\n\n\t/**\n\t * Convert the given character to a single glyph index.\n\t * Note that this function assumes that there is a one-to-one mapping between\n\t * the given character and a glyph; for complex scripts this might not be the case.\n\t * @param  {string}\n\t * @return {Number}\n\t */\n\tFont.prototype.charToGlyphIndex = function(s) {\n\t    return this.encoding.charToGlyphIndex(s);\n\t};\n\n\t/**\n\t * Convert the given character to a single Glyph object.\n\t * Note that this function assumes that there is a one-to-one mapping between\n\t * the given character and a glyph; for complex scripts this might not be the case.\n\t * @param  {string}\n\t * @return {opentype.Glyph}\n\t */\n\tFont.prototype.charToGlyph = function(c) {\n\t    var glyphIndex = this.charToGlyphIndex(c);\n\t    var glyph = this.glyphs.get(glyphIndex);\n\t    if (!glyph) {\n\t        // .notdef\n\t        glyph = this.glyphs.get(0);\n\t    }\n\n\t    return glyph;\n\t};\n\n\t/**\n\t * Update features\n\t * @param {any} options features options\n\t */\n\tFont.prototype.updateFeatures = function (options) {\n\t    // TODO: update all features options not only 'latn'.\n\t    return this.defaultRenderOptions.features.map(function (feature) {\n\t        if (feature.script === 'latn') {\n\t            return {\n\t                script: 'latn',\n\t                tags: feature.tags.filter(function (tag) { return options[tag]; })\n\t            };\n\t        } else {\n\t            return feature;\n\t        }\n\t    });\n\t};\n\n\t/**\n\t * Convert the given text to a list of Glyph objects.\n\t * Note that there is no strict one-to-one mapping between characters and\n\t * glyphs, so the list of returned glyphs can be larger or smaller than the\n\t * length of the given string.\n\t * @param  {string}\n\t * @param  {GlyphRenderOptions} [options]\n\t * @return {opentype.Glyph[]}\n\t */\n\tFont.prototype.stringToGlyphs = function(s, options) {\n\t    var this$1 = this;\n\n\n\t    var bidi = new Bidi();\n\n\t    // Create and register 'glyphIndex' state modifier\n\t    var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };\n\t    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);\n\n\t    // roll-back to default features\n\t    var features = options ?\n\t    this.updateFeatures(options.features) :\n\t    this.defaultRenderOptions.features;\n\n\t    bidi.applyFeatures(this, features);\n\n\t    var indexes = bidi.getTextGlyphs(s);\n\n\t    var length = indexes.length;\n\n\t    // convert glyph indexes to glyph objects\n\t    var glyphs = new Array(length);\n\t    var notdef = this.glyphs.get(0);\n\t    for (var i = 0; i < length; i += 1) {\n\t        glyphs[i] = this.glyphs.get(indexes[i]) || notdef;\n\t    }\n\t    return glyphs;\n\t};\n\n\t/**\n\t * @param  {string}\n\t * @return {Number}\n\t */\n\tFont.prototype.nameToGlyphIndex = function(name) {\n\t    return this.glyphNames.nameToGlyphIndex(name);\n\t};\n\n\t/**\n\t * @param  {string}\n\t * @return {opentype.Glyph}\n\t */\n\tFont.prototype.nameToGlyph = function(name) {\n\t    var glyphIndex = this.nameToGlyphIndex(name);\n\t    var glyph = this.glyphs.get(glyphIndex);\n\t    if (!glyph) {\n\t        // .notdef\n\t        glyph = this.glyphs.get(0);\n\t    }\n\n\t    return glyph;\n\t};\n\n\t/**\n\t * @param  {Number}\n\t * @return {String}\n\t */\n\tFont.prototype.glyphIndexToName = function(gid) {\n\t    if (!this.glyphNames.glyphIndexToName) {\n\t        return '';\n\t    }\n\n\t    return this.glyphNames.glyphIndexToName(gid);\n\t};\n\n\t/**\n\t * Retrieve the value of the kerning pair between the left glyph (or its index)\n\t * and the right glyph (or its index). If no kerning pair is found, return 0.\n\t * The kerning value gets added to the advance width when calculating the spacing\n\t * between glyphs.\n\t * For GPOS kerning, this method uses the default script and language, which covers\n\t * most use cases. To have greater control, use font.position.getKerningValue .\n\t * @param  {opentype.Glyph} leftGlyph\n\t * @param  {opentype.Glyph} rightGlyph\n\t * @return {Number}\n\t */\n\tFont.prototype.getKerningValue = function(leftGlyph, rightGlyph) {\n\t    leftGlyph = leftGlyph.index || leftGlyph;\n\t    rightGlyph = rightGlyph.index || rightGlyph;\n\t    var gposKerning = this.position.defaultKerningTables;\n\t    if (gposKerning) {\n\t        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);\n\t    }\n\t    // \"kern\" table\n\t    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;\n\t};\n\n\t/**\n\t * @typedef GlyphRenderOptions\n\t * @type Object\n\t * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.\n\t *                               See https://www.microsoft.com/typography/otspec/scripttags.htm\n\t * @property {string} [language='dflt'] - language system used to determine which features to apply.\n\t *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx\n\t * @property {boolean} [kerning=true] - whether to include kerning values\n\t * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.\n\t *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm\n\t */\n\tFont.prototype.defaultRenderOptions = {\n\t    kerning: true,\n\t    features: [\n\t        /**\n\t         * these 4 features are required to render Arabic text properly\n\t         * and shouldn't be turned off when rendering arabic text.\n\t         */\n\t        { script: 'arab', tags: ['init', 'medi', 'fina', 'rlig'] },\n\t        { script: 'latn', tags: ['liga', 'rlig'] }\n\t    ]\n\t};\n\n\t/**\n\t * Helper function that invokes the given callback for each glyph in the given text.\n\t * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text\n\t * @param {string} text - The text to apply.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {GlyphRenderOptions=} options\n\t * @param  {Function} callback\n\t */\n\tFont.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {\n\t    x = x !== undefined ? x : 0;\n\t    y = y !== undefined ? y : 0;\n\t    fontSize = fontSize !== undefined ? fontSize : 72;\n\t    options = Object.assign({}, this.defaultRenderOptions, options);\n\t    var fontScale = 1 / this.unitsPerEm * fontSize;\n\t    var glyphs = this.stringToGlyphs(text, options);\n\t    var kerningLookups;\n\t    if (options.kerning) {\n\t        var script = options.script || this.position.getDefaultScriptName();\n\t        kerningLookups = this.position.getKerningTables(script, options.language);\n\t    }\n\t    for (var i = 0; i < glyphs.length; i += 1) {\n\t        var glyph = glyphs[i];\n\t        callback.call(this, glyph, x, y, fontSize, options);\n\t        if (glyph.advanceWidth) {\n\t            x += glyph.advanceWidth * fontScale;\n\t        }\n\n\t        if (options.kerning && i < glyphs.length - 1) {\n\t            // We should apply position adjustment lookups in a more generic way.\n\t            // Here we only use the xAdvance value.\n\t            var kerningValue = kerningLookups ?\n\t                  this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :\n\t                  this.getKerningValue(glyph, glyphs[i + 1]);\n\t            x += kerningValue * fontScale;\n\t        }\n\n\t        if (options.letterSpacing) {\n\t            x += options.letterSpacing * fontSize;\n\t        } else if (options.tracking) {\n\t            x += (options.tracking / 1000) * fontSize;\n\t        }\n\t    }\n\t    return x;\n\t};\n\n\t/**\n\t * Create a Path object that represents the given text.\n\t * @param  {string} text - The text to create.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {GlyphRenderOptions=} options\n\t * @return {opentype.Path}\n\t */\n\tFont.prototype.getPath = function(text, x, y, fontSize, options) {\n\t    var fullPath = new Path();\n\t    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n\t        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n\t        fullPath.extend(glyphPath);\n\t    });\n\t    return fullPath;\n\t};\n\n\t/**\n\t * Create an array of Path objects that represent the glyphs of a given text.\n\t * @param  {string} text - The text to create.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {GlyphRenderOptions=} options\n\t * @return {opentype.Path[]}\n\t */\n\tFont.prototype.getPaths = function(text, x, y, fontSize, options) {\n\t    var glyphPaths = [];\n\t    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n\t        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n\t        glyphPaths.push(glyphPath);\n\t    });\n\n\t    return glyphPaths;\n\t};\n\n\t/**\n\t * Returns the advance width of a text.\n\t *\n\t * This is something different than Path.getBoundingBox() as for example a\n\t * suffixed whitespace increases the advanceWidth but not the bounding box\n\t * or an overhanging letter like a calligraphic 'f' might have a quite larger\n\t * bounding box than its advance width.\n\t *\n\t * This corresponds to canvas2dContext.measureText(text).width\n\t *\n\t * @param  {string} text - The text to create.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {GlyphRenderOptions=} options\n\t * @return advance width\n\t */\n\tFont.prototype.getAdvanceWidth = function(text, fontSize, options) {\n\t    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});\n\t};\n\n\t/**\n\t * Draw the text on the given drawing context.\n\t * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n\t * @param  {string} text - The text to create.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {GlyphRenderOptions=} options\n\t */\n\tFont.prototype.draw = function(ctx, text, x, y, fontSize, options) {\n\t    this.getPath(text, x, y, fontSize, options).draw(ctx);\n\t};\n\n\t/**\n\t * Draw the points of all glyphs in the text.\n\t * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n\t * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n\t * @param {string} text - The text to create.\n\t * @param {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param {GlyphRenderOptions=} options\n\t */\n\tFont.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {\n\t    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n\t        glyph.drawPoints(ctx, gX, gY, gFontSize);\n\t    });\n\t};\n\n\t/**\n\t * Draw lines indicating important font measurements for all glyphs in the text.\n\t * Black lines indicate the origin of the coordinate system (point 0,0).\n\t * Blue lines indicate the glyph bounding box.\n\t * Green line indicates the advance width of the glyph.\n\t * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n\t * @param {string} text - The text to create.\n\t * @param {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param {GlyphRenderOptions=} options\n\t */\n\tFont.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {\n\t    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n\t        glyph.drawMetrics(ctx, gX, gY, gFontSize);\n\t    });\n\t};\n\n\t/**\n\t * @param  {string}\n\t * @return {string}\n\t */\n\tFont.prototype.getEnglishName = function(name) {\n\t    var translations = this.names[name];\n\t    if (translations) {\n\t        return translations.en;\n\t    }\n\t};\n\n\t/**\n\t * Validate\n\t */\n\tFont.prototype.validate = function() {\n\t    var _this = this;\n\n\t    function assert(predicate, message) {\n\t    }\n\n\t    function assertNamePresent(name) {\n\t        var englishName = _this.getEnglishName(name);\n\t        assert(englishName && englishName.trim().length > 0);\n\t    }\n\n\t    // Identification information\n\t    assertNamePresent('fontFamily');\n\t    assertNamePresent('weightName');\n\t    assertNamePresent('manufacturer');\n\t    assertNamePresent('copyright');\n\t    assertNamePresent('version');\n\n\t    // Dimension information\n\t    assert(this.unitsPerEm > 0);\n\t};\n\n\t/**\n\t * Convert the font object to a SFNT data structure.\n\t * This structure contains all the necessary tables and metadata to create a binary OTF file.\n\t * @return {opentype.Table}\n\t */\n\tFont.prototype.toTables = function() {\n\t    return sfnt.fontToTable(this);\n\t};\n\t/**\n\t * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.\n\t */\n\tFont.prototype.toBuffer = function() {\n\t    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');\n\t    return this.toArrayBuffer();\n\t};\n\t/**\n\t * Converts a `opentype.Font` into an `ArrayBuffer`\n\t * @return {ArrayBuffer}\n\t */\n\tFont.prototype.toArrayBuffer = function() {\n\t    var sfntTable = this.toTables();\n\t    var bytes = sfntTable.encode();\n\t    var buffer = new ArrayBuffer(bytes.length);\n\t    var intArray = new Uint8Array(buffer);\n\t    for (var i = 0; i < bytes.length; i++) {\n\t        intArray[i] = bytes[i];\n\t    }\n\n\t    return buffer;\n\t};\n\n\t/**\n\t * Initiate a download of the OpenType font.\n\t */\n\tFont.prototype.download = function(fileName) {\n\t    var familyName = this.getEnglishName('fontFamily');\n\t    var styleName = this.getEnglishName('fontSubfamily');\n\t    fileName = fileName || familyName.replace(/\\s/g, '') + '-' + styleName + '.otf';\n\t    var arrayBuffer = this.toArrayBuffer();\n\n\t    if (isBrowser()) {\n\t        window.URL = window.URL || window.webkitURL;\n\n\t        if (window.URL) {\n\t            var dataView = new DataView(arrayBuffer);\n\t            var blob = new Blob([dataView], {type: 'font/opentype'});\n\n\t            var link = document.createElement('a');\n\t            link.href = window.URL.createObjectURL(blob);\n\t            link.download = fileName;\n\n\t            var event = document.createEvent('MouseEvents');\n\t            event.initEvent('click', true, false);\n\t            link.dispatchEvent(event);\n\t        } else {\n\t            console.warn('Font file could not be downloaded. Try using a different browser.');\n\t        }\n\t    } else {\n\t        var fs = __webpack_require__(/*! fs */ \"fs\");\n\t        var buffer = arrayBufferToNodeBuffer(arrayBuffer);\n\t        fs.writeFileSync(fileName, buffer);\n\t    }\n\t};\n\t/**\n\t * @private\n\t */\n\tFont.prototype.fsSelectionValues = {\n\t    ITALIC:              0x001, //1\n\t    UNDERSCORE:          0x002, //2\n\t    NEGATIVE:            0x004, //4\n\t    OUTLINED:            0x008, //8\n\t    STRIKEOUT:           0x010, //16\n\t    BOLD:                0x020, //32\n\t    REGULAR:             0x040, //64\n\t    USER_TYPO_METRICS:   0x080, //128\n\t    WWS:                 0x100, //256\n\t    OBLIQUE:             0x200  //512\n\t};\n\n\t/**\n\t * @private\n\t */\n\tFont.prototype.usWidthClasses = {\n\t    ULTRA_CONDENSED: 1,\n\t    EXTRA_CONDENSED: 2,\n\t    CONDENSED: 3,\n\t    SEMI_CONDENSED: 4,\n\t    MEDIUM: 5,\n\t    SEMI_EXPANDED: 6,\n\t    EXPANDED: 7,\n\t    EXTRA_EXPANDED: 8,\n\t    ULTRA_EXPANDED: 9\n\t};\n\n\t/**\n\t * @private\n\t */\n\tFont.prototype.usWeightClasses = {\n\t    THIN: 100,\n\t    EXTRA_LIGHT: 200,\n\t    LIGHT: 300,\n\t    NORMAL: 400,\n\t    MEDIUM: 500,\n\t    SEMI_BOLD: 600,\n\t    BOLD: 700,\n\t    EXTRA_BOLD: 800,\n\t    BLACK:    900\n\t};\n\n\t// The `fvar` table stores font variation axes and instances.\n\n\tfunction addName(name, names) {\n\t    var nameString = JSON.stringify(name);\n\t    var nameID = 256;\n\t    for (var nameKey in names) {\n\t        var n = parseInt(nameKey);\n\t        if (!n || n < 256) {\n\t            continue;\n\t        }\n\n\t        if (JSON.stringify(names[nameKey]) === nameString) {\n\t            return n;\n\t        }\n\n\t        if (nameID <= n) {\n\t            nameID = n + 1;\n\t        }\n\t    }\n\n\t    names[nameID] = name;\n\t    return nameID;\n\t}\n\n\tfunction makeFvarAxis(n, axis, names) {\n\t    var nameID = addName(axis.name, names);\n\t    return [\n\t        {name: 'tag_' + n, type: 'TAG', value: axis.tag},\n\t        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},\n\t        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},\n\t        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},\n\t        {name: 'flags_' + n, type: 'USHORT', value: 0},\n\t        {name: 'nameID_' + n, type: 'USHORT', value: nameID}\n\t    ];\n\t}\n\n\tfunction parseFvarAxis(data, start, names) {\n\t    var axis = {};\n\t    var p = new parse.Parser(data, start);\n\t    axis.tag = p.parseTag();\n\t    axis.minValue = p.parseFixed();\n\t    axis.defaultValue = p.parseFixed();\n\t    axis.maxValue = p.parseFixed();\n\t    p.skip('uShort', 1);  // reserved for flags; no values defined\n\t    axis.name = names[p.parseUShort()] || {};\n\t    return axis;\n\t}\n\n\tfunction makeFvarInstance(n, inst, axes, names) {\n\t    var nameID = addName(inst.name, names);\n\t    var fields = [\n\t        {name: 'nameID_' + n, type: 'USHORT', value: nameID},\n\t        {name: 'flags_' + n, type: 'USHORT', value: 0}\n\t    ];\n\n\t    for (var i = 0; i < axes.length; ++i) {\n\t        var axisTag = axes[i].tag;\n\t        fields.push({\n\t            name: 'axis_' + n + ' ' + axisTag,\n\t            type: 'FIXED',\n\t            value: inst.coordinates[axisTag] << 16\n\t        });\n\t    }\n\n\t    return fields;\n\t}\n\n\tfunction parseFvarInstance(data, start, axes, names) {\n\t    var inst = {};\n\t    var p = new parse.Parser(data, start);\n\t    inst.name = names[p.parseUShort()] || {};\n\t    p.skip('uShort', 1);  // reserved for flags; no values defined\n\n\t    inst.coordinates = {};\n\t    for (var i = 0; i < axes.length; ++i) {\n\t        inst.coordinates[axes[i].tag] = p.parseFixed();\n\t    }\n\n\t    return inst;\n\t}\n\n\tfunction makeFvarTable(fvar, names) {\n\t    var result = new table.Table('fvar', [\n\t        {name: 'version', type: 'ULONG', value: 0x10000},\n\t        {name: 'offsetToData', type: 'USHORT', value: 0},\n\t        {name: 'countSizePairs', type: 'USHORT', value: 2},\n\t        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},\n\t        {name: 'axisSize', type: 'USHORT', value: 20},\n\t        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},\n\t        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}\n\t    ]);\n\t    result.offsetToData = result.sizeOf();\n\n\t    for (var i = 0; i < fvar.axes.length; i++) {\n\t        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));\n\t    }\n\n\t    for (var j = 0; j < fvar.instances.length; j++) {\n\t        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));\n\t    }\n\n\t    return result;\n\t}\n\n\tfunction parseFvarTable(data, start, names) {\n\t    var p = new parse.Parser(data, start);\n\t    var tableVersion = p.parseULong();\n\t    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');\n\t    var offsetToData = p.parseOffset16();\n\t    // Skip countSizePairs.\n\t    p.skip('uShort', 1);\n\t    var axisCount = p.parseUShort();\n\t    var axisSize = p.parseUShort();\n\t    var instanceCount = p.parseUShort();\n\t    var instanceSize = p.parseUShort();\n\n\t    var axes = [];\n\t    for (var i = 0; i < axisCount; i++) {\n\t        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));\n\t    }\n\n\t    var instances = [];\n\t    var instanceStart = start + offsetToData + axisCount * axisSize;\n\t    for (var j = 0; j < instanceCount; j++) {\n\t        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));\n\t    }\n\n\t    return {axes: axes, instances: instances};\n\t}\n\n\tvar fvar = { make: makeFvarTable, parse: parseFvarTable };\n\n\t// The `GDEF` table contains various glyph properties\n\n\tvar attachList = function() {\n\t    return {\n\t        coverage: this.parsePointer(Parser.coverage),\n\t        attachPoints: this.parseList(Parser.pointer(Parser.uShortList))\n\t    };\n\t};\n\n\tvar caretValue = function() {\n\t    var format = this.parseUShort();\n\t    check.argument(format === 1 || format === 2 || format === 3,\n\t        'Unsupported CaretValue table version.');\n\t    if (format === 1) {\n\t        return { coordinate: this.parseShort() };\n\t    } else if (format === 2) {\n\t        return { pointindex: this.parseShort() };\n\t    } else if (format === 3) {\n\t        // Device / Variation Index tables unsupported\n\t        return { coordinate: this.parseShort() };\n\t    }\n\t};\n\n\tvar ligGlyph = function() {\n\t    return this.parseList(Parser.pointer(caretValue));\n\t};\n\n\tvar ligCaretList = function() {\n\t    return {\n\t        coverage: this.parsePointer(Parser.coverage),\n\t        ligGlyphs: this.parseList(Parser.pointer(ligGlyph))\n\t    };\n\t};\n\n\tvar markGlyphSets = function() {\n\t    this.parseUShort(); // Version\n\t    return this.parseList(Parser.pointer(Parser.coverage));\n\t};\n\n\tfunction parseGDEFTable(data, start) {\n\t    start = start || 0;\n\t    var p = new Parser(data, start);\n\t    var tableVersion = p.parseVersion(1);\n\t    check.argument(tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,\n\t        'Unsupported GDEF table version.');\n\t    var gdef = {\n\t        version: tableVersion,\n\t        classDef: p.parsePointer(Parser.classDef),\n\t        attachList: p.parsePointer(attachList),\n\t        ligCaretList: p.parsePointer(ligCaretList),\n\t        markAttachClassDef: p.parsePointer(Parser.classDef)\n\t    };\n\t    if (tableVersion >= 1.2) {\n\t        gdef.markGlyphSets = p.parsePointer(markGlyphSets);\n\t    }\n\t    return gdef;\n\t}\n\tvar gdef = { parse: parseGDEFTable };\n\n\t// The `GPOS` table contains kerning pairs, among other things.\n\n\tvar subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused\n\n\t// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable\n\t// this = Parser instance\n\tsubtableParsers$1[1] = function parseLookup1() {\n\t    var start = this.offset + this.relativeOffset;\n\t    var posformat = this.parseUShort();\n\t    if (posformat === 1) {\n\t        return {\n\t            posFormat: 1,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            value: this.parseValueRecord()\n\t        };\n\t    } else if (posformat === 2) {\n\t        return {\n\t            posFormat: 2,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            values: this.parseValueRecordList()\n\t        };\n\t    }\n\t    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');\n\t};\n\n\t// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable\n\tsubtableParsers$1[2] = function parseLookup2() {\n\t    var start = this.offset + this.relativeOffset;\n\t    var posFormat = this.parseUShort();\n\t    check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');\n\t    var coverage = this.parsePointer(Parser.coverage);\n\t    var valueFormat1 = this.parseUShort();\n\t    var valueFormat2 = this.parseUShort();\n\t    if (posFormat === 1) {\n\t        // Adjustments for Glyph Pairs\n\t        return {\n\t            posFormat: posFormat,\n\t            coverage: coverage,\n\t            valueFormat1: valueFormat1,\n\t            valueFormat2: valueFormat2,\n\t            pairSets: this.parseList(Parser.pointer(Parser.list(function() {\n\t                return {        // pairValueRecord\n\t                    secondGlyph: this.parseUShort(),\n\t                    value1: this.parseValueRecord(valueFormat1),\n\t                    value2: this.parseValueRecord(valueFormat2)\n\t                };\n\t            })))\n\t        };\n\t    } else if (posFormat === 2) {\n\t        var classDef1 = this.parsePointer(Parser.classDef);\n\t        var classDef2 = this.parsePointer(Parser.classDef);\n\t        var class1Count = this.parseUShort();\n\t        var class2Count = this.parseUShort();\n\t        return {\n\t            // Class Pair Adjustment\n\t            posFormat: posFormat,\n\t            coverage: coverage,\n\t            valueFormat1: valueFormat1,\n\t            valueFormat2: valueFormat2,\n\t            classDef1: classDef1,\n\t            classDef2: classDef2,\n\t            class1Count: class1Count,\n\t            class2Count: class2Count,\n\t            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {\n\t                return {\n\t                    value1: this.parseValueRecord(valueFormat1),\n\t                    value2: this.parseValueRecord(valueFormat2)\n\t                };\n\t            }))\n\t        };\n\t    }\n\t};\n\n\tsubtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };\n\tsubtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };\n\tsubtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };\n\tsubtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };\n\tsubtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };\n\tsubtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };\n\tsubtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };\n\n\t// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos\n\tfunction parseGposTable(data, start) {\n\t    start = start || 0;\n\t    var p = new Parser(data, start);\n\t    var tableVersion = p.parseVersion(1);\n\t    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);\n\n\t    if (tableVersion === 1) {\n\t        return {\n\t            version: tableVersion,\n\t            scripts: p.parseScriptList(),\n\t            features: p.parseFeatureList(),\n\t            lookups: p.parseLookupList(subtableParsers$1)\n\t        };\n\t    } else {\n\t        return {\n\t            version: tableVersion,\n\t            scripts: p.parseScriptList(),\n\t            features: p.parseFeatureList(),\n\t            lookups: p.parseLookupList(subtableParsers$1),\n\t            variations: p.parseFeatureVariationsList()\n\t        };\n\t    }\n\n\t}\n\n\t// GPOS Writing //////////////////////////////////////////////\n\t// NOT SUPPORTED\n\tvar subtableMakers$1 = new Array(10);\n\n\tfunction makeGposTable(gpos) {\n\t    return new table.Table('GPOS', [\n\t        {name: 'version', type: 'ULONG', value: 0x10000},\n\t        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},\n\t        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},\n\t        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}\n\t    ]);\n\t}\n\n\tvar gpos = { parse: parseGposTable, make: makeGposTable };\n\n\t// The `kern` table contains kerning pairs.\n\n\tfunction parseWindowsKernTable(p) {\n\t    var pairs = {};\n\t    // Skip nTables.\n\t    p.skip('uShort');\n\t    var subtableVersion = p.parseUShort();\n\t    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');\n\t    // Skip subtableLength, subtableCoverage\n\t    p.skip('uShort', 2);\n\t    var nPairs = p.parseUShort();\n\t    // Skip searchRange, entrySelector, rangeShift.\n\t    p.skip('uShort', 3);\n\t    for (var i = 0; i < nPairs; i += 1) {\n\t        var leftIndex = p.parseUShort();\n\t        var rightIndex = p.parseUShort();\n\t        var value = p.parseShort();\n\t        pairs[leftIndex + ',' + rightIndex] = value;\n\t    }\n\t    return pairs;\n\t}\n\n\tfunction parseMacKernTable(p) {\n\t    var pairs = {};\n\t    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.\n\t    // Skip the rest.\n\t    p.skip('uShort');\n\t    var nTables = p.parseULong();\n\t    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');\n\t    if (nTables > 1) {\n\t        console.warn('Only the first kern subtable is supported.');\n\t    }\n\t    p.skip('uLong');\n\t    var coverage = p.parseUShort();\n\t    var subtableVersion = coverage & 0xFF;\n\t    p.skip('uShort');\n\t    if (subtableVersion === 0) {\n\t        var nPairs = p.parseUShort();\n\t        // Skip searchRange, entrySelector, rangeShift.\n\t        p.skip('uShort', 3);\n\t        for (var i = 0; i < nPairs; i += 1) {\n\t            var leftIndex = p.parseUShort();\n\t            var rightIndex = p.parseUShort();\n\t            var value = p.parseShort();\n\t            pairs[leftIndex + ',' + rightIndex] = value;\n\t        }\n\t    }\n\t    return pairs;\n\t}\n\n\t// Parse the `kern` table which contains kerning pairs.\n\tfunction parseKernTable(data, start) {\n\t    var p = new parse.Parser(data, start);\n\t    var tableVersion = p.parseUShort();\n\t    if (tableVersion === 0) {\n\t        return parseWindowsKernTable(p);\n\t    } else if (tableVersion === 1) {\n\t        return parseMacKernTable(p);\n\t    } else {\n\t        throw new Error('Unsupported kern table version (' + tableVersion + ').');\n\t    }\n\t}\n\n\tvar kern = { parse: parseKernTable };\n\n\t// The `loca` table stores the offsets to the locations of the glyphs in the font.\n\n\t// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n\t// relative to the beginning of the glyphData table.\n\t// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n\t// The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n\t// version where offsets are stored as uLongs. The `head` table specifies which version to use\n\t// (under indexToLocFormat).\n\tfunction parseLocaTable(data, start, numGlyphs, shortVersion) {\n\t    var p = new parse.Parser(data, start);\n\t    var parseFn = shortVersion ? p.parseUShort : p.parseULong;\n\t    // There is an extra entry after the last index element to compute the length of the last glyph.\n\t    // That's why we use numGlyphs + 1.\n\t    var glyphOffsets = [];\n\t    for (var i = 0; i < numGlyphs + 1; i += 1) {\n\t        var glyphOffset = parseFn.call(p);\n\t        if (shortVersion) {\n\t            // The short table version stores the actual offset divided by 2.\n\t            glyphOffset *= 2;\n\t        }\n\n\t        glyphOffsets.push(glyphOffset);\n\t    }\n\n\t    return glyphOffsets;\n\t}\n\n\tvar loca = { parse: parseLocaTable };\n\n\t// opentype.js\n\n\t/**\n\t * The opentype library.\n\t * @namespace opentype\n\t */\n\n\t// File loaders /////////////////////////////////////////////////////////\n\t/**\n\t * Loads a font from a file. The callback throws an error message as the first parameter if it fails\n\t * and the font as an ArrayBuffer in the second parameter if it succeeds.\n\t * @param  {string} path - The path of the file\n\t * @param  {Function} callback - The function to call when the font load completes\n\t */\n\tfunction loadFromFile(path, callback) {\n\t    var fs = __webpack_require__(/*! fs */ \"fs\");\n\t    fs.readFile(path, function(err, buffer) {\n\t        if (err) {\n\t            return callback(err.message);\n\t        }\n\n\t        callback(null, nodeBufferToArrayBuffer(buffer));\n\t    });\n\t}\n\t/**\n\t * Loads a font from a URL. The callback throws an error message as the first parameter if it fails\n\t * and the font as an ArrayBuffer in the second parameter if it succeeds.\n\t * @param  {string} url - The URL of the font file.\n\t * @param  {Function} callback - The function to call when the font load completes\n\t */\n\tfunction loadFromUrl(url, callback) {\n\t    var request = new XMLHttpRequest();\n\t    request.open('get', url, true);\n\t    request.responseType = 'arraybuffer';\n\t    request.onload = function() {\n\t        if (request.response) {\n\t            return callback(null, request.response);\n\t        } else {\n\t            return callback('Font could not be loaded: ' + request.statusText);\n\t        }\n\t    };\n\n\t    request.onerror = function () {\n\t        callback('Font could not be loaded');\n\t    };\n\n\t    request.send();\n\t}\n\n\t// Table Directory Entries //////////////////////////////////////////////\n\t/**\n\t * Parses OpenType table entries.\n\t * @param  {DataView}\n\t * @param  {Number}\n\t * @return {Object[]}\n\t */\n\tfunction parseOpenTypeTableEntries(data, numTables) {\n\t    var tableEntries = [];\n\t    var p = 12;\n\t    for (var i = 0; i < numTables; i += 1) {\n\t        var tag = parse.getTag(data, p);\n\t        var checksum = parse.getULong(data, p + 4);\n\t        var offset = parse.getULong(data, p + 8);\n\t        var length = parse.getULong(data, p + 12);\n\t        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});\n\t        p += 16;\n\t    }\n\n\t    return tableEntries;\n\t}\n\n\t/**\n\t * Parses WOFF table entries.\n\t * @param  {DataView}\n\t * @param  {Number}\n\t * @return {Object[]}\n\t */\n\tfunction parseWOFFTableEntries(data, numTables) {\n\t    var tableEntries = [];\n\t    var p = 44; // offset to the first table directory entry.\n\t    for (var i = 0; i < numTables; i += 1) {\n\t        var tag = parse.getTag(data, p);\n\t        var offset = parse.getULong(data, p + 4);\n\t        var compLength = parse.getULong(data, p + 8);\n\t        var origLength = parse.getULong(data, p + 12);\n\t        var compression = (void 0);\n\t        if (compLength < origLength) {\n\t            compression = 'WOFF';\n\t        } else {\n\t            compression = false;\n\t        }\n\n\t        tableEntries.push({tag: tag, offset: offset, compression: compression,\n\t            compressedLength: compLength, length: origLength});\n\t        p += 20;\n\t    }\n\n\t    return tableEntries;\n\t}\n\n\t/**\n\t * @typedef TableData\n\t * @type Object\n\t * @property {DataView} data - The DataView\n\t * @property {number} offset - The data offset.\n\t */\n\n\t/**\n\t * @param  {DataView}\n\t * @param  {Object}\n\t * @return {TableData}\n\t */\n\tfunction uncompressTable(data, tableEntry) {\n\t    if (tableEntry.compression === 'WOFF') {\n\t        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);\n\t        var outBuffer = new Uint8Array(tableEntry.length);\n\t        tinyInflate(inBuffer, outBuffer);\n\t        if (outBuffer.byteLength !== tableEntry.length) {\n\t            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\\'t match recorded length');\n\t        }\n\n\t        var view = new DataView(outBuffer.buffer, 0);\n\t        return {data: view, offset: 0};\n\t    } else {\n\t        return {data: data, offset: tableEntry.offset};\n\t    }\n\t}\n\n\t// Public API ///////////////////////////////////////////////////////////\n\n\t/**\n\t * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n\t * Throws an error if the font could not be parsed.\n\t * @param  {ArrayBuffer}\n\t * @param  {Object} opt - options for parsing\n\t * @return {opentype.Font}\n\t */\n\tfunction parseBuffer(buffer, opt) {\n\t    opt = (opt === undefined || opt === null) ?  {} : opt;\n\n\t    var indexToLocFormat;\n\t    var ltagTable;\n\n\t    // Since the constructor can also be called to create new fonts from scratch, we indicate this\n\t    // should be an empty font that we'll fill with our own data.\n\t    var font = new Font({empty: true});\n\n\t    // OpenType fonts use big endian byte ordering.\n\t    // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n\t    // Instead we use DataViews where we can specify endianness.\n\t    var data = new DataView(buffer, 0);\n\t    var numTables;\n\t    var tableEntries = [];\n\t    var signature = parse.getTag(data, 0);\n\t    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {\n\t        font.outlinesFormat = 'truetype';\n\t        numTables = parse.getUShort(data, 4);\n\t        tableEntries = parseOpenTypeTableEntries(data, numTables);\n\t    } else if (signature === 'OTTO') {\n\t        font.outlinesFormat = 'cff';\n\t        numTables = parse.getUShort(data, 4);\n\t        tableEntries = parseOpenTypeTableEntries(data, numTables);\n\t    } else if (signature === 'wOFF') {\n\t        var flavor = parse.getTag(data, 4);\n\t        if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n\t            font.outlinesFormat = 'truetype';\n\t        } else if (flavor === 'OTTO') {\n\t            font.outlinesFormat = 'cff';\n\t        } else {\n\t            throw new Error('Unsupported OpenType flavor ' + signature);\n\t        }\n\n\t        numTables = parse.getUShort(data, 12);\n\t        tableEntries = parseWOFFTableEntries(data, numTables);\n\t    } else {\n\t        throw new Error('Unsupported OpenType signature ' + signature);\n\t    }\n\n\t    var cffTableEntry;\n\t    var fvarTableEntry;\n\t    var glyfTableEntry;\n\t    var gdefTableEntry;\n\t    var gposTableEntry;\n\t    var gsubTableEntry;\n\t    var hmtxTableEntry;\n\t    var kernTableEntry;\n\t    var locaTableEntry;\n\t    var nameTableEntry;\n\t    var metaTableEntry;\n\t    var p;\n\n\t    for (var i = 0; i < numTables; i += 1) {\n\t        var tableEntry = tableEntries[i];\n\t        var table = (void 0);\n\t        switch (tableEntry.tag) {\n\t            case 'cmap':\n\t                table = uncompressTable(data, tableEntry);\n\t                font.tables.cmap = cmap.parse(table.data, table.offset);\n\t                font.encoding = new CmapEncoding(font.tables.cmap);\n\t                break;\n\t            case 'cvt ' :\n\t                table = uncompressTable(data, tableEntry);\n\t                p = new parse.Parser(table.data, table.offset);\n\t                font.tables.cvt = p.parseShortList(tableEntry.length / 2);\n\t                break;\n\t            case 'fvar':\n\t                fvarTableEntry = tableEntry;\n\t                break;\n\t            case 'fpgm' :\n\t                table = uncompressTable(data, tableEntry);\n\t                p = new parse.Parser(table.data, table.offset);\n\t                font.tables.fpgm = p.parseByteList(tableEntry.length);\n\t                break;\n\t            case 'head':\n\t                table = uncompressTable(data, tableEntry);\n\t                font.tables.head = head.parse(table.data, table.offset);\n\t                font.unitsPerEm = font.tables.head.unitsPerEm;\n\t                indexToLocFormat = font.tables.head.indexToLocFormat;\n\t                break;\n\t            case 'hhea':\n\t                table = uncompressTable(data, tableEntry);\n\t                font.tables.hhea = hhea.parse(table.data, table.offset);\n\t                font.ascender = font.tables.hhea.ascender;\n\t                font.descender = font.tables.hhea.descender;\n\t                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n\t                break;\n\t            case 'hmtx':\n\t                hmtxTableEntry = tableEntry;\n\t                break;\n\t            case 'ltag':\n\t                table = uncompressTable(data, tableEntry);\n\t                ltagTable = ltag.parse(table.data, table.offset);\n\t                break;\n\t            case 'maxp':\n\t                table = uncompressTable(data, tableEntry);\n\t                font.tables.maxp = maxp.parse(table.data, table.offset);\n\t                font.numGlyphs = font.tables.maxp.numGlyphs;\n\t                break;\n\t            case 'name':\n\t                nameTableEntry = tableEntry;\n\t                break;\n\t            case 'OS/2':\n\t                table = uncompressTable(data, tableEntry);\n\t                font.tables.os2 = os2.parse(table.data, table.offset);\n\t                break;\n\t            case 'post':\n\t                table = uncompressTable(data, tableEntry);\n\t                font.tables.post = post.parse(table.data, table.offset);\n\t                font.glyphNames = new GlyphNames(font.tables.post);\n\t                break;\n\t            case 'prep' :\n\t                table = uncompressTable(data, tableEntry);\n\t                p = new parse.Parser(table.data, table.offset);\n\t                font.tables.prep = p.parseByteList(tableEntry.length);\n\t                break;\n\t            case 'glyf':\n\t                glyfTableEntry = tableEntry;\n\t                break;\n\t            case 'loca':\n\t                locaTableEntry = tableEntry;\n\t                break;\n\t            case 'CFF ':\n\t                cffTableEntry = tableEntry;\n\t                break;\n\t            case 'kern':\n\t                kernTableEntry = tableEntry;\n\t                break;\n\t            case 'GDEF':\n\t                gdefTableEntry = tableEntry;\n\t                break;\n\t            case 'GPOS':\n\t                gposTableEntry = tableEntry;\n\t                break;\n\t            case 'GSUB':\n\t                gsubTableEntry = tableEntry;\n\t                break;\n\t            case 'meta':\n\t                metaTableEntry = tableEntry;\n\t                break;\n\t        }\n\t    }\n\n\t    var nameTable = uncompressTable(data, nameTableEntry);\n\t    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);\n\t    font.names = font.tables.name;\n\n\t    if (glyfTableEntry && locaTableEntry) {\n\t        var shortVersion = indexToLocFormat === 0;\n\t        var locaTable = uncompressTable(data, locaTableEntry);\n\t        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);\n\t        var glyfTable = uncompressTable(data, glyfTableEntry);\n\t        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);\n\t    } else if (cffTableEntry) {\n\t        var cffTable = uncompressTable(data, cffTableEntry);\n\t        cff.parse(cffTable.data, cffTable.offset, font, opt);\n\t    } else {\n\t        throw new Error('Font doesn\\'t contain TrueType or CFF outlines.');\n\t    }\n\n\t    var hmtxTable = uncompressTable(data, hmtxTableEntry);\n\t    hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);\n\t    addGlyphNames(font, opt);\n\n\t    if (kernTableEntry) {\n\t        var kernTable = uncompressTable(data, kernTableEntry);\n\t        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);\n\t    } else {\n\t        font.kerningPairs = {};\n\t    }\n\n\t    if (gdefTableEntry) {\n\t        var gdefTable = uncompressTable(data, gdefTableEntry);\n\t        font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);\n\t    }\n\n\t    if (gposTableEntry) {\n\t        var gposTable = uncompressTable(data, gposTableEntry);\n\t        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);\n\t        font.position.init();\n\t    }\n\n\t    if (gsubTableEntry) {\n\t        var gsubTable = uncompressTable(data, gsubTableEntry);\n\t        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);\n\t    }\n\n\t    if (fvarTableEntry) {\n\t        var fvarTable = uncompressTable(data, fvarTableEntry);\n\t        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);\n\t    }\n\n\t    if (metaTableEntry) {\n\t        var metaTable = uncompressTable(data, metaTableEntry);\n\t        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);\n\t        font.metas = font.tables.meta;\n\t    }\n\n\t    return font;\n\t}\n\n\t/**\n\t * Asynchronously load the font from a URL or a filesystem. When done, call the callback\n\t * with two arguments `(err, font)`. The `err` will be null on success,\n\t * the `font` is a Font object.\n\t * We use the node.js callback convention so that\n\t * opentype.js can integrate with frameworks like async.js.\n\t * @alias opentype.load\n\t * @param  {string} url - The URL of the font to load.\n\t * @param  {Function} callback - The callback.\n\t */\n\tfunction load(url, callback, opt) {\n\t    opt = (opt === undefined || opt === null) ?  {} : opt;\n\t    var isNode = typeof window === 'undefined';\n\t    var loadFn = isNode && !opt.isUrl ? loadFromFile : loadFromUrl;\n\n\t    return new Promise(function (resolve, reject) {\n\t        loadFn(url, function(err, arrayBuffer) {\n\t            if (err) {\n\t                if (callback) {\n\t                    return callback(err);\n\t                } else {\n\t                    reject(err);\n\t                }\n\t            }\n\t            var font;\n\t            try {\n\t                font = parseBuffer(arrayBuffer, opt);\n\t            } catch (e) {\n\t                if (callback) {\n\t                    return callback(e, null);\n\t                } else {\n\t                    reject(e);\n\t                }\n\t            }\n\t            if (callback) {\n\t                return callback(null, font);\n\t            } else {\n\t                resolve(font);\n\t            }\n\t        });\n\t    });\n\t}\n\n\t/**\n\t * Synchronously load the font from a URL or file.\n\t * When done, returns the font object or throws an error.\n\t * @alias opentype.loadSync\n\t * @param  {string} url - The URL of the font to load.\n\t * @param  {Object} opt - opt.lowMemory\n\t * @return {opentype.Font}\n\t */\n\tfunction loadSync(url, opt) {\n\t    var fs = __webpack_require__(/*! fs */ \"fs\");\n\t    var buffer = fs.readFileSync(url);\n\t    return parseBuffer(nodeBufferToArrayBuffer(buffer), opt);\n\t}\n\n\tvar opentype = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tFont: Font,\n\t\tGlyph: Glyph,\n\t\tPath: Path,\n\t\tBoundingBox: BoundingBox,\n\t\t_parse: parse,\n\t\tparse: parseBuffer,\n\t\tload: load,\n\t\tloadSync: loadSync\n\t});\n\n\texports.BoundingBox = BoundingBox;\n\texports.Font = Font;\n\texports.Glyph = Glyph;\n\texports.Path = Path;\n\texports._parse = parse;\n\texports.default = opentype;\n\texports.load = load;\n\texports.loadSync = loadSync;\n\texports.parse = parseBuffer;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=opentype.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvZGlzdC9vcGVudHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLEtBQTREO0FBQzdELENBQUMsQ0FDd0Q7QUFDekQsQ0FBQyw2QkFBNkI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxXQUFXLE9BQU87QUFDakMsZUFBZSxnQkFBZ0IsT0FBTzs7QUFFdEM7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU8sT0FBTzs7QUFFN0I7QUFDQTtBQUNBOztBQUVBLGVBQWUsUUFBUSxPQUFP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QU07QUFDTjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sMkJBQTJCO0FBQ2pDLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sK0JBQStCO0FBQ3JDOztBQUVBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsK0NBQStDO0FBQ3pELFVBQVUs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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOENBQThDO0FBQzVELGNBQWMsOEVBQThFO0FBQzVGLGNBQWM7QUFDZDtBQUNBLE9BQU87QUFDUDtBQUNBLGNBQWMsOENBQThDO0FBQzVELGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4Q0FBOEM7QUFDeEQsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4Q0FBOEM7QUFDeEQsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4Q0FBOEM7QUFDeEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyREFBMkQ7QUFDOUU7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNO0FBQ047O0FBRUE7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QkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0Isb0NBQW9DO0FBQ3BDLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZixPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTztBQUM1Qjs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0EseUJBQXlCO0FBQ3pCLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFF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O0FBRWY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsVUFBVTtBQUNWLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsY0FBSTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsYUFBYTs7QUFFN0QsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9kaXN0L29wZW50eXBlLmpzPzU2NTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwczovL29wZW50eXBlLmpzLm9yZyB2MS4zLjQgfCAoYykgRnJlZGVyaWsgRGUgQmxlc2VyIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBNSVQgTGljZW5zZSB8IFVzZXMgdGlueS1pbmZsYXRlIGJ5IERldm9uIEdvdmV0dCBhbmQgc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdCBwb2x5ZmlsbCBieSBNYXRoaWFzIEJ5bmVuc1xuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5vcGVudHlwZSA9IHt9KSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cblx0LyohIGh0dHBzOi8vbXRocy5iZS9jb2RlcG9pbnRhdCB2MC4yLjAgYnkgQG1hdGhpYXMgKi9cblx0aWYgKCFTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KSB7XG5cdFx0KGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBJRSA4IG9ubHkgc3VwcG9ydHMgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgb24gRE9NIGVsZW1lbnRzXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0XHRcdHZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9ICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG9iamVjdCwgb2JqZWN0KSAmJiAkZGVmaW5lUHJvcGVydHk7XG5cdFx0XHRcdH0gY2F0Y2goZXJyb3IpIHt9XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9KCkpO1xuXHRcdFx0dmFyIGNvZGVQb2ludEF0ID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRcdFx0aWYgKHRoaXMgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHRocm93IFR5cGVFcnJvcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG5cdFx0XHRcdHZhciBzaXplID0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdFx0Ly8gYFRvSW50ZWdlcmBcblx0XHRcdFx0dmFyIGluZGV4ID0gcG9zaXRpb24gPyBOdW1iZXIocG9zaXRpb24pIDogMDtcblx0XHRcdFx0aWYgKGluZGV4ICE9IGluZGV4KSB7IC8vIGJldHRlciBgaXNOYU5gXG5cdFx0XHRcdFx0aW5kZXggPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEFjY291bnQgZm9yIG91dC1vZi1ib3VuZHMgaW5kaWNlczpcblx0XHRcdFx0aWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBHZXQgdGhlIGZpcnN0IGNvZGUgdW5pdFxuXHRcdFx0XHR2YXIgZmlyc3QgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG5cdFx0XHRcdHZhciBzZWNvbmQ7XG5cdFx0XHRcdGlmICggLy8gY2hlY2sgaWYgaXTigJlzIHRoZSBzdGFydCBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0Zmlyc3QgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRiAmJiAvLyBoaWdoIHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdHNpemUgPiBpbmRleCArIDEgLy8gdGhlcmUgaXMgYSBuZXh0IGNvZGUgdW5pdFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRzZWNvbmQgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCArIDEpO1xuXHRcdFx0XHRcdGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG5cdFx0XHRcdFx0XHRyZXR1cm4gKGZpcnN0IC0gMHhEODAwKSAqIDB4NDAwICsgc2Vjb25kIC0gMHhEQzAwICsgMHgxMDAwMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZpcnN0O1xuXHRcdFx0fTtcblx0XHRcdGlmIChkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCAnY29kZVBvaW50QXQnLCB7XG5cdFx0XHRcdFx0J3ZhbHVlJzogY29kZVBvaW50QXQsXG5cdFx0XHRcdFx0J2NvbmZpZ3VyYWJsZSc6IHRydWUsXG5cdFx0XHRcdFx0J3dyaXRhYmxlJzogdHJ1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQgPSBjb2RlUG9pbnRBdDtcblx0XHRcdH1cblx0XHR9KCkpO1xuXHR9XG5cblx0dmFyIFRJTkZfT0sgPSAwO1xuXHR2YXIgVElORl9EQVRBX0VSUk9SID0gLTM7XG5cblx0ZnVuY3Rpb24gVHJlZSgpIHtcblx0ICB0aGlzLnRhYmxlID0gbmV3IFVpbnQxNkFycmF5KDE2KTsgICAvKiB0YWJsZSBvZiBjb2RlIGxlbmd0aCBjb3VudHMgKi9cblx0ICB0aGlzLnRyYW5zID0gbmV3IFVpbnQxNkFycmF5KDI4OCk7ICAvKiBjb2RlIC0+IHN5bWJvbCB0cmFuc2xhdGlvbiB0YWJsZSAqL1xuXHR9XG5cblx0ZnVuY3Rpb24gRGF0YShzb3VyY2UsIGRlc3QpIHtcblx0ICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblx0ICB0aGlzLnNvdXJjZUluZGV4ID0gMDtcblx0ICB0aGlzLnRhZyA9IDA7XG5cdCAgdGhpcy5iaXRjb3VudCA9IDA7XG5cdCAgXG5cdCAgdGhpcy5kZXN0ID0gZGVzdDtcblx0ICB0aGlzLmRlc3RMZW4gPSAwO1xuXHQgIFxuXHQgIHRoaXMubHRyZWUgPSBuZXcgVHJlZSgpOyAgLyogZHluYW1pYyBsZW5ndGgvc3ltYm9sIHRyZWUgKi9cblx0ICB0aGlzLmR0cmVlID0gbmV3IFRyZWUoKTsgIC8qIGR5bmFtaWMgZGlzdGFuY2UgdHJlZSAqL1xuXHR9XG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0ICogLS0gdW5pbml0aWFsaXplZCBnbG9iYWwgZGF0YSAoc3RhdGljIHN0cnVjdHVyZXMpIC0tICpcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0dmFyIHNsdHJlZSA9IG5ldyBUcmVlKCk7XG5cdHZhciBzZHRyZWUgPSBuZXcgVHJlZSgpO1xuXG5cdC8qIGV4dHJhIGJpdHMgYW5kIGJhc2UgdGFibGVzIGZvciBsZW5ndGggY29kZXMgKi9cblx0dmFyIGxlbmd0aF9iaXRzID0gbmV3IFVpbnQ4QXJyYXkoMzApO1xuXHR2YXIgbGVuZ3RoX2Jhc2UgPSBuZXcgVWludDE2QXJyYXkoMzApO1xuXG5cdC8qIGV4dHJhIGJpdHMgYW5kIGJhc2UgdGFibGVzIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuXHR2YXIgZGlzdF9iaXRzID0gbmV3IFVpbnQ4QXJyYXkoMzApO1xuXHR2YXIgZGlzdF9iYXNlID0gbmV3IFVpbnQxNkFycmF5KDMwKTtcblxuXHQvKiBzcGVjaWFsIG9yZGVyaW5nIG9mIGNvZGUgbGVuZ3RoIGNvZGVzICovXG5cdHZhciBjbGNpZHggPSBuZXcgVWludDhBcnJheShbXG5cdCAgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNixcblx0ICAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMixcblx0ICAxNCwgMSwgMTVcblx0XSk7XG5cblx0LyogdXNlZCBieSB0aW5mX2RlY29kZV90cmVlcywgYXZvaWRzIGFsbG9jYXRpb25zIGV2ZXJ5IGNhbGwgKi9cblx0dmFyIGNvZGVfdHJlZSA9IG5ldyBUcmVlKCk7XG5cdHZhciBsZW5ndGhzID0gbmV3IFVpbnQ4QXJyYXkoMjg4ICsgMzIpO1xuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0ICogLS0gdXRpbGl0eSBmdW5jdGlvbnMgLS0gKlxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8qIGJ1aWxkIGV4dHJhIGJpdHMgYW5kIGJhc2UgdGFibGVzICovXG5cdGZ1bmN0aW9uIHRpbmZfYnVpbGRfYml0c19iYXNlKGJpdHMsIGJhc2UsIGRlbHRhLCBmaXJzdCkge1xuXHQgIHZhciBpLCBzdW07XG5cblx0ICAvKiBidWlsZCBiaXRzIHRhYmxlICovXG5cdCAgZm9yIChpID0gMDsgaSA8IGRlbHRhOyArK2kpIHsgYml0c1tpXSA9IDA7IH1cblx0ICBmb3IgKGkgPSAwOyBpIDwgMzAgLSBkZWx0YTsgKytpKSB7IGJpdHNbaSArIGRlbHRhXSA9IGkgLyBkZWx0YSB8IDA7IH1cblxuXHQgIC8qIGJ1aWxkIGJhc2UgdGFibGUgKi9cblx0ICBmb3IgKHN1bSA9IGZpcnN0LCBpID0gMDsgaSA8IDMwOyArK2kpIHtcblx0ICAgIGJhc2VbaV0gPSBzdW07XG5cdCAgICBzdW0gKz0gMSA8PCBiaXRzW2ldO1xuXHQgIH1cblx0fVxuXG5cdC8qIGJ1aWxkIHRoZSBmaXhlZCBodWZmbWFuIHRyZWVzICovXG5cdGZ1bmN0aW9uIHRpbmZfYnVpbGRfZml4ZWRfdHJlZXMobHQsIGR0KSB7XG5cdCAgdmFyIGk7XG5cblx0ICAvKiBidWlsZCBmaXhlZCBsZW5ndGggdHJlZSAqL1xuXHQgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHsgbHQudGFibGVbaV0gPSAwOyB9XG5cblx0ICBsdC50YWJsZVs3XSA9IDI0O1xuXHQgIGx0LnRhYmxlWzhdID0gMTUyO1xuXHQgIGx0LnRhYmxlWzldID0gMTEyO1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IDI0OyArK2kpIHsgbHQudHJhbnNbaV0gPSAyNTYgKyBpOyB9XG5cdCAgZm9yIChpID0gMDsgaSA8IDE0NDsgKytpKSB7IGx0LnRyYW5zWzI0ICsgaV0gPSBpOyB9XG5cdCAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkgeyBsdC50cmFuc1syNCArIDE0NCArIGldID0gMjgwICsgaTsgfVxuXHQgIGZvciAoaSA9IDA7IGkgPCAxMTI7ICsraSkgeyBsdC50cmFuc1syNCArIDE0NCArIDggKyBpXSA9IDE0NCArIGk7IH1cblxuXHQgIC8qIGJ1aWxkIGZpeGVkIGRpc3RhbmNlIHRyZWUgKi9cblx0ICBmb3IgKGkgPSAwOyBpIDwgNTsgKytpKSB7IGR0LnRhYmxlW2ldID0gMDsgfVxuXG5cdCAgZHQudGFibGVbNV0gPSAzMjtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCAzMjsgKytpKSB7IGR0LnRyYW5zW2ldID0gaTsgfVxuXHR9XG5cblx0LyogZ2l2ZW4gYW4gYXJyYXkgb2YgY29kZSBsZW5ndGhzLCBidWlsZCBhIHRyZWUgKi9cblx0dmFyIG9mZnMgPSBuZXcgVWludDE2QXJyYXkoMTYpO1xuXG5cdGZ1bmN0aW9uIHRpbmZfYnVpbGRfdHJlZSh0LCBsZW5ndGhzLCBvZmYsIG51bSkge1xuXHQgIHZhciBpLCBzdW07XG5cblx0ICAvKiBjbGVhciBjb2RlIGxlbmd0aCBjb3VudCB0YWJsZSAqL1xuXHQgIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7IHQudGFibGVbaV0gPSAwOyB9XG5cblx0ICAvKiBzY2FuIHN5bWJvbCBsZW5ndGhzLCBhbmQgc3VtIGNvZGUgbGVuZ3RoIGNvdW50cyAqL1xuXHQgIGZvciAoaSA9IDA7IGkgPCBudW07ICsraSkgeyB0LnRhYmxlW2xlbmd0aHNbb2ZmICsgaV1dKys7IH1cblxuXHQgIHQudGFibGVbMF0gPSAwO1xuXG5cdCAgLyogY29tcHV0ZSBvZmZzZXQgdGFibGUgZm9yIGRpc3RyaWJ1dGlvbiBzb3J0ICovXG5cdCAgZm9yIChzdW0gPSAwLCBpID0gMDsgaSA8IDE2OyArK2kpIHtcblx0ICAgIG9mZnNbaV0gPSBzdW07XG5cdCAgICBzdW0gKz0gdC50YWJsZVtpXTtcblx0ICB9XG5cblx0ICAvKiBjcmVhdGUgY29kZS0+c3ltYm9sIHRyYW5zbGF0aW9uIHRhYmxlIChzeW1ib2xzIHNvcnRlZCBieSBjb2RlKSAqL1xuXHQgIGZvciAoaSA9IDA7IGkgPCBudW07ICsraSkge1xuXHQgICAgaWYgKGxlbmd0aHNbb2ZmICsgaV0pIHsgdC50cmFuc1tvZmZzW2xlbmd0aHNbb2ZmICsgaV1dKytdID0gaTsgfVxuXHQgIH1cblx0fVxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQgKiAtLSBkZWNvZGUgZnVuY3Rpb25zIC0tICpcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8qIGdldCBvbmUgYml0IGZyb20gc291cmNlIHN0cmVhbSAqL1xuXHRmdW5jdGlvbiB0aW5mX2dldGJpdChkKSB7XG5cdCAgLyogY2hlY2sgaWYgdGFnIGlzIGVtcHR5ICovXG5cdCAgaWYgKCFkLmJpdGNvdW50LS0pIHtcblx0ICAgIC8qIGxvYWQgbmV4dCB0YWcgKi9cblx0ICAgIGQudGFnID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXTtcblx0ICAgIGQuYml0Y291bnQgPSA3O1xuXHQgIH1cblxuXHQgIC8qIHNoaWZ0IGJpdCBvdXQgb2YgdGFnICovXG5cdCAgdmFyIGJpdCA9IGQudGFnICYgMTtcblx0ICBkLnRhZyA+Pj49IDE7XG5cblx0ICByZXR1cm4gYml0O1xuXHR9XG5cblx0LyogcmVhZCBhIG51bSBiaXQgdmFsdWUgZnJvbSBhIHN0cmVhbSBhbmQgYWRkIGJhc2UgKi9cblx0ZnVuY3Rpb24gdGluZl9yZWFkX2JpdHMoZCwgbnVtLCBiYXNlKSB7XG5cdCAgaWYgKCFudW0pXG5cdCAgICB7IHJldHVybiBiYXNlOyB9XG5cblx0ICB3aGlsZSAoZC5iaXRjb3VudCA8IDI0KSB7XG5cdCAgICBkLnRhZyB8PSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4KytdIDw8IGQuYml0Y291bnQ7XG5cdCAgICBkLmJpdGNvdW50ICs9IDg7XG5cdCAgfVxuXG5cdCAgdmFyIHZhbCA9IGQudGFnICYgKDB4ZmZmZiA+Pj4gKDE2IC0gbnVtKSk7XG5cdCAgZC50YWcgPj4+PSBudW07XG5cdCAgZC5iaXRjb3VudCAtPSBudW07XG5cdCAgcmV0dXJuIHZhbCArIGJhc2U7XG5cdH1cblxuXHQvKiBnaXZlbiBhIGRhdGEgc3RyZWFtIGFuZCBhIHRyZWUsIGRlY29kZSBhIHN5bWJvbCAqL1xuXHRmdW5jdGlvbiB0aW5mX2RlY29kZV9zeW1ib2woZCwgdCkge1xuXHQgIHdoaWxlIChkLmJpdGNvdW50IDwgMjQpIHtcblx0ICAgIGQudGFnIHw9IGQuc291cmNlW2Quc291cmNlSW5kZXgrK10gPDwgZC5iaXRjb3VudDtcblx0ICAgIGQuYml0Y291bnQgKz0gODtcblx0ICB9XG5cdCAgXG5cdCAgdmFyIHN1bSA9IDAsIGN1ciA9IDAsIGxlbiA9IDA7XG5cdCAgdmFyIHRhZyA9IGQudGFnO1xuXG5cdCAgLyogZ2V0IG1vcmUgYml0cyB3aGlsZSBjb2RlIHZhbHVlIGlzIGFib3ZlIHN1bSAqL1xuXHQgIGRvIHtcblx0ICAgIGN1ciA9IDIgKiBjdXIgKyAodGFnICYgMSk7XG5cdCAgICB0YWcgPj4+PSAxO1xuXHQgICAgKytsZW47XG5cblx0ICAgIHN1bSArPSB0LnRhYmxlW2xlbl07XG5cdCAgICBjdXIgLT0gdC50YWJsZVtsZW5dO1xuXHQgIH0gd2hpbGUgKGN1ciA+PSAwKTtcblx0ICBcblx0ICBkLnRhZyA9IHRhZztcblx0ICBkLmJpdGNvdW50IC09IGxlbjtcblxuXHQgIHJldHVybiB0LnRyYW5zW3N1bSArIGN1cl07XG5cdH1cblxuXHQvKiBnaXZlbiBhIGRhdGEgc3RyZWFtLCBkZWNvZGUgZHluYW1pYyB0cmVlcyBmcm9tIGl0ICovXG5cdGZ1bmN0aW9uIHRpbmZfZGVjb2RlX3RyZWVzKGQsIGx0LCBkdCkge1xuXHQgIHZhciBobGl0LCBoZGlzdCwgaGNsZW47XG5cdCAgdmFyIGksIG51bSwgbGVuZ3RoO1xuXG5cdCAgLyogZ2V0IDUgYml0cyBITElUICgyNTctMjg2KSAqL1xuXHQgIGhsaXQgPSB0aW5mX3JlYWRfYml0cyhkLCA1LCAyNTcpO1xuXG5cdCAgLyogZ2V0IDUgYml0cyBIRElTVCAoMS0zMikgKi9cblx0ICBoZGlzdCA9IHRpbmZfcmVhZF9iaXRzKGQsIDUsIDEpO1xuXG5cdCAgLyogZ2V0IDQgYml0cyBIQ0xFTiAoNC0xOSkgKi9cblx0ICBoY2xlbiA9IHRpbmZfcmVhZF9iaXRzKGQsIDQsIDQpO1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IDE5OyArK2kpIHsgbGVuZ3Roc1tpXSA9IDA7IH1cblxuXHQgIC8qIHJlYWQgY29kZSBsZW5ndGhzIGZvciBjb2RlIGxlbmd0aCBhbHBoYWJldCAqL1xuXHQgIGZvciAoaSA9IDA7IGkgPCBoY2xlbjsgKytpKSB7XG5cdCAgICAvKiBnZXQgMyBiaXRzIGNvZGUgbGVuZ3RoICgwLTcpICovXG5cdCAgICB2YXIgY2xlbiA9IHRpbmZfcmVhZF9iaXRzKGQsIDMsIDApO1xuXHQgICAgbGVuZ3Roc1tjbGNpZHhbaV1dID0gY2xlbjtcblx0ICB9XG5cblx0ICAvKiBidWlsZCBjb2RlIGxlbmd0aCB0cmVlICovXG5cdCAgdGluZl9idWlsZF90cmVlKGNvZGVfdHJlZSwgbGVuZ3RocywgMCwgMTkpO1xuXG5cdCAgLyogZGVjb2RlIGNvZGUgbGVuZ3RocyBmb3IgdGhlIGR5bmFtaWMgdHJlZXMgKi9cblx0ICBmb3IgKG51bSA9IDA7IG51bSA8IGhsaXQgKyBoZGlzdDspIHtcblx0ICAgIHZhciBzeW0gPSB0aW5mX2RlY29kZV9zeW1ib2woZCwgY29kZV90cmVlKTtcblxuXHQgICAgc3dpdGNoIChzeW0pIHtcblx0ICAgICAgY2FzZSAxNjpcblx0ICAgICAgICAvKiBjb3B5IHByZXZpb3VzIGNvZGUgbGVuZ3RoIDMtNiB0aW1lcyAocmVhZCAyIGJpdHMpICovXG5cdCAgICAgICAgdmFyIHByZXYgPSBsZW5ndGhzW251bSAtIDFdO1xuXHQgICAgICAgIGZvciAobGVuZ3RoID0gdGluZl9yZWFkX2JpdHMoZCwgMiwgMyk7IGxlbmd0aDsgLS1sZW5ndGgpIHtcblx0ICAgICAgICAgIGxlbmd0aHNbbnVtKytdID0gcHJldjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgMTc6XG5cdCAgICAgICAgLyogcmVwZWF0IGNvZGUgbGVuZ3RoIDAgZm9yIDMtMTAgdGltZXMgKHJlYWQgMyBiaXRzKSAqL1xuXHQgICAgICAgIGZvciAobGVuZ3RoID0gdGluZl9yZWFkX2JpdHMoZCwgMywgMyk7IGxlbmd0aDsgLS1sZW5ndGgpIHtcblx0ICAgICAgICAgIGxlbmd0aHNbbnVtKytdID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgMTg6XG5cdCAgICAgICAgLyogcmVwZWF0IGNvZGUgbGVuZ3RoIDAgZm9yIDExLTEzOCB0aW1lcyAocmVhZCA3IGJpdHMpICovXG5cdCAgICAgICAgZm9yIChsZW5ndGggPSB0aW5mX3JlYWRfYml0cyhkLCA3LCAxMSk7IGxlbmd0aDsgLS1sZW5ndGgpIHtcblx0ICAgICAgICAgIGxlbmd0aHNbbnVtKytdID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgLyogdmFsdWVzIDAtMTUgcmVwcmVzZW50IHRoZSBhY3R1YWwgY29kZSBsZW5ndGhzICovXG5cdCAgICAgICAgbGVuZ3Roc1tudW0rK10gPSBzeW07XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLyogYnVpbGQgZHluYW1pYyB0cmVlcyAqL1xuXHQgIHRpbmZfYnVpbGRfdHJlZShsdCwgbGVuZ3RocywgMCwgaGxpdCk7XG5cdCAgdGluZl9idWlsZF90cmVlKGR0LCBsZW5ndGhzLCBobGl0LCBoZGlzdCk7XG5cdH1cblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdCAqIC0tIGJsb2NrIGluZmxhdGUgZnVuY3Rpb25zIC0tICpcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKiBnaXZlbiBhIHN0cmVhbSBhbmQgdHdvIHRyZWVzLCBpbmZsYXRlIGEgYmxvY2sgb2YgZGF0YSAqL1xuXHRmdW5jdGlvbiB0aW5mX2luZmxhdGVfYmxvY2tfZGF0YShkLCBsdCwgZHQpIHtcblx0ICB3aGlsZSAoMSkge1xuXHQgICAgdmFyIHN5bSA9IHRpbmZfZGVjb2RlX3N5bWJvbChkLCBsdCk7XG5cblx0ICAgIC8qIGNoZWNrIGZvciBlbmQgb2YgYmxvY2sgKi9cblx0ICAgIGlmIChzeW0gPT09IDI1Nikge1xuXHQgICAgICByZXR1cm4gVElORl9PSztcblx0ICAgIH1cblxuXHQgICAgaWYgKHN5bSA8IDI1Nikge1xuXHQgICAgICBkLmRlc3RbZC5kZXN0TGVuKytdID0gc3ltO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIGxlbmd0aCwgZGlzdCwgb2Zmcztcblx0ICAgICAgdmFyIGk7XG5cblx0ICAgICAgc3ltIC09IDI1NztcblxuXHQgICAgICAvKiBwb3NzaWJseSBnZXQgbW9yZSBiaXRzIGZyb20gbGVuZ3RoIGNvZGUgKi9cblx0ICAgICAgbGVuZ3RoID0gdGluZl9yZWFkX2JpdHMoZCwgbGVuZ3RoX2JpdHNbc3ltXSwgbGVuZ3RoX2Jhc2Vbc3ltXSk7XG5cblx0ICAgICAgZGlzdCA9IHRpbmZfZGVjb2RlX3N5bWJvbChkLCBkdCk7XG5cblx0ICAgICAgLyogcG9zc2libHkgZ2V0IG1vcmUgYml0cyBmcm9tIGRpc3RhbmNlIGNvZGUgKi9cblx0ICAgICAgb2ZmcyA9IGQuZGVzdExlbiAtIHRpbmZfcmVhZF9iaXRzKGQsIGRpc3RfYml0c1tkaXN0XSwgZGlzdF9iYXNlW2Rpc3RdKTtcblxuXHQgICAgICAvKiBjb3B5IG1hdGNoICovXG5cdCAgICAgIGZvciAoaSA9IG9mZnM7IGkgPCBvZmZzICsgbGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICBkLmRlc3RbZC5kZXN0TGVuKytdID0gZC5kZXN0W2ldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0LyogaW5mbGF0ZSBhbiB1bmNvbXByZXNzZWQgYmxvY2sgb2YgZGF0YSAqL1xuXHRmdW5jdGlvbiB0aW5mX2luZmxhdGVfdW5jb21wcmVzc2VkX2Jsb2NrKGQpIHtcblx0ICB2YXIgbGVuZ3RoLCBpbnZsZW5ndGg7XG5cdCAgdmFyIGk7XG5cdCAgXG5cdCAgLyogdW5yZWFkIGZyb20gYml0YnVmZmVyICovXG5cdCAgd2hpbGUgKGQuYml0Y291bnQgPiA4KSB7XG5cdCAgICBkLnNvdXJjZUluZGV4LS07XG5cdCAgICBkLmJpdGNvdW50IC09IDg7XG5cdCAgfVxuXG5cdCAgLyogZ2V0IGxlbmd0aCAqL1xuXHQgIGxlbmd0aCA9IGQuc291cmNlW2Quc291cmNlSW5kZXggKyAxXTtcblx0ICBsZW5ndGggPSAyNTYgKiBsZW5ndGggKyBkLnNvdXJjZVtkLnNvdXJjZUluZGV4XTtcblxuXHQgIC8qIGdldCBvbmUncyBjb21wbGVtZW50IG9mIGxlbmd0aCAqL1xuXHQgIGludmxlbmd0aCA9IGQuc291cmNlW2Quc291cmNlSW5kZXggKyAzXTtcblx0ICBpbnZsZW5ndGggPSAyNTYgKiBpbnZsZW5ndGggKyBkLnNvdXJjZVtkLnNvdXJjZUluZGV4ICsgMl07XG5cblx0ICAvKiBjaGVjayBsZW5ndGggKi9cblx0ICBpZiAobGVuZ3RoICE9PSAofmludmxlbmd0aCAmIDB4MDAwMGZmZmYpKVxuXHQgICAgeyByZXR1cm4gVElORl9EQVRBX0VSUk9SOyB9XG5cblx0ICBkLnNvdXJjZUluZGV4ICs9IDQ7XG5cblx0ICAvKiBjb3B5IGJsb2NrICovXG5cdCAgZm9yIChpID0gbGVuZ3RoOyBpOyAtLWkpXG5cdCAgICB7IGQuZGVzdFtkLmRlc3RMZW4rK10gPSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4KytdOyB9XG5cblx0ICAvKiBtYWtlIHN1cmUgd2Ugc3RhcnQgbmV4dCBibG9jayBvbiBhIGJ5dGUgYm91bmRhcnkgKi9cblx0ICBkLmJpdGNvdW50ID0gMDtcblxuXHQgIHJldHVybiBUSU5GX09LO1xuXHR9XG5cblx0LyogaW5mbGF0ZSBzdHJlYW0gZnJvbSBzb3VyY2UgdG8gZGVzdCAqL1xuXHRmdW5jdGlvbiB0aW5mX3VuY29tcHJlc3Moc291cmNlLCBkZXN0KSB7XG5cdCAgdmFyIGQgPSBuZXcgRGF0YShzb3VyY2UsIGRlc3QpO1xuXHQgIHZhciBiZmluYWwsIGJ0eXBlLCByZXM7XG5cblx0ICBkbyB7XG5cdCAgICAvKiByZWFkIGZpbmFsIGJsb2NrIGZsYWcgKi9cblx0ICAgIGJmaW5hbCA9IHRpbmZfZ2V0Yml0KGQpO1xuXG5cdCAgICAvKiByZWFkIGJsb2NrIHR5cGUgKDIgYml0cykgKi9cblx0ICAgIGJ0eXBlID0gdGluZl9yZWFkX2JpdHMoZCwgMiwgMCk7XG5cblx0ICAgIC8qIGRlY29tcHJlc3MgYmxvY2sgKi9cblx0ICAgIHN3aXRjaCAoYnR5cGUpIHtcblx0ICAgICAgY2FzZSAwOlxuXHQgICAgICAgIC8qIGRlY29tcHJlc3MgdW5jb21wcmVzc2VkIGJsb2NrICovXG5cdCAgICAgICAgcmVzID0gdGluZl9pbmZsYXRlX3VuY29tcHJlc3NlZF9ibG9jayhkKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgY2FzZSAxOlxuXHQgICAgICAgIC8qIGRlY29tcHJlc3MgYmxvY2sgd2l0aCBmaXhlZCBodWZmbWFuIHRyZWVzICovXG5cdCAgICAgICAgcmVzID0gdGluZl9pbmZsYXRlX2Jsb2NrX2RhdGEoZCwgc2x0cmVlLCBzZHRyZWUpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlIDI6XG5cdCAgICAgICAgLyogZGVjb21wcmVzcyBibG9jayB3aXRoIGR5bmFtaWMgaHVmZm1hbiB0cmVlcyAqL1xuXHQgICAgICAgIHRpbmZfZGVjb2RlX3RyZWVzKGQsIGQubHRyZWUsIGQuZHRyZWUpO1xuXHQgICAgICAgIHJlcyA9IHRpbmZfaW5mbGF0ZV9ibG9ja19kYXRhKGQsIGQubHRyZWUsIGQuZHRyZWUpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBkZWZhdWx0OlxuXHQgICAgICAgIHJlcyA9IFRJTkZfREFUQV9FUlJPUjtcblx0ICAgIH1cblxuXHQgICAgaWYgKHJlcyAhPT0gVElORl9PSylcblx0ICAgICAgeyB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgZXJyb3InKTsgfVxuXG5cdCAgfSB3aGlsZSAoIWJmaW5hbCk7XG5cblx0ICBpZiAoZC5kZXN0TGVuIDwgZC5kZXN0Lmxlbmd0aCkge1xuXHQgICAgaWYgKHR5cGVvZiBkLmRlc3Quc2xpY2UgPT09ICdmdW5jdGlvbicpXG5cdCAgICAgIHsgcmV0dXJuIGQuZGVzdC5zbGljZSgwLCBkLmRlc3RMZW4pOyB9XG5cdCAgICBlbHNlXG5cdCAgICAgIHsgcmV0dXJuIGQuZGVzdC5zdWJhcnJheSgwLCBkLmRlc3RMZW4pOyB9XG5cdCAgfVxuXHQgIFxuXHQgIHJldHVybiBkLmRlc3Q7XG5cdH1cblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdCAqIC0tIGluaXRpYWxpemF0aW9uIC0tICpcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRyZWVzICovXG5cdHRpbmZfYnVpbGRfZml4ZWRfdHJlZXMoc2x0cmVlLCBzZHRyZWUpO1xuXG5cdC8qIGJ1aWxkIGV4dHJhIGJpdHMgYW5kIGJhc2UgdGFibGVzICovXG5cdHRpbmZfYnVpbGRfYml0c19iYXNlKGxlbmd0aF9iaXRzLCBsZW5ndGhfYmFzZSwgNCwgMyk7XG5cdHRpbmZfYnVpbGRfYml0c19iYXNlKGRpc3RfYml0cywgZGlzdF9iYXNlLCAyLCAxKTtcblxuXHQvKiBmaXggYSBzcGVjaWFsIGNhc2UgKi9cblx0bGVuZ3RoX2JpdHNbMjhdID0gMDtcblx0bGVuZ3RoX2Jhc2VbMjhdID0gMjU4O1xuXG5cdHZhciB0aW55SW5mbGF0ZSA9IHRpbmZfdW5jb21wcmVzcztcblxuXHQvLyBUaGUgQm91bmRpbmcgQm94IG9iamVjdFxuXG5cdGZ1bmN0aW9uIGRlcml2ZSh2MCwgdjEsIHYyLCB2MywgdCkge1xuXHQgICAgcmV0dXJuIE1hdGgucG93KDEgLSB0LCAzKSAqIHYwICtcblx0ICAgICAgICAzICogTWF0aC5wb3coMSAtIHQsIDIpICogdCAqIHYxICtcblx0ICAgICAgICAzICogKDEgLSB0KSAqIE1hdGgucG93KHQsIDIpICogdjIgK1xuXHQgICAgICAgIE1hdGgucG93KHQsIDMpICogdjM7XG5cdH1cblx0LyoqXG5cdCAqIEEgYm91bmRpbmcgYm94IGlzIGFuIGVuY2xvc2luZyBib3ggdGhhdCBkZXNjcmliZXMgdGhlIHNtYWxsZXN0IG1lYXN1cmUgd2l0aGluIHdoaWNoIGFsbCB0aGUgcG9pbnRzIGxpZS5cblx0ICogSXQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGJvdW5kaW5nIGJveCBvZiBhIGdseXBoIG9yIHRleHQgcGF0aC5cblx0ICpcblx0ICogT24gaW5pdGlhbGl6YXRpb24sIHgxL3kxL3gyL3kyIHdpbGwgYmUgTmFOLiBDaGVjayBpZiB0aGUgYm91bmRpbmcgYm94IGlzIGVtcHR5IHVzaW5nIGBpc0VtcHR5KClgLlxuXHQgKlxuXHQgKiBAZXhwb3J0cyBvcGVudHlwZS5Cb3VuZGluZ0JveFxuXHQgKiBAY2xhc3Ncblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBCb3VuZGluZ0JveCgpIHtcblx0ICAgIHRoaXMueDEgPSBOdW1iZXIuTmFOO1xuXHQgICAgdGhpcy55MSA9IE51bWJlci5OYU47XG5cdCAgICB0aGlzLngyID0gTnVtYmVyLk5hTjtcblx0ICAgIHRoaXMueTIgPSBOdW1iZXIuTmFOO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYm91bmRpbmcgYm94IGlzIGVtcHR5LCB0aGF0IGlzLCBubyBwb2ludHMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBib3ggeWV0LlxuXHQgKi9cblx0Qm91bmRpbmdCb3gucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBpc05hTih0aGlzLngxKSB8fCBpc05hTih0aGlzLnkxKSB8fCBpc05hTih0aGlzLngyKSB8fCBpc05hTih0aGlzLnkyKTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkIHRoZSBwb2ludCB0byB0aGUgYm91bmRpbmcgYm94LlxuXHQgKiBUaGUgeDEveTEveDIveTIgY29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kaW5nIGJveCB3aWxsIG5vdyBlbmNvbXBhc3MgdGhlIGdpdmVuIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuXHQgKi9cblx0Qm91bmRpbmdCb3gucHJvdG90eXBlLmFkZFBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuXHQgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgIGlmIChpc05hTih0aGlzLngxKSB8fCBpc05hTih0aGlzLngyKSkge1xuXHQgICAgICAgICAgICB0aGlzLngxID0geDtcblx0ICAgICAgICAgICAgdGhpcy54MiA9IHg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh4IDwgdGhpcy54MSkge1xuXHQgICAgICAgICAgICB0aGlzLngxID0geDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHggPiB0aGlzLngyKSB7XG5cdCAgICAgICAgICAgIHRoaXMueDIgPSB4O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgeSA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgICBpZiAoaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy55MikpIHtcblx0ICAgICAgICAgICAgdGhpcy55MSA9IHk7XG5cdCAgICAgICAgICAgIHRoaXMueTIgPSB5O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoeSA8IHRoaXMueTEpIHtcblx0ICAgICAgICAgICAgdGhpcy55MSA9IHk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh5ID4gdGhpcy55Mikge1xuXHQgICAgICAgICAgICB0aGlzLnkyID0geTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBhIFggY29vcmRpbmF0ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuXHQgKiBUaGlzIGV4dGVuZHMgdGhlIGJvdW5kaW5nIGJveCB0byBpbmNsdWRlIHRoZSBYIGNvb3JkaW5hdGUuXG5cdCAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnRlcm5hbGx5IGluc2lkZSBvZiBhZGRCZXppZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG5cdCAqL1xuXHRCb3VuZGluZ0JveC5wcm90b3R5cGUuYWRkWCA9IGZ1bmN0aW9uKHgpIHtcblx0ICAgIHRoaXMuYWRkUG9pbnQoeCwgbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBhIFkgY29vcmRpbmF0ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuXHQgKiBUaGlzIGV4dGVuZHMgdGhlIGJvdW5kaW5nIGJveCB0byBpbmNsdWRlIHRoZSBZIGNvb3JkaW5hdGUuXG5cdCAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnRlcm5hbGx5IGluc2lkZSBvZiBhZGRCZXppZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG5cdCAqL1xuXHRCb3VuZGluZ0JveC5wcm90b3R5cGUuYWRkWSA9IGZ1bmN0aW9uKHkpIHtcblx0ICAgIHRoaXMuYWRkUG9pbnQobnVsbCwgeSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBhIELDqXppZXIgY3VydmUgdG8gdGhlIGJvdW5kaW5nIGJveC5cblx0ICogVGhpcyBleHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSB0aGUgZW50aXJlIELDqXppZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4MCAtIFRoZSBzdGFydGluZyBYIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5MCAtIFRoZSBzdGFydGluZyBZIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4MSAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5MSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4MiAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geTIgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgZW5kaW5nIFggY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgZW5kaW5nIFkgY29vcmRpbmF0ZS5cblx0ICovXG5cdEJvdW5kaW5nQm94LnByb3RvdHlwZS5hZGRCZXppZXIgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG5cdCAgICAvLyBUaGlzIGNvZGUgaXMgYmFzZWQgb24gaHR0cDovL25pc2hpb2hpcm9rYXp1LmJsb2dzcG90LmNvbS8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXG5cdCAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2ljb25zOC9zdmctcGF0aC1ib3VuZGluZy1ib3hcblxuXHQgICAgdmFyIHAwID0gW3gwLCB5MF07XG5cdCAgICB2YXIgcDEgPSBbeDEsIHkxXTtcblx0ICAgIHZhciBwMiA9IFt4MiwgeTJdO1xuXHQgICAgdmFyIHAzID0gW3gsIHldO1xuXG5cdCAgICB0aGlzLmFkZFBvaW50KHgwLCB5MCk7XG5cdCAgICB0aGlzLmFkZFBvaW50KHgsIHkpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAxOyBpKyspIHtcblx0ICAgICAgICB2YXIgYiA9IDYgKiBwMFtpXSAtIDEyICogcDFbaV0gKyA2ICogcDJbaV07XG5cdCAgICAgICAgdmFyIGEgPSAtMyAqIHAwW2ldICsgOSAqIHAxW2ldIC0gOSAqIHAyW2ldICsgMyAqIHAzW2ldO1xuXHQgICAgICAgIHZhciBjID0gMyAqIHAxW2ldIC0gMyAqIHAwW2ldO1xuXG5cdCAgICAgICAgaWYgKGEgPT09IDApIHtcblx0ICAgICAgICAgICAgaWYgKGIgPT09IDApIHsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgdmFyIHQgPSAtYyAvIGI7XG5cdCAgICAgICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHsgdGhpcy5hZGRYKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdCkpOyB9XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSkgeyB0aGlzLmFkZFkoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0KSk7IH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgYjJhYyA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGMgKiBhO1xuXHQgICAgICAgIGlmIChiMmFjIDwgMCkgeyBjb250aW51ZTsgfVxuXHQgICAgICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuXHQgICAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG5cdCAgICAgICAgICAgIGlmIChpID09PSAwKSB7IHRoaXMuYWRkWChkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQxKSk7IH1cblx0ICAgICAgICAgICAgaWYgKGkgPT09IDEpIHsgdGhpcy5hZGRZKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdDEpKTsgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcblx0ICAgICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuXHQgICAgICAgICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzLmFkZFgoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0MikpOyB9XG5cdCAgICAgICAgICAgIGlmIChpID09PSAxKSB7IHRoaXMuYWRkWShkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQyKSk7IH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBhIHF1YWRyYXRpYyBjdXJ2ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuXHQgKiBUaGlzIGV4dGVuZHMgdGhlIGJvdW5kaW5nIGJveCB0byBpbmNsdWRlIHRoZSBlbnRpcmUgcXVhZHJhdGljIGN1cnZlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geDAgLSBUaGUgc3RhcnRpbmcgWCBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geTAgLSBUaGUgc3RhcnRpbmcgWSBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geDEgLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geTEgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBlbmRpbmcgWCBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBlbmRpbmcgWSBjb29yZGluYXRlLlxuXHQgKi9cblx0Qm91bmRpbmdCb3gucHJvdG90eXBlLmFkZFF1YWQgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSwgeCwgeSkge1xuXHQgICAgdmFyIGNwMXggPSB4MCArIDIgLyAzICogKHgxIC0geDApO1xuXHQgICAgdmFyIGNwMXkgPSB5MCArIDIgLyAzICogKHkxIC0geTApO1xuXHQgICAgdmFyIGNwMnggPSBjcDF4ICsgMSAvIDMgKiAoeCAtIHgwKTtcblx0ICAgIHZhciBjcDJ5ID0gY3AxeSArIDEgLyAzICogKHkgLSB5MCk7XG5cdCAgICB0aGlzLmFkZEJlemllcih4MCwgeTAsIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xuXHR9O1xuXG5cdC8vIEdlb21ldHJpYyBvYmplY3RzXG5cblx0LyoqXG5cdCAqIEEgYsOpemllciBwYXRoIGNvbnRhaW5pbmcgYSBzZXQgb2YgcGF0aCBjb21tYW5kcyBzaW1pbGFyIHRvIGEgU1ZHIHBhdGguXG5cdCAqIFBhdGhzIGNhbiBiZSBkcmF3biBvbiBhIGNvbnRleHQgdXNpbmcgYGRyYXdgLlxuXHQgKiBAZXhwb3J0cyBvcGVudHlwZS5QYXRoXG5cdCAqIEBjbGFzc1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFBhdGgoKSB7XG5cdCAgICB0aGlzLmNvbW1hbmRzID0gW107XG5cdCAgICB0aGlzLmZpbGwgPSAnYmxhY2snO1xuXHQgICAgdGhpcy5zdHJva2UgPSBudWxsO1xuXHQgICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtICB7bnVtYmVyfSB4XG5cdCAqIEBwYXJhbSAge251bWJlcn0geVxuXHQgKi9cblx0UGF0aC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuXHQgICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcblx0ICAgICAgICB0eXBlOiAnTScsXG5cdCAgICAgICAgeDogeCxcblx0ICAgICAgICB5OiB5XG5cdCAgICB9KTtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtICB7bnVtYmVyfSB4XG5cdCAqIEBwYXJhbSAge251bWJlcn0geVxuXHQgKi9cblx0UGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuXHQgICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcblx0ICAgICAgICB0eXBlOiAnTCcsXG5cdCAgICAgICAgeDogeCxcblx0ICAgICAgICB5OiB5XG5cdCAgICB9KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgY3ViaWMgY3VydmVcblx0ICogQGZ1bmN0aW9uXG5cdCAqIGN1cnZlVG9cblx0ICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG5cdCAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2wgMVxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sIDFcblx0ICogQHBhcmFtICB7bnVtYmVyfSB4MiAtIHggb2YgY29udHJvbCAyXG5cdCAqIEBwYXJhbSAge251bWJlcn0geTIgLSB5IG9mIGNvbnRyb2wgMlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcblx0ICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBjdWJpYyBjdXJ2ZVxuXHQgKiBAZnVuY3Rpb25cblx0ICogYmV6aWVyQ3VydmVUb1xuXHQgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcblx0ICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbCAxXG5cdCAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2wgMVxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHgyIC0geCBvZiBjb250cm9sIDJcblx0ICogQHBhcmFtICB7bnVtYmVyfSB5MiAtIHkgb2YgY29udHJvbCAyXG5cdCAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcblx0ICogQHNlZSBjdXJ2ZVRvXG5cdCAqL1xuXHRQYXRoLnByb3RvdHlwZS5jdXJ2ZVRvID0gUGF0aC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG5cdCAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuXHQgICAgICAgIHR5cGU6ICdDJyxcblx0ICAgICAgICB4MTogeDEsXG5cdCAgICAgICAgeTE6IHkxLFxuXHQgICAgICAgIHgyOiB4Mixcblx0ICAgICAgICB5MjogeTIsXG5cdCAgICAgICAgeDogeCxcblx0ICAgICAgICB5OiB5XG5cdCAgICB9KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgcXVhZHJhdGljIGN1cnZlXG5cdCAqIEBmdW5jdGlvblxuXHQgKiBxdWFkcmF0aWNDdXJ2ZVRvXG5cdCAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sXG5cdCAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2xcblx0ICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG5cdCAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuXHQgKi9cblxuXHQvKipcblx0ICogRHJhd3MgcXVhZHJhdGljIGN1cnZlXG5cdCAqIEBmdW5jdGlvblxuXHQgKiBxdWFkVG9cblx0ICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG5cdCAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2xcblx0ICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbFxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcblx0ICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG5cdCAqL1xuXHRQYXRoLnByb3RvdHlwZS5xdWFkVG8gPSBQYXRoLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24oeDEsIHkxLCB4LCB5KSB7XG5cdCAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuXHQgICAgICAgIHR5cGU6ICdRJyxcblx0ICAgICAgICB4MTogeDEsXG5cdCAgICAgICAgeTE6IHkxLFxuXHQgICAgICAgIHg6IHgsXG5cdCAgICAgICAgeTogeVxuXHQgICAgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlcyB0aGUgcGF0aFxuXHQgKiBAZnVuY3Rpb24gY2xvc2VQYXRoXG5cdCAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuXHQgKi9cblxuXHQvKipcblx0ICogQ2xvc2UgdGhlIHBhdGhcblx0ICogQGZ1bmN0aW9uIGNsb3NlXG5cdCAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuXHQgKi9cblx0UGF0aC5wcm90b3R5cGUuY2xvc2UgPSBQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcblx0ICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG5cdCAgICAgICAgdHlwZTogJ1onXG5cdCAgICB9KTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkIHRoZSBnaXZlbiBwYXRoIG9yIGxpc3Qgb2YgY29tbWFuZHMgdG8gdGhlIGNvbW1hbmRzIG9mIHRoaXMgcGF0aC5cblx0ICogQHBhcmFtICB7QXJyYXl9IHBhdGhPckNvbW1hbmRzIC0gYW5vdGhlciBvcGVudHlwZS5QYXRoLCBhbiBvcGVudHlwZS5Cb3VuZGluZ0JveCwgb3IgYW4gYXJyYXkgb2YgY29tbWFuZHMuXG5cdCAqL1xuXHRQYXRoLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihwYXRoT3JDb21tYW5kcykge1xuXHQgICAgaWYgKHBhdGhPckNvbW1hbmRzLmNvbW1hbmRzKSB7XG5cdCAgICAgICAgcGF0aE9yQ29tbWFuZHMgPSBwYXRoT3JDb21tYW5kcy5jb21tYW5kcztcblx0ICAgIH0gZWxzZSBpZiAocGF0aE9yQ29tbWFuZHMgaW5zdGFuY2VvZiBCb3VuZGluZ0JveCkge1xuXHQgICAgICAgIHZhciBib3ggPSBwYXRoT3JDb21tYW5kcztcblx0ICAgICAgICB0aGlzLm1vdmVUbyhib3gueDEsIGJveC55MSk7XG5cdCAgICAgICAgdGhpcy5saW5lVG8oYm94LngyLCBib3gueTEpO1xuXHQgICAgICAgIHRoaXMubGluZVRvKGJveC54MiwgYm94LnkyKTtcblx0ICAgICAgICB0aGlzLmxpbmVUbyhib3gueDEsIGJveC55Mik7XG5cdCAgICAgICAgdGhpcy5jbG9zZSgpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5jb21tYW5kcywgcGF0aE9yQ29tbWFuZHMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgcGF0aC5cblx0ICogQHJldHVybnMge29wZW50eXBlLkJvdW5kaW5nQm94fVxuXHQgKi9cblx0UGF0aC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBib3ggPSBuZXcgQm91bmRpbmdCb3goKTtcblxuXHQgICAgdmFyIHN0YXJ0WCA9IDA7XG5cdCAgICB2YXIgc3RhcnRZID0gMDtcblx0ICAgIHZhciBwcmV2WCA9IDA7XG5cdCAgICB2YXIgcHJldlkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG5cdCAgICAgICAgc3dpdGNoIChjbWQudHlwZSkge1xuXHQgICAgICAgICAgICBjYXNlICdNJzpcblx0ICAgICAgICAgICAgICAgIGJveC5hZGRQb2ludChjbWQueCwgY21kLnkpO1xuXHQgICAgICAgICAgICAgICAgc3RhcnRYID0gcHJldlggPSBjbWQueDtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0WSA9IHByZXZZID0gY21kLnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnTCc6XG5cdCAgICAgICAgICAgICAgICBib3guYWRkUG9pbnQoY21kLngsIGNtZC55KTtcblx0ICAgICAgICAgICAgICAgIHByZXZYID0gY21kLng7XG5cdCAgICAgICAgICAgICAgICBwcmV2WSA9IGNtZC55O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ1EnOlxuXHQgICAgICAgICAgICAgICAgYm94LmFkZFF1YWQocHJldlgsIHByZXZZLCBjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcblx0ICAgICAgICAgICAgICAgIHByZXZYID0gY21kLng7XG5cdCAgICAgICAgICAgICAgICBwcmV2WSA9IGNtZC55O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ0MnOlxuXHQgICAgICAgICAgICAgICAgYm94LmFkZEJlemllcihwcmV2WCwgcHJldlksIGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcblx0ICAgICAgICAgICAgICAgIHByZXZYID0gY21kLng7XG5cdCAgICAgICAgICAgICAgICBwcmV2WSA9IGNtZC55O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ1onOlxuXHQgICAgICAgICAgICAgICAgcHJldlggPSBzdGFydFg7XG5cdCAgICAgICAgICAgICAgICBwcmV2WSA9IHN0YXJ0WTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhdGggY29tbWFuZCAnICsgY21kLnR5cGUpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChib3guaXNFbXB0eSgpKSB7XG5cdCAgICAgICAgYm94LmFkZFBvaW50KDAsIDApO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGJveDtcblx0fTtcblxuXHQvKipcblx0ICogRHJhdyB0aGUgcGF0aCB0byBhIDJEIGNvbnRleHQuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dC5cblx0ICovXG5cdFBhdGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgpIHtcblx0ICAgIGN0eC5iZWdpblBhdGgoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBjbWQgPSB0aGlzLmNvbW1hbmRzW2ldO1xuXHQgICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG5cdCAgICAgICAgICAgIGN0eC5tb3ZlVG8oY21kLngsIGNtZC55KTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcblx0ICAgICAgICAgICAgY3R4LmxpbmVUbyhjbWQueCwgY21kLnkpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuXHQgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjbWQueDEsIGNtZC55MSwgY21kLngyLCBjbWQueTIsIGNtZC54LCBjbWQueSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG5cdCAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNtZC54MSwgY21kLnkxLCBjbWQueCwgY21kLnkpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuXHQgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5maWxsKSB7XG5cdCAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZmlsbDtcblx0ICAgICAgICBjdHguZmlsbCgpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5zdHJva2UpIHtcblx0ICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZTtcblx0ICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aDtcblx0ICAgICAgICBjdHguc3Ryb2tlKCk7XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhlIFBhdGggdG8gYSBzdHJpbmcgb2YgcGF0aCBkYXRhIGluc3RydWN0aW9uc1xuXHQgKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcblx0ICogQHBhcmFtICB7bnVtYmVyfSBbZGVjaW1hbFBsYWNlcz0yXSAtIFRoZSBhbW91bnQgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGZsb2F0aW5nLXBvaW50IHZhbHVlc1xuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRQYXRoLnByb3RvdHlwZS50b1BhdGhEYXRhID0gZnVuY3Rpb24oZGVjaW1hbFBsYWNlcykge1xuXHQgICAgZGVjaW1hbFBsYWNlcyA9IGRlY2ltYWxQbGFjZXMgIT09IHVuZGVmaW5lZCA/IGRlY2ltYWxQbGFjZXMgOiAyO1xuXG5cdCAgICBmdW5jdGlvbiBmbG9hdFRvU3RyaW5nKHYpIHtcblx0ICAgICAgICBpZiAoTWF0aC5yb3VuZCh2KSA9PT0gdikge1xuXHQgICAgICAgICAgICByZXR1cm4gJycgKyBNYXRoLnJvdW5kKHYpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2LnRvRml4ZWQoZGVjaW1hbFBsYWNlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwYWNrVmFsdWVzKCkge1xuXHQgICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuXHQgICAgICAgIHZhciBzID0gJyc7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgdmFyIHYgPSBhcmd1bWVudHMkMVtpXTtcblx0ICAgICAgICAgICAgaWYgKHYgPj0gMCAmJiBpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgcyArPSAnICc7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBzICs9IGZsb2F0VG9TdHJpbmcodik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHM7XG5cdCAgICB9XG5cblx0ICAgIHZhciBkID0gJyc7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgY21kID0gdGhpcy5jb21tYW5kc1tpXTtcblx0ICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuXHQgICAgICAgICAgICBkICs9ICdNJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcblx0ICAgICAgICAgICAgZCArPSAnTCcgKyBwYWNrVmFsdWVzKGNtZC54LCBjbWQueSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG5cdCAgICAgICAgICAgIGQgKz0gJ0MnICsgcGFja1ZhbHVlcyhjbWQueDEsIGNtZC55MSwgY21kLngyLCBjbWQueTIsIGNtZC54LCBjbWQueSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG5cdCAgICAgICAgICAgIGQgKz0gJ1EnICsgcGFja1ZhbHVlcyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcblx0ICAgICAgICAgICAgZCArPSAnWic7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZDtcblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydCB0aGUgcGF0aCB0byBhbiBTVkcgPHBhdGg+IGVsZW1lbnQsIGFzIGEgc3RyaW5nLlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFtkZWNpbWFsUGxhY2VzPTJdIC0gVGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgZmxvYXRpbmctcG9pbnQgdmFsdWVzXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdFBhdGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oZGVjaW1hbFBsYWNlcykge1xuXHQgICAgdmFyIHN2ZyA9ICc8cGF0aCBkPVwiJztcblx0ICAgIHN2ZyArPSB0aGlzLnRvUGF0aERhdGEoZGVjaW1hbFBsYWNlcyk7XG5cdCAgICBzdmcgKz0gJ1wiJztcblx0ICAgIGlmICh0aGlzLmZpbGwgJiYgdGhpcy5maWxsICE9PSAnYmxhY2snKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuZmlsbCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICBzdmcgKz0gJyBmaWxsPVwibm9uZVwiJztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBzdmcgKz0gJyBmaWxsPVwiJyArIHRoaXMuZmlsbCArICdcIic7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5zdHJva2UpIHtcblx0ICAgICAgICBzdmcgKz0gJyBzdHJva2U9XCInICsgdGhpcy5zdHJva2UgKyAnXCIgc3Ryb2tlLXdpZHRoPVwiJyArIHRoaXMuc3Ryb2tlV2lkdGggKyAnXCInO1xuXHQgICAgfVxuXG5cdCAgICBzdmcgKz0gJy8+Jztcblx0ICAgIHJldHVybiBzdmc7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhlIHBhdGggdG8gYSBET00gZWxlbWVudC5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbZGVjaW1hbFBsYWNlcz0yXSAtIFRoZSBhbW91bnQgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGZsb2F0aW5nLXBvaW50IHZhbHVlc1xuXHQgKiBAcmV0dXJuIHtTVkdQYXRoRWxlbWVudH1cblx0ICovXG5cdFBhdGgucHJvdG90eXBlLnRvRE9NRWxlbWVudCA9IGZ1bmN0aW9uKGRlY2ltYWxQbGFjZXMpIHtcblx0ICAgIHZhciB0ZW1wb3JhcnlQYXRoID0gdGhpcy50b1BhdGhEYXRhKGRlY2ltYWxQbGFjZXMpO1xuXHQgICAgdmFyIG5ld1BhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcblxuXHQgICAgbmV3UGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCB0ZW1wb3JhcnlQYXRoKTtcblxuXHQgICAgcmV0dXJuIG5ld1BhdGg7XG5cdH07XG5cblx0Ly8gUnVuLXRpbWUgY2hlY2tpbmcgb2YgcHJlY29uZGl0aW9ucy5cblxuXHRmdW5jdGlvbiBmYWlsKG1lc3NhZ2UpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcblx0fVxuXG5cdC8vIFByZWNvbmRpdGlvbiBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGUgZ2l2ZW4gcHJlZGljYXRlIGlzIHRydWUuXG5cdC8vIElmIG5vdCwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cblx0ZnVuY3Rpb24gYXJndW1lbnQocHJlZGljYXRlLCBtZXNzYWdlKSB7XG5cdCAgICBpZiAoIXByZWRpY2F0ZSkge1xuXHQgICAgICAgIGZhaWwobWVzc2FnZSk7XG5cdCAgICB9XG5cdH1cblx0dmFyIGNoZWNrID0geyBmYWlsOiBmYWlsLCBhcmd1bWVudDogYXJndW1lbnQsIGFzc2VydDogYXJndW1lbnQgfTtcblxuXHQvLyBEYXRhIHR5cGVzIHVzZWQgaW4gdGhlIE9wZW5UeXBlIGZvbnQgZmlsZS5cblxuXHR2YXIgTElNSVQxNiA9IDMyNzY4OyAvLyBUaGUgbGltaXQgYXQgd2hpY2ggYSAxNi1iaXQgbnVtYmVyIHN3aXRjaGVzIHNpZ25zID09IDJeMTVcblx0dmFyIExJTUlUMzIgPSAyMTQ3NDgzNjQ4OyAvLyBUaGUgbGltaXQgYXQgd2hpY2ggYSAzMi1iaXQgbnVtYmVyIHN3aXRjaGVzIHNpZ25zID09IDIgXiAzMVxuXG5cdC8qKlxuXHQgKiBAZXhwb3J0cyBvcGVudHlwZS5kZWNvZGVcblx0ICogQGNsYXNzXG5cdCAqL1xuXHR2YXIgZGVjb2RlID0ge307XG5cdC8qKlxuXHQgKiBAZXhwb3J0cyBvcGVudHlwZS5lbmNvZGVcblx0ICogQGNsYXNzXG5cdCAqL1xuXHR2YXIgZW5jb2RlID0ge307XG5cdC8qKlxuXHQgKiBAZXhwb3J0cyBvcGVudHlwZS5zaXplT2Zcblx0ICogQGNsYXNzXG5cdCAqL1xuXHR2YXIgc2l6ZU9mID0ge307XG5cblx0Ly8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSB2YWx1ZS5cblx0ZnVuY3Rpb24gY29uc3RhbnQodikge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiB2O1xuXHQgICAgfTtcblx0fVxuXG5cdC8vIE9wZW5UeXBlIGRhdGEgdHlwZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYW4gOC1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMSBieXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLkJZVEUgPSBmdW5jdGlvbih2KSB7XG5cdCAgICBjaGVjay5hcmd1bWVudCh2ID49IDAgJiYgdiA8PSAyNTUsICdCeXRlIHZhbHVlIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS4nKTtcblx0ICAgIHJldHVybiBbdl07XG5cdH07XG5cdC8qKlxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5CWVRFID0gY29uc3RhbnQoMSk7XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYSA4LWJpdCBzaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMSBieXRlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ31cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLkNIQVIgPSBmdW5jdGlvbih2KSB7XG5cdCAgICByZXR1cm4gW3YuY2hhckNvZGVBdCgwKV07XG5cdH07XG5cblx0LyoqXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZU9mLkNIQVIgPSBjb25zdGFudCgxKTtcblxuXHQvKipcblx0ICogQ29udmVydCBhbiBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIGJ5dGVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ31cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLkNIQVJBUlJBWSA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIGlmICh0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICB2ID0gJyc7XG5cdCAgICAgICAgY29uc29sZS53YXJuKCdVbmRlZmluZWQgQ0hBUkFSUkFZIGVuY291bnRlcmVkIGFuZCB0cmVhdGVkIGFzIGFuIGVtcHR5IHN0cmluZy4gVGhpcyBpcyBwcm9iYWJseSBjYXVzZWQgYnkgYSBtaXNzaW5nIGdseXBoIG5hbWUuJyk7XG5cdCAgICB9XG5cdCAgICB2YXIgYiA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgYltpXSA9IHYuY2hhckNvZGVBdChpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGI7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QXJyYXl9XG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuQ0hBUkFSUkFZID0gZnVuY3Rpb24odikge1xuXHQgICAgaWYgKHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHYubGVuZ3RoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgMTYtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDIgYnl0ZXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuVVNIT1JUID0gZnVuY3Rpb24odikge1xuXHQgICAgcmV0dXJuIFsodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcblx0fTtcblxuXHQvKipcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuVVNIT1JUID0gY29uc3RhbnQoMik7XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYSAxNi1iaXQgc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDIgYnl0ZXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuU0hPUlQgPSBmdW5jdGlvbih2KSB7XG5cdCAgICAvLyBUd28ncyBjb21wbGVtZW50XG5cdCAgICBpZiAodiA+PSBMSU1JVDE2KSB7XG5cdCAgICAgICAgdiA9IC0oMiAqIExJTUlUMTYgLSB2KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIFsodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcblx0fTtcblxuXHQvKipcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuU0hPUlQgPSBjb25zdGFudCgyKTtcblxuXHQvKipcblx0ICogQ29udmVydCBhIDI0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAzIGJ5dGVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLlVJTlQyNCA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHJldHVybiBbKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG5cdH07XG5cblx0LyoqXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZU9mLlVJTlQyNCA9IGNvbnN0YW50KDMpO1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgMzItYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDQgYnl0ZXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuVUxPTkcgPSBmdW5jdGlvbih2KSB7XG5cdCAgICByZXR1cm4gWyh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5VTE9ORyA9IGNvbnN0YW50KDQpO1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgMzItYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDQgYnl0ZXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuTE9ORyA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIC8vIFR3bydzIGNvbXBsZW1lbnRcblx0ICAgIGlmICh2ID49IExJTUlUMzIpIHtcblx0ICAgICAgICB2ID0gLSgyICogTElNSVQzMiAtIHYpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gWyh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5MT05HID0gY29uc3RhbnQoNCk7XG5cblx0ZW5jb2RlLkZJWEVEID0gZW5jb2RlLlVMT05HO1xuXHRzaXplT2YuRklYRUQgPSBzaXplT2YuVUxPTkc7XG5cblx0ZW5jb2RlLkZXT1JEID0gZW5jb2RlLlNIT1JUO1xuXHRzaXplT2YuRldPUkQgPSBzaXplT2YuU0hPUlQ7XG5cblx0ZW5jb2RlLlVGV09SRCA9IGVuY29kZS5VU0hPUlQ7XG5cdHNpemVPZi5VRldPUkQgPSBzaXplT2YuVVNIT1JUO1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgMzItYml0IEFwcGxlIE1hYyB0aW1lc3RhbXAgaW50ZWdlciB0byBhIGxpc3Qgb2YgOCBieXRlcywgNjQtYml0IHRpbWVzdGFtcC5cblx0ICogQHBhcmFtIHtudW1iZXJ9XG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGVuY29kZS5MT05HREFURVRJTUUgPSBmdW5jdGlvbih2KSB7XG5cdCAgICByZXR1cm4gWzAsIDAsIDAsIDAsICh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5MT05HREFURVRJTUUgPSBjb25zdGFudCg4KTtcblxuXHQvKipcblx0ICogQ29udmVydCBhIDQtY2hhciB0YWcgdG8gYSBsaXN0IG9mIDQgYnl0ZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuVEFHID0gZnVuY3Rpb24odikge1xuXHQgICAgY2hlY2suYXJndW1lbnQodi5sZW5ndGggPT09IDQsICdUYWcgc2hvdWxkIGJlIGV4YWN0bHkgNCBBU0NJSSBjaGFyYWN0ZXJzLicpO1xuXHQgICAgcmV0dXJuIFt2LmNoYXJDb2RlQXQoMCksXG5cdCAgICAgICAgICAgIHYuY2hhckNvZGVBdCgxKSxcblx0ICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDIpLFxuXHQgICAgICAgICAgICB2LmNoYXJDb2RlQXQoMyldO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5UQUcgPSBjb25zdGFudCg0KTtcblxuXHQvLyBDRkYgZGF0YSB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdGVuY29kZS5DYXJkOCA9IGVuY29kZS5CWVRFO1xuXHRzaXplT2YuQ2FyZDggPSBzaXplT2YuQllURTtcblxuXHRlbmNvZGUuQ2FyZDE2ID0gZW5jb2RlLlVTSE9SVDtcblx0c2l6ZU9mLkNhcmQxNiA9IHNpemVPZi5VU0hPUlQ7XG5cblx0ZW5jb2RlLk9mZlNpemUgPSBlbmNvZGUuQllURTtcblx0c2l6ZU9mLk9mZlNpemUgPSBzaXplT2YuQllURTtcblxuXHRlbmNvZGUuU0lEID0gZW5jb2RlLlVTSE9SVDtcblx0c2l6ZU9mLlNJRCA9IHNpemVPZi5VU0hPUlQ7XG5cblx0Ly8gQ29udmVydCBhIG51bWVyaWMgb3BlcmFuZCBvciBjaGFyc3RyaW5nIG51bWJlciB0byBhIHZhcmlhYmxlLXNpemUgbGlzdCBvZiBieXRlcy5cblx0LyoqXG5cdCAqIENvbnZlcnQgYSBudW1lcmljIG9wZXJhbmQgb3IgY2hhcnN0cmluZyBudW1iZXIgdG8gYSB2YXJpYWJsZS1zaXplIGxpc3Qgb2YgYnl0ZXMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuTlVNQkVSID0gZnVuY3Rpb24odikge1xuXHQgICAgaWYgKHYgPj0gLTEwNyAmJiB2IDw9IDEwNykge1xuXHQgICAgICAgIHJldHVybiBbdiArIDEzOV07XG5cdCAgICB9IGVsc2UgaWYgKHYgPj0gMTA4ICYmIHYgPD0gMTEzMSkge1xuXHQgICAgICAgIHYgPSB2IC0gMTA4O1xuXHQgICAgICAgIHJldHVybiBbKHYgPj4gOCkgKyAyNDcsIHYgJiAweEZGXTtcblx0ICAgIH0gZWxzZSBpZiAodiA+PSAtMTEzMSAmJiB2IDw9IC0xMDgpIHtcblx0ICAgICAgICB2ID0gLXYgLSAxMDg7XG5cdCAgICAgICAgcmV0dXJuIFsodiA+PiA4KSArIDI1MSwgdiAmIDB4RkZdO1xuXHQgICAgfSBlbHNlIGlmICh2ID49IC0zMjc2OCAmJiB2IDw9IDMyNzY3KSB7XG5cdCAgICAgICAgcmV0dXJuIGVuY29kZS5OVU1CRVIxNih2KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIGVuY29kZS5OVU1CRVIzMih2KTtcblx0ICAgIH1cblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9XG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuTlVNQkVSID0gZnVuY3Rpb24odikge1xuXHQgICAgcmV0dXJuIGVuY29kZS5OVU1CRVIodikubGVuZ3RoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgc2lnbmVkIG51bWJlciBiZXR3ZWVuIC0zMjc2OCBhbmQgKzMyNzY3IHRvIGEgdGhyZWUtYnl0ZSB2YWx1ZS5cblx0ICogVGhpcyBlbnN1cmVzIHdlIGFsd2F5cyB1c2UgdGhyZWUgYnl0ZXMsIGJ1dCBpcyBub3QgdGhlIG1vc3QgY29tcGFjdCBmb3JtYXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuTlVNQkVSMTYgPSBmdW5jdGlvbih2KSB7XG5cdCAgICByZXR1cm4gWzI4LCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcblx0fTtcblxuXHQvKipcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuTlVNQkVSMTYgPSBjb25zdGFudCgzKTtcblxuXHQvKipcblx0ICogQ29udmVydCBhIHNpZ25lZCBudW1iZXIgYmV0d2VlbiAtKDJeMzEpIGFuZCArKDJeMzEtMSkgdG8gYSBmaXZlLWJ5dGUgdmFsdWUuXG5cdCAqIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGJlIHN1cmUgeW91IGFsd2F5cyB1c2UgZm91ciBieXRlcyxcblx0ICogYXQgdGhlIGV4cGVuc2Ugb2Ygd2FzdGluZyBhIGZldyBieXRlcyBmb3Igc21hbGxlciBudW1iZXJzLlxuXHQgKiBAcGFyYW0ge251bWJlcn1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLk5VTUJFUjMyID0gZnVuY3Rpb24odikge1xuXHQgICAgcmV0dXJuIFsyOSwgKHYgPj4gMjQpICYgMHhGRiwgKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG5cdH07XG5cblx0LyoqXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZU9mLk5VTUJFUjMyID0gY29uc3RhbnQoNSk7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuUkVBTCA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHZhciB2YWx1ZSA9IHYudG9TdHJpbmcoKTtcblxuXHQgICAgLy8gU29tZSBudW1iZXJzIHVzZSBhbiBlcHNpbG9uIHRvIGVuY29kZSB0aGUgdmFsdWUuIChlLmcuIEphdmFTY3JpcHQgd2lsbCBzdG9yZSAwLjAwMDAwMDEgYXMgMWUtNylcblx0ICAgIC8vIFRoaXMgY29kZSBjb252ZXJ0cyBpdCBiYWNrIHRvIGEgbnVtYmVyIHdpdGhvdXQgdGhlIGVwc2lsb24uXG5cdCAgICB2YXIgbSA9IC9cXC4oXFxkKj8pKD86OXs1LDIwfXwwezUsMjB9KVxcZHswLDJ9KD86ZSguKyl8JCkvLmV4ZWModmFsdWUpO1xuXHQgICAgaWYgKG0pIHtcblx0ICAgICAgICB2YXIgZXBzaWxvbiA9IHBhcnNlRmxvYXQoJzFlJyArICgobVsyXSA/ICttWzJdIDogMCkgKyBtWzFdLmxlbmd0aCkpO1xuXHQgICAgICAgIHZhbHVlID0gKE1hdGgucm91bmQodiAqIGVwc2lsb24pIC8gZXBzaWxvbikudG9TdHJpbmcoKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIG5pYmJsZXMgPSAnJztcblx0ICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHZhbHVlLmxlbmd0aDsgaSA8IGlpOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgYyA9IHZhbHVlW2ldO1xuXHQgICAgICAgIGlmIChjID09PSAnZScpIHtcblx0ICAgICAgICAgICAgbmliYmxlcyArPSB2YWx1ZVsrK2ldID09PSAnLScgPyAnYycgOiAnYic7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLicpIHtcblx0ICAgICAgICAgICAgbmliYmxlcyArPSAnYSc7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLScpIHtcblx0ICAgICAgICAgICAgbmliYmxlcyArPSAnZSc7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgbmliYmxlcyArPSBjO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgbmliYmxlcyArPSAobmliYmxlcy5sZW5ndGggJiAxKSA/ICdmJyA6ICdmZic7XG5cdCAgICB2YXIgb3V0ID0gWzMwXTtcblx0ICAgIGZvciAodmFyIGkkMSA9IDAsIGlpJDEgPSBuaWJibGVzLmxlbmd0aDsgaSQxIDwgaWkkMTsgaSQxICs9IDIpIHtcblx0ICAgICAgICBvdXQucHVzaChwYXJzZUludChuaWJibGVzLnN1YnN0cihpJDEsIDIpLCAxNikpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb3V0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn1cblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5SRUFMID0gZnVuY3Rpb24odikge1xuXHQgICAgcmV0dXJuIGVuY29kZS5SRUFMKHYpLmxlbmd0aDtcblx0fTtcblxuXHRlbmNvZGUuTkFNRSA9IGVuY29kZS5DSEFSQVJSQVk7XG5cdHNpemVPZi5OQU1FID0gc2l6ZU9mLkNIQVJBUlJBWTtcblxuXHRlbmNvZGUuU1RSSU5HID0gZW5jb2RlLkNIQVJBUlJBWTtcblx0c2l6ZU9mLlNUUklORyA9IHNpemVPZi5DSEFSQVJSQVk7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuXHQgKiBAcGFyYW0ge251bWJlcn0gbnVtQnl0ZXNcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGRlY29kZS5VVEY4ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBudW1CeXRlcykge1xuXHQgICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcblx0ICAgIHZhciBudW1DaGFycyA9IG51bUJ5dGVzO1xuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1DaGFyczsgaisrLCBvZmZzZXQgKz0gMSkge1xuXHQgICAgICAgIGNvZGVQb2ludHNbal0gPSBkYXRhLmdldFVpbnQ4KG9mZnNldCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVQb2ludHMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcblx0ICogQHBhcmFtIHtudW1iZXJ9IG51bUJ5dGVzXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRkZWNvZGUuVVRGMTYgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIG51bUJ5dGVzKSB7XG5cdCAgICB2YXIgY29kZVBvaW50cyA9IFtdO1xuXHQgICAgdmFyIG51bUNoYXJzID0gbnVtQnl0ZXMgLyAyO1xuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1DaGFyczsgaisrLCBvZmZzZXQgKz0gMikge1xuXHQgICAgICAgIGNvZGVQb2ludHNbal0gPSBkYXRhLmdldFVpbnQxNihvZmZzZXQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydCBhIEphdmFTY3JpcHQgc3RyaW5nIHRvIFVURjE2LUJFLlxuXHQgKiBAcGFyYW0ge3N0cmluZ31cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLlVURjE2ID0gZnVuY3Rpb24odikge1xuXHQgICAgdmFyIGIgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBjb2RlcG9pbnQgPSB2LmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgYltiLmxlbmd0aF0gPSAoY29kZXBvaW50ID4+IDgpICYgMHhGRjtcblx0ICAgICAgICBiW2IubGVuZ3RoXSA9IGNvZGVwb2ludCAmIDB4RkY7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ31cblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5VVEYxNiA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHJldHVybiB2Lmxlbmd0aCAqIDI7XG5cdH07XG5cblx0Ly8gRGF0YSBmb3IgY29udmVydGluZyBvbGQgZWlnaHQtYml0IE1hY2ludG9zaCBlbmNvZGluZ3MgdG8gVW5pY29kZS5cblx0Ly8gVGhpcyByZXByZXNlbnRhdGlvbiBpcyBvcHRpbWl6ZWQgZm9yIGRlY29kaW5nOyBlbmNvZGluZyBpcyBzbG93ZXJcblx0Ly8gYW5kIG5lZWRzIG1vcmUgbWVtb3J5LiBUaGUgYXNzdW1wdGlvbiBpcyB0aGF0IGFsbCBvcGVudHlwZS5qcyB1c2Vyc1xuXHQvLyB3YW50IHRvIG9wZW4gZm9udHMsIGJ1dCBzYXZpbmcgYSBmb250IHdpbGwgYmUgY29tcGFyYXRpdmVseSByYXJlXG5cdC8vIHNvIGl0IGNhbiBiZSBtb3JlIGV4cGVuc2l2ZS4gS2V5ZWQgYnkgSUFOQSBjaGFyYWN0ZXIgc2V0IG5hbWUuXG5cdC8vXG5cdC8vIFB5dGhvbiBzY3JpcHQgZm9yIGdlbmVyYXRpbmcgdGhlc2Ugc3RyaW5nczpcblx0Ly9cblx0Ly8gICAgIHMgPSB1Jycuam9pbihbY2hyKGMpLmRlY29kZSgnbWFjX2dyZWVrJykgZm9yIGMgaW4gcmFuZ2UoMTI4LCAyNTYpXSlcblx0Ly8gICAgIHByaW50KHMuZW5jb2RlKCd1dGYtOCcpKVxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHZhciBlaWdodEJpdE1hY0VuY29kaW5ncyA9IHtcblx0ICAgICd4LW1hYy1jcm9hdGlhbic6ICAvLyBQeXRob246ICdtYWNfY3JvYXRpYW4nXG5cdCAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuxaDihKLCtMKo4omgxb3DmOKInsKx4omk4oml4oiGwrXiiILiiJHiiI/FoeKIq8KqwrrOqcW+w7gnICtcblx0ICAgICfCv8KhwqziiJrGkuKJiMSGwqvEjOKApsKgw4DDg8OVxZLFk8SQ4oCU4oCc4oCd4oCY4oCZw7fil4rvo7/CqeKBhOKCrOKAueKAusOGwrvigJPCt+KAmuKAnuKAsMOCxIfDgcSNw4jDjcOOw4/DjMOTw5TEkcOSw5rDm8OZxLHLhsucwq/PgMOLy5rCuMOKw6bLhycsXG5cdCAgICAneC1tYWMtY3lyaWxsaWMnOiAgLy8gUHl0aG9uOiAnbWFjX2N5cmlsbGljJ1xuXHQgICAgJ9CQ0JHQktCT0JTQldCW0JfQmNCZ0JrQm9Cc0J3QntCf0KDQodCi0KPQpNCl0KbQp9Co0KnQqtCr0KzQrdCu0K/igKDCsNKQwqPCp+KAosK20IbCrsKp4oSi0ILRkuKJoNCD0ZPiiJ7CseKJpOKJpdGWwrXSkdCI0ITRlNCH0ZfQidGZ0IrRmicgK1xuXHQgICAgJ9GY0IXCrOKImsaS4omI4oiGwqvCu+KApsKg0IvRm9CM0ZzRleKAk+KAlOKAnOKAneKAmOKAmcO34oCe0I7RntCP0Z/ihJbQgdGR0Y/QsNCx0LLQs9C00LXQttC30LjQudC60LvQvNC90L7Qv9GA0YHRgtGD0YTRhdGG0YfRiNGJ0YrRi9GM0Y3RjicsXG5cdCAgICAneC1tYWMtZ2FlbGljJzogLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL0dBRUxJQy5UWFRcblx0ICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4biCwrHiiaTiiaXhuIPEisSL4biK4biL4bie4bifxKDEoeG5gMOmw7gnICtcblx0ICAgICfhuYHhuZbhuZfJvMaSxb/huaDCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZ4bmh4bqbw7/FuOG5quKCrOKAueKAusW2xbfhuavCt+G7suG7s+KBisOCw4rDgcOLw4jDjcOOw4/DjMOTw5TimaPDksOaw5vDmcSxw53DvcW0xbXhuoThuoXhuoDhuoHhuoLhuoMnLFxuXHQgICAgJ3gtbWFjLWdyZWVrJzogIC8vIFB5dGhvbjogJ21hY19ncmVlaydcblx0ICAgICfDhMK5wrLDicKzw5bDnM6Fw6DDosOkzoTCqMOnw6nDqMOqw6vCo+KEosOuw6/igKLCveKAsMO0w7bCpuKCrMO5w7vDvOKAoM6TzpTOmM6bzp7OoMOfwq7Cqc6jzqrCp+KJoMKwwrfOkcKx4omk4omlwqXOks6VzpbOl86ZzprOnM6mzqvOqM6pJyArXG5cdCAgICAnzqzOncKszp/OoeKJiM6kwqvCu+KApsKgzqXOp86GzojFk+KAk+KAleKAnOKAneKAmOKAmcO3zonOis6Mzo7Orc6uzq/PjM6Pz43Osc6yz4jOtM61z4bOs863zrnOvs66zrvOvM69zr/PgM+Oz4HPg8+EzrjPic+Cz4fPhc62z4rPi86QzrBcXHUwMEFEJyxcblx0ICAgICd4LW1hYy1pY2VsYW5kaWMnOiAgLy8gUHl0aG9uOiAnbWFjX2ljZWxhbmQnXG5cdCAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvMOdwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnDpsO4JyArXG5cdCAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGE4oKsw5DDsMOew77DvcK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLhycsXG5cdCAgICAneC1tYWMtaW51aXQnOiAvLyBodHRwOi8vdW5pY29kZS5vcmcvUHVibGljL01BUFBJTkdTL1ZFTkRPUlMvQVBQTEUvSU5VSVQuVFhUXG5cdCAgICAn4ZCD4ZCE4ZCF4ZCG4ZCK4ZCL4ZCx4ZCy4ZCz4ZC04ZC44ZC54ZGJ4ZGO4ZGP4ZGQ4ZGR4ZGV4ZGW4ZGm4ZGt4ZGu4ZGv4ZGw4ZGy4ZGz4ZKD4ZKL4ZKM4ZKN4ZKO4ZKQ4ZKRwrDhkqHhkqXhkqbigKLCtuGSp8KuwqnihKLhkqjhkqrhkqvhkrvhk4Lhk4Phk4Thk4Xhk4fhk4jhk5Dhk6/hk7Dhk7Hhk7Lhk7Thk7XhlIXhk5Xhk5bhk5cnICtcblx0ICAgICfhk5jhk5rhk5vhk6rhlKjhlKnhlKrhlKvhlK3igKbCoOGUruGUvuGVleGVluGVl+KAk+KAlOKAnOKAneKAmOKAmeGVmOGVmeGVmuGVneGVhuGVh+GViOGVieGVi+GVjOGVkOGVv+GWgOGWgeGWguGWg+GWhOGWheGWj+GWkOGWkeGWkuGWk+GWlOGWleGZseGZsuGZs+GZtOGZteGZtuGWluGWoOGWoeGWouGWo+GWpOGWpeGWpuGVvMWBxYInLFxuXHQgICAgJ3gtbWFjLWNlJzogIC8vIFB5dGhvbjogJ21hY19sYXRpbjInXG5cdCAgICAnw4TEgMSBw4nEhMOWw5zDocSFxIzDpMSNxIbEh8OpxbnFusSOw63Ej8SSxJPElsOzxJfDtMO2w7XDusSaxJvDvOKAoMKwxJjCo8Kn4oCiwrbDn8KuwqnihKLEmcKo4omgxKPErsSvxKriiaTiiaXEq8S24oiC4oiRxYLEu8S8xL3EvsS5xLrFhScgK1xuXHQgICAgJ8WGxYPCrOKImsWExYfiiIbCq8K74oCmwqDFiMWQw5XFkcWM4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rFjcWUxZXFmOKAueKAusWZxZbFl8Wg4oCa4oCexaHFmsWbw4HFpMWlw43FvcW+xarDk8OUxavFrsOaxa/FsMWxxbLFs8Odw73Et8W7xYHFvMSiy4cnLFxuXHQgICAgbWFjaW50b3NoOiAgLy8gUHl0aG9uOiAnbWFjX3JvbWFuJ1xuXHQgICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrOqcOmw7gnICtcblx0ICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTigqzigLnigLrvrIHvrILigKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4cnLFxuXHQgICAgJ3gtbWFjLXJvbWFuaWFuJzogIC8vIFB5dGhvbjogJ21hY19yb21hbmlhbidcblx0ICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDEgsiY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnEg8iZJyArXG5cdCAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGE4oKs4oC54oC6yJrIm+KAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLhycsXG5cdCAgICAneC1tYWMtdHVya2lzaCc6ICAvLyBQeXRob246ICdtYWNfdHVya2lzaCdcblx0ICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnDpsO4JyArXG5cdCAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W4xJ7En8SwxLHFnsWf4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nvoqDLhsucwq/LmMuZy5rCuMudy5vLhydcblx0fTtcblxuXHQvKipcblx0ICogRGVjb2RlcyBhbiBvbGQtc3R5bGUgTWFjaW50b3NoIHN0cmluZy4gUmV0dXJucyBlaXRoZXIgYSBVbmljb2RlIEphdmFTY3JpcHRcblx0ICogc3RyaW5nLCBvciAndW5kZWZpbmVkJyBpZiB0aGUgZW5jb2RpbmcgaXMgdW5zdXBwb3J0ZWQuIEZvciBleGFtcGxlLCB3ZSBkb1xuXHQgKiBub3Qgc3VwcG9ydCBDaGluZXNlLCBKYXBhbmVzZSBvciBLb3JlYW4gYmVjYXVzZSB0aGVzZSB3b3VsZCBuZWVkIGxhcmdlXG5cdCAqIG1hcHBpbmcgdGFibGVzLlxuXHQgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlld1xuXHQgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhTGVuZ3RoXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0ZGVjb2RlLk1BQ1NUUklORyA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQsIGRhdGFMZW5ndGgsIGVuY29kaW5nKSB7XG5cdCAgICB2YXIgdGFibGUgPSBlaWdodEJpdE1hY0VuY29kaW5nc1tlbmNvZGluZ107XG5cdCAgICBpZiAodGFibGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICB9XG5cblx0ICAgIHZhciByZXN1bHQgPSAnJztcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGMgPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKTtcblx0ICAgICAgICAvLyBJbiBhbGwgZWlnaHQtYml0IE1hYyBlbmNvZGluZ3MsIHRoZSBjaGFyYWN0ZXJzIDB4MDAuLjB4N0YgYXJlXG5cdCAgICAgICAgLy8gbWFwcGVkIHRvIFUrMDAwMC4uVSswMDdGOyB3ZSBvbmx5IG5lZWQgdG8gbG9vayB1cCB0aGUgb3RoZXJzLlxuXHQgICAgICAgIGlmIChjIDw9IDB4N0YpIHtcblx0ICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmVzdWx0ICs9IHRhYmxlW2MgJiAweDdGXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gSGVscGVyIGZ1bmN0aW9uIGZvciBlbmNvZGUuTUFDU1RSSU5HLiBSZXR1cm5zIGEgZGljdGlvbmFyeSBmb3IgbWFwcGluZ1xuXHQvLyBVbmljb2RlIGNoYXJhY3RlciBjb2RlcyB0byB0aGVpciA4LWJpdCBNYWNPUyBlcXVpdmFsZW50LiBUaGlzIHRhYmxlXG5cdC8vIGlzIG5vdCBleGFjdGx5IGEgc3VwZXIgY2hlYXAgZGF0YSBzdHJ1Y3R1cmUsIGJ1dCB3ZSBkbyBub3QgY2FyZSBiZWNhdXNlXG5cdC8vIGVuY29kaW5nIE1hY2ludG9zaCBzdHJpbmdzIGlzIG9ubHkgcmFyZWx5IG5lZWRlZCBpbiB0eXBpY2FsIGFwcGxpY2F0aW9ucy5cblx0dmFyIG1hY0VuY29kaW5nVGFibGVDYWNoZSA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIG5ldyBXZWFrTWFwKCk7XG5cdHZhciBtYWNFbmNvZGluZ0NhY2hlS2V5cztcblx0dmFyIGdldE1hY0VuY29kaW5nVGFibGUgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcblx0ICAgIC8vIFNpbmNlIHdlIHVzZSBlbmNvZGluZyBhcyBhIGNhY2hlIGtleSBmb3IgV2Vha01hcCwgaXQgaGFzIHRvIGJlXG5cdCAgICAvLyBhIFN0cmluZyBvYmplY3QgYW5kIG5vdCBhIGxpdGVyYWwuIEFuZCBhdCBsZWFzdCBvbiBOb2RlSlMgMi4xMC4xLFxuXHQgICAgLy8gV2Vha01hcCByZXF1aXJlcyB0aGF0IHRoZSBzYW1lIFN0cmluZyBpbnN0YW5jZSBpcyBwYXNzZWQgZm9yIGNhY2hlIGhpdHMuXG5cdCAgICBpZiAoIW1hY0VuY29kaW5nQ2FjaGVLZXlzKSB7XG5cdCAgICAgICAgbWFjRW5jb2RpbmdDYWNoZUtleXMgPSB7fTtcblx0ICAgICAgICBmb3IgKHZhciBlIGluIGVpZ2h0Qml0TWFjRW5jb2RpbmdzKSB7XG5cdCAgICAgICAgICAgIC8qanNoaW50IC1XMDUzICovICAvLyBTdXBwcmVzcyBcIkRvIG5vdCB1c2UgU3RyaW5nIGFzIGEgY29uc3RydWN0b3IuXCJcblx0ICAgICAgICAgICAgbWFjRW5jb2RpbmdDYWNoZUtleXNbZV0gPSBuZXcgU3RyaW5nKGUpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGNhY2hlS2V5ID0gbWFjRW5jb2RpbmdDYWNoZUtleXNbZW5jb2RpbmddO1xuXHQgICAgaWYgKGNhY2hlS2V5ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfVxuXG5cdCAgICAvLyBXZSBjYW4ndCBkbyBcImlmIChjYWNoZS5oYXMoa2V5KSkge3JldHVybiBjYWNoZS5nZXQoa2V5KX1cIiBoZXJlOlxuXHQgICAgLy8gc2luY2UgZ2FyYmFnZSBjb2xsZWN0aW9uIG1heSBydW4gYXQgYW55IHRpbWUsIGl0IGNvdWxkIGFsc28ga2ljayBpblxuXHQgICAgLy8gYmV0d2VlbiB0aGUgY2FsbHMgdG8gY2FjaGUuaGFzKCkgYW5kIGNhY2hlLmdldCgpLiBJbiB0aGF0IGNhc2UsXG5cdCAgICAvLyB3ZSB3b3VsZCByZXR1cm4gJ3VuZGVmaW5lZCcgZXZlbiB0aG91Z2ggd2UgZG8gc3VwcG9ydCB0aGUgZW5jb2RpbmcuXG5cdCAgICBpZiAobWFjRW5jb2RpbmdUYWJsZUNhY2hlKSB7XG5cdCAgICAgICAgdmFyIGNhY2hlZFRhYmxlID0gbWFjRW5jb2RpbmdUYWJsZUNhY2hlLmdldChjYWNoZUtleSk7XG5cdCAgICAgICAgaWYgKGNhY2hlZFRhYmxlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFRhYmxlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGRlY29kaW5nVGFibGUgPSBlaWdodEJpdE1hY0VuY29kaW5nc1tlbmNvZGluZ107XG5cdCAgICBpZiAoZGVjb2RpbmdUYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH1cblxuXHQgICAgdmFyIGVuY29kaW5nVGFibGUgPSB7fTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVjb2RpbmdUYWJsZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGVuY29kaW5nVGFibGVbZGVjb2RpbmdUYWJsZS5jaGFyQ29kZUF0KGkpXSA9IGkgKyAweDgwO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobWFjRW5jb2RpbmdUYWJsZUNhY2hlKSB7XG5cdCAgICAgICAgbWFjRW5jb2RpbmdUYWJsZUNhY2hlLnNldChjYWNoZUtleSwgZW5jb2RpbmdUYWJsZSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBlbmNvZGluZ1RhYmxlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmNvZGVzIGFuIG9sZC1zdHlsZSBNYWNpbnRvc2ggc3RyaW5nLiBSZXR1cm5zIGEgYnl0ZSBhcnJheSB1cG9uIHN1Y2Nlc3MuXG5cdCAqIElmIHRoZSByZXF1ZXN0ZWQgZW5jb2RpbmcgaXMgdW5zdXBwb3J0ZWQsIG9yIGlmIHRoZSBpbnB1dCBzdHJpbmcgY29udGFpbnNcblx0ICogYSBjaGFyYWN0ZXIgdGhhdCBjYW5ub3QgYmUgZXhwcmVzc2VkIGluIHRoZSBlbmNvZGluZywgdGhlIGZ1bmN0aW9uIHJldHVybnNcblx0ICogJ3VuZGVmaW5lZCcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGVuY29kZS5NQUNTVFJJTkcgPSBmdW5jdGlvbihzdHIsIGVuY29kaW5nKSB7XG5cdCAgICB2YXIgdGFibGUgPSBnZXRNYWNFbmNvZGluZ1RhYmxlKGVuY29kaW5nKTtcblx0ICAgIGlmICh0YWJsZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH1cblxuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG5cdCAgICAgICAgLy8gSW4gYWxsIGVpZ2h0LWJpdCBNYWMgZW5jb2RpbmdzLCB0aGUgY2hhcmFjdGVycyAweDAwLi4weDdGIGFyZVxuXHQgICAgICAgIC8vIG1hcHBlZCB0byBVKzAwMDAuLlUrMDA3Rjsgd2Ugb25seSBuZWVkIHRvIGxvb2sgdXAgdGhlIG90aGVycy5cblx0ICAgICAgICBpZiAoYyA+PSAweDgwKSB7XG5cdCAgICAgICAgICAgIGMgPSB0YWJsZVtjXTtcblx0ICAgICAgICAgICAgaWYgKGMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgLy8gc3RyIGNvbnRhaW5zIGEgVW5pY29kZSBjaGFyYWN0ZXIgdGhhdCBjYW5ub3QgYmUgZW5jb2RlZFxuXHQgICAgICAgICAgICAgICAgLy8gaW4gdGhlIHJlcXVlc3RlZCBlbmNvZGluZy5cblx0ICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0W2ldID0gYztcblx0ICAgICAgICAvLyByZXN1bHQucHVzaChjKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0clxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZW5jb2Rpbmdcblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5NQUNTVFJJTkcgPSBmdW5jdGlvbihzdHIsIGVuY29kaW5nKSB7XG5cdCAgICB2YXIgYiA9IGVuY29kZS5NQUNTVFJJTkcoc3RyLCBlbmNvZGluZyk7XG5cdCAgICBpZiAoYiAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIGIubGVuZ3RoO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgIH1cblx0fTtcblxuXHQvLyBIZWxwZXIgZm9yIGVuY29kZS5WQVJERUxUQVNcblx0ZnVuY3Rpb24gaXNCeXRlRW5jb2RhYmxlKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdmFsdWUgPj0gLTEyOCAmJiB2YWx1ZSA8PSAxMjc7XG5cdH1cblxuXHQvLyBIZWxwZXIgZm9yIGVuY29kZS5WQVJERUxUQVNcblx0ZnVuY3Rpb24gZW5jb2RlVmFyRGVsdGFSdW5Bc1plcm9lcyhkZWx0YXMsIHBvcywgcmVzdWx0KSB7XG5cdCAgICB2YXIgcnVuTGVuZ3RoID0gMDtcblx0ICAgIHZhciBudW1EZWx0YXMgPSBkZWx0YXMubGVuZ3RoO1xuXHQgICAgd2hpbGUgKHBvcyA8IG51bURlbHRhcyAmJiBydW5MZW5ndGggPCA2NCAmJiBkZWx0YXNbcG9zXSA9PT0gMCkge1xuXHQgICAgICAgICsrcG9zO1xuXHQgICAgICAgICsrcnVuTGVuZ3RoO1xuXHQgICAgfVxuXHQgICAgcmVzdWx0LnB1c2goMHg4MCB8IChydW5MZW5ndGggLSAxKSk7XG5cdCAgICByZXR1cm4gcG9zO1xuXHR9XG5cblx0Ly8gSGVscGVyIGZvciBlbmNvZGUuVkFSREVMVEFTXG5cdGZ1bmN0aW9uIGVuY29kZVZhckRlbHRhUnVuQXNCeXRlcyhkZWx0YXMsIG9mZnNldCwgcmVzdWx0KSB7XG5cdCAgICB2YXIgcnVuTGVuZ3RoID0gMDtcblx0ICAgIHZhciBudW1EZWx0YXMgPSBkZWx0YXMubGVuZ3RoO1xuXHQgICAgdmFyIHBvcyA9IG9mZnNldDtcblx0ICAgIHdoaWxlIChwb3MgPCBudW1EZWx0YXMgJiYgcnVuTGVuZ3RoIDwgNjQpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBkZWx0YXNbcG9zXTtcblx0ICAgICAgICBpZiAoIWlzQnl0ZUVuY29kYWJsZSh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gV2l0aGluIGEgYnl0ZS1lbmNvZGVkIHJ1biBvZiBkZWx0YXMsIGEgc2luZ2xlIHplcm8gaXMgYmVzdFxuXHQgICAgICAgIC8vIHN0b3JlZCBsaXRlcmFsbHkgYXMgMHgwMCB2YWx1ZS4gSG93ZXZlciwgaWYgd2UgaGF2ZSB0d28gb3Jcblx0ICAgICAgICAvLyBtb3JlIHplcm9lcyBpbiBhIHNlcXVlbmNlLCBpdCBpcyBiZXR0ZXIgdG8gc3RhcnQgYSBuZXcgcnVuLlxuXHQgICAgICAgIC8vIEZvcmUgZXhhbXBsZSwgdGhlIHNlcXVlbmNlIG9mIGRlbHRhcyBbMTUsIDE1LCAwLCAxNSwgMTVdXG5cdCAgICAgICAgLy8gYmVjb21lcyA2IGJ5dGVzICgwNCAwRiAwRiAwMCAwRiAwRikgd2hlbiBzdG9yaW5nIHRoZSB6ZXJvXG5cdCAgICAgICAgLy8gd2l0aGluIHRoZSBjdXJyZW50IHJ1biwgYnV0IDcgYnl0ZXMgKDAxIDBGIDBGIDgwIDAxIDBGIDBGKVxuXHQgICAgICAgIC8vIHdoZW4gc3RhcnRpbmcgYSBuZXcgcnVuLlxuXHQgICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiBwb3MgKyAxIDwgbnVtRGVsdGFzICYmIGRlbHRhc1twb3MgKyAxXSA9PT0gMCkge1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICArK3Bvcztcblx0ICAgICAgICArK3J1bkxlbmd0aDtcblx0ICAgIH1cblx0ICAgIHJlc3VsdC5wdXNoKHJ1bkxlbmd0aCAtIDEpO1xuXHQgICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IHBvczsgKytpKSB7XG5cdCAgICAgICAgcmVzdWx0LnB1c2goKGRlbHRhc1tpXSArIDI1NikgJiAweGZmKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBwb3M7XG5cdH1cblxuXHQvLyBIZWxwZXIgZm9yIGVuY29kZS5WQVJERUxUQVNcblx0ZnVuY3Rpb24gZW5jb2RlVmFyRGVsdGFSdW5Bc1dvcmRzKGRlbHRhcywgb2Zmc2V0LCByZXN1bHQpIHtcblx0ICAgIHZhciBydW5MZW5ndGggPSAwO1xuXHQgICAgdmFyIG51bURlbHRhcyA9IGRlbHRhcy5sZW5ndGg7XG5cdCAgICB2YXIgcG9zID0gb2Zmc2V0O1xuXHQgICAgd2hpbGUgKHBvcyA8IG51bURlbHRhcyAmJiBydW5MZW5ndGggPCA2NCkge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IGRlbHRhc1twb3NdO1xuXG5cdCAgICAgICAgLy8gV2l0aGluIGEgd29yZC1lbmNvZGVkIHJ1biBvZiBkZWx0YXMsIGl0IGlzIGVhc2llc3QgdG8gc3RhcnRcblx0ICAgICAgICAvLyBhIG5ldyBydW4gKHdpdGggYSBkaWZmZXJlbnQgZW5jb2RpbmcpIHdoZW5ldmVyIHdlIGVuY291bnRlclxuXHQgICAgICAgIC8vIGEgemVybyB2YWx1ZS4gRm9yIGV4YW1wbGUsIHRoZSBzZXF1ZW5jZSBbMHg2NjY2LCAwLCAweDc3NzddXG5cdCAgICAgICAgLy8gbmVlZHMgNyBieXRlcyB3aGVuIHN0b3JpbmcgdGhlIHplcm8gaW5zaWRlIHRoZSBjdXJyZW50IHJ1blxuXHQgICAgICAgIC8vICg0MiA2NiA2NiAwMCAwMCA3NyA3NyksIGFuZCBlcXVhbGx5IDcgYnl0ZXMgd2hlbiBzdGFydGluZyBhXG5cdCAgICAgICAgLy8gbmV3IHJ1biAoNDAgNjYgNjYgODAgNDAgNzcgNzcpLlxuXHQgICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBXaXRoaW4gYSB3b3JkLWVuY29kZWQgcnVuIG9mIGRlbHRhcywgYSBzaW5nbGUgdmFsdWUgaW4gdGhlXG5cdCAgICAgICAgLy8gcmFuZ2UgKC0xMjguLjEyNykgc2hvdWxkIGJlIGVuY29kZWQgd2l0aGluIHRoZSBjdXJyZW50IHJ1blxuXHQgICAgICAgIC8vIGJlY2F1c2UgaXQgaXMgbW9yZSBjb21wYWN0LiBGb3IgZXhhbXBsZSwgdGhlIHNlcXVlbmNlXG5cdCAgICAgICAgLy8gWzB4NjY2NiwgMiwgMHg3Nzc3XSBiZWNvbWVzIDcgYnl0ZXMgd2hlbiBzdG9yaW5nIHRoZSB2YWx1ZVxuXHQgICAgICAgIC8vIGxpdGVyYWxseSAoNDIgNjYgNjYgMDAgMDIgNzcgNzcpLCBidXQgOCBieXRlcyB3aGVuIHN0YXJ0aW5nXG5cdCAgICAgICAgLy8gYSBuZXcgcnVuICg0MCA2NiA2NiAwMCAwMiA0MCA3NyA3NykuXG5cdCAgICAgICAgaWYgKGlzQnl0ZUVuY29kYWJsZSh2YWx1ZSkgJiYgcG9zICsgMSA8IG51bURlbHRhcyAmJiBpc0J5dGVFbmNvZGFibGUoZGVsdGFzW3BvcyArIDFdKSkge1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICArK3Bvcztcblx0ICAgICAgICArK3J1bkxlbmd0aDtcblx0ICAgIH1cblx0ICAgIHJlc3VsdC5wdXNoKDB4NDAgfCAocnVuTGVuZ3RoIC0gMSkpO1xuXHQgICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IHBvczsgKytpKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IGRlbHRhc1tpXTtcblx0ICAgICAgICByZXN1bHQucHVzaCgoKHZhbCArIDB4MTAwMDApID4+IDgpICYgMHhmZiwgKHZhbCArIDB4MTAwKSAmIDB4ZmYpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHBvcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmNvZGUgYSBsaXN0IG9mIHZhcmlhdGlvbiBhZGp1c3RtZW50IGRlbHRhcy5cblx0ICpcblx0ICogVmFyaWF0aW9uIGFkanVzdG1lbnQgZGVsdGFzIGFyZSB1c2VkIGluIOKAmGd2YXLigJkgYW5kIOKAmGN2YXLigJkgdGFibGVzLlxuXHQgKiBUaGV5IGluZGljYXRlIGhvdyBwb2ludHMgKGluIOKAmGd2YXLigJkpIG9yIHZhbHVlcyAoaW4g4oCYY3ZhcuKAmSkgZ2V0IGFkanVzdGVkXG5cdCAqIHdoZW4gZ2VuZXJhdGluZyBpbnN0YW5jZXMgb2YgdmFyaWF0aW9uIGZvbnRzLlxuXHQgKlxuXHQgKiBAc2VlIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMvZ3Zhci5odG1cblx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA2L0NoYXA2Z3Zhci5odG1sXG5cdCAqIEBwYXJhbSB7QXJyYXl9XG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLlZBUkRFTFRBUyA9IGZ1bmN0aW9uKGRlbHRhcykge1xuXHQgICAgdmFyIHBvcyA9IDA7XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICB3aGlsZSAocG9zIDwgZGVsdGFzLmxlbmd0aCkge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IGRlbHRhc1twb3NdO1xuXHQgICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuXHQgICAgICAgICAgICBwb3MgPSBlbmNvZGVWYXJEZWx0YVJ1bkFzWmVyb2VzKGRlbHRhcywgcG9zLCByZXN1bHQpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPj0gLTEyOCAmJiB2YWx1ZSA8PSAxMjcpIHtcblx0ICAgICAgICAgICAgcG9zID0gZW5jb2RlVmFyRGVsdGFSdW5Bc0J5dGVzKGRlbHRhcywgcG9zLCByZXN1bHQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHBvcyA9IGVuY29kZVZhckRlbHRhUnVuQXNXb3JkcyhkZWx0YXMsIHBvcywgcmVzdWx0KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8vIENvbnZlcnQgYSBsaXN0IG9mIHZhbHVlcyB0byBhIENGRiBJTkRFWCBzdHJ1Y3R1cmUuXG5cdC8vIFRoZSB2YWx1ZXMgc2hvdWxkIGJlIG9iamVjdHMgY29udGFpbmluZyBuYW1lIC8gdHlwZSAvIHZhbHVlLlxuXHQvKipcblx0ICogQHBhcmFtIHtBcnJheX0gbFxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuSU5ERVggPSBmdW5jdGlvbihsKSB7XG5cdCAgICAvL3ZhciBvZmZzZXQsIG9mZnNldHMsIG9mZnNldEVuY29kZXIsIGVuY29kZWRPZmZzZXRzLCBlbmNvZGVkT2Zmc2V0LCBkYXRhLFxuXHQgICAgLy8gICAgaSwgdjtcblx0ICAgIC8vIEJlY2F1c2Ugd2UgaGF2ZSB0byBrbm93IHdoaWNoIGRhdGEgdHlwZSB0byB1c2UgdG8gZW5jb2RlIHRoZSBvZmZzZXRzLFxuXHQgICAgLy8gd2UgaGF2ZSB0byBnbyB0aHJvdWdoIHRoZSB2YWx1ZXMgdHdpY2U6IG9uY2UgdG8gZW5jb2RlIHRoZSBkYXRhIGFuZFxuXHQgICAgLy8gY2FsY3VsYXRlIHRoZSBvZmZzZXRzLCB0aGVuIGFnYWluIHRvIGVuY29kZSB0aGUgb2Zmc2V0cyB1c2luZyB0aGUgZml0dGluZyBkYXRhIHR5cGUuXG5cdCAgICB2YXIgb2Zmc2V0ID0gMTsgLy8gRmlyc3Qgb2Zmc2V0IGlzIGFsd2F5cyAxLlxuXHQgICAgdmFyIG9mZnNldHMgPSBbb2Zmc2V0XTtcblx0ICAgIHZhciBkYXRhID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGwubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgdiA9IGVuY29kZS5PQkpFQ1QobFtpXSk7XG5cdCAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZGF0YSwgdik7XG5cdCAgICAgICAgb2Zmc2V0ICs9IHYubGVuZ3RoO1xuXHQgICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gWzAsIDBdO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZW5jb2RlZE9mZnNldHMgPSBbXTtcblx0ICAgIHZhciBvZmZTaXplID0gKDEgKyBNYXRoLmZsb29yKE1hdGgubG9nKG9mZnNldCkgLyBNYXRoLmxvZygyKSkgLyA4KSB8IDA7XG5cdCAgICB2YXIgb2Zmc2V0RW5jb2RlciA9IFt1bmRlZmluZWQsIGVuY29kZS5CWVRFLCBlbmNvZGUuVVNIT1JULCBlbmNvZGUuVUlOVDI0LCBlbmNvZGUuVUxPTkddW29mZlNpemVdO1xuXHQgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgb2Zmc2V0cy5sZW5ndGg7IGkkMSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGVuY29kZWRPZmZzZXQgPSBvZmZzZXRFbmNvZGVyKG9mZnNldHNbaSQxXSk7XG5cdCAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW5jb2RlZE9mZnNldHMsIGVuY29kZWRPZmZzZXQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdChlbmNvZGUuQ2FyZDE2KGwubGVuZ3RoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlLk9mZlNpemUob2ZmU2l6ZSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWRPZmZzZXRzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhKTtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtBcnJheX1cblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5JTkRFWCA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHJldHVybiBlbmNvZGUuSU5ERVgodikubGVuZ3RoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGFuIG9iamVjdCB0byBhIENGRiBESUNUIHN0cnVjdHVyZS5cblx0ICogVGhlIGtleXMgc2hvdWxkIGJlIG51bWVyaWMuXG5cdCAqIFRoZSB2YWx1ZXMgc2hvdWxkIGJlIG9iamVjdHMgY29udGFpbmluZyBuYW1lIC8gdHlwZSAvIHZhbHVlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuRElDVCA9IGZ1bmN0aW9uKG0pIHtcblx0ICAgIHZhciBkID0gW107XG5cdCAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG0pO1xuXHQgICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgLy8gT2JqZWN0LmtleXMoKSByZXR1cm4gc3RyaW5nIGtleXMsIGJ1dCBvdXIga2V5cyBhcmUgYWx3YXlzIG51bWVyaWMuXG5cdCAgICAgICAgdmFyIGsgPSBwYXJzZUludChrZXlzW2ldLCAwKTtcblx0ICAgICAgICB2YXIgdiA9IG1ba107XG5cdCAgICAgICAgLy8gVmFsdWUgY29tZXMgYmVmb3JlIHRoZSBrZXkuXG5cdCAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQU5EKHYudmFsdWUsIHYudHlwZSkpO1xuXHQgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuT1BFUkFUT1IoaykpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZDtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtPYmplY3R9XG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuRElDVCA9IGZ1bmN0aW9uKG0pIHtcblx0ICAgIHJldHVybiBlbmNvZGUuRElDVChtKS5sZW5ndGg7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuT1BFUkFUT1IgPSBmdW5jdGlvbih2KSB7XG5cdCAgICBpZiAodiA8IDEyMDApIHtcblx0ICAgICAgICByZXR1cm4gW3ZdO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gWzEyLCB2IC0gMTIwMF07XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHZcblx0ICogQHBhcmFtIHtzdHJpbmd9XG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGVuY29kZS5PUEVSQU5EID0gZnVuY3Rpb24odiwgdHlwZSkge1xuXHQgICAgdmFyIGQgPSBbXTtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgICAgIGNoZWNrLmFyZ3VtZW50KHYubGVuZ3RoID09PSB0eXBlLmxlbmd0aCwgJ05vdCBlbm91Z2ggYXJndW1lbnRzIGdpdmVuIGZvciB0eXBlJyArIHR5cGUpO1xuXHQgICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk9QRVJBTkQodltpXSwgdHlwZVtpXSkpO1xuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKHR5cGUgPT09ICdTSUQnKSB7XG5cdCAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSKHYpKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvZmZzZXQnKSB7XG5cdCAgICAgICAgICAgIC8vIFdlIG1ha2UgaXQgZWFzeSBmb3Igb3Vyc2VsdmVzIGFuZCBhbHdheXMgZW5jb2RlIG9mZnNldHMgYXNcblx0ICAgICAgICAgICAgLy8gNCBieXRlcy4gVGhpcyBtYWtlcyBvZmZzZXQgY2FsY3VsYXRpb24gZm9yIHRoZSB0b3AgZGljdCBlYXNpZXIuXG5cdCAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSMzIodikpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5OVU1CRVIodikpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlYWwnKSB7XG5cdCAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuUkVBTCh2KSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG9wZXJhbmQgdHlwZSAnICsgdHlwZSk7XG5cdCAgICAgICAgICAgIC8vIEZJWE1FIEFkZCBzdXBwb3J0IGZvciBib29sZWFuc1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGQ7XG5cdH07XG5cblx0ZW5jb2RlLk9QID0gZW5jb2RlLkJZVEU7XG5cdHNpemVPZi5PUCA9IHNpemVPZi5CWVRFO1xuXG5cdC8vIG1lbW9pemUgY2hhcnN0cmluZyBlbmNvZGluZyB1c2luZyBXZWFrTWFwIGlmIGF2YWlsYWJsZVxuXHR2YXIgd21tID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgbmV3IFdlYWtNYXAoKTtcblxuXHQvKipcblx0ICogQ29udmVydCBhIGxpc3Qgb2YgQ2hhclN0cmluZyBvcGVyYXRpb25zIHRvIGJ5dGVzLlxuXHQgKiBAcGFyYW0ge0FycmF5fVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuQ0hBUlNUUklORyA9IGZ1bmN0aW9uKG9wcykge1xuXHQgICAgLy8gU2VlIGVuY29kZS5NQUNTVFJJTkcgZm9yIHdoeSB3ZSBkb24ndCBkbyBcImlmICh3bW0gJiYgd21tLmhhcyhvcHMpKVwiLlxuXHQgICAgaWYgKHdtbSkge1xuXHQgICAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IHdtbS5nZXQob3BzKTtcblx0ICAgICAgICBpZiAoY2FjaGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gY2FjaGVkVmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgZCA9IFtdO1xuXHQgICAgdmFyIGxlbmd0aCA9IG9wcy5sZW5ndGg7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgb3AgPSBvcHNbaV07XG5cdCAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZVtvcC50eXBlXShvcC52YWx1ZSkpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAod21tKSB7XG5cdCAgICAgICAgd21tLnNldChvcHMsIGQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZDtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtBcnJheX1cblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5DSEFSU1RSSU5HID0gZnVuY3Rpb24ob3BzKSB7XG5cdCAgICByZXR1cm4gZW5jb2RlLkNIQVJTVFJJTkcob3BzKS5sZW5ndGg7XG5cdH07XG5cblx0Ly8gVXRpbGl0eSBmdW5jdGlvbnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogQ29udmVydCBhbiBvYmplY3QgY29udGFpbmluZyBuYW1lIC8gdHlwZSAvIHZhbHVlIHRvIGJ5dGVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLk9CSkVDVCA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHZhciBlbmNvZGluZ0Z1bmN0aW9uID0gZW5jb2RlW3YudHlwZV07XG5cdCAgICBjaGVjay5hcmd1bWVudChlbmNvZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBlbmNvZGluZyBmdW5jdGlvbiBmb3IgdHlwZSAnICsgdi50eXBlKTtcblx0ICAgIHJldHVybiBlbmNvZGluZ0Z1bmN0aW9uKHYudmFsdWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge09iamVjdH1cblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5PQkpFQ1QgPSBmdW5jdGlvbih2KSB7XG5cdCAgICB2YXIgc2l6ZU9mRnVuY3Rpb24gPSBzaXplT2Zbdi50eXBlXTtcblx0ICAgIGNoZWNrLmFyZ3VtZW50KHNpemVPZkZ1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBzaXplT2YgZnVuY3Rpb24gZm9yIHR5cGUgJyArIHYudHlwZSk7XG5cdCAgICByZXR1cm4gc2l6ZU9mRnVuY3Rpb24odi52YWx1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYSB0YWJsZSBvYmplY3QgdG8gYnl0ZXMuXG5cdCAqIEEgdGFibGUgY29udGFpbnMgYSBsaXN0IG9mIGZpZWxkcyBjb250YWluaW5nIHRoZSBtZXRhZGF0YSAobmFtZSwgdHlwZSBhbmQgZGVmYXVsdCB2YWx1ZSkuXG5cdCAqIFRoZSB0YWJsZSBpdHNlbGYgaGFzIHRoZSBmaWVsZCB2YWx1ZXMgc2V0IGFzIGF0dHJpYnV0ZXMuXG5cdCAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGVuY29kZS5UQUJMRSA9IGZ1bmN0aW9uKHRhYmxlKSB7XG5cdCAgICB2YXIgZCA9IFtdO1xuXHQgICAgdmFyIGxlbmd0aCA9IHRhYmxlLmZpZWxkcy5sZW5ndGg7XG5cdCAgICB2YXIgc3VidGFibGVzID0gW107XG5cdCAgICB2YXIgc3VidGFibGVPZmZzZXRzID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgZmllbGQgPSB0YWJsZS5maWVsZHNbaV07XG5cdCAgICAgICAgdmFyIGVuY29kaW5nRnVuY3Rpb24gPSBlbmNvZGVbZmllbGQudHlwZV07XG5cdCAgICAgICAgY2hlY2suYXJndW1lbnQoZW5jb2RpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gZW5jb2RpbmcgZnVuY3Rpb24gZm9yIGZpZWxkIHR5cGUgJyArIGZpZWxkLnR5cGUgKyAnICgnICsgZmllbGQubmFtZSArICcpJyk7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdGFibGVbZmllbGQubmFtZV07XG5cdCAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC52YWx1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgYnl0ZXMgPSBlbmNvZGluZ0Z1bmN0aW9uKHZhbHVlKTtcblxuXHQgICAgICAgIGlmIChmaWVsZC50eXBlID09PSAnVEFCTEUnKSB7XG5cdCAgICAgICAgICAgIHN1YnRhYmxlT2Zmc2V0cy5wdXNoKGQubGVuZ3RoKTtcblx0ICAgICAgICAgICAgZCA9IGQuY29uY2F0KFswLCAwXSk7XG5cdCAgICAgICAgICAgIHN1YnRhYmxlcy5wdXNoKGJ5dGVzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBkID0gZC5jb25jYXQoYnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc3VidGFibGVzLmxlbmd0aDsgaSQxICs9IDEpIHtcblx0ICAgICAgICB2YXIgbyA9IHN1YnRhYmxlT2Zmc2V0c1tpJDFdO1xuXHQgICAgICAgIHZhciBvZmZzZXQgPSBkLmxlbmd0aDtcblx0ICAgICAgICBjaGVjay5hcmd1bWVudChvZmZzZXQgPCA2NTUzNiwgJ1RhYmxlICcgKyB0YWJsZS50YWJsZU5hbWUgKyAnIHRvbyBiaWcuJyk7XG5cdCAgICAgICAgZFtvXSA9IG9mZnNldCA+PiA4O1xuXHQgICAgICAgIGRbbyArIDFdID0gb2Zmc2V0ICYgMHhmZjtcblx0ICAgICAgICBkID0gZC5jb25jYXQoc3VidGFibGVzW2kkMV0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZDtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtvcGVudHlwZS5UYWJsZX1cblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5UQUJMRSA9IGZ1bmN0aW9uKHRhYmxlKSB7XG5cdCAgICB2YXIgbnVtQnl0ZXMgPSAwO1xuXHQgICAgdmFyIGxlbmd0aCA9IHRhYmxlLmZpZWxkcy5sZW5ndGg7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgZmllbGQgPSB0YWJsZS5maWVsZHNbaV07XG5cdCAgICAgICAgdmFyIHNpemVPZkZ1bmN0aW9uID0gc2l6ZU9mW2ZpZWxkLnR5cGVdO1xuXHQgICAgICAgIGNoZWNrLmFyZ3VtZW50KHNpemVPZkZ1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBzaXplT2YgZnVuY3Rpb24gZm9yIGZpZWxkIHR5cGUgJyArIGZpZWxkLnR5cGUgKyAnICgnICsgZmllbGQubmFtZSArICcpJyk7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdGFibGVbZmllbGQubmFtZV07XG5cdCAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC52YWx1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBudW1CeXRlcyArPSBzaXplT2ZGdW5jdGlvbih2YWx1ZSk7XG5cblx0ICAgICAgICAvLyBTdWJ0YWJsZXMgdGFrZSAyIG1vcmUgYnl0ZXMgZm9yIG9mZnNldHMuXG5cdCAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09ICdUQUJMRScpIHtcblx0ICAgICAgICAgICAgbnVtQnl0ZXMgKz0gMjtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBudW1CeXRlcztcblx0fTtcblxuXHRlbmNvZGUuUkVDT1JEID0gZW5jb2RlLlRBQkxFO1xuXHRzaXplT2YuUkVDT1JEID0gc2l6ZU9mLlRBQkxFO1xuXG5cdC8vIE1lcmdlIGluIGEgbGlzdCBvZiBieXRlcy5cblx0ZW5jb2RlLkxJVEVSQUwgPSBmdW5jdGlvbih2KSB7XG5cdCAgICByZXR1cm4gdjtcblx0fTtcblxuXHRzaXplT2YuTElURVJBTCA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHJldHVybiB2Lmxlbmd0aDtcblx0fTtcblxuXHQvLyBUYWJsZSBtZXRhZGF0YVxuXG5cdC8qKlxuXHQgKiBAZXhwb3J0cyBvcGVudHlwZS5UYWJsZVxuXHQgKiBAY2xhc3Ncblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBmaWVsZHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBUYWJsZSh0YWJsZU5hbWUsIGZpZWxkcywgb3B0aW9ucykge1xuXHQgICAgLy8gRm9yIGNvdmVyYWdlIHRhYmxlcyB3aXRoIGNvdmVyYWdlIGZvcm1hdCAyLCB3ZSBkbyBub3Qgd2FudCB0byBhZGQgdGhlIGNvdmVyYWdlIGRhdGEgZGlyZWN0bHkgdG8gdGhlIHRhYmxlIG9iamVjdCxcblx0ICAgIC8vIGFzIHRoaXMgd2lsbCByZXN1bHQgaW4gd3JvbmcgZW5jb2Rpbmcgb3JkZXIgb2YgdGhlIGNvdmVyYWdlIGRhdGEgb24gc2VyaWFsaXphdGlvbiB0byBieXRlcy5cblx0ICAgIC8vIFRoZSBmYWxsYmFjayBvZiB1c2luZyB0aGUgZmllbGQgdmFsdWVzIGRpcmVjdGx5IHdoZW4gbm90IHByZXNlbnQgb24gdGhlIHRhYmxlIGlzIGhhbmRsZWQgaW4gdHlwZXMuZW5jb2RlLlRBQkxFKCkgYWxyZWFkeS5cblx0ICAgIGlmIChmaWVsZHMubGVuZ3RoICYmIChmaWVsZHNbMF0ubmFtZSAhPT0gJ2NvdmVyYWdlRm9ybWF0JyB8fCBmaWVsZHNbMF0udmFsdWUgPT09IDEpKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuXHQgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gZmllbGQudmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcblx0ICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuXHQgICAgaWYgKG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuXHQgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9wdGlvbktleXMubGVuZ3RoOyBpJDEgKz0gMSkge1xuXHQgICAgICAgICAgICB2YXIgayA9IG9wdGlvbktleXNbaSQxXTtcblx0ICAgICAgICAgICAgdmFyIHYgPSBvcHRpb25zW2tdO1xuXHQgICAgICAgICAgICBpZiAodGhpc1trXSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzW2tdID0gdjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFbmNvZGVzIHRoZSB0YWJsZSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBieXRlc1xuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdFRhYmxlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBlbmNvZGUuVEFCTEUodGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgdGFibGUuXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG5cdFRhYmxlLnByb3RvdHlwZS5zaXplT2YgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBzaXplT2YuVEFCTEUodGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiB1c2hvcnRMaXN0KGl0ZW1OYW1lLCBsaXN0LCBjb3VudCkge1xuXHQgICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBjb3VudCA9IGxpc3QubGVuZ3RoO1xuXHQgICAgfVxuXHQgICAgdmFyIGZpZWxkcyA9IG5ldyBBcnJheShsaXN0Lmxlbmd0aCArIDEpO1xuXHQgICAgZmllbGRzWzBdID0ge25hbWU6IGl0ZW1OYW1lICsgJ0NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBjb3VudH07XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBmaWVsZHNbaSArIDFdID0ge25hbWU6IGl0ZW1OYW1lICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsaXN0W2ldfTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmaWVsZHM7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIHRhYmxlTGlzdChpdGVtTmFtZSwgcmVjb3JkcywgaXRlbUNhbGxiYWNrKSB7XG5cdCAgICB2YXIgY291bnQgPSByZWNvcmRzLmxlbmd0aDtcblx0ICAgIHZhciBmaWVsZHMgPSBuZXcgQXJyYXkoY291bnQgKyAxKTtcblx0ICAgIGZpZWxkc1swXSA9IHtuYW1lOiBpdGVtTmFtZSArICdDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogY291bnR9O1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgZmllbGRzW2kgKyAxXSA9IHtuYW1lOiBpdGVtTmFtZSArIGksIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBpdGVtQ2FsbGJhY2socmVjb3Jkc1tpXSwgaSl9O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZpZWxkcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gcmVjb3JkTGlzdChpdGVtTmFtZSwgcmVjb3JkcywgaXRlbUNhbGxiYWNrKSB7XG5cdCAgICB2YXIgY291bnQgPSByZWNvcmRzLmxlbmd0aDtcblx0ICAgIHZhciBmaWVsZHMgPSBbXTtcblx0ICAgIGZpZWxkc1swXSA9IHtuYW1lOiBpdGVtTmFtZSArICdDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogY291bnR9O1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgZmllbGRzID0gZmllbGRzLmNvbmNhdChpdGVtQ2FsbGJhY2socmVjb3Jkc1tpXSwgaSkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZpZWxkcztcblx0fVxuXG5cdC8vIENvbW1vbiBMYXlvdXQgVGFibGVzXG5cblx0LyoqXG5cdCAqIEBleHBvcnRzIG9wZW50eXBlLkNvdmVyYWdlXG5cdCAqIEBjbGFzc1xuXHQgKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQGV4dGVuZHMgb3BlbnR5cGUuVGFibGVcblx0ICovXG5cdGZ1bmN0aW9uIENvdmVyYWdlKGNvdmVyYWdlVGFibGUpIHtcblx0ICAgIGlmIChjb3ZlcmFnZVRhYmxlLmZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgIFRhYmxlLmNhbGwodGhpcywgJ2NvdmVyYWdlVGFibGUnLFxuXHQgICAgICAgICAgICBbe25hbWU6ICdjb3ZlcmFnZUZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX1dXG5cdCAgICAgICAgICAgIC5jb25jYXQodXNob3J0TGlzdCgnZ2x5cGgnLCBjb3ZlcmFnZVRhYmxlLmdseXBocykpXG5cdCAgICAgICAgKTtcblx0ICAgIH0gZWxzZSBpZiAoY292ZXJhZ2VUYWJsZS5mb3JtYXQgPT09IDIpIHtcblx0ICAgICAgICBUYWJsZS5jYWxsKHRoaXMsICdjb3ZlcmFnZVRhYmxlJyxcblx0ICAgICAgICAgICAgW3tuYW1lOiAnY292ZXJhZ2VGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDJ9XVxuXHQgICAgICAgICAgICAuY29uY2F0KHJlY29yZExpc3QoJ3JhbmdlUmVjb3JkJywgY292ZXJhZ2VUYWJsZS5yYW5nZXMsIGZ1bmN0aW9uKFJhbmdlUmVjb3JkKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1xuXHQgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnc3RhcnRHbHlwaElEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBSYW5nZVJlY29yZC5zdGFydH0sXG5cdCAgICAgICAgICAgICAgICAgICAge25hbWU6ICdlbmRHbHlwaElEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBSYW5nZVJlY29yZC5lbmR9LFxuXHQgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnc3RhcnRDb3ZlcmFnZUluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBSYW5nZVJlY29yZC5pbmRleH0gXTtcblx0ICAgICAgICAgICAgfSkpXG5cdCAgICAgICAgKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnQ292ZXJhZ2UgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xuXHQgICAgfVxuXHR9XG5cdENvdmVyYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGFibGUucHJvdG90eXBlKTtcblx0Q292ZXJhZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ292ZXJhZ2U7XG5cblx0ZnVuY3Rpb24gU2NyaXB0TGlzdChzY3JpcHRMaXN0VGFibGUpIHtcblx0ICAgIFRhYmxlLmNhbGwodGhpcywgJ3NjcmlwdExpc3RUYWJsZScsXG5cdCAgICAgICAgcmVjb3JkTGlzdCgnc2NyaXB0UmVjb3JkJywgc2NyaXB0TGlzdFRhYmxlLCBmdW5jdGlvbihzY3JpcHRSZWNvcmQsIGkpIHtcblx0ICAgICAgICAgICAgdmFyIHNjcmlwdCA9IHNjcmlwdFJlY29yZC5zY3JpcHQ7XG5cdCAgICAgICAgICAgIHZhciBkZWZhdWx0TGFuZ1N5cyA9IHNjcmlwdC5kZWZhdWx0TGFuZ1N5cztcblx0ICAgICAgICAgICAgY2hlY2suYXNzZXJ0KCEhZGVmYXVsdExhbmdTeXMsICdVbmFibGUgdG8gd3JpdGUgR1NVQjogc2NyaXB0ICcgKyBzY3JpcHRSZWNvcmQudGFnICsgJyBoYXMgbm8gZGVmYXVsdCBsYW5ndWFnZSBzeXN0ZW0uJyk7XG5cdCAgICAgICAgICAgIHJldHVybiBbXG5cdCAgICAgICAgICAgICAgICB7bmFtZTogJ3NjcmlwdFRhZycgKyBpLCB0eXBlOiAnVEFHJywgdmFsdWU6IHNjcmlwdFJlY29yZC50YWd9LFxuXHQgICAgICAgICAgICAgICAge25hbWU6ICdzY3JpcHQnICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyBUYWJsZSgnc2NyaXB0VGFibGUnLCBbXG5cdCAgICAgICAgICAgICAgICAgICAge25hbWU6ICdkZWZhdWx0TGFuZ1N5cycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgVGFibGUoJ2RlZmF1bHRMYW5nU3lzJywgW1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2xvb2t1cE9yZGVyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdyZXFGZWF0dXJlSW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGRlZmF1bHRMYW5nU3lzLnJlcUZlYXR1cmVJbmRleH1dXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQodXNob3J0TGlzdCgnZmVhdHVyZUluZGV4JywgZGVmYXVsdExhbmdTeXMuZmVhdHVyZUluZGV4ZXMpKSl9XG5cdCAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQocmVjb3JkTGlzdCgnbGFuZ1N5cycsIHNjcmlwdC5sYW5nU3lzUmVjb3JkcywgZnVuY3Rpb24obGFuZ1N5c1JlY29yZCwgaSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZ1N5cyA9IGxhbmdTeXNSZWNvcmQubGFuZ1N5cztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbGFuZ1N5c1RhZycgKyBpLCB0eXBlOiAnVEFHJywgdmFsdWU6IGxhbmdTeXNSZWNvcmQudGFnfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbGFuZ1N5cycgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IFRhYmxlKCdsYW5nU3lzJywgW1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbG9va3VwT3JkZXInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAncmVxRmVhdHVyZUluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsYW5nU3lzLnJlcUZlYXR1cmVJbmRleH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdCh1c2hvcnRMaXN0KCdmZWF0dXJlSW5kZXgnLCBsYW5nU3lzLmZlYXR1cmVJbmRleGVzKSkpfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBdO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKSl9XG5cdCAgICAgICAgICAgIF07XG5cdCAgICAgICAgfSlcblx0ICAgICk7XG5cdH1cblx0U2NyaXB0TGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRhYmxlLnByb3RvdHlwZSk7XG5cdFNjcmlwdExpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NyaXB0TGlzdDtcblxuXHQvKipcblx0ICogQGV4cG9ydHMgb3BlbnR5cGUuRmVhdHVyZUxpc3Rcblx0ICogQGNsYXNzXG5cdCAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAZXh0ZW5kcyBvcGVudHlwZS5UYWJsZVxuXHQgKi9cblx0ZnVuY3Rpb24gRmVhdHVyZUxpc3QoZmVhdHVyZUxpc3RUYWJsZSkge1xuXHQgICAgVGFibGUuY2FsbCh0aGlzLCAnZmVhdHVyZUxpc3RUYWJsZScsXG5cdCAgICAgICAgcmVjb3JkTGlzdCgnZmVhdHVyZVJlY29yZCcsIGZlYXR1cmVMaXN0VGFibGUsIGZ1bmN0aW9uKGZlYXR1cmVSZWNvcmQsIGkpIHtcblx0ICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlUmVjb3JkLmZlYXR1cmU7XG5cdCAgICAgICAgICAgIHJldHVybiBbXG5cdCAgICAgICAgICAgICAgICB7bmFtZTogJ2ZlYXR1cmVUYWcnICsgaSwgdHlwZTogJ1RBRycsIHZhbHVlOiBmZWF0dXJlUmVjb3JkLnRhZ30sXG5cdCAgICAgICAgICAgICAgICB7bmFtZTogJ2ZlYXR1cmUnICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyBUYWJsZSgnZmVhdHVyZVRhYmxlJywgW1xuXHQgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnZmVhdHVyZVBhcmFtcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZmVhdHVyZS5mZWF0dXJlUGFyYW1zfSBdLmNvbmNhdCh1c2hvcnRMaXN0KCdsb29rdXBMaXN0SW5kZXgnLCBmZWF0dXJlLmxvb2t1cExpc3RJbmRleGVzKSkpfVxuXHQgICAgICAgICAgICBdO1xuXHQgICAgICAgIH0pXG5cdCAgICApO1xuXHR9XG5cdEZlYXR1cmVMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGFibGUucHJvdG90eXBlKTtcblx0RmVhdHVyZUxpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmVhdHVyZUxpc3Q7XG5cblx0LyoqXG5cdCAqIEBleHBvcnRzIG9wZW50eXBlLkxvb2t1cExpc3Rcblx0ICogQGNsYXNzXG5cdCAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG5cdCAqIEBwYXJhbSB7T2JqZWN0fVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQGV4dGVuZHMgb3BlbnR5cGUuVGFibGVcblx0ICovXG5cdGZ1bmN0aW9uIExvb2t1cExpc3QobG9va3VwTGlzdFRhYmxlLCBzdWJ0YWJsZU1ha2Vycykge1xuXHQgICAgVGFibGUuY2FsbCh0aGlzLCAnbG9va3VwTGlzdFRhYmxlJywgdGFibGVMaXN0KCdsb29rdXAnLCBsb29rdXBMaXN0VGFibGUsIGZ1bmN0aW9uKGxvb2t1cFRhYmxlKSB7XG5cdCAgICAgICAgdmFyIHN1YnRhYmxlQ2FsbGJhY2sgPSBzdWJ0YWJsZU1ha2Vyc1tsb29rdXBUYWJsZS5sb29rdXBUeXBlXTtcblx0ICAgICAgICBjaGVjay5hc3NlcnQoISFzdWJ0YWJsZUNhbGxiYWNrLCAnVW5hYmxlIHRvIHdyaXRlIEdTVUIgbG9va3VwIHR5cGUgJyArIGxvb2t1cFRhYmxlLmxvb2t1cFR5cGUgKyAnIHRhYmxlcy4nKTtcblx0ICAgICAgICByZXR1cm4gbmV3IFRhYmxlKCdsb29rdXBUYWJsZScsIFtcblx0ICAgICAgICAgICAge25hbWU6ICdsb29rdXBUeXBlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsb29rdXBUYWJsZS5sb29rdXBUeXBlfSxcblx0ICAgICAgICAgICAge25hbWU6ICdsb29rdXBGbGFnJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsb29rdXBUYWJsZS5sb29rdXBGbGFnfVxuXHQgICAgICAgIF0uY29uY2F0KHRhYmxlTGlzdCgnc3VidGFibGUnLCBsb29rdXBUYWJsZS5zdWJ0YWJsZXMsIHN1YnRhYmxlQ2FsbGJhY2spKSk7XG5cdCAgICB9KSk7XG5cdH1cblx0TG9va3VwTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRhYmxlLnByb3RvdHlwZSk7XG5cdExvb2t1cExpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9va3VwTGlzdDtcblxuXHQvLyBSZWNvcmQgPSBzYW1lIGFzIFRhYmxlLCBidXQgaW5saW5lZCAoYSBUYWJsZSBoYXMgYW4gb2Zmc2V0IGFuZCBpdHMgZGF0YSBpcyBmdXJ0aGVyIGluIHRoZSBzdHJlYW0pXG5cdC8vIERvbid0IHVzZSBvZmZzZXRzIGluc2lkZSBSZWNvcmRzIChwcm9iYWJsZSBidWcpLCBvbmx5IGluIFRhYmxlcy5cblx0dmFyIHRhYmxlID0ge1xuXHQgICAgVGFibGU6IFRhYmxlLFxuXHQgICAgUmVjb3JkOiBUYWJsZSxcblx0ICAgIENvdmVyYWdlOiBDb3ZlcmFnZSxcblx0ICAgIFNjcmlwdExpc3Q6IFNjcmlwdExpc3QsXG5cdCAgICBGZWF0dXJlTGlzdDogRmVhdHVyZUxpc3QsXG5cdCAgICBMb29rdXBMaXN0OiBMb29rdXBMaXN0LFxuXHQgICAgdXNob3J0TGlzdDogdXNob3J0TGlzdCxcblx0ICAgIHRhYmxlTGlzdDogdGFibGVMaXN0LFxuXHQgICAgcmVjb3JkTGlzdDogcmVjb3JkTGlzdCxcblx0fTtcblxuXHQvLyBQYXJzaW5nIHV0aWxpdHkgZnVuY3Rpb25zXG5cblx0Ly8gUmV0cmlldmUgYW4gdW5zaWduZWQgYnl0ZSBmcm9tIHRoZSBEYXRhVmlldy5cblx0ZnVuY3Rpb24gZ2V0Qnl0ZShkYXRhVmlldywgb2Zmc2V0KSB7XG5cdCAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KTtcblx0fVxuXG5cdC8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIDE2LWJpdCBzaG9ydCBmcm9tIHRoZSBEYXRhVmlldy5cblx0Ly8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuXHRmdW5jdGlvbiBnZXRVU2hvcnQoZGF0YVZpZXcsIG9mZnNldCkge1xuXHQgICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQsIGZhbHNlKTtcblx0fVxuXG5cdC8vIFJldHJpZXZlIGEgc2lnbmVkIDE2LWJpdCBzaG9ydCBmcm9tIHRoZSBEYXRhVmlldy5cblx0Ly8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuXHRmdW5jdGlvbiBnZXRTaG9ydChkYXRhVmlldywgb2Zmc2V0KSB7XG5cdCAgICByZXR1cm4gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBmYWxzZSk7XG5cdH1cblxuXHQvLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCAzMi1iaXQgbG9uZyBmcm9tIHRoZSBEYXRhVmlldy5cblx0Ly8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuXHRmdW5jdGlvbiBnZXRVTG9uZyhkYXRhVmlldywgb2Zmc2V0KSB7XG5cdCAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuXHR9XG5cblx0Ly8gUmV0cmlldmUgYSAzMi1iaXQgc2lnbmVkIGZpeGVkLXBvaW50IG51bWJlciAoMTYuMTYpIGZyb20gdGhlIERhdGFWaWV3LlxuXHQvLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5cdGZ1bmN0aW9uIGdldEZpeGVkKGRhdGFWaWV3LCBvZmZzZXQpIHtcblx0ICAgIHZhciBkZWNpbWFsID0gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBmYWxzZSk7XG5cdCAgICB2YXIgZnJhY3Rpb24gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMiwgZmFsc2UpO1xuXHQgICAgcmV0dXJuIGRlY2ltYWwgKyBmcmFjdGlvbiAvIDY1NTM1O1xuXHR9XG5cblx0Ly8gUmV0cmlldmUgYSA0LWNoYXJhY3RlciB0YWcgZnJvbSB0aGUgRGF0YVZpZXcuXG5cdC8vIFRhZ3MgYXJlIHVzZWQgdG8gaWRlbnRpZnkgdGFibGVzLlxuXHRmdW5jdGlvbiBnZXRUYWcoZGF0YVZpZXcsIG9mZnNldCkge1xuXHQgICAgdmFyIHRhZyA9ICcnO1xuXHQgICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIDQ7IGkgKz0gMSkge1xuXHQgICAgICAgIHRhZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldEludDgoaSkpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGFnO1xuXHR9XG5cblx0Ly8gUmV0cmlldmUgYW4gb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuXHQvLyBPZmZzZXRzIGFyZSAxIHRvIDQgYnl0ZXMgaW4gbGVuZ3RoLCBkZXBlbmRpbmcgb24gdGhlIG9mZlNpemUgYXJndW1lbnQuXG5cdGZ1bmN0aW9uIGdldE9mZnNldChkYXRhVmlldywgb2Zmc2V0LCBvZmZTaXplKSB7XG5cdCAgICB2YXIgdiA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9mZlNpemU7IGkgKz0gMSkge1xuXHQgICAgICAgIHYgPDw9IDg7XG5cdCAgICAgICAgdiArPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHY7XG5cdH1cblxuXHQvLyBSZXRyaWV2ZSBhIG51bWJlciBvZiBieXRlcyBmcm9tIHN0YXJ0IG9mZnNldCB0byB0aGUgZW5kIG9mZnNldCBmcm9tIHRoZSBEYXRhVmlldy5cblx0ZnVuY3Rpb24gZ2V0Qnl0ZXMoZGF0YVZpZXcsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcblx0ICAgIHZhciBieXRlcyA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IHN0YXJ0T2Zmc2V0OyBpIDwgZW5kT2Zmc2V0OyBpICs9IDEpIHtcblx0ICAgICAgICBieXRlcy5wdXNoKGRhdGFWaWV3LmdldFVpbnQ4KGkpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGJ5dGVzO1xuXHR9XG5cblx0Ly8gQ29udmVydCB0aGUgbGlzdCBvZiBieXRlcyB0byBhIHN0cmluZy5cblx0ZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuXHQgICAgdmFyIHMgPSAnJztcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcztcblx0fVxuXG5cdHZhciB0eXBlT2Zmc2V0cyA9IHtcblx0ICAgIGJ5dGU6IDEsXG5cdCAgICB1U2hvcnQ6IDIsXG5cdCAgICBzaG9ydDogMixcblx0ICAgIHVMb25nOiA0LFxuXHQgICAgZml4ZWQ6IDQsXG5cdCAgICBsb25nRGF0ZVRpbWU6IDgsXG5cdCAgICB0YWc6IDRcblx0fTtcblxuXHQvLyBBIHN0YXRlZnVsIHBhcnNlciB0aGF0IGNoYW5nZXMgdGhlIG9mZnNldCB3aGVuZXZlciBhIHZhbHVlIGlzIHJldHJpZXZlZC5cblx0Ly8gVGhlIGRhdGEgaXMgYSBEYXRhVmlldy5cblx0ZnVuY3Rpb24gUGFyc2VyKGRhdGEsIG9mZnNldCkge1xuXHQgICAgdGhpcy5kYXRhID0gZGF0YTtcblx0ICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuXHQgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IDA7XG5cdH1cblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0VWludDgodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcblx0ICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMTtcblx0ICAgIHJldHVybiB2O1xuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VDaGFyID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG5cdCAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDE7XG5cdCAgICByZXR1cm4gdjtcblx0fTtcblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2FyZDggPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZTtcblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcblx0ICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcblx0ICAgIHJldHVybiB2O1xuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VDYXJkMTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlU0lEID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlU2hvcnQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG5cdCAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG5cdCAgICByZXR1cm4gdjtcblx0fTtcblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlRjJEb3QxNCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KSAvIDE2Mzg0O1xuXHQgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuXHQgICAgcmV0dXJuIHY7XG5cdH07XG5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgdiA9IGdldFVMb25nKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcblx0ICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcblx0ICAgIHJldHVybiB2O1xuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VPZmZzZXQzMiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZztcblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlRml4ZWQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciB2ID0gZ2V0Rml4ZWQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuXHQgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuXHQgICAgcmV0dXJuIHY7XG5cdH07XG5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHQgICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuXHQgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcblx0ICAgIHZhciBzdHJpbmcgPSAnJztcblx0ICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gbGVuZ3RoO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHN0cmluZztcblx0fTtcblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlVGFnID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmluZyg0KTtcblx0fTtcblxuXHQvLyBMT05HREFURVRJTUUgaXMgYSA2NC1iaXQgaW50ZWdlci5cblx0Ly8gSmF2YVNjcmlwdCBhbmQgdW5peCB0aW1lc3RhbXBzIHRyYWRpdGlvbmFsbHkgdXNlIDMyIGJpdHMsIHNvIHdlXG5cdC8vIG9ubHkgdGFrZSB0aGUgbGFzdCAzMiBiaXRzLlxuXHQvLyArIFNpbmNlIHVudGlsIDIwMzggdGhvc2UgYml0cyB3aWxsIGJlIGZpbGxlZCBieSB6ZXJvcyB3ZSBjYW4gaWdub3JlIHRoZW0uXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VMb25nRGF0ZVRpbWUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciB2ID0gZ2V0VUxvbmcodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQgKyA0KTtcblx0ICAgIC8vIFN1YnRyYWN0IHNlY29uZHMgYmV0d2VlbiAwMS8wMS8xOTA0IGFuZCAwMS8wMS8xOTcwXG5cdCAgICAvLyB0byBjb252ZXJ0IEFwcGxlIE1hYyB0aW1lc3RhbXAgdG8gU3RhbmRhcmQgVW5peCB0aW1lc3RhbXBcblx0ICAgIHYgLT0gMjA4Mjg0NDgwMDtcblx0ICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gODtcblx0ICAgIHJldHVybiB2O1xuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VWZXJzaW9uID0gZnVuY3Rpb24obWlub3JCYXNlKSB7XG5cdCAgICB2YXIgbWFqb3IgPSBnZXRVU2hvcnQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuXG5cdCAgICAvLyBIb3cgdG8gaW50ZXJwcmV0IHRoZSBtaW5vciB2ZXJzaW9uIGlzIHZlcnkgdmFndWUgaW4gdGhlIHNwZWMuIDB4NTAwMCBpcyA1LCAweDEwMDAgaXMgMVxuXHQgICAgLy8gRGVmYXVsdCByZXR1cm5zIHRoZSBjb3JyZWN0IG51bWJlciBpZiBtaW5vciA9IDB4TjAwMCB3aGVyZSBOIGlzIDAtOVxuXHQgICAgLy8gU2V0IG1pbm9yQmFzZSB0byAxIGZvciB0YWJsZXMgdGhhdCB1c2UgbWlub3IgPSBOIHdoZXJlIE4gaXMgMC05XG5cdCAgICB2YXIgbWlub3IgPSBnZXRVU2hvcnQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQgKyAyKTtcblx0ICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcblx0ICAgIGlmIChtaW5vckJhc2UgPT09IHVuZGVmaW5lZCkgeyBtaW5vckJhc2UgPSAweDEwMDA7IH1cblx0ICAgIHJldHVybiBtYWpvciArIG1pbm9yIC8gbWlub3JCYXNlIC8gMTA7XG5cdH07XG5cblx0UGFyc2VyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24odHlwZSwgYW1vdW50KSB7XG5cdCAgICBpZiAoYW1vdW50ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBhbW91bnQgPSAxO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IHR5cGVPZmZzZXRzW3R5cGVdICogYW1vdW50O1xuXHR9O1xuXG5cdC8vLy8vIFBhcnNpbmcgbGlzdHMgYW5kIHJlY29yZHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdC8vIFBhcnNlIGEgbGlzdCBvZiAzMiBiaXQgdW5zaWduZWQgaW50ZWdlcnMuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZ0xpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuXHQgICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHsgY291bnQgPSB0aGlzLnBhcnNlVUxvbmcoKTsgfVxuXHQgICAgdmFyIG9mZnNldHMgPSBuZXcgQXJyYXkoY291bnQpO1xuXHQgICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuXHQgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHQgICAgICAgIG9mZnNldHNbaV0gPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0KTtcblx0ICAgICAgICBvZmZzZXQgKz0gNDtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDQ7XG5cdCAgICByZXR1cm4gb2Zmc2V0cztcblx0fTtcblxuXHQvLyBQYXJzZSBhIGxpc3Qgb2YgMTYgYml0IHVuc2lnbmVkIGludGVnZXJzLiBUaGUgbGVuZ3RoIG9mIHRoZSBsaXN0IGNhbiBiZSByZWFkIG9uIHRoZSBzdHJlYW1cblx0Ly8gb3IgcHJvdmlkZWQgYXMgYW4gYXJndW1lbnQuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VPZmZzZXQxNkxpc3QgPVxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0TGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG5cdCAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkgeyBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTsgfVxuXHQgICAgdmFyIG9mZnNldHMgPSBuZXcgQXJyYXkoY291bnQpO1xuXHQgICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuXHQgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHQgICAgICAgIG9mZnNldHNbaV0gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0KTtcblx0ICAgICAgICBvZmZzZXQgKz0gMjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDI7XG5cdCAgICByZXR1cm4gb2Zmc2V0cztcblx0fTtcblxuXHQvLyBQYXJzZXMgYSBsaXN0IG9mIDE2IGJpdCBzaWduZWQgaW50ZWdlcnMuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VTaG9ydExpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuXHQgICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuXHQgICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuXHQgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHQgICAgICAgIGxpc3RbaV0gPSBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQpO1xuXHQgICAgICAgIG9mZnNldCArPSAyO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50ICogMjtcblx0ICAgIHJldHVybiBsaXN0O1xuXHR9O1xuXG5cdC8vIFBhcnNlcyBhIGxpc3Qgb2YgYnl0ZXMuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlTGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG5cdCAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG5cdCAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG5cdCAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgbGlzdFtpXSA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCsrKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudDtcblx0ICAgIHJldHVybiBsaXN0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBhIGxpc3Qgb2YgaXRlbXMuXG5cdCAqIFJlY29yZCBjb3VudCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cblx0ICogaXRlbUNhbGxiYWNrIGlzIG9uZSBvZiB0aGUgUGFyc2VyIG1ldGhvZHMuXG5cdCAqL1xuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdCA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcblx0ICAgIGlmICghaXRlbUNhbGxiYWNrKSB7XG5cdCAgICAgICAgaXRlbUNhbGxiYWNrID0gY291bnQ7XG5cdCAgICAgICAgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICB9XG5cdCAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgICBsaXN0W2ldID0gaXRlbUNhbGxiYWNrLmNhbGwodGhpcyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGlzdDtcblx0fTtcblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdDMyID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuXHQgICAgaWYgKCFpdGVtQ2FsbGJhY2spIHtcblx0ICAgICAgICBpdGVtQ2FsbGJhY2sgPSBjb3VudDtcblx0ICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVTG9uZygpO1xuXHQgICAgfVxuXHQgICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgbGlzdFtpXSA9IGl0ZW1DYWxsYmFjay5jYWxsKHRoaXMpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpc3Q7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIGEgbGlzdCBvZiByZWNvcmRzLlxuXHQgKiBSZWNvcmQgY291bnQgaXMgb3B0aW9uYWwsIGlmIG9taXR0ZWQgaXQgaXMgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG5cdCAqIEV4YW1wbGUgb2YgcmVjb3JkRGVzY3JpcHRpb246IHsgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCwgbG9va3VwTGlzdEluZGV4OiBQYXJzZXIudVNob3J0IH1cblx0ICovXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VSZWNvcmRMaXN0ID0gZnVuY3Rpb24oY291bnQsIHJlY29yZERlc2NyaXB0aW9uKSB7XG5cdCAgICAvLyBJZiB0aGUgY291bnQgYXJndW1lbnQgaXMgYWJzZW50LCByZWFkIGl0IGluIHRoZSBzdHJlYW0uXG5cdCAgICBpZiAoIXJlY29yZERlc2NyaXB0aW9uKSB7XG5cdCAgICAgICAgcmVjb3JkRGVzY3JpcHRpb24gPSBjb3VudDtcblx0ICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIH1cblx0ICAgIHZhciByZWNvcmRzID0gbmV3IEFycmF5KGNvdW50KTtcblx0ICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhyZWNvcmREZXNjcmlwdGlvbik7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgICB2YXIgcmVjID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcblx0ICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IHJlY29yZERlc2NyaXB0aW9uW2ZpZWxkTmFtZV07XG5cdCAgICAgICAgICAgIHJlY1tmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlY29yZHNbaV0gPSByZWM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVjb3Jkcztcblx0fTtcblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlUmVjb3JkTGlzdDMyID0gZnVuY3Rpb24oY291bnQsIHJlY29yZERlc2NyaXB0aW9uKSB7XG5cdCAgICAvLyBJZiB0aGUgY291bnQgYXJndW1lbnQgaXMgYWJzZW50LCByZWFkIGl0IGluIHRoZSBzdHJlYW0uXG5cdCAgICBpZiAoIXJlY29yZERlc2NyaXB0aW9uKSB7XG5cdCAgICAgICAgcmVjb3JkRGVzY3JpcHRpb24gPSBjb3VudDtcblx0ICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVTG9uZygpO1xuXHQgICAgfVxuXHQgICAgdmFyIHJlY29yZHMgPSBuZXcgQXJyYXkoY291bnQpO1xuXHQgICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKHJlY29yZERlc2NyaXB0aW9uKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHQgICAgICAgIHZhciByZWMgPSB7fTtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGRzW2pdO1xuXHQgICAgICAgICAgICB2YXIgZmllbGRUeXBlID0gcmVjb3JkRGVzY3JpcHRpb25bZmllbGROYW1lXTtcblx0ICAgICAgICAgICAgcmVjW2ZpZWxkTmFtZV0gPSBmaWVsZFR5cGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVjb3Jkc1tpXSA9IHJlYztcblx0ICAgIH1cblx0ICAgIHJldHVybiByZWNvcmRzO1xuXHR9O1xuXG5cdC8vIFBhcnNlIGEgZGF0YSBzdHJ1Y3R1cmUgaW50byBhbiBvYmplY3Rcblx0Ly8gRXhhbXBsZSBvZiBkZXNjcmlwdGlvbjogeyBzZXF1ZW5jZUluZGV4OiBQYXJzZXIudVNob3J0LCBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnQgfVxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RydWN0ID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcblx0ICAgIGlmICh0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24uY2FsbCh0aGlzKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKGRlc2NyaXB0aW9uKTtcblx0ICAgICAgICB2YXIgc3RydWN0ID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcblx0ICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IGRlc2NyaXB0aW9uW2ZpZWxkTmFtZV07XG5cdCAgICAgICAgICAgIHN0cnVjdFtmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBzdHJ1Y3Q7XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIGEgR1BPUyB2YWx1ZVJlY29yZFxuXHQgKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3BvcyN2YWx1ZS1yZWNvcmRcblx0ICogdmFsdWVGb3JtYXQgaXMgb3B0aW9uYWwsIGlmIG9taXR0ZWQgaXQgaXMgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG5cdCAqL1xuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFsdWVSZWNvcmQgPSBmdW5jdGlvbih2YWx1ZUZvcm1hdCkge1xuXHQgICAgaWYgKHZhbHVlRm9ybWF0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICB2YWx1ZUZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIH1cblx0ICAgIGlmICh2YWx1ZUZvcm1hdCA9PT0gMCkge1xuXHQgICAgICAgIC8vIHZhbHVlRm9ybWF0MiBpbiBrZXJuaW5nIHBhaXJzIGlzIG1vc3Qgb2Z0ZW4gMFxuXHQgICAgICAgIC8vIGluIHRoaXMgY2FzZSByZXR1cm4gdW5kZWZpbmVkIGluc3RlYWQgb2YgYW4gZW1wdHkgb2JqZWN0LCB0byBzYXZlIHNwYWNlXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHZhbHVlUmVjb3JkID0ge307XG5cblx0ICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwMSkgeyB2YWx1ZVJlY29yZC54UGxhY2VtZW50ID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cblx0ICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwMikgeyB2YWx1ZVJlY29yZC55UGxhY2VtZW50ID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cblx0ICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwNCkgeyB2YWx1ZVJlY29yZC54QWR2YW5jZSA9IHRoaXMucGFyc2VTaG9ydCgpOyB9XG5cdCAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMDgpIHsgdmFsdWVSZWNvcmQueUFkdmFuY2UgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuXG5cdCAgICAvLyBEZXZpY2UgdGFibGUgKG5vbi12YXJpYWJsZSBmb250KSAvIFZhcmlhdGlvbkluZGV4IHRhYmxlICh2YXJpYWJsZSBmb250KSBub3Qgc3VwcG9ydGVkXG5cdCAgICAvLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9mci1mci90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvY2hhcHRlcjIjZGV2VmFySWR4VGJsc1xuXHQgICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDEwKSB7IHZhbHVlUmVjb3JkLnhQbGFEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG5cdCAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMjApIHsgdmFsdWVSZWNvcmQueVBsYURldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cblx0ICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDA0MCkgeyB2YWx1ZVJlY29yZC54QWR2RGV2aWNlID0gdW5kZWZpbmVkOyB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuXHQgICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDgwKSB7IHZhbHVlUmVjb3JkLnlBZHZEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG5cblx0ICAgIHJldHVybiB2YWx1ZVJlY29yZDtcblx0fTtcblxuXHQvKipcblx0ICogUGFyc2UgYSBsaXN0IG9mIEdQT1MgdmFsdWVSZWNvcmRzXG5cdCAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI3ZhbHVlLXJlY29yZFxuXHQgKiB2YWx1ZUZvcm1hdCBhbmQgdmFsdWVDb3VudCBhcmUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG5cdCAqL1xuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFsdWVSZWNvcmRMaXN0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgdmFsdWVGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICB2YXIgdmFsdWVDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVDb3VudCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuXHQgICAgICAgIHZhbHVlc1tpXSA9IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh2YWx1ZUZvcm1hdCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWVzO1xuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VQb2ludGVyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcblx0ICAgIHZhciBzdHJ1Y3RPZmZzZXQgPSB0aGlzLnBhcnNlT2Zmc2V0MTYoKTtcblx0ICAgIGlmIChzdHJ1Y3RPZmZzZXQgPiAwKSB7XG5cdCAgICAgICAgLy8gTlVMTCBvZmZzZXQgPT4gcmV0dXJuIHVuZGVmaW5lZFxuXHQgICAgICAgIHJldHVybiBuZXcgUGFyc2VyKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyBzdHJ1Y3RPZmZzZXQpLnBhcnNlU3RydWN0KGRlc2NyaXB0aW9uKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdH07XG5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZVBvaW50ZXIzMiA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG5cdCAgICB2YXIgc3RydWN0T2Zmc2V0ID0gdGhpcy5wYXJzZU9mZnNldDMyKCk7XG5cdCAgICBpZiAoc3RydWN0T2Zmc2V0ID4gMCkge1xuXHQgICAgICAgIC8vIE5VTEwgb2Zmc2V0ID0+IHJldHVybiB1bmRlZmluZWRcblx0ICAgICAgICByZXR1cm4gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgc3RydWN0T2Zmc2V0KS5wYXJzZVN0cnVjdChkZXNjcmlwdGlvbik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBhIGxpc3Qgb2Ygb2Zmc2V0cyB0byBsaXN0cyBvZiAxNi1iaXQgaW50ZWdlcnMsXG5cdCAqIG9yIGEgbGlzdCBvZiBvZmZzZXRzIHRvIGxpc3RzIG9mIG9mZnNldHMgdG8gYW55IGtpbmQgb2YgaXRlbXMuXG5cdCAqIElmIGl0ZW1DYWxsYmFjayBpcyBub3QgcHJvdmlkZWQsIGEgbGlzdCBvZiBsaXN0IG9mIFVTaG9ydCBpcyBhc3N1bWVkLlxuXHQgKiBJZiBwcm92aWRlZCwgaXRlbUNhbGxiYWNrIGlzIGNhbGxlZCBvbiBlYWNoIGl0ZW0gYW5kIG11c3QgcGFyc2UgdGhlIGl0ZW0uXG5cdCAqIFNlZSBleGFtcGxlcyBpbiB0YWJsZXMvZ3N1Yi5qc1xuXHQgKi9cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpc3RPZkxpc3RzID0gZnVuY3Rpb24oaXRlbUNhbGxiYWNrKSB7XG5cdCAgICB2YXIgb2Zmc2V0cyA9IHRoaXMucGFyc2VPZmZzZXQxNkxpc3QoKTtcblx0ICAgIHZhciBjb3VudCA9IG9mZnNldHMubGVuZ3RoO1xuXHQgICAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gdGhpcy5yZWxhdGl2ZU9mZnNldDtcblx0ICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHQgICAgICAgIHZhciBzdGFydCA9IG9mZnNldHNbaV07XG5cdCAgICAgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG5cdCAgICAgICAgICAgIC8vIE5VTEwgb2Zmc2V0XG5cdCAgICAgICAgICAgIC8vIEFkZCBpIGFzIG93bmVkIHByb3BlcnR5IHRvIGxpc3QuIENvbnZlbmllbnQgd2l0aCBhc3NlcnQuXG5cdCAgICAgICAgICAgIGxpc3RbaV0gPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gc3RhcnQ7XG5cdCAgICAgICAgaWYgKGl0ZW1DYWxsYmFjaykge1xuXHQgICAgICAgICAgICB2YXIgc3ViT2Zmc2V0cyA9IHRoaXMucGFyc2VPZmZzZXQxNkxpc3QoKTtcblx0ICAgICAgICAgICAgdmFyIHN1Ykxpc3QgPSBuZXcgQXJyYXkoc3ViT2Zmc2V0cy5sZW5ndGgpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yk9mZnNldHMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSBzdGFydCArIHN1Yk9mZnNldHNbal07XG5cdCAgICAgICAgICAgICAgICBzdWJMaXN0W2pdID0gaXRlbUNhbGxiYWNrLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbGlzdFtpXSA9IHN1Ykxpc3Q7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgbGlzdFtpXSA9IHRoaXMucGFyc2VVU2hvcnRMaXN0KCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IHJlbGF0aXZlT2Zmc2V0O1xuXHQgICAgcmV0dXJuIGxpc3Q7XG5cdH07XG5cblx0Ly8vLy8gQ29tcGxleCB0YWJsZXMgcGFyc2luZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0Ly8gUGFyc2UgYSBjb3ZlcmFnZSB0YWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cblx0Ly8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cblx0Ly8gcGFyc2VyLm9mZnNldCBtdXN0IHBvaW50IHRvIHRoZSBzdGFydCBvZiB0aGUgdGFibGUgY29udGFpbmluZyB0aGUgY292ZXJhZ2UuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VDb3ZlcmFnZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuXHQgICAgdmFyIGZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIHZhciBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIGlmIChmb3JtYXQgPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBmb3JtYXQ6IDEsXG5cdCAgICAgICAgICAgIGdseXBoczogdGhpcy5wYXJzZVVTaG9ydExpc3QoY291bnQpXG5cdCAgICAgICAgfTtcblx0ICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG5cdCAgICAgICAgdmFyIHJhbmdlcyA9IG5ldyBBcnJheShjb3VudCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHJhbmdlc1tpXSA9IHtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnBhcnNlVVNob3J0KCksXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMucGFyc2VVU2hvcnQoKSxcblx0ICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzLnBhcnNlVVNob3J0KClcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgZm9ybWF0OiAyLFxuXHQgICAgICAgICAgICByYW5nZXM6IHJhbmdlc1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJzB4JyArIHN0YXJ0T2Zmc2V0LnRvU3RyaW5nKDE2KSArICc6IENvdmVyYWdlIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcblx0fTtcblxuXHQvLyBQYXJzZSBhIENsYXNzIERlZmluaXRpb24gVGFibGUgaW4gYSBHU1VCLCBHUE9TIG9yIEdERUYgdGFibGUuXG5cdC8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcHRlcjIuaHRtXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0RlZiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuXHQgICAgdmFyIGZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIGlmIChmb3JtYXQgPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBmb3JtYXQ6IDEsXG5cdCAgICAgICAgICAgIHN0YXJ0R2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSxcblx0ICAgICAgICAgICAgY2xhc3NlczogdGhpcy5wYXJzZVVTaG9ydExpc3QoKVxuXHQgICAgICAgIH07XG5cdCAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGZvcm1hdDogMixcblx0ICAgICAgICAgICAgcmFuZ2VzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdCh7XG5cdCAgICAgICAgICAgICAgICBzdGFydDogUGFyc2VyLnVTaG9ydCxcblx0ICAgICAgICAgICAgICAgIGVuZDogUGFyc2VyLnVTaG9ydCxcblx0ICAgICAgICAgICAgICAgIGNsYXNzSWQ6IFBhcnNlci51U2hvcnRcblx0ICAgICAgICAgICAgfSlcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgdGhyb3cgbmV3IEVycm9yKCcweCcgKyBzdGFydE9mZnNldC50b1N0cmluZygxNikgKyAnOiBDbGFzc0RlZiBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG5cdH07XG5cblx0Ly8vLy8gU3RhdGljIG1ldGhvZHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gVGhlc2UgY29udmVuaWVuY2UgbWV0aG9kcyBjYW4gYmUgdXNlZCBhcyBjYWxsYmFja3MgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBcInRoaXNcIiBjb250ZXh0IHNldCB0byBhIFBhcnNlciBpbnN0YW5jZS5cblxuXHRQYXJzZXIubGlzdCA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QoY291bnQsIGl0ZW1DYWxsYmFjayk7XG5cdCAgICB9O1xuXHR9O1xuXG5cdFBhcnNlci5saXN0MzIgPSBmdW5jdGlvbihjb3VudCwgaXRlbUNhbGxiYWNrKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0MzIoY291bnQsIGl0ZW1DYWxsYmFjayk7XG5cdCAgICB9O1xuXHR9O1xuXG5cdFBhcnNlci5yZWNvcmRMaXN0ID0gZnVuY3Rpb24oY291bnQsIHJlY29yZERlc2NyaXB0aW9uKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZWNvcmRMaXN0KGNvdW50LCByZWNvcmREZXNjcmlwdGlvbik7XG5cdCAgICB9O1xuXHR9O1xuXG5cdFBhcnNlci5yZWNvcmRMaXN0MzIgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlY29yZExpc3QzMihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pO1xuXHQgICAgfTtcblx0fTtcblxuXHRQYXJzZXIucG9pbnRlciA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKGRlc2NyaXB0aW9uKTtcblx0ICAgIH07XG5cdH07XG5cblx0UGFyc2VyLnBvaW50ZXIzMiA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyMzIoZGVzY3JpcHRpb24pO1xuXHQgICAgfTtcblx0fTtcblxuXHRQYXJzZXIudGFnID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRhZztcblx0UGFyc2VyLmJ5dGUgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZTtcblx0UGFyc2VyLnVTaG9ydCA9IFBhcnNlci5vZmZzZXQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5cdFBhcnNlci51U2hvcnRMaXN0ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydExpc3Q7XG5cdFBhcnNlci51TG9uZyA9IFBhcnNlci5vZmZzZXQzMiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZztcblx0UGFyc2VyLnVMb25nTGlzdCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZ0xpc3Q7XG5cdFBhcnNlci5zdHJ1Y3QgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RydWN0O1xuXHRQYXJzZXIuY292ZXJhZ2UgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ292ZXJhZ2U7XG5cdFBhcnNlci5jbGFzc0RlZiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0RlZjtcblxuXHQvLy8vLyBTY3JpcHQsIEZlYXR1cmUsIExvb2t1cCBsaXN0cyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXB0ZXIyLmh0bVxuXG5cdHZhciBsYW5nU3lzVGFibGUgPSB7XG5cdCAgICByZXNlcnZlZDogUGFyc2VyLnVTaG9ydCxcblx0ICAgIHJlcUZlYXR1cmVJbmRleDogUGFyc2VyLnVTaG9ydCxcblx0ICAgIGZlYXR1cmVJbmRleGVzOiBQYXJzZXIudVNob3J0TGlzdFxuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VTY3JpcHRMaXN0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLnJlY29yZExpc3Qoe1xuXHQgICAgICAgIHRhZzogUGFyc2VyLnRhZyxcblx0ICAgICAgICBzY3JpcHQ6IFBhcnNlci5wb2ludGVyKHtcblx0ICAgICAgICAgICAgZGVmYXVsdExhbmdTeXM6IFBhcnNlci5wb2ludGVyKGxhbmdTeXNUYWJsZSksXG5cdCAgICAgICAgICAgIGxhbmdTeXNSZWNvcmRzOiBQYXJzZXIucmVjb3JkTGlzdCh7XG5cdCAgICAgICAgICAgICAgICB0YWc6IFBhcnNlci50YWcsXG5cdCAgICAgICAgICAgICAgICBsYW5nU3lzOiBQYXJzZXIucG9pbnRlcihsYW5nU3lzVGFibGUpXG5cdCAgICAgICAgICAgIH0pXG5cdCAgICAgICAgfSlcblx0ICAgIH0pKSB8fCBbXTtcblx0fTtcblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlRmVhdHVyZUxpc3QgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIucmVjb3JkTGlzdCh7XG5cdCAgICAgICAgdGFnOiBQYXJzZXIudGFnLFxuXHQgICAgICAgIGZlYXR1cmU6IFBhcnNlci5wb2ludGVyKHtcblx0ICAgICAgICAgICAgZmVhdHVyZVBhcmFtczogUGFyc2VyLm9mZnNldDE2LFxuXHQgICAgICAgICAgICBsb29rdXBMaXN0SW5kZXhlczogUGFyc2VyLnVTaG9ydExpc3Rcblx0ICAgICAgICB9KVxuXHQgICAgfSkpIHx8IFtdO1xuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VMb29rdXBMaXN0ID0gZnVuY3Rpb24obG9va3VwVGFibGVQYXJzZXJzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmxpc3QoUGFyc2VyLnBvaW50ZXIoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIGxvb2t1cFR5cGUgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgY2hlY2suYXJndW1lbnQoMSA8PSBsb29rdXBUeXBlICYmIGxvb2t1cFR5cGUgPD0gOSwgJ0dQT1MvR1NVQiBsb29rdXAgdHlwZSAnICsgbG9va3VwVHlwZSArICcgdW5rbm93bi4nKTtcblx0ICAgICAgICB2YXIgbG9va3VwRmxhZyA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICB2YXIgdXNlTWFya0ZpbHRlcmluZ1NldCA9IGxvb2t1cEZsYWcgJiAweDEwO1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGxvb2t1cFR5cGU6IGxvb2t1cFR5cGUsXG5cdCAgICAgICAgICAgIGxvb2t1cEZsYWc6IGxvb2t1cEZsYWcsXG5cdCAgICAgICAgICAgIHN1YnRhYmxlczogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIobG9va3VwVGFibGVQYXJzZXJzW2xvb2t1cFR5cGVdKSksXG5cdCAgICAgICAgICAgIG1hcmtGaWx0ZXJpbmdTZXQ6IHVzZU1hcmtGaWx0ZXJpbmdTZXQgPyB0aGlzLnBhcnNlVVNob3J0KCkgOiB1bmRlZmluZWRcblx0ICAgICAgICB9O1xuXHQgICAgfSkpKSB8fCBbXTtcblx0fTtcblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlRmVhdHVyZVZhcmlhdGlvbnNMaXN0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIzMihmdW5jdGlvbigpIHtcblx0ICAgICAgICB2YXIgbWFqb3JWZXJzaW9uID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIHZhciBtaW5vclZlcnNpb24gPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgY2hlY2suYXJndW1lbnQobWFqb3JWZXJzaW9uID09PSAxICYmIG1pbm9yVmVyc2lvbiA8IDEsICdHUE9TL0dTVUIgZmVhdHVyZSB2YXJpYXRpb25zIHRhYmxlIHVua25vd24uJyk7XG5cdCAgICAgICAgdmFyIGZlYXR1cmVWYXJpYXRpb25zID0gdGhpcy5wYXJzZVJlY29yZExpc3QzMih7XG5cdCAgICAgICAgICAgIGNvbmRpdGlvblNldE9mZnNldDogUGFyc2VyLm9mZnNldDMyLFxuXHQgICAgICAgICAgICBmZWF0dXJlVGFibGVTdWJzdGl0dXRpb25PZmZzZXQ6IFBhcnNlci5vZmZzZXQzMlxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBmZWF0dXJlVmFyaWF0aW9ucztcblx0ICAgIH0pIHx8IFtdO1xuXHR9O1xuXG5cdHZhciBwYXJzZSA9IHtcblx0ICAgIGdldEJ5dGU6IGdldEJ5dGUsXG5cdCAgICBnZXRDYXJkODogZ2V0Qnl0ZSxcblx0ICAgIGdldFVTaG9ydDogZ2V0VVNob3J0LFxuXHQgICAgZ2V0Q2FyZDE2OiBnZXRVU2hvcnQsXG5cdCAgICBnZXRTaG9ydDogZ2V0U2hvcnQsXG5cdCAgICBnZXRVTG9uZzogZ2V0VUxvbmcsXG5cdCAgICBnZXRGaXhlZDogZ2V0Rml4ZWQsXG5cdCAgICBnZXRUYWc6IGdldFRhZyxcblx0ICAgIGdldE9mZnNldDogZ2V0T2Zmc2V0LFxuXHQgICAgZ2V0Qnl0ZXM6IGdldEJ5dGVzLFxuXHQgICAgYnl0ZXNUb1N0cmluZzogYnl0ZXNUb1N0cmluZyxcblx0ICAgIFBhcnNlcjogUGFyc2VyLFxuXHR9O1xuXG5cdC8vIFRoZSBgY21hcGAgdGFibGUgc3RvcmVzIHRoZSBtYXBwaW5ncyBmcm9tIGNoYXJhY3RlcnMgdG8gZ2x5cGhzLlxuXG5cdGZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlRm9ybWF0MTIoY21hcCwgcCkge1xuXHQgICAgLy9Ta2lwIHJlc2VydmVkLlxuXHQgICAgcC5wYXJzZVVTaG9ydCgpO1xuXG5cdCAgICAvLyBMZW5ndGggaW4gYnl0ZXMgb2YgdGhlIHN1Yi10YWJsZXMuXG5cdCAgICBjbWFwLmxlbmd0aCA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgY21hcC5sYW5ndWFnZSA9IHAucGFyc2VVTG9uZygpO1xuXG5cdCAgICB2YXIgZ3JvdXBDb3VudDtcblx0ICAgIGNtYXAuZ3JvdXBDb3VudCA9IGdyb3VwQ291bnQgPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgIGNtYXAuZ2x5cGhJbmRleE1hcCA9IHt9O1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQ291bnQ7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBzdGFydENoYXJDb2RlID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICAgICAgdmFyIGVuZENoYXJDb2RlID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICAgICAgdmFyIHN0YXJ0R2x5cGhJZCA9IHAucGFyc2VVTG9uZygpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgYyA9IHN0YXJ0Q2hhckNvZGU7IGMgPD0gZW5kQ2hhckNvZGU7IGMgKz0gMSkge1xuXHQgICAgICAgICAgICBjbWFwLmdseXBoSW5kZXhNYXBbY10gPSBzdGFydEdseXBoSWQ7XG5cdCAgICAgICAgICAgIHN0YXJ0R2x5cGhJZCsrO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlRm9ybWF0NChjbWFwLCBwLCBkYXRhLCBzdGFydCwgb2Zmc2V0KSB7XG5cdCAgICAvLyBMZW5ndGggaW4gYnl0ZXMgb2YgdGhlIHN1Yi10YWJsZXMuXG5cdCAgICBjbWFwLmxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIGNtYXAubGFuZ3VhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG5cblx0ICAgIC8vIHNlZ0NvdW50IGlzIHN0b3JlZCB4IDIuXG5cdCAgICB2YXIgc2VnQ291bnQ7XG5cdCAgICBjbWFwLnNlZ0NvdW50ID0gc2VnQ291bnQgPSBwLnBhcnNlVVNob3J0KCkgPj4gMTtcblxuXHQgICAgLy8gU2tpcCBzZWFyY2hSYW5nZSwgZW50cnlTZWxlY3RvciwgcmFuZ2VTaGlmdC5cblx0ICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG5cblx0ICAgIC8vIFRoZSBcInVucm9sbGVkXCIgbWFwcGluZyBmcm9tIGNoYXJhY3RlciBjb2RlcyB0byBnbHlwaCBpbmRpY2VzLlxuXHQgICAgY21hcC5nbHlwaEluZGV4TWFwID0ge307XG5cdCAgICB2YXIgZW5kQ291bnRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTQpO1xuXHQgICAgdmFyIHN0YXJ0Q291bnRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDIpO1xuXHQgICAgdmFyIGlkRGVsdGFQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDQpO1xuXHQgICAgdmFyIGlkUmFuZ2VPZmZzZXRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDYpO1xuXHQgICAgdmFyIGdseXBoSW5kZXhPZmZzZXQgPSBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA4O1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdDb3VudCAtIDE7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBnbHlwaEluZGV4ID0gKHZvaWQgMCk7XG5cdCAgICAgICAgdmFyIGVuZENvdW50ID0gZW5kQ291bnRQYXJzZXIucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICB2YXIgc3RhcnRDb3VudCA9IHN0YXJ0Q291bnRQYXJzZXIucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICB2YXIgaWREZWx0YSA9IGlkRGVsdGFQYXJzZXIucGFyc2VTaG9ydCgpO1xuXHQgICAgICAgIHZhciBpZFJhbmdlT2Zmc2V0ID0gaWRSYW5nZU9mZnNldFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIGZvciAodmFyIGMgPSBzdGFydENvdW50OyBjIDw9IGVuZENvdW50OyBjICs9IDEpIHtcblx0ICAgICAgICAgICAgaWYgKGlkUmFuZ2VPZmZzZXQgIT09IDApIHtcblx0ICAgICAgICAgICAgICAgIC8vIFRoZSBpZFJhbmdlT2Zmc2V0IGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBpZFJhbmdlT2Zmc2V0IGFycmF5LlxuXHQgICAgICAgICAgICAgICAgLy8gVGFrZSB0aGUgY3VycmVudCBvZmZzZXQgaW4gdGhlIGlkUmFuZ2VPZmZzZXQgYXJyYXkuXG5cdCAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ID0gKGlkUmFuZ2VPZmZzZXRQYXJzZXIub2Zmc2V0ICsgaWRSYW5nZU9mZnNldFBhcnNlci5yZWxhdGl2ZU9mZnNldCAtIDIpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHZhbHVlIG9mIHRoZSBpZFJhbmdlT2Zmc2V0LCB3aGljaCB3aWxsIG1vdmUgdXMgaW50byB0aGUgZ2x5cGhJbmRleCBhcnJheS5cblx0ICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gaWRSYW5nZU9mZnNldDtcblxuXHQgICAgICAgICAgICAgICAgLy8gVGhlbiBhZGQgdGhlIGNoYXJhY3RlciBpbmRleCBvZiB0aGUgY3VycmVudCBzZWdtZW50LCBtdWx0aXBsaWVkIGJ5IDIgZm9yIFVTSE9SVHMuXG5cdCAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ICs9IChjIC0gc3RhcnRDb3VudCkgKiAyO1xuXHQgICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBnbHlwaEluZGV4T2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIGlmIChnbHlwaEluZGV4ICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IChnbHlwaEluZGV4ICsgaWREZWx0YSkgJiAweEZGRkY7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGMgKyBpZERlbHRhKSAmIDB4RkZGRjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IGdseXBoSW5kZXg7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9XG5cblx0Ly8gUGFyc2UgdGhlIGBjbWFwYCB0YWJsZS4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG5cdC8vIFRoZXJlIGFyZSBtYW55IGF2YWlsYWJsZSBmb3JtYXRzLCBidXQgd2Ugb25seSBzdXBwb3J0IHRoZSBXaW5kb3dzIGZvcm1hdCA0IGFuZCAxMi5cblx0Ly8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYENtYXBFbmNvZGluZ2Agb2JqZWN0IG9yIG51bGwgaWYgbm8gc3VwcG9ydGVkIGZvcm1hdCBjb3VsZCBiZSBmb3VuZC5cblx0ZnVuY3Rpb24gcGFyc2VDbWFwVGFibGUoZGF0YSwgc3RhcnQpIHtcblx0ICAgIHZhciBjbWFwID0ge307XG5cdCAgICBjbWFwLnZlcnNpb24gPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQpO1xuXHQgICAgY2hlY2suYXJndW1lbnQoY21hcC52ZXJzaW9uID09PSAwLCAnY21hcCB0YWJsZSB2ZXJzaW9uIHNob3VsZCBiZSAwLicpO1xuXG5cdCAgICAvLyBUaGUgY21hcCB0YWJsZSBjYW4gY29udGFpbiBtYW55IHN1Yi10YWJsZXMsIGVhY2ggd2l0aCB0aGVpciBvd24gZm9ybWF0LlxuXHQgICAgLy8gV2UncmUgb25seSBpbnRlcmVzdGVkIGluIGEgXCJwbGF0Zm9ybSAwXCIgKFVuaWNvZGUgZm9ybWF0KSBhbmQgXCJwbGF0Zm9ybSAzXCIgKFdpbmRvd3MgZm9ybWF0KSB0YWJsZS5cblx0ICAgIGNtYXAubnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgMik7XG5cdCAgICB2YXIgb2Zmc2V0ID0gLTE7XG5cdCAgICBmb3IgKHZhciBpID0gY21hcC5udW1UYWJsZXMgLSAxOyBpID49IDA7IGkgLT0gMSkge1xuXHQgICAgICAgIHZhciBwbGF0Zm9ybUlkID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgNCArIChpICogOCkpO1xuXHQgICAgICAgIHZhciBlbmNvZGluZ0lkID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgNCArIChpICogOCkgKyAyKTtcblx0ICAgICAgICBpZiAoKHBsYXRmb3JtSWQgPT09IDMgJiYgKGVuY29kaW5nSWQgPT09IDAgfHwgZW5jb2RpbmdJZCA9PT0gMSB8fCBlbmNvZGluZ0lkID09PSAxMCkpIHx8XG5cdCAgICAgICAgICAgIChwbGF0Zm9ybUlkID09PSAwICYmIChlbmNvZGluZ0lkID09PSAwIHx8IGVuY29kaW5nSWQgPT09IDEgfHwgZW5jb2RpbmdJZCA9PT0gMiB8fCBlbmNvZGluZ0lkID09PSAzIHx8IGVuY29kaW5nSWQgPT09IDQpKSkge1xuXHQgICAgICAgICAgICBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpICsgNCk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcblx0ICAgICAgICAvLyBUaGVyZSBpcyBubyBjbWFwIHRhYmxlIGluIHRoZSBmb250IHRoYXQgd2Ugc3VwcG9ydC5cblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGNtYXAgc3ViLXRhYmxlcyBmb3VuZC4nKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0KTtcblx0ICAgIGNtYXAuZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuXG5cdCAgICBpZiAoY21hcC5mb3JtYXQgPT09IDEyKSB7XG5cdCAgICAgICAgcGFyc2VDbWFwVGFibGVGb3JtYXQxMihjbWFwLCBwKTtcblx0ICAgIH0gZWxzZSBpZiAoY21hcC5mb3JtYXQgPT09IDQpIHtcblx0ICAgICAgICBwYXJzZUNtYXBUYWJsZUZvcm1hdDQoY21hcCwgcCwgZGF0YSwgc3RhcnQsIG9mZnNldCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBmb3JtYXQgNCBhbmQgMTIgY21hcCB0YWJsZXMgYXJlIHN1cHBvcnRlZCAoZm91bmQgZm9ybWF0ICcgKyBjbWFwLmZvcm1hdCArICcpLicpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gY21hcDtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZFNlZ21lbnQodCwgY29kZSwgZ2x5cGhJbmRleCkge1xuXHQgICAgdC5zZWdtZW50cy5wdXNoKHtcblx0ICAgICAgICBlbmQ6IGNvZGUsXG5cdCAgICAgICAgc3RhcnQ6IGNvZGUsXG5cdCAgICAgICAgZGVsdGE6IC0oY29kZSAtIGdseXBoSW5kZXgpLFxuXHQgICAgICAgIG9mZnNldDogMCxcblx0ICAgICAgICBnbHlwaEluZGV4OiBnbHlwaEluZGV4XG5cdCAgICB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpIHtcblx0ICAgIHQuc2VnbWVudHMucHVzaCh7XG5cdCAgICAgICAgZW5kOiAweEZGRkYsXG5cdCAgICAgICAgc3RhcnQ6IDB4RkZGRixcblx0ICAgICAgICBkZWx0YTogMSxcblx0ICAgICAgICBvZmZzZXQ6IDBcblx0ICAgIH0pO1xuXHR9XG5cblx0Ly8gTWFrZSBjbWFwIHRhYmxlLCBmb3JtYXQgNCBieSBkZWZhdWx0LCAxMiBpZiBuZWVkZWQgb25seVxuXHRmdW5jdGlvbiBtYWtlQ21hcFRhYmxlKGdseXBocykge1xuXHQgICAgLy8gUGxhbiAwIGlzIHRoZSBiYXNlIFVuaWNvZGUgUGxhbiBidXQgZW1vamlzLCBmb3IgZXhhbXBsZSBhcmUgb24gYW5vdGhlciBwbGFuLCBhbmQgbmVlZHMgY21hcCAxMiBmb3JtYXQgKHdpdGggMzJiaXQpXG5cdCAgICB2YXIgaXNQbGFuME9ubHkgPSB0cnVlO1xuXHQgICAgdmFyIGk7XG5cblx0ICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gYWRkIGNtYXAgZm9ybWF0IDEyIG9yIGlmIGZvcm1hdCA0IG9ubHkgaXMgZmluZVxuXHQgICAgZm9yIChpID0gZ2x5cGhzLmxlbmd0aCAtIDE7IGkgPiAwOyBpIC09IDEpIHtcblx0ICAgICAgICB2YXIgZyA9IGdseXBocy5nZXQoaSk7XG5cdCAgICAgICAgaWYgKGcudW5pY29kZSA+IDY1NTM1KSB7XG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgQ01BUCBmb3JtYXQgMTIgKG5lZWRlZCEpJyk7XG5cdCAgICAgICAgICAgIGlzUGxhbjBPbmx5ID0gZmFsc2U7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGNtYXBUYWJsZSA9IFtcblx0ICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbnVtVGFibGVzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBpc1BsYW4wT25seSA/IDEgOiAyfSxcblxuXHQgICAgICAgIC8vIENNQVAgNCBoZWFkZXJcblx0ICAgICAgICB7bmFtZTogJ3BsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDN9LFxuXHQgICAgICAgIHtuYW1lOiAnZW5jb2RpbmdJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG5cdCAgICAgICAge25hbWU6ICdvZmZzZXQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogaXNQbGFuME9ubHkgPyAxMiA6ICgxMiArIDgpfVxuXHQgICAgXTtcblxuXHQgICAgaWYgKCFpc1BsYW4wT25seSlcblx0ICAgICAgICB7IGNtYXBUYWJsZSA9IGNtYXBUYWJsZS5jb25jYXQoW1xuXHQgICAgICAgICAgICAvLyBDTUFQIDEyIGhlYWRlclxuXHQgICAgICAgICAgICB7bmFtZTogJ2NtYXAxMlBsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDN9LCAvLyBXZSBlbmNvZGUgb25seSBmb3IgUGxhdGZvcm1JRCA9IDMgKFdpbmRvd3MpIGJlY2F1c2UgaXQgaXMgc3VwcG9ydGVkIGV2ZXJ5d2hlcmVcblx0ICAgICAgICAgICAge25hbWU6ICdjbWFwMTJFbmNvZGluZ0lEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxMH0sXG5cdCAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyT2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9XG5cdCAgICAgICAgXSk7IH1cblxuXHQgICAgY21hcFRhYmxlID0gY21hcFRhYmxlLmNvbmNhdChbXG5cdCAgICAgICAgLy8gQ01BUCA0IFN1YnRhYmxlXG5cdCAgICAgICAge25hbWU6ICdmb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDR9LFxuXHQgICAgICAgIHtuYW1lOiAnY21hcDRMZW5ndGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbGFuZ3VhZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnc2VnQ291bnRYMicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdzZWFyY2hSYW5nZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdlbnRyeVNlbGVjdG9yJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3JhbmdlU2hpZnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG5cdCAgICBdKTtcblxuXHQgICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ2NtYXAnLCBjbWFwVGFibGUpO1xuXG5cdCAgICB0LnNlZ21lbnRzID0gW107XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzLmdldChpKTtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBoLnVuaWNvZGVzLmxlbmd0aDsgaiArPSAxKSB7XG5cdCAgICAgICAgICAgIGFkZFNlZ21lbnQodCwgZ2x5cGgudW5pY29kZXNbal0sIGkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHQuc2VnbWVudHMgPSB0LnNlZ21lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBhZGRUZXJtaW5hdG9yU2VnbWVudCh0KTtcblxuXHQgICAgdmFyIHNlZ0NvdW50ID0gdC5zZWdtZW50cy5sZW5ndGg7XG5cdCAgICB2YXIgc2VnQ291bnRUb1JlbW92ZSA9IDA7XG5cblx0ICAgIC8vIENNQVAgNFxuXHQgICAgLy8gU2V0IHVwIHBhcmFsbGVsIHNlZ21lbnQgYXJyYXlzLlxuXHQgICAgdmFyIGVuZENvdW50cyA9IFtdO1xuXHQgICAgdmFyIHN0YXJ0Q291bnRzID0gW107XG5cdCAgICB2YXIgaWREZWx0YXMgPSBbXTtcblx0ICAgIHZhciBpZFJhbmdlT2Zmc2V0cyA9IFtdO1xuXHQgICAgdmFyIGdseXBoSWRzID0gW107XG5cblx0ICAgIC8vIENNQVAgMTJcblx0ICAgIHZhciBjbWFwMTJHcm91cHMgPSBbXTtcblxuXHQgICAgLy8gUmVtaW5kZXIgdGhpcyBsb29wIGlzIG5vdCBmb2xsb3dpbmcgdGhlIHNwZWNpZmljYXRpb24gYXQgMTAwJVxuXHQgICAgLy8gVGhlIHNwZWNpZmljYXRpb24gLT4gZmluZCBzdWl0ZXMgb2YgY2hhcmFjdGVycyBhbmQgbWFrZSBhIGdyb3VwXG5cdCAgICAvLyBIZXJlIHdlJ3JlIGRvaW5nIG9uZSBncm91cCBmb3IgZWFjaCBsZXR0ZXJcblx0ICAgIC8vIERvaW5nIGFzIHRoZSBzcGVjIGNhbiBzYXZlIDggdGltZXMgKG9yIG1vcmUpIHNwYWNlXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgc2VnQ291bnQ7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBzZWdtZW50ID0gdC5zZWdtZW50c1tpXTtcblxuXHQgICAgICAgIC8vIENNQVAgNFxuXHQgICAgICAgIGlmIChzZWdtZW50LmVuZCA8PSA2NTUzNSAmJiBzZWdtZW50LnN0YXJ0IDw9IDY1NTM1KSB7XG5cdCAgICAgICAgICAgIGVuZENvdW50cyA9IGVuZENvdW50cy5jb25jYXQoe25hbWU6ICdlbmRfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5lbmR9KTtcblx0ICAgICAgICAgICAgc3RhcnRDb3VudHMgPSBzdGFydENvdW50cy5jb25jYXQoe25hbWU6ICdzdGFydF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50LnN0YXJ0fSk7XG5cdCAgICAgICAgICAgIGlkRGVsdGFzID0gaWREZWx0YXMuY29uY2F0KHtuYW1lOiAnaWREZWx0YV8nICsgaSwgdHlwZTogJ1NIT1JUJywgdmFsdWU6IHNlZ21lbnQuZGVsdGF9KTtcblx0ICAgICAgICAgICAgaWRSYW5nZU9mZnNldHMgPSBpZFJhbmdlT2Zmc2V0cy5jb25jYXQoe25hbWU6ICdpZFJhbmdlT2Zmc2V0XycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQub2Zmc2V0fSk7XG5cdCAgICAgICAgICAgIGlmIChzZWdtZW50LmdseXBoSWQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgZ2x5cGhJZHMgPSBnbHlwaElkcy5jb25jYXQoe25hbWU6ICdnbHlwaF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50LmdseXBoSWR9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIFNraXAgVW5pY29kZSA+IDY1NTM1ICgxNmJpdCB1bnNpZ25lZCBtYXgpIGZvciBDTUFQIDQsIHdpbGwgYmUgYWRkZWQgaW4gQ01BUCAxMlxuXHQgICAgICAgICAgICBzZWdDb3VudFRvUmVtb3ZlICs9IDE7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ01BUCAxMlxuXHQgICAgICAgIC8vIFNraXAgVGVybWluYXRvciBTZWdtZW50XG5cdCAgICAgICAgaWYgKCFpc1BsYW4wT25seSAmJiBzZWdtZW50LmdseXBoSW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICBjbWFwMTJHcm91cHMgPSBjbWFwMTJHcm91cHMuY29uY2F0KHtuYW1lOiAnY21hcDEyU3RhcnRfJyArIGksIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBzZWdtZW50LnN0YXJ0fSk7XG5cdCAgICAgICAgICAgIGNtYXAxMkdyb3VwcyA9IGNtYXAxMkdyb3Vwcy5jb25jYXQoe25hbWU6ICdjbWFwMTJFbmRfJyArIGksIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBzZWdtZW50LmVuZH0pO1xuXHQgICAgICAgICAgICBjbWFwMTJHcm91cHMgPSBjbWFwMTJHcm91cHMuY29uY2F0KHtuYW1lOiAnY21hcDEyR2x5cGhfJyArIGksIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBzZWdtZW50LmdseXBoSW5kZXh9KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vIENNQVAgNCBTdWJ0YWJsZVxuXHQgICAgdC5zZWdDb3VudFgyID0gKHNlZ0NvdW50IC0gc2VnQ291bnRUb1JlbW92ZSkgKiAyO1xuXHQgICAgdC5zZWFyY2hSYW5nZSA9IE1hdGgucG93KDIsIE1hdGguZmxvb3IoTWF0aC5sb2coKHNlZ0NvdW50IC0gc2VnQ291bnRUb1JlbW92ZSkpIC8gTWF0aC5sb2coMikpKSAqIDI7XG5cdCAgICB0LmVudHJ5U2VsZWN0b3IgPSBNYXRoLmxvZyh0LnNlYXJjaFJhbmdlIC8gMikgLyBNYXRoLmxvZygyKTtcblx0ICAgIHQucmFuZ2VTaGlmdCA9IHQuc2VnQ291bnRYMiAtIHQuc2VhcmNoUmFuZ2U7XG5cblx0ICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGVuZENvdW50cyk7XG5cdCAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAncmVzZXJ2ZWRQYWQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9KTtcblx0ICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KHN0YXJ0Q291bnRzKTtcblx0ICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGlkRGVsdGFzKTtcblx0ICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGlkUmFuZ2VPZmZzZXRzKTtcblx0ICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGdseXBoSWRzKTtcblxuXHQgICAgdC5jbWFwNExlbmd0aCA9IDE0ICsgLy8gU3VidGFibGUgaGVhZGVyXG5cdCAgICAgICAgZW5kQ291bnRzLmxlbmd0aCAqIDIgK1xuXHQgICAgICAgIDIgKyAvLyByZXNlcnZlZFBhZFxuXHQgICAgICAgIHN0YXJ0Q291bnRzLmxlbmd0aCAqIDIgK1xuXHQgICAgICAgIGlkRGVsdGFzLmxlbmd0aCAqIDIgK1xuXHQgICAgICAgIGlkUmFuZ2VPZmZzZXRzLmxlbmd0aCAqIDIgK1xuXHQgICAgICAgIGdseXBoSWRzLmxlbmd0aCAqIDI7XG5cblx0ICAgIGlmICghaXNQbGFuME9ubHkpIHtcblx0ICAgICAgICAvLyBDTUFQIDEyIFN1YnRhYmxlXG5cdCAgICAgICAgdmFyIGNtYXAxMkxlbmd0aCA9IDE2ICsgLy8gU3VidGFibGUgaGVhZGVyXG5cdCAgICAgICAgICAgIGNtYXAxMkdyb3Vwcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgdC5jbWFwMTJPZmZzZXQgPSAxMiArICgyICogMikgKyA0ICsgdC5jbWFwNExlbmd0aDtcblx0ICAgICAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChbXG5cdCAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyRm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxMn0sXG5cdCAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyUmVzZXJ2ZWQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgICAgICB7bmFtZTogJ2NtYXAxMkxlbmd0aCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBjbWFwMTJMZW5ndGh9LFxuXHQgICAgICAgICAgICB7bmFtZTogJ2NtYXAxMkxhbmd1YWdlJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuXHQgICAgICAgICAgICB7bmFtZTogJ2NtYXAxMm5Hcm91cHMnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogY21hcDEyR3JvdXBzLmxlbmd0aCAvIDN9XG5cdCAgICAgICAgXSk7XG5cblx0ICAgICAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChjbWFwMTJHcm91cHMpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdDtcblx0fVxuXG5cdHZhciBjbWFwID0geyBwYXJzZTogcGFyc2VDbWFwVGFibGUsIG1ha2U6IG1ha2VDbWFwVGFibGUgfTtcblxuXHQvLyBHbHlwaCBlbmNvZGluZ1xuXG5cdHZhciBjZmZTdGFuZGFyZFN0cmluZ3MgPSBbXG5cdCAgICAnLm5vdGRlZicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsICdhbXBlcnNhbmQnLCAncXVvdGVyaWdodCcsXG5cdCAgICAncGFyZW5sZWZ0JywgJ3BhcmVucmlnaHQnLCAnYXN0ZXJpc2snLCAncGx1cycsICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ3NsYXNoJywgJ3plcm8nLCAnb25lJywgJ3R3bycsXG5cdCAgICAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJywgJ2VxdWFsJywgJ2dyZWF0ZXInLFxuXHQgICAgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuXHQgICAgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnYnJhY2tldGxlZnQnLCAnYmFja3NsYXNoJywgJ2JyYWNrZXRyaWdodCcsICdhc2NpaWNpcmN1bScsICd1bmRlcnNjb3JlJyxcblx0ICAgICdxdW90ZWxlZnQnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLCAncCcsICdxJywgJ3InLCAncycsICd0Jyxcblx0ICAgICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsICdleGNsYW1kb3duJywgJ2NlbnQnLCAnc3RlcmxpbmcnLFxuXHQgICAgJ2ZyYWN0aW9uJywgJ3llbicsICdmbG9yaW4nLCAnc2VjdGlvbicsICdjdXJyZW5jeScsICdxdW90ZXNpbmdsZScsICdxdW90ZWRibGxlZnQnLCAnZ3VpbGxlbW90bGVmdCcsXG5cdCAgICAnZ3VpbHNpbmdsbGVmdCcsICdndWlsc2luZ2xyaWdodCcsICdmaScsICdmbCcsICdlbmRhc2gnLCAnZGFnZ2VyJywgJ2RhZ2dlcmRibCcsICdwZXJpb2RjZW50ZXJlZCcsICdwYXJhZ3JhcGgnLFxuXHQgICAgJ2J1bGxldCcsICdxdW90ZXNpbmdsYmFzZScsICdxdW90ZWRibGJhc2UnLCAncXVvdGVkYmxyaWdodCcsICdndWlsbGVtb3RyaWdodCcsICdlbGxpcHNpcycsICdwZXJ0aG91c2FuZCcsXG5cdCAgICAncXVlc3Rpb25kb3duJywgJ2dyYXZlJywgJ2FjdXRlJywgJ2NpcmN1bWZsZXgnLCAndGlsZGUnLCAnbWFjcm9uJywgJ2JyZXZlJywgJ2RvdGFjY2VudCcsICdkaWVyZXNpcycsICdyaW5nJyxcblx0ICAgICdjZWRpbGxhJywgJ2h1bmdhcnVtbGF1dCcsICdvZ29uZWsnLCAnY2Fyb24nLCAnZW1kYXNoJywgJ0FFJywgJ29yZGZlbWluaW5lJywgJ0xzbGFzaCcsICdPc2xhc2gnLCAnT0UnLFxuXHQgICAgJ29yZG1hc2N1bGluZScsICdhZScsICdkb3RsZXNzaScsICdsc2xhc2gnLCAnb3NsYXNoJywgJ29lJywgJ2dlcm1hbmRibHMnLCAnb25lc3VwZXJpb3InLCAnbG9naWNhbG5vdCcsICdtdScsXG5cdCAgICAndHJhZGVtYXJrJywgJ0V0aCcsICdvbmVoYWxmJywgJ3BsdXNtaW51cycsICdUaG9ybicsICdvbmVxdWFydGVyJywgJ2RpdmlkZScsICdicm9rZW5iYXInLCAnZGVncmVlJywgJ3Rob3JuJyxcblx0ICAgICd0aHJlZXF1YXJ0ZXJzJywgJ3R3b3N1cGVyaW9yJywgJ3JlZ2lzdGVyZWQnLCAnbWludXMnLCAnZXRoJywgJ211bHRpcGx5JywgJ3RocmVlc3VwZXJpb3InLCAnY29weXJpZ2h0Jyxcblx0ICAgICdBYWN1dGUnLCAnQWNpcmN1bWZsZXgnLCAnQWRpZXJlc2lzJywgJ0FncmF2ZScsICdBcmluZycsICdBdGlsZGUnLCAnQ2NlZGlsbGEnLCAnRWFjdXRlJywgJ0VjaXJjdW1mbGV4Jyxcblx0ICAgICdFZGllcmVzaXMnLCAnRWdyYXZlJywgJ0lhY3V0ZScsICdJY2lyY3VtZmxleCcsICdJZGllcmVzaXMnLCAnSWdyYXZlJywgJ050aWxkZScsICdPYWN1dGUnLCAnT2NpcmN1bWZsZXgnLFxuXHQgICAgJ09kaWVyZXNpcycsICdPZ3JhdmUnLCAnT3RpbGRlJywgJ1NjYXJvbicsICdVYWN1dGUnLCAnVWNpcmN1bWZsZXgnLCAnVWRpZXJlc2lzJywgJ1VncmF2ZScsICdZYWN1dGUnLFxuXHQgICAgJ1lkaWVyZXNpcycsICdaY2Fyb24nLCAnYWFjdXRlJywgJ2FjaXJjdW1mbGV4JywgJ2FkaWVyZXNpcycsICdhZ3JhdmUnLCAnYXJpbmcnLCAnYXRpbGRlJywgJ2NjZWRpbGxhJywgJ2VhY3V0ZScsXG5cdCAgICAnZWNpcmN1bWZsZXgnLCAnZWRpZXJlc2lzJywgJ2VncmF2ZScsICdpYWN1dGUnLCAnaWNpcmN1bWZsZXgnLCAnaWRpZXJlc2lzJywgJ2lncmF2ZScsICdudGlsZGUnLCAnb2FjdXRlJyxcblx0ICAgICdvY2lyY3VtZmxleCcsICdvZGllcmVzaXMnLCAnb2dyYXZlJywgJ290aWxkZScsICdzY2Fyb24nLCAndWFjdXRlJywgJ3VjaXJjdW1mbGV4JywgJ3VkaWVyZXNpcycsICd1Z3JhdmUnLFxuXHQgICAgJ3lhY3V0ZScsICd5ZGllcmVzaXMnLCAnemNhcm9uJywgJ2V4Y2xhbXNtYWxsJywgJ0h1bmdhcnVtbGF1dHNtYWxsJywgJ2RvbGxhcm9sZHN0eWxlJywgJ2RvbGxhcnN1cGVyaW9yJyxcblx0ICAgICdhbXBlcnNhbmRzbWFsbCcsICdBY3V0ZXNtYWxsJywgJ3BhcmVubGVmdHN1cGVyaW9yJywgJ3BhcmVucmlnaHRzdXBlcmlvcicsICcyNjYgZmYnLCAnb25lZG90ZW5sZWFkZXInLFxuXHQgICAgJ3plcm9vbGRzdHlsZScsICdvbmVvbGRzdHlsZScsICd0d29vbGRzdHlsZScsICd0aHJlZW9sZHN0eWxlJywgJ2ZvdXJvbGRzdHlsZScsICdmaXZlb2xkc3R5bGUnLCAnc2l4b2xkc3R5bGUnLFxuXHQgICAgJ3NldmVub2xkc3R5bGUnLCAnZWlnaHRvbGRzdHlsZScsICduaW5lb2xkc3R5bGUnLCAnY29tbWFzdXBlcmlvcicsICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJywgJ3BlcmlvZHN1cGVyaW9yJyxcblx0ICAgICdxdWVzdGlvbnNtYWxsJywgJ2FzdXBlcmlvcicsICdic3VwZXJpb3InLCAnY2VudHN1cGVyaW9yJywgJ2RzdXBlcmlvcicsICdlc3VwZXJpb3InLCAnaXN1cGVyaW9yJywgJ2xzdXBlcmlvcicsXG5cdCAgICAnbXN1cGVyaW9yJywgJ25zdXBlcmlvcicsICdvc3VwZXJpb3InLCAncnN1cGVyaW9yJywgJ3NzdXBlcmlvcicsICd0c3VwZXJpb3InLCAnZmYnLCAnZmZpJywgJ2ZmbCcsXG5cdCAgICAncGFyZW5sZWZ0aW5mZXJpb3InLCAncGFyZW5yaWdodGluZmVyaW9yJywgJ0NpcmN1bWZsZXhzbWFsbCcsICdoeXBoZW5zdXBlcmlvcicsICdHcmF2ZXNtYWxsJywgJ0FzbWFsbCcsXG5cdCAgICAnQnNtYWxsJywgJ0NzbWFsbCcsICdEc21hbGwnLCAnRXNtYWxsJywgJ0ZzbWFsbCcsICdHc21hbGwnLCAnSHNtYWxsJywgJ0lzbWFsbCcsICdKc21hbGwnLCAnS3NtYWxsJywgJ0xzbWFsbCcsXG5cdCAgICAnTXNtYWxsJywgJ05zbWFsbCcsICdPc21hbGwnLCAnUHNtYWxsJywgJ1FzbWFsbCcsICdSc21hbGwnLCAnU3NtYWxsJywgJ1RzbWFsbCcsICdVc21hbGwnLCAnVnNtYWxsJywgJ1dzbWFsbCcsXG5cdCAgICAnWHNtYWxsJywgJ1lzbWFsbCcsICdac21hbGwnLCAnY29sb25tb25ldGFyeScsICdvbmVmaXR0ZWQnLCAncnVwaWFoJywgJ1RpbGRlc21hbGwnLCAnZXhjbGFtZG93bnNtYWxsJyxcblx0ICAgICdjZW50b2xkc3R5bGUnLCAnTHNsYXNoc21hbGwnLCAnU2Nhcm9uc21hbGwnLCAnWmNhcm9uc21hbGwnLCAnRGllcmVzaXNzbWFsbCcsICdCcmV2ZXNtYWxsJywgJ0Nhcm9uc21hbGwnLFxuXHQgICAgJ0RvdGFjY2VudHNtYWxsJywgJ01hY3JvbnNtYWxsJywgJ2ZpZ3VyZWRhc2gnLCAnaHlwaGVuaW5mZXJpb3InLCAnT2dvbmVrc21hbGwnLCAnUmluZ3NtYWxsJywgJ0NlZGlsbGFzbWFsbCcsXG5cdCAgICAncXVlc3Rpb25kb3duc21hbGwnLCAnb25lZWlnaHRoJywgJ3RocmVlZWlnaHRocycsICdmaXZlZWlnaHRocycsICdzZXZlbmVpZ2h0aHMnLCAnb25ldGhpcmQnLCAndHdvdGhpcmRzJyxcblx0ICAgICd6ZXJvc3VwZXJpb3InLCAnZm91cnN1cGVyaW9yJywgJ2ZpdmVzdXBlcmlvcicsICdzaXhzdXBlcmlvcicsICdzZXZlbnN1cGVyaW9yJywgJ2VpZ2h0c3VwZXJpb3InLCAnbmluZXN1cGVyaW9yJyxcblx0ICAgICd6ZXJvaW5mZXJpb3InLCAnb25laW5mZXJpb3InLCAndHdvaW5mZXJpb3InLCAndGhyZWVpbmZlcmlvcicsICdmb3VyaW5mZXJpb3InLCAnZml2ZWluZmVyaW9yJywgJ3NpeGluZmVyaW9yJyxcblx0ICAgICdzZXZlbmluZmVyaW9yJywgJ2VpZ2h0aW5mZXJpb3InLCAnbmluZWluZmVyaW9yJywgJ2NlbnRpbmZlcmlvcicsICdkb2xsYXJpbmZlcmlvcicsICdwZXJpb2RpbmZlcmlvcicsXG5cdCAgICAnY29tbWFpbmZlcmlvcicsICdBZ3JhdmVzbWFsbCcsICdBYWN1dGVzbWFsbCcsICdBY2lyY3VtZmxleHNtYWxsJywgJ0F0aWxkZXNtYWxsJywgJ0FkaWVyZXNpc3NtYWxsJyxcblx0ICAgICdBcmluZ3NtYWxsJywgJ0FFc21hbGwnLCAnQ2NlZGlsbGFzbWFsbCcsICdFZ3JhdmVzbWFsbCcsICdFYWN1dGVzbWFsbCcsICdFY2lyY3VtZmxleHNtYWxsJywgJ0VkaWVyZXNpc3NtYWxsJyxcblx0ICAgICdJZ3JhdmVzbWFsbCcsICdJYWN1dGVzbWFsbCcsICdJY2lyY3VtZmxleHNtYWxsJywgJ0lkaWVyZXNpc3NtYWxsJywgJ0V0aHNtYWxsJywgJ050aWxkZXNtYWxsJywgJ09ncmF2ZXNtYWxsJyxcblx0ICAgICdPYWN1dGVzbWFsbCcsICdPY2lyY3VtZmxleHNtYWxsJywgJ090aWxkZXNtYWxsJywgJ09kaWVyZXNpc3NtYWxsJywgJ09Fc21hbGwnLCAnT3NsYXNoc21hbGwnLCAnVWdyYXZlc21hbGwnLFxuXHQgICAgJ1VhY3V0ZXNtYWxsJywgJ1VjaXJjdW1mbGV4c21hbGwnLCAnVWRpZXJlc2lzc21hbGwnLCAnWWFjdXRlc21hbGwnLCAnVGhvcm5zbWFsbCcsICdZZGllcmVzaXNzbWFsbCcsICcwMDEuMDAwJyxcblx0ICAgICcwMDEuMDAxJywgJzAwMS4wMDInLCAnMDAxLjAwMycsICdCbGFjaycsICdCb2xkJywgJ0Jvb2snLCAnTGlnaHQnLCAnTWVkaXVtJywgJ1JlZ3VsYXInLCAnUm9tYW4nLCAnU2VtaWJvbGQnXTtcblxuXHR2YXIgY2ZmU3RhbmRhcmRFbmNvZGluZyA9IFtcblx0ICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuXHQgICAgJycsICcnLCAnJywgJycsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsICdhbXBlcnNhbmQnLCAncXVvdGVyaWdodCcsXG5cdCAgICAncGFyZW5sZWZ0JywgJ3BhcmVucmlnaHQnLCAnYXN0ZXJpc2snLCAncGx1cycsICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ3NsYXNoJywgJ3plcm8nLCAnb25lJywgJ3R3bycsXG5cdCAgICAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJywgJ2VxdWFsJywgJ2dyZWF0ZXInLFxuXHQgICAgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuXHQgICAgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnYnJhY2tldGxlZnQnLCAnYmFja3NsYXNoJywgJ2JyYWNrZXRyaWdodCcsICdhc2NpaWNpcmN1bScsICd1bmRlcnNjb3JlJyxcblx0ICAgICdxdW90ZWxlZnQnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLCAncCcsICdxJywgJ3InLCAncycsICd0Jyxcblx0ICAgICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcblx0ICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcblx0ICAgICdleGNsYW1kb3duJywgJ2NlbnQnLCAnc3RlcmxpbmcnLCAnZnJhY3Rpb24nLCAneWVuJywgJ2Zsb3JpbicsICdzZWN0aW9uJywgJ2N1cnJlbmN5JywgJ3F1b3Rlc2luZ2xlJyxcblx0ICAgICdxdW90ZWRibGxlZnQnLCAnZ3VpbGxlbW90bGVmdCcsICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJycsICdlbmRhc2gnLCAnZGFnZ2VyJyxcblx0ICAgICdkYWdnZXJkYmwnLCAncGVyaW9kY2VudGVyZWQnLCAnJywgJ3BhcmFncmFwaCcsICdidWxsZXQnLCAncXVvdGVzaW5nbGJhc2UnLCAncXVvdGVkYmxiYXNlJywgJ3F1b3RlZGJscmlnaHQnLFxuXHQgICAgJ2d1aWxsZW1vdHJpZ2h0JywgJ2VsbGlwc2lzJywgJ3BlcnRob3VzYW5kJywgJycsICdxdWVzdGlvbmRvd24nLCAnJywgJ2dyYXZlJywgJ2FjdXRlJywgJ2NpcmN1bWZsZXgnLCAndGlsZGUnLFxuXHQgICAgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAnZGllcmVzaXMnLCAnJywgJ3JpbmcnLCAnY2VkaWxsYScsICcnLCAnaHVuZ2FydW1sYXV0JywgJ29nb25laycsICdjYXJvbicsXG5cdCAgICAnZW1kYXNoJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICdBRScsICcnLCAnb3JkZmVtaW5pbmUnLCAnJywgJycsICcnLFxuXHQgICAgJycsICdMc2xhc2gnLCAnT3NsYXNoJywgJ09FJywgJ29yZG1hc2N1bGluZScsICcnLCAnJywgJycsICcnLCAnJywgJ2FlJywgJycsICcnLCAnJywgJ2RvdGxlc3NpJywgJycsICcnLFxuXHQgICAgJ2xzbGFzaCcsICdvc2xhc2gnLCAnb2UnLCAnZ2VybWFuZGJscyddO1xuXG5cdHZhciBjZmZFeHBlcnRFbmNvZGluZyA9IFtcblx0ICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuXHQgICAgJycsICcnLCAnJywgJycsICdzcGFjZScsICdleGNsYW1zbWFsbCcsICdIdW5nYXJ1bWxhdXRzbWFsbCcsICcnLCAnZG9sbGFyb2xkc3R5bGUnLCAnZG9sbGFyc3VwZXJpb3InLFxuXHQgICAgJ2FtcGVyc2FuZHNtYWxsJywgJ0FjdXRlc21hbGwnLCAncGFyZW5sZWZ0c3VwZXJpb3InLCAncGFyZW5yaWdodHN1cGVyaW9yJywgJ3R3b2RvdGVubGVhZGVyJywgJ29uZWRvdGVubGVhZGVyJyxcblx0ICAgICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ2ZyYWN0aW9uJywgJ3plcm9vbGRzdHlsZScsICdvbmVvbGRzdHlsZScsICd0d29vbGRzdHlsZScsICd0aHJlZW9sZHN0eWxlJyxcblx0ICAgICdmb3Vyb2xkc3R5bGUnLCAnZml2ZW9sZHN0eWxlJywgJ3NpeG9sZHN0eWxlJywgJ3NldmVub2xkc3R5bGUnLCAnZWlnaHRvbGRzdHlsZScsICduaW5lb2xkc3R5bGUnLCAnY29sb24nLFxuXHQgICAgJ3NlbWljb2xvbicsICdjb21tYXN1cGVyaW9yJywgJ3RocmVlcXVhcnRlcnNlbWRhc2gnLCAncGVyaW9kc3VwZXJpb3InLCAncXVlc3Rpb25zbWFsbCcsICcnLCAnYXN1cGVyaW9yJyxcblx0ICAgICdic3VwZXJpb3InLCAnY2VudHN1cGVyaW9yJywgJ2RzdXBlcmlvcicsICdlc3VwZXJpb3InLCAnJywgJycsICdpc3VwZXJpb3InLCAnJywgJycsICdsc3VwZXJpb3InLCAnbXN1cGVyaW9yJyxcblx0ICAgICduc3VwZXJpb3InLCAnb3N1cGVyaW9yJywgJycsICcnLCAncnN1cGVyaW9yJywgJ3NzdXBlcmlvcicsICd0c3VwZXJpb3InLCAnJywgJ2ZmJywgJ2ZpJywgJ2ZsJywgJ2ZmaScsICdmZmwnLFxuXHQgICAgJ3BhcmVubGVmdGluZmVyaW9yJywgJycsICdwYXJlbnJpZ2h0aW5mZXJpb3InLCAnQ2lyY3VtZmxleHNtYWxsJywgJ2h5cGhlbnN1cGVyaW9yJywgJ0dyYXZlc21hbGwnLCAnQXNtYWxsJyxcblx0ICAgICdCc21hbGwnLCAnQ3NtYWxsJywgJ0RzbWFsbCcsICdFc21hbGwnLCAnRnNtYWxsJywgJ0dzbWFsbCcsICdIc21hbGwnLCAnSXNtYWxsJywgJ0pzbWFsbCcsICdLc21hbGwnLCAnTHNtYWxsJyxcblx0ICAgICdNc21hbGwnLCAnTnNtYWxsJywgJ09zbWFsbCcsICdQc21hbGwnLCAnUXNtYWxsJywgJ1JzbWFsbCcsICdTc21hbGwnLCAnVHNtYWxsJywgJ1VzbWFsbCcsICdWc21hbGwnLCAnV3NtYWxsJyxcblx0ICAgICdYc21hbGwnLCAnWXNtYWxsJywgJ1pzbWFsbCcsICdjb2xvbm1vbmV0YXJ5JywgJ29uZWZpdHRlZCcsICdydXBpYWgnLCAnVGlsZGVzbWFsbCcsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuXHQgICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcblx0ICAgICdleGNsYW1kb3duc21hbGwnLCAnY2VudG9sZHN0eWxlJywgJ0xzbGFzaHNtYWxsJywgJycsICcnLCAnU2Nhcm9uc21hbGwnLCAnWmNhcm9uc21hbGwnLCAnRGllcmVzaXNzbWFsbCcsXG5cdCAgICAnQnJldmVzbWFsbCcsICdDYXJvbnNtYWxsJywgJycsICdEb3RhY2NlbnRzbWFsbCcsICcnLCAnJywgJ01hY3JvbnNtYWxsJywgJycsICcnLCAnZmlndXJlZGFzaCcsICdoeXBoZW5pbmZlcmlvcicsXG5cdCAgICAnJywgJycsICdPZ29uZWtzbWFsbCcsICdSaW5nc21hbGwnLCAnQ2VkaWxsYXNtYWxsJywgJycsICcnLCAnJywgJ29uZXF1YXJ0ZXInLCAnb25laGFsZicsICd0aHJlZXF1YXJ0ZXJzJyxcblx0ICAgICdxdWVzdGlvbmRvd25zbWFsbCcsICdvbmVlaWdodGgnLCAndGhyZWVlaWdodGhzJywgJ2ZpdmVlaWdodGhzJywgJ3NldmVuZWlnaHRocycsICdvbmV0aGlyZCcsICd0d290aGlyZHMnLCAnJyxcblx0ICAgICcnLCAnemVyb3N1cGVyaW9yJywgJ29uZXN1cGVyaW9yJywgJ3R3b3N1cGVyaW9yJywgJ3RocmVlc3VwZXJpb3InLCAnZm91cnN1cGVyaW9yJywgJ2ZpdmVzdXBlcmlvcicsXG5cdCAgICAnc2l4c3VwZXJpb3InLCAnc2V2ZW5zdXBlcmlvcicsICdlaWdodHN1cGVyaW9yJywgJ25pbmVzdXBlcmlvcicsICd6ZXJvaW5mZXJpb3InLCAnb25laW5mZXJpb3InLCAndHdvaW5mZXJpb3InLFxuXHQgICAgJ3RocmVlaW5mZXJpb3InLCAnZm91cmluZmVyaW9yJywgJ2ZpdmVpbmZlcmlvcicsICdzaXhpbmZlcmlvcicsICdzZXZlbmluZmVyaW9yJywgJ2VpZ2h0aW5mZXJpb3InLFxuXHQgICAgJ25pbmVpbmZlcmlvcicsICdjZW50aW5mZXJpb3InLCAnZG9sbGFyaW5mZXJpb3InLCAncGVyaW9kaW5mZXJpb3InLCAnY29tbWFpbmZlcmlvcicsICdBZ3JhdmVzbWFsbCcsXG5cdCAgICAnQWFjdXRlc21hbGwnLCAnQWNpcmN1bWZsZXhzbWFsbCcsICdBdGlsZGVzbWFsbCcsICdBZGllcmVzaXNzbWFsbCcsICdBcmluZ3NtYWxsJywgJ0FFc21hbGwnLCAnQ2NlZGlsbGFzbWFsbCcsXG5cdCAgICAnRWdyYXZlc21hbGwnLCAnRWFjdXRlc21hbGwnLCAnRWNpcmN1bWZsZXhzbWFsbCcsICdFZGllcmVzaXNzbWFsbCcsICdJZ3JhdmVzbWFsbCcsICdJYWN1dGVzbWFsbCcsXG5cdCAgICAnSWNpcmN1bWZsZXhzbWFsbCcsICdJZGllcmVzaXNzbWFsbCcsICdFdGhzbWFsbCcsICdOdGlsZGVzbWFsbCcsICdPZ3JhdmVzbWFsbCcsICdPYWN1dGVzbWFsbCcsXG5cdCAgICAnT2NpcmN1bWZsZXhzbWFsbCcsICdPdGlsZGVzbWFsbCcsICdPZGllcmVzaXNzbWFsbCcsICdPRXNtYWxsJywgJ09zbGFzaHNtYWxsJywgJ1VncmF2ZXNtYWxsJywgJ1VhY3V0ZXNtYWxsJyxcblx0ICAgICdVY2lyY3VtZmxleHNtYWxsJywgJ1VkaWVyZXNpc3NtYWxsJywgJ1lhY3V0ZXNtYWxsJywgJ1Rob3Juc21hbGwnLCAnWWRpZXJlc2lzc21hbGwnXTtcblxuXHR2YXIgc3RhbmRhcmROYW1lcyA9IFtcblx0ICAgICcubm90ZGVmJywgJy5udWxsJywgJ25vbm1hcmtpbmdyZXR1cm4nLCAnc3BhY2UnLCAnZXhjbGFtJywgJ3F1b3RlZGJsJywgJ251bWJlcnNpZ24nLCAnZG9sbGFyJywgJ3BlcmNlbnQnLFxuXHQgICAgJ2FtcGVyc2FuZCcsICdxdW90ZXNpbmdsZScsICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLFxuXHQgICAgJ3plcm8nLCAnb25lJywgJ3R3bycsICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLFxuXHQgICAgJ2VxdWFsJywgJ2dyZWF0ZXInLCAncXVlc3Rpb24nLCAnYXQnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLFxuXHQgICAgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0Jyxcblx0ICAgICdhc2NpaWNpcmN1bScsICd1bmRlcnNjb3JlJywgJ2dyYXZlJywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbicsICdvJyxcblx0ICAgICdwJywgJ3EnLCAncicsICdzJywgJ3QnLCAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnYnJhY2VsZWZ0JywgJ2JhcicsICdicmFjZXJpZ2h0JywgJ2FzY2lpdGlsZGUnLFxuXHQgICAgJ0FkaWVyZXNpcycsICdBcmluZycsICdDY2VkaWxsYScsICdFYWN1dGUnLCAnTnRpbGRlJywgJ09kaWVyZXNpcycsICdVZGllcmVzaXMnLCAnYWFjdXRlJywgJ2FncmF2ZScsXG5cdCAgICAnYWNpcmN1bWZsZXgnLCAnYWRpZXJlc2lzJywgJ2F0aWxkZScsICdhcmluZycsICdjY2VkaWxsYScsICdlYWN1dGUnLCAnZWdyYXZlJywgJ2VjaXJjdW1mbGV4JywgJ2VkaWVyZXNpcycsXG5cdCAgICAnaWFjdXRlJywgJ2lncmF2ZScsICdpY2lyY3VtZmxleCcsICdpZGllcmVzaXMnLCAnbnRpbGRlJywgJ29hY3V0ZScsICdvZ3JhdmUnLCAnb2NpcmN1bWZsZXgnLCAnb2RpZXJlc2lzJyxcblx0ICAgICdvdGlsZGUnLCAndWFjdXRlJywgJ3VncmF2ZScsICd1Y2lyY3VtZmxleCcsICd1ZGllcmVzaXMnLCAnZGFnZ2VyJywgJ2RlZ3JlZScsICdjZW50JywgJ3N0ZXJsaW5nJywgJ3NlY3Rpb24nLFxuXHQgICAgJ2J1bGxldCcsICdwYXJhZ3JhcGgnLCAnZ2VybWFuZGJscycsICdyZWdpc3RlcmVkJywgJ2NvcHlyaWdodCcsICd0cmFkZW1hcmsnLCAnYWN1dGUnLCAnZGllcmVzaXMnLCAnbm90ZXF1YWwnLFxuXHQgICAgJ0FFJywgJ09zbGFzaCcsICdpbmZpbml0eScsICdwbHVzbWludXMnLCAnbGVzc2VxdWFsJywgJ2dyZWF0ZXJlcXVhbCcsICd5ZW4nLCAnbXUnLCAncGFydGlhbGRpZmYnLCAnc3VtbWF0aW9uJyxcblx0ICAgICdwcm9kdWN0JywgJ3BpJywgJ2ludGVncmFsJywgJ29yZGZlbWluaW5lJywgJ29yZG1hc2N1bGluZScsICdPbWVnYScsICdhZScsICdvc2xhc2gnLCAncXVlc3Rpb25kb3duJyxcblx0ICAgICdleGNsYW1kb3duJywgJ2xvZ2ljYWxub3QnLCAncmFkaWNhbCcsICdmbG9yaW4nLCAnYXBwcm94ZXF1YWwnLCAnRGVsdGEnLCAnZ3VpbGxlbW90bGVmdCcsICdndWlsbGVtb3RyaWdodCcsXG5cdCAgICAnZWxsaXBzaXMnLCAnbm9uYnJlYWtpbmdzcGFjZScsICdBZ3JhdmUnLCAnQXRpbGRlJywgJ090aWxkZScsICdPRScsICdvZScsICdlbmRhc2gnLCAnZW1kYXNoJywgJ3F1b3RlZGJsbGVmdCcsXG5cdCAgICAncXVvdGVkYmxyaWdodCcsICdxdW90ZWxlZnQnLCAncXVvdGVyaWdodCcsICdkaXZpZGUnLCAnbG96ZW5nZScsICd5ZGllcmVzaXMnLCAnWWRpZXJlc2lzJywgJ2ZyYWN0aW9uJyxcblx0ICAgICdjdXJyZW5jeScsICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJ2RhZ2dlcmRibCcsICdwZXJpb2RjZW50ZXJlZCcsICdxdW90ZXNpbmdsYmFzZScsXG5cdCAgICAncXVvdGVkYmxiYXNlJywgJ3BlcnRob3VzYW5kJywgJ0FjaXJjdW1mbGV4JywgJ0VjaXJjdW1mbGV4JywgJ0FhY3V0ZScsICdFZGllcmVzaXMnLCAnRWdyYXZlJywgJ0lhY3V0ZScsXG5cdCAgICAnSWNpcmN1bWZsZXgnLCAnSWRpZXJlc2lzJywgJ0lncmF2ZScsICdPYWN1dGUnLCAnT2NpcmN1bWZsZXgnLCAnYXBwbGUnLCAnT2dyYXZlJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsXG5cdCAgICAnVWdyYXZlJywgJ2RvdGxlc3NpJywgJ2NpcmN1bWZsZXgnLCAndGlsZGUnLCAnbWFjcm9uJywgJ2JyZXZlJywgJ2RvdGFjY2VudCcsICdyaW5nJywgJ2NlZGlsbGEnLCAnaHVuZ2FydW1sYXV0Jyxcblx0ICAgICdvZ29uZWsnLCAnY2Fyb24nLCAnTHNsYXNoJywgJ2xzbGFzaCcsICdTY2Fyb24nLCAnc2Nhcm9uJywgJ1pjYXJvbicsICd6Y2Fyb24nLCAnYnJva2VuYmFyJywgJ0V0aCcsICdldGgnLFxuXHQgICAgJ1lhY3V0ZScsICd5YWN1dGUnLCAnVGhvcm4nLCAndGhvcm4nLCAnbWludXMnLCAnbXVsdGlwbHknLCAnb25lc3VwZXJpb3InLCAndHdvc3VwZXJpb3InLCAndGhyZWVzdXBlcmlvcicsXG5cdCAgICAnb25laGFsZicsICdvbmVxdWFydGVyJywgJ3RocmVlcXVhcnRlcnMnLCAnZnJhbmMnLCAnR2JyZXZlJywgJ2dicmV2ZScsICdJZG90YWNjZW50JywgJ1NjZWRpbGxhJywgJ3NjZWRpbGxhJyxcblx0ICAgICdDYWN1dGUnLCAnY2FjdXRlJywgJ0NjYXJvbicsICdjY2Fyb24nLCAnZGNyb2F0J107XG5cblx0LyoqXG5cdCAqIFRoaXMgaXMgdGhlIGVuY29kaW5nIHVzZWQgZm9yIGZvbnRzIGNyZWF0ZWQgZnJvbSBzY3JhdGNoLlxuXHQgKiBJdCBsb29wcyB0aHJvdWdoIGFsbCBnbHlwaHMgYW5kIGZpbmRzIHRoZSBhcHByb3ByaWF0ZSB1bmljb2RlIHZhbHVlLlxuXHQgKiBTaW5jZSBpdCdzIGxpbmVhciB0aW1lLCBvdGhlciBlbmNvZGluZ3Mgd2lsbCBiZSBmYXN0ZXIuXG5cdCAqIEBleHBvcnRzIG9wZW50eXBlLkRlZmF1bHRFbmNvZGluZ1xuXHQgKiBAY2xhc3Ncblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cblx0ICovXG5cdGZ1bmN0aW9uIERlZmF1bHRFbmNvZGluZyhmb250KSB7XG5cdCAgICB0aGlzLmZvbnQgPSBmb250O1xuXHR9XG5cblx0RGVmYXVsdEVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24oYykge1xuXHQgICAgdmFyIGNvZGUgPSBjLmNvZGVQb2ludEF0KDApO1xuXHQgICAgdmFyIGdseXBocyA9IHRoaXMuZm9udC5nbHlwaHM7XG5cdCAgICBpZiAoZ2x5cGhzKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzLmdldChpKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaC51bmljb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGdseXBoLnVuaWNvZGVzW2pdID09PSBjb2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogQGV4cG9ydHMgb3BlbnR5cGUuQ21hcEVuY29kaW5nXG5cdCAqIEBjbGFzc1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGNtYXAgLSBhIG9iamVjdCB3aXRoIHRoZSBjbWFwIGVuY29kZWQgZGF0YVxuXHQgKi9cblx0ZnVuY3Rpb24gQ21hcEVuY29kaW5nKGNtYXApIHtcblx0ICAgIHRoaXMuY21hcCA9IGNtYXA7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtICB7c3RyaW5nfSBjIC0gdGhlIGNoYXJhY3RlclxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBnbHlwaCBpbmRleC5cblx0ICovXG5cdENtYXBFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKGMpIHtcblx0ICAgIHJldHVybiB0aGlzLmNtYXAuZ2x5cGhJbmRleE1hcFtjLmNvZGVQb2ludEF0KDApXSB8fCAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZXhwb3J0cyBvcGVudHlwZS5DZmZFbmNvZGluZ1xuXHQgKiBAY2xhc3Ncblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyAtIFRoZSBlbmNvZGluZ1xuXHQgKiBAcGFyYW0ge0FycmF5fSBjaGFyc2V0IC0gVGhlIGNoYXJhY3RlciBzZXQuXG5cdCAqL1xuXHRmdW5jdGlvbiBDZmZFbmNvZGluZyhlbmNvZGluZywgY2hhcnNldCkge1xuXHQgICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuXHQgICAgdGhpcy5jaGFyc2V0ID0gY2hhcnNldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHMgLSBUaGUgY2hhcmFjdGVyXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4LlxuXHQgKi9cblx0Q2ZmRW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbihzKSB7XG5cdCAgICB2YXIgY29kZSA9IHMuY29kZVBvaW50QXQoMCk7XG5cdCAgICB2YXIgY2hhck5hbWUgPSB0aGlzLmVuY29kaW5nW2NvZGVdO1xuXHQgICAgcmV0dXJuIHRoaXMuY2hhcnNldC5pbmRleE9mKGNoYXJOYW1lKTtcblx0fTtcblxuXHQvKipcblx0ICogQGV4cG9ydHMgb3BlbnR5cGUuR2x5cGhOYW1lc1xuXHQgKiBAY2xhc3Ncblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb3N0XG5cdCAqL1xuXHRmdW5jdGlvbiBHbHlwaE5hbWVzKHBvc3QpIHtcblx0ICAgIHN3aXRjaCAocG9zdC52ZXJzaW9uKSB7XG5cdCAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICB0aGlzLm5hbWVzID0gc3RhbmRhcmROYW1lcy5zbGljZSgpO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgIHRoaXMubmFtZXMgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocG9zdC5nbHlwaE5hbWVJbmRleFtpXSA8IHN0YW5kYXJkTmFtZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lc1tpXSA9IHN0YW5kYXJkTmFtZXNbcG9zdC5nbHlwaE5hbWVJbmRleFtpXV07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZXNbaV0gPSBwb3N0Lm5hbWVzW3Bvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gLSBzdGFuZGFyZE5hbWVzLmxlbmd0aF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIDIuNTpcblx0ICAgICAgICAgICAgdGhpcy5uYW1lcyA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSQxKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmFtZXNbaSQxXSA9IHN0YW5kYXJkTmFtZXNbaSQxICsgcG9zdC5nbHlwaE5hbWVJbmRleFtpJDFdXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgdGhpcy5uYW1lcyA9IFtdO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICB0aGlzLm5hbWVzID0gW107XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGluZGV4IG9mIGEgZ2x5cGggYnkgbmFtZS5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIC0gVGhlIGdseXBoIG5hbWVcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXhcblx0ICovXG5cdEdseXBoTmFtZXMucHJvdG90eXBlLm5hbWVUb0dseXBoSW5kZXggPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICByZXR1cm4gdGhpcy5uYW1lcy5pbmRleE9mKG5hbWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IGdpZFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRHbHlwaE5hbWVzLnByb3RvdHlwZS5nbHlwaEluZGV4VG9OYW1lID0gZnVuY3Rpb24oZ2lkKSB7XG5cdCAgICByZXR1cm4gdGhpcy5uYW1lc1tnaWRdO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGFkZEdseXBoTmFtZXNBbGwoZm9udCkge1xuXHQgICAgdmFyIGdseXBoO1xuXHQgICAgdmFyIGdseXBoSW5kZXhNYXAgPSBmb250LnRhYmxlcy5jbWFwLmdseXBoSW5kZXhNYXA7XG5cdCAgICB2YXIgY2hhckNvZGVzID0gT2JqZWN0LmtleXMoZ2x5cGhJbmRleE1hcCk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhckNvZGVzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGMgPSBjaGFyQ29kZXNbaV07XG5cdCAgICAgICAgdmFyIGdseXBoSW5kZXggPSBnbHlwaEluZGV4TWFwW2NdO1xuXHQgICAgICAgIGdseXBoID0gZm9udC5nbHlwaHMuZ2V0KGdseXBoSW5kZXgpO1xuXHQgICAgICAgIGdseXBoLmFkZFVuaWNvZGUocGFyc2VJbnQoYykpO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBmb250LmdseXBocy5sZW5ndGg7IGkkMSArPSAxKSB7XG5cdCAgICAgICAgZ2x5cGggPSBmb250LmdseXBocy5nZXQoaSQxKTtcblx0ICAgICAgICBpZiAoZm9udC5jZmZFbmNvZGluZykge1xuXHQgICAgICAgICAgICBpZiAoZm9udC5pc0NJREZvbnQpIHtcblx0ICAgICAgICAgICAgICAgIGdseXBoLm5hbWUgPSAnZ2lkJyArIGkkMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGdseXBoLm5hbWUgPSBmb250LmNmZkVuY29kaW5nLmNoYXJzZXRbaSQxXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAoZm9udC5nbHlwaE5hbWVzLm5hbWVzKSB7XG5cdCAgICAgICAgICAgIGdseXBoLm5hbWUgPSBmb250LmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZShpJDEpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEdseXBoTmFtZXNUb1VuaWNvZGVNYXAoZm9udCkge1xuXHQgICAgZm9udC5fSW5kZXhUb1VuaWNvZGVNYXAgPSB7fTtcblxuXHQgICAgdmFyIGdseXBoSW5kZXhNYXAgPSBmb250LnRhYmxlcy5jbWFwLmdseXBoSW5kZXhNYXA7XG5cdCAgICB2YXIgY2hhckNvZGVzID0gT2JqZWN0LmtleXMoZ2x5cGhJbmRleE1hcCk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhckNvZGVzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGMgPSBjaGFyQ29kZXNbaV07XG5cdCAgICAgICAgdmFyIGdseXBoSW5kZXggPSBnbHlwaEluZGV4TWFwW2NdO1xuXHQgICAgICAgIGlmIChmb250Ll9JbmRleFRvVW5pY29kZU1hcFtnbHlwaEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIGZvbnQuX0luZGV4VG9Vbmljb2RlTWFwW2dseXBoSW5kZXhdID0ge1xuXHQgICAgICAgICAgICAgICAgdW5pY29kZXM6IFtwYXJzZUludChjKV1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBmb250Ll9JbmRleFRvVW5pY29kZU1hcFtnbHlwaEluZGV4XS51bmljb2Rlcy5wdXNoKHBhcnNlSW50KGMpKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH1cblxuXHQvKipcblx0ICogQGFsaWFzIG9wZW50eXBlLmFkZEdseXBoTmFtZXNcblx0ICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuXHQgKiBAcGFyYW0ge09iamVjdH1cblx0ICovXG5cdGZ1bmN0aW9uIGFkZEdseXBoTmFtZXMoZm9udCwgb3B0KSB7XG5cdCAgICBpZiAob3B0Lmxvd01lbW9yeSkge1xuXHQgICAgICAgIGFkZEdseXBoTmFtZXNUb1VuaWNvZGVNYXAoZm9udCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGFkZEdseXBoTmFtZXNBbGwoZm9udCk7XG5cdCAgICB9XG5cdH1cblxuXHQvLyBEcmF3aW5nIHV0aWxpdHkgZnVuY3Rpb25zLlxuXG5cdC8vIERyYXcgYSBsaW5lIG9uIHRoZSBnaXZlbiBjb250ZXh0IGZyb20gcG9pbnQgYHgxLHkxYCB0byBwb2ludCBgeDIseTJgLlxuXHRmdW5jdGlvbiBsaW5lKGN0eCwgeDEsIHkxLCB4MiwgeTIpIHtcblx0ICAgIGN0eC5iZWdpblBhdGgoKTtcblx0ICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblx0ICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcblx0ICAgIGN0eC5zdHJva2UoKTtcblx0fVxuXG5cdHZhciBkcmF3ID0geyBsaW5lOiBsaW5lIH07XG5cblx0Ly8gVGhlIEdseXBoIG9iamVjdFxuXHQvLyBpbXBvcnQgZ2x5ZiBmcm9tICcuL3RhYmxlcy9nbHlmJyBDYW4ndCBiZSBpbXBvcnRlZCBoZXJlLCBiZWNhdXNlIGl0J3MgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG5cblx0ZnVuY3Rpb24gZ2V0UGF0aERlZmluaXRpb24oZ2x5cGgsIHBhdGgpIHtcblx0ICAgIHZhciBfcGF0aCA9IHBhdGggfHwgbmV3IFBhdGgoKTtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBfcGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgX3BhdGggPSBfcGF0aCgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIF9wYXRoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHApIHtcblx0ICAgICAgICAgICAgX3BhdGggPSBwO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdH1cblx0LyoqXG5cdCAqIEB0eXBlZGVmIEdseXBoT3B0aW9uc1xuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSAtIFRoZSBnbHlwaCBuYW1lXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdW5pY29kZV1cblx0ICogQHByb3BlcnR5IHtBcnJheX0gW3VuaWNvZGVzXVxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3hNaW5dXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeU1pbl1cblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFt4TWF4XVxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3lNYXhdXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYWR2YW5jZVdpZHRoXVxuXHQgKi9cblxuXHQvLyBBIEdseXBoIGlzIGFuIGluZGl2aWR1YWwgbWFyayB0aGF0IG9mdGVuIGNvcnJlc3BvbmRzIHRvIGEgY2hhcmFjdGVyLlxuXHQvLyBTb21lIGdseXBocywgc3VjaCBhcyBsaWdhdHVyZXMsIGFyZSBhIGNvbWJpbmF0aW9uIG9mIG1hbnkgY2hhcmFjdGVycy5cblx0Ly8gR2x5cGhzIGFyZSB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2tzIG9mIGEgZm9udC5cblx0Ly9cblx0Ly8gVGhlIGBHbHlwaGAgY2xhc3MgY29udGFpbnMgdXRpbGl0eSBtZXRob2RzIGZvciBkcmF3aW5nIHRoZSBwYXRoIGFuZCBpdHMgcG9pbnRzLlxuXHQvKipcblx0ICogQGV4cG9ydHMgb3BlbnR5cGUuR2x5cGhcblx0ICogQGNsYXNzXG5cdCAqIEBwYXJhbSB7R2x5cGhPcHRpb25zfVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEdseXBoKG9wdGlvbnMpIHtcblx0ICAgIC8vIEJ5IHB1dHRpbmcgYWxsIHRoZSBjb2RlIG9uIGEgcHJvdG90eXBlIGZ1bmN0aW9uICh3aGljaCBpcyBvbmx5IGRlY2xhcmVkIG9uY2UpXG5cdCAgICAvLyB3ZSByZWR1Y2UgdGhlIG1lbW9yeSByZXF1aXJlbWVudHMgZm9yIGxhcmdlciBmb250cyBieSBzb21lIDIlXG5cdCAgICB0aGlzLmJpbmRDb25zdHJ1Y3RvclZhbHVlcyhvcHRpb25zKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtHbHlwaE9wdGlvbnN9XG5cdCAqL1xuXHRHbHlwaC5wcm90b3R5cGUuYmluZENvbnN0cnVjdG9yVmFsdWVzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcblxuXHQgICAgLy8gVGhlc2UgdGhyZWUgdmFsdWVzIGNhbm5vdCBiZSBkZWZlcnJlZCBmb3IgbWVtb3J5IG9wdGltaXphdGlvbjpcblx0ICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBudWxsO1xuXHQgICAgdGhpcy51bmljb2RlID0gb3B0aW9ucy51bmljb2RlIHx8IHVuZGVmaW5lZDtcblx0ICAgIHRoaXMudW5pY29kZXMgPSBvcHRpb25zLnVuaWNvZGVzIHx8IG9wdGlvbnMudW5pY29kZSAhPT0gdW5kZWZpbmVkID8gW29wdGlvbnMudW5pY29kZV0gOiBbXTtcblxuXHQgICAgLy8gQnV0IGJ5IGJpbmRpbmcgdGhlc2UgdmFsdWVzIG9ubHkgd2hlbiBuZWNlc3NhcnksIHdlIHJlZHVjZSBjYW5cblx0ICAgIC8vIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzIGJ5IGFsbW9zdCAzJSBmb3IgbGFyZ2VyIGZvbnRzLlxuXHQgICAgaWYgKCd4TWluJyBpbiBvcHRpb25zKSB7XG5cdCAgICAgICAgdGhpcy54TWluID0gb3B0aW9ucy54TWluO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoJ3lNaW4nIGluIG9wdGlvbnMpIHtcblx0ICAgICAgICB0aGlzLnlNaW4gPSBvcHRpb25zLnlNaW47XG5cdCAgICB9XG5cblx0ICAgIGlmICgneE1heCcgaW4gb3B0aW9ucykge1xuXHQgICAgICAgIHRoaXMueE1heCA9IG9wdGlvbnMueE1heDtcblx0ICAgIH1cblxuXHQgICAgaWYgKCd5TWF4JyBpbiBvcHRpb25zKSB7XG5cdCAgICAgICAgdGhpcy55TWF4ID0gb3B0aW9ucy55TWF4O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoJ2FkdmFuY2VXaWR0aCcgaW4gb3B0aW9ucykge1xuXHQgICAgICAgIHRoaXMuYWR2YW5jZVdpZHRoID0gb3B0aW9ucy5hZHZhbmNlV2lkdGg7XG5cdCAgICB9XG5cblx0ICAgIC8vIFRoZSBwYXRoIGZvciBhIGdseXBoIGlzIHRoZSBtb3N0IG1lbW9yeSBpbnRlbnNpdmUsIGFuZCBpcyBib3VuZCBhcyBhIHZhbHVlXG5cdCAgICAvLyB3aXRoIGEgZ2V0dGVyL3NldHRlciB0byBlbnN1cmUgd2UgYWN0dWFsbHkgZG8gcGF0aCBwYXJzaW5nIG9ubHkgb25jZSB0aGVcblx0ICAgIC8vIHBhdGggaXMgYWN0dWFsbHkgbmVlZGVkIGJ5IGFueXRoaW5nLlxuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwYXRoJywgZ2V0UGF0aERlZmluaXRpb24odGhpcywgb3B0aW9ucy5wYXRoKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfVxuXHQgKi9cblx0R2x5cGgucHJvdG90eXBlLmFkZFVuaWNvZGUgPSBmdW5jdGlvbih1bmljb2RlKSB7XG5cdCAgICBpZiAodGhpcy51bmljb2Rlcy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICB0aGlzLnVuaWNvZGUgPSB1bmljb2RlO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnVuaWNvZGVzLnB1c2godW5pY29kZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgbWluaW11bSBib3VuZGluZyBib3ggZm9yIHRoaXMgZ2x5cGguXG5cdCAqIEByZXR1cm4ge29wZW50eXBlLkJvdW5kaW5nQm94fVxuXHQgKi9cblx0R2x5cGgucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5wYXRoLmdldEJvdW5kaW5nQm94KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhlIGdseXBoIHRvIGEgUGF0aCB3ZSBjYW4gZHJhdyBvbiBhIGRyYXdpbmcgY29udGV4dC5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuXHQgKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zIC0geFNjYWxlLCB5U2NhbGUgdG8gc3RyZXRjaCB0aGUgZ2x5cGguXG5cdCAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGlmIGhpbnRpbmcgaXMgdG8gYmUgdXNlZCwgdGhlIGZvbnRcblx0ICogQHJldHVybiB7b3BlbnR5cGUuUGF0aH1cblx0ICovXG5cdEdseXBoLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24oeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZvbnQpIHtcblx0ICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcblx0ICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcblx0ICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG5cdCAgICB2YXIgY29tbWFuZHM7XG5cdCAgICB2YXIgaFBvaW50cztcblx0ICAgIGlmICghb3B0aW9ucykgeyBvcHRpb25zID0geyB9OyB9XG5cdCAgICB2YXIgeFNjYWxlID0gb3B0aW9ucy54U2NhbGU7XG5cdCAgICB2YXIgeVNjYWxlID0gb3B0aW9ucy55U2NhbGU7XG5cblx0ICAgIGlmIChvcHRpb25zLmhpbnRpbmcgJiYgZm9udCAmJiBmb250LmhpbnRpbmcpIHtcblx0ICAgICAgICAvLyBpbiBjYXNlIG9mIGhpbnRpbmcsIHRoZSBoaW50aW5nIGVuZ2luZSB0YWtlcyBjYXJlXG5cdCAgICAgICAgLy8gb2Ygc2NhbGluZyB0aGUgcG9pbnRzIChub3QgdGhlIHBhdGgpIGJlZm9yZSBoaW50aW5nLlxuXHQgICAgICAgIGhQb2ludHMgPSB0aGlzLnBhdGggJiYgZm9udC5oaW50aW5nLmV4ZWModGhpcywgZm9udFNpemUpO1xuXHQgICAgICAgIC8vIGluIGNhc2UgdGhlIGhpbnRpbmcgZW5naW5lIGZhaWxlZCBoUG9pbnRzIGlzIHVuZGVmaW5lZFxuXHQgICAgICAgIC8vIGFuZCB0aHVzIHJldmVydHMgdG8gcGxhaW4gcmVuZGluZ1xuXHQgICAgfVxuXG5cdCAgICBpZiAoaFBvaW50cykge1xuXHQgICAgICAgIC8vIENhbGwgZm9udC5oaW50aW5nLmdldENvbW1hbmRzIGluc3RlYWQgb2YgYGdseWYuZ2V0UGF0aChoUG9pbnRzKS5jb21tYW5kc2AgdG8gYXZvaWQgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG5cdCAgICAgICAgY29tbWFuZHMgPSBmb250LmhpbnRpbmcuZ2V0Q29tbWFuZHMoaFBvaW50cyk7XG5cdCAgICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG5cdCAgICAgICAgeSA9IE1hdGgucm91bmQoeSk7XG5cdCAgICAgICAgLy8gVE9ETyBpbiBjYXNlIG9mIGhpbnRpbmcgeHlTY2FsaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXG5cdCAgICAgICAgeFNjYWxlID0geVNjYWxlID0gMTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgY29tbWFuZHMgPSB0aGlzLnBhdGguY29tbWFuZHM7XG5cdCAgICAgICAgdmFyIHNjYWxlID0gMSAvICh0aGlzLnBhdGgudW5pdHNQZXJFbSB8fCAxMDAwKSAqIGZvbnRTaXplO1xuXHQgICAgICAgIGlmICh4U2NhbGUgPT09IHVuZGVmaW5lZCkgeyB4U2NhbGUgPSBzY2FsZTsgfVxuXHQgICAgICAgIGlmICh5U2NhbGUgPT09IHVuZGVmaW5lZCkgeyB5U2NhbGUgPSBzY2FsZTsgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgcCA9IG5ldyBQYXRoKCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGNtZCA9IGNvbW1hbmRzW2ldO1xuXHQgICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG5cdCAgICAgICAgICAgIHAubW92ZVRvKHggKyAoY21kLnggKiB4U2NhbGUpLCB5ICsgKC1jbWQueSAqIHlTY2FsZSkpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuXHQgICAgICAgICAgICBwLmxpbmVUbyh4ICsgKGNtZC54ICogeFNjYWxlKSwgeSArICgtY21kLnkgKiB5U2NhbGUpKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcblx0ICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyAoY21kLngxICogeFNjYWxlKSwgeSArICgtY21kLnkxICogeVNjYWxlKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLnggKiB4U2NhbGUpLCB5ICsgKC1jbWQueSAqIHlTY2FsZSkpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuXHQgICAgICAgICAgICBwLmN1cnZlVG8oeCArIChjbWQueDEgKiB4U2NhbGUpLCB5ICsgKC1jbWQueTEgKiB5U2NhbGUpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueDIgKiB4U2NhbGUpLCB5ICsgKC1jbWQueTIgKiB5U2NhbGUpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueCAqIHhTY2FsZSksIHkgKyAoLWNtZC55ICogeVNjYWxlKSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG5cdCAgICAgICAgICAgIHAuY2xvc2VQYXRoKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcDtcblx0fTtcblxuXHQvKipcblx0ICogU3BsaXQgdGhlIGdseXBoIGludG8gY29udG91cnMuXG5cdCAqIFRoaXMgZnVuY3Rpb24gaXMgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFuZCB0b1xuXHQgKiBwcm92aWRlIHJhdyBhY2Nlc3MgdG8gdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmVzLlxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdEdseXBoLnByb3RvdHlwZS5nZXRDb250b3VycyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgaWYgKHRoaXMucG9pbnRzID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gW107XG5cdCAgICB9XG5cblx0ICAgIHZhciBjb250b3VycyA9IFtdO1xuXHQgICAgdmFyIGN1cnJlbnRDb250b3VyID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIHB0ID0gdGhpcy5wb2ludHNbaV07XG5cdCAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG5cdCAgICAgICAgaWYgKHB0Lmxhc3RQb2ludE9mQ29udG91cikge1xuXHQgICAgICAgICAgICBjb250b3Vycy5wdXNoKGN1cnJlbnRDb250b3VyKTtcblx0ICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGNoZWNrLmFyZ3VtZW50KGN1cnJlbnRDb250b3VyLmxlbmd0aCA9PT0gMCwgJ1RoZXJlIGFyZSBzdGlsbCBwb2ludHMgbGVmdCBpbiB0aGUgY3VycmVudCBjb250b3VyLicpO1xuXHQgICAgcmV0dXJuIGNvbnRvdXJzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlIHhNaW4veU1pbi94TWF4L3lNYXgvbHNiL3JzYiBmb3IgYSBHbHlwaC5cblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKi9cblx0R2x5cGgucHJvdG90eXBlLmdldE1ldHJpY3MgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBjb21tYW5kcyA9IHRoaXMucGF0aC5jb21tYW5kcztcblx0ICAgIHZhciB4Q29vcmRzID0gW107XG5cdCAgICB2YXIgeUNvb3JkcyA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcblx0ICAgICAgICBpZiAoY21kLnR5cGUgIT09ICdaJykge1xuXHQgICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngpO1xuXHQgICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ1EnIHx8IGNtZC50eXBlID09PSAnQycpIHtcblx0ICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54MSk7XG5cdCAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueTEpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG5cdCAgICAgICAgICAgIHhDb29yZHMucHVzaChjbWQueDIpO1xuXHQgICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkyKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBtZXRyaWNzID0ge1xuXHQgICAgICAgIHhNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHhDb29yZHMpLFxuXHQgICAgICAgIHlNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHlDb29yZHMpLFxuXHQgICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhDb29yZHMpLFxuXHQgICAgICAgIHlNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHlDb29yZHMpLFxuXHQgICAgICAgIGxlZnRTaWRlQmVhcmluZzogdGhpcy5sZWZ0U2lkZUJlYXJpbmdcblx0ICAgIH07XG5cblx0ICAgIGlmICghaXNGaW5pdGUobWV0cmljcy54TWluKSkge1xuXHQgICAgICAgIG1ldHJpY3MueE1pbiA9IDA7XG5cdCAgICB9XG5cblx0ICAgIGlmICghaXNGaW5pdGUobWV0cmljcy54TWF4KSkge1xuXHQgICAgICAgIG1ldHJpY3MueE1heCA9IHRoaXMuYWR2YW5jZVdpZHRoO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueU1pbikpIHtcblx0ICAgICAgICBtZXRyaWNzLnlNaW4gPSAwO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueU1heCkpIHtcblx0ICAgICAgICBtZXRyaWNzLnlNYXggPSAwO1xuXHQgICAgfVxuXG5cdCAgICBtZXRyaWNzLnJpZ2h0U2lkZUJlYXJpbmcgPSB0aGlzLmFkdmFuY2VXaWR0aCAtIG1ldHJpY3MubGVmdFNpZGVCZWFyaW5nIC0gKG1ldHJpY3MueE1heCAtIG1ldHJpY3MueE1pbik7XG5cdCAgICByZXR1cm4gbWV0cmljcztcblx0fTtcblxuXHQvKipcblx0ICogRHJhdyB0aGUgZ2x5cGggb24gdGhlIGdpdmVuIGNvbnRleHQuXG5cdCAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG5cdCAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnMgLSB4U2NhbGUsIHlTY2FsZSB0byBzdHJldGNoIHRoZSBnbHlwaC5cblx0ICovXG5cdEdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuXHQgICAgdGhpcy5nZXRQYXRoKHgsIHksIGZvbnRTaXplLCBvcHRpb25zKS5kcmF3KGN0eCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXcgdGhlIHBvaW50cyBvZiB0aGUgZ2x5cGguXG5cdCAqIE9uLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIGJsdWUsIG9mZi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiByZWQuXG5cdCAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG5cdCAqL1xuXHRHbHlwaC5wcm90b3R5cGUuZHJhd1BvaW50cyA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgZm9udFNpemUpIHtcblx0ICAgIGZ1bmN0aW9uIGRyYXdDaXJjbGVzKGwsIHgsIHksIHNjYWxlKSB7XG5cdCAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbC5sZW5ndGg7IGogKz0gMSkge1xuXHQgICAgICAgICAgICBjdHgubW92ZVRvKHggKyAobFtqXS54ICogc2NhbGUpLCB5ICsgKGxbal0ueSAqIHNjYWxlKSk7XG5cdCAgICAgICAgICAgIGN0eC5hcmMoeCArIChsW2pdLnggKiBzY2FsZSksIHkgKyAobFtqXS55ICogc2NhbGUpLCAyLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblx0ICAgICAgICBjdHguZmlsbCgpO1xuXHQgICAgfVxuXG5cdCAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG5cdCAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG5cdCAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDI0O1xuXHQgICAgdmFyIHNjYWxlID0gMSAvIHRoaXMucGF0aC51bml0c1BlckVtICogZm9udFNpemU7XG5cblx0ICAgIHZhciBibHVlQ2lyY2xlcyA9IFtdO1xuXHQgICAgdmFyIHJlZENpcmNsZXMgPSBbXTtcblx0ICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGNtZCA9IHBhdGguY29tbWFuZHNbaV07XG5cdCAgICAgICAgaWYgKGNtZC54ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgYmx1ZUNpcmNsZXMucHVzaCh7eDogY21kLngsIHk6IC1jbWQueX0pO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjbWQueDEgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICByZWRDaXJjbGVzLnB1c2goe3g6IGNtZC54MSwgeTogLWNtZC55MX0pO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjbWQueDIgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICByZWRDaXJjbGVzLnB1c2goe3g6IGNtZC54MiwgeTogLWNtZC55Mn0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgY3R4LmZpbGxTdHlsZSA9ICdibHVlJztcblx0ICAgIGRyYXdDaXJjbGVzKGJsdWVDaXJjbGVzLCB4LCB5LCBzY2FsZSk7XG5cdCAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG5cdCAgICBkcmF3Q2lyY2xlcyhyZWRDaXJjbGVzLCB4LCB5LCBzY2FsZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXcgbGluZXMgaW5kaWNhdGluZyBpbXBvcnRhbnQgZm9udCBtZWFzdXJlbWVudHMuXG5cdCAqIEJsYWNrIGxpbmVzIGluZGljYXRlIHRoZSBvcmlnaW4gb2YgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIChwb2ludCAwLDApLlxuXHQgKiBCbHVlIGxpbmVzIGluZGljYXRlIHRoZSBnbHlwaCBib3VuZGluZyBib3guXG5cdCAqIEdyZWVuIGxpbmUgaW5kaWNhdGVzIHRoZSBhZHZhbmNlIHdpZHRoIG9mIHRoZSBnbHlwaC5cblx0ICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cblx0ICovXG5cdEdseXBoLnByb3RvdHlwZS5kcmF3TWV0cmljcyA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgZm9udFNpemUpIHtcblx0ICAgIHZhciBzY2FsZTtcblx0ICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcblx0ICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcblx0ICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogMjQ7XG5cdCAgICBzY2FsZSA9IDEgLyB0aGlzLnBhdGgudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXHQgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cblx0ICAgIC8vIERyYXcgdGhlIG9yaWdpblxuXHQgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcblx0ICAgIGRyYXcubGluZShjdHgsIHgsIC0xMDAwMCwgeCwgMTAwMDApO1xuXHQgICAgZHJhdy5saW5lKGN0eCwgLTEwMDAwLCB5LCAxMDAwMCwgeSk7XG5cblx0ICAgIC8vIFRoaXMgY29kZSBpcyBoZXJlIGR1ZSB0byBtZW1vcnkgb3B0aW1pemF0aW9uOiBieSBub3QgdXNpbmdcblx0ICAgIC8vIGRlZmF1bHRzIGluIHRoZSBjb25zdHJ1Y3Rvciwgd2Ugc2F2ZSBhIG5vdGFibGUgYW1vdW50IG9mIG1lbW9yeS5cblx0ICAgIHZhciB4TWluID0gdGhpcy54TWluIHx8IDA7XG5cdCAgICB2YXIgeU1pbiA9IHRoaXMueU1pbiB8fCAwO1xuXHQgICAgdmFyIHhNYXggPSB0aGlzLnhNYXggfHwgMDtcblx0ICAgIHZhciB5TWF4ID0gdGhpcy55TWF4IHx8IDA7XG5cdCAgICB2YXIgYWR2YW5jZVdpZHRoID0gdGhpcy5hZHZhbmNlV2lkdGggfHwgMDtcblxuXHQgICAgLy8gRHJhdyB0aGUgZ2x5cGggYm94XG5cdCAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG5cdCAgICBkcmF3LmxpbmUoY3R4LCB4ICsgKHhNaW4gKiBzY2FsZSksIC0xMDAwMCwgeCArICh4TWluICogc2NhbGUpLCAxMDAwMCk7XG5cdCAgICBkcmF3LmxpbmUoY3R4LCB4ICsgKHhNYXggKiBzY2FsZSksIC0xMDAwMCwgeCArICh4TWF4ICogc2NhbGUpLCAxMDAwMCk7XG5cdCAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHkgKyAoLXlNaW4gKiBzY2FsZSksIDEwMDAwLCB5ICsgKC15TWluICogc2NhbGUpKTtcblx0ICAgIGRyYXcubGluZShjdHgsIC0xMDAwMCwgeSArICgteU1heCAqIHNjYWxlKSwgMTAwMDAsIHkgKyAoLXlNYXggKiBzY2FsZSkpO1xuXG5cdCAgICAvLyBEcmF3IHRoZSBhZHZhbmNlIHdpZHRoXG5cdCAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuXHQgICAgZHJhdy5saW5lKGN0eCwgeCArIChhZHZhbmNlV2lkdGggKiBzY2FsZSksIC0xMDAwMCwgeCArIChhZHZhbmNlV2lkdGggKiBzY2FsZSksIDEwMDAwKTtcblx0fTtcblxuXHQvLyBUaGUgR2x5cGhTZXQgb2JqZWN0XG5cblx0Ly8gRGVmaW5lIGEgcHJvcGVydHkgb24gdGhlIGdseXBoIHRoYXQgZGVwZW5kcyBvbiB0aGUgcGF0aCBiZWluZyBsb2FkZWQuXG5cdGZ1bmN0aW9uIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCBleHRlcm5hbE5hbWUsIGludGVybmFsTmFtZSkge1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdseXBoLCBleHRlcm5hbE5hbWUsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAvLyBSZXF1ZXN0IHRoZSBwYXRoIHByb3BlcnR5IHRvIG1ha2Ugc3VyZSB0aGUgcGF0aCBpcyBsb2FkZWQuXG5cdCAgICAgICAgICAgIGdseXBoLnBhdGg7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgICAgICAgICByZXR1cm4gZ2x5cGhbaW50ZXJuYWxOYW1lXTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24obmV3VmFsdWUpIHtcblx0ICAgICAgICAgICAgZ2x5cGhbaW50ZXJuYWxOYW1lXSA9IG5ld1ZhbHVlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgR2x5cGhTZXQgcmVwcmVzZW50cyBhbGwgZ2x5cGhzIGF2YWlsYWJsZSBpbiB0aGUgZm9udCwgYnV0IG1vZGVsbGVkIHVzaW5nXG5cdCAqIGEgZGVmZXJyZWQgZ2x5cGggbG9hZGVyLCBmb3IgcmV0cmlldmluZyBnbHlwaHMgb25seSBvbmNlIHRoZXkgYXJlIGFic29sdXRlbHlcblx0ICogbmVjZXNzYXJ5LCB0byBrZWVwIHRoZSBtZW1vcnkgZm9vdHByaW50IGRvd24uXG5cdCAqIEBleHBvcnRzIG9wZW50eXBlLkdseXBoU2V0XG5cdCAqIEBjbGFzc1xuXHQgKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG5cdCAqIEBwYXJhbSB7QXJyYXl9XG5cdCAqL1xuXHRmdW5jdGlvbiBHbHlwaFNldChmb250LCBnbHlwaHMpIHtcblx0ICAgIHRoaXMuZm9udCA9IGZvbnQ7XG5cdCAgICB0aGlzLmdseXBocyA9IHt9O1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoZ2x5cGhzKSkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcblx0ICAgICAgICAgICAgZ2x5cGgucGF0aC51bml0c1BlckVtID0gZm9udC51bml0c1BlckVtO1xuXHQgICAgICAgICAgICB0aGlzLmdseXBoc1tpXSA9IGdseXBoO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdGhpcy5sZW5ndGggPSAoZ2x5cGhzICYmIGdseXBocy5sZW5ndGgpIHx8IDA7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cblx0ICovXG5cdEdseXBoU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCkge1xuXHQgICAgLy8gdGhpcy5nbHlwaHNbaW5kZXhdIGlzICd1bmRlZmluZWQnIHdoZW4gbG93IG1lbW9yeSBtb2RlIGlzIG9uLiBnbHlwaCBpcyBwdXNoZWQgb24gcmVxdWVzdCBvbmx5LlxuXHQgICAgaWYgKHRoaXMuZ2x5cGhzW2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgdGhpcy5mb250Ll9wdXNoKGluZGV4KTtcblx0ICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ2x5cGhzW2luZGV4XSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICB0aGlzLmdseXBoc1tpbmRleF0gPSB0aGlzLmdseXBoc1tpbmRleF0oKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgZ2x5cGggPSB0aGlzLmdseXBoc1tpbmRleF07XG5cdCAgICAgICAgdmFyIHVuaWNvZGVPYmogPSB0aGlzLmZvbnQuX0luZGV4VG9Vbmljb2RlTWFwW2luZGV4XTtcblxuXHQgICAgICAgIGlmICh1bmljb2RlT2JqKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdW5pY29kZU9iai51bmljb2Rlcy5sZW5ndGg7IGorKylcblx0ICAgICAgICAgICAgICAgIHsgZ2x5cGguYWRkVW5pY29kZSh1bmljb2RlT2JqLnVuaWNvZGVzW2pdKTsgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh0aGlzLmZvbnQuY2ZmRW5jb2RpbmcpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuZm9udC5pc0NJREZvbnQpIHtcblx0ICAgICAgICAgICAgICAgIGdseXBoLm5hbWUgPSAnZ2lkJyArIGluZGV4O1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZ2x5cGgubmFtZSA9IHRoaXMuZm9udC5jZmZFbmNvZGluZy5jaGFyc2V0W2luZGV4XTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mb250LmdseXBoTmFtZXMubmFtZXMpIHtcblx0ICAgICAgICAgICAgZ2x5cGgubmFtZSA9IHRoaXMuZm9udC5nbHlwaE5hbWVzLmdseXBoSW5kZXhUb05hbWUoaW5kZXgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuZ2x5cGhzW2luZGV4XS5hZHZhbmNlV2lkdGggPSB0aGlzLmZvbnQuX2htdHhUYWJsZURhdGFbaW5kZXhdLmFkdmFuY2VXaWR0aDtcblx0ICAgICAgICB0aGlzLmdseXBoc1tpbmRleF0ubGVmdFNpZGVCZWFyaW5nID0gdGhpcy5mb250Ll9obXR4VGFibGVEYXRhW2luZGV4XS5sZWZ0U2lkZUJlYXJpbmc7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmICh0eXBlb2YgdGhpcy5nbHlwaHNbaW5kZXhdID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2luZGV4XSA9IHRoaXMuZ2x5cGhzW2luZGV4XSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuZ2x5cGhzW2luZGV4XTtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0gIHtPYmplY3R9XG5cdCAqL1xuXHRHbHlwaFNldC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGluZGV4LCBsb2FkZXIpIHtcblx0ICAgIHRoaXMuZ2x5cGhzW2luZGV4XSA9IGxvYWRlcjtcblx0ICAgIHRoaXMubGVuZ3RoKys7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBhbGlhcyBvcGVudHlwZS5nbHlwaExvYWRlclxuXHQgKiBAcGFyYW0gIHtvcGVudHlwZS5Gb250fSBmb250XG5cdCAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG5cdCAqL1xuXHRmdW5jdGlvbiBnbHlwaExvYWRlcihmb250LCBpbmRleCkge1xuXHQgICAgcmV0dXJuIG5ldyBHbHlwaCh7aW5kZXg6IGluZGV4LCBmb250OiBmb250fSk7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGUgYSBzdHViIGdseXBoIHRoYXQgY2FuIGJlIGZpbGxlZCB3aXRoIGFsbCBtZXRhZGF0YSAqZXhjZXB0KlxuXHQgKiB0aGUgXCJwb2ludHNcIiBhbmQgXCJwYXRoXCIgcHJvcGVydGllcywgd2hpY2ggbXVzdCBiZSBsb2FkZWQgb25seSBvbmNlXG5cdCAqIHRoZSBnbHlwaCdzIHBhdGggaXMgYWN0dWFsbHkgcmVxdWVzdGVkIGZvciB0ZXh0IHNoYXBpbmcuXG5cdCAqIEBhbGlhcyBvcGVudHlwZS50dGZHbHlwaExvYWRlclxuXHQgKiBAcGFyYW0gIHtvcGVudHlwZS5Gb250fSBmb250XG5cdCAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtICB7RnVuY3Rpb259IHBhcnNlR2x5cGhcblx0ICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG5cdCAqIEBwYXJhbSAge251bWJlcn0gcG9zaXRpb25cblx0ICogQHBhcmFtICB7RnVuY3Rpb259IGJ1aWxkUGF0aFxuXHQgKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cblx0ICovXG5cdGZ1bmN0aW9uIHR0ZkdseXBoTG9hZGVyKGZvbnQsIGluZGV4LCBwYXJzZUdseXBoLCBkYXRhLCBwb3NpdGlvbiwgYnVpbGRQYXRoKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIGdseXBoID0gbmV3IEdseXBoKHtpbmRleDogaW5kZXgsIGZvbnQ6IGZvbnR9KTtcblxuXHQgICAgICAgIGdseXBoLnBhdGggPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcGFyc2VHbHlwaChnbHlwaCwgZGF0YSwgcG9zaXRpb24pO1xuXHQgICAgICAgICAgICB2YXIgcGF0aCA9IGJ1aWxkUGF0aChmb250LmdseXBocywgZ2x5cGgpO1xuXHQgICAgICAgICAgICBwYXRoLnVuaXRzUGVyRW0gPSBmb250LnVuaXRzUGVyRW07XG5cdCAgICAgICAgICAgIHJldHVybiBwYXRoO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3hNaW4nLCAnX3hNaW4nKTtcblx0ICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3hNYXgnLCAnX3hNYXgnKTtcblx0ICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3lNaW4nLCAnX3lNaW4nKTtcblx0ICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3lNYXgnLCAnX3lNYXgnKTtcblxuXHQgICAgICAgIHJldHVybiBnbHlwaDtcblx0ICAgIH07XG5cdH1cblx0LyoqXG5cdCAqIEBhbGlhcyBvcGVudHlwZS5jZmZHbHlwaExvYWRlclxuXHQgKiBAcGFyYW0gIHtvcGVudHlwZS5Gb250fSBmb250XG5cdCAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtICB7RnVuY3Rpb259IHBhcnNlQ0ZGQ2hhcnN0cmluZ1xuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IGNoYXJzdHJpbmdcblx0ICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG5cdCAqL1xuXHRmdW5jdGlvbiBjZmZHbHlwaExvYWRlcihmb250LCBpbmRleCwgcGFyc2VDRkZDaGFyc3RyaW5nLCBjaGFyc3RyaW5nKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIGdseXBoID0gbmV3IEdseXBoKHtpbmRleDogaW5kZXgsIGZvbnQ6IGZvbnR9KTtcblxuXHQgICAgICAgIGdseXBoLnBhdGggPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIHBhdGggPSBwYXJzZUNGRkNoYXJzdHJpbmcoZm9udCwgZ2x5cGgsIGNoYXJzdHJpbmcpO1xuXHQgICAgICAgICAgICBwYXRoLnVuaXRzUGVyRW0gPSBmb250LnVuaXRzUGVyRW07XG5cdCAgICAgICAgICAgIHJldHVybiBwYXRoO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICByZXR1cm4gZ2x5cGg7XG5cdCAgICB9O1xuXHR9XG5cblx0dmFyIGdseXBoc2V0ID0geyBHbHlwaFNldDogR2x5cGhTZXQsIGdseXBoTG9hZGVyOiBnbHlwaExvYWRlciwgdHRmR2x5cGhMb2FkZXI6IHR0ZkdseXBoTG9hZGVyLCBjZmZHbHlwaExvYWRlcjogY2ZmR2x5cGhMb2FkZXIgfTtcblxuXHQvLyBUaGUgYENGRmAgdGFibGUgY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuXG5cdC8vIEN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gdGhhdCBjYW4gYWxzbyBjaGVjayBsaXN0cy5cblx0ZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcblx0ICAgIGlmIChhID09PSBiKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuXHQgICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgICAgICBpZiAoIWVxdWFscyhhW2ldLCBiW2ldKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0fVxuXG5cdC8vIFN1YnJvdXRpbmVzIGFyZSBlbmNvZGVkIHVzaW5nIHRoZSBuZWdhdGl2ZSBoYWxmIG9mIHRoZSBudW1iZXIgc3BhY2UuXG5cdC8vIFNlZSB0eXBlIDIgY2hhcHRlciA0LjcgXCJTdWJyb3V0aW5lIG9wZXJhdG9yc1wiLlxuXHRmdW5jdGlvbiBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoc3VicnMpIHtcblx0ICAgIHZhciBiaWFzO1xuXHQgICAgaWYgKHN1YnJzLmxlbmd0aCA8IDEyNDApIHtcblx0ICAgICAgICBiaWFzID0gMTA3O1xuXHQgICAgfSBlbHNlIGlmIChzdWJycy5sZW5ndGggPCAzMzkwMCkge1xuXHQgICAgICAgIGJpYXMgPSAxMTMxO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBiaWFzID0gMzI3Njg7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBiaWFzO1xuXHR9XG5cblx0Ly8gUGFyc2UgYSBgQ0ZGYCBJTkRFWCBhcnJheS5cblx0Ly8gQW4gaW5kZXggYXJyYXkgY29uc2lzdHMgb2YgYSBsaXN0IG9mIG9mZnNldHMsIHRoZW4gYSBsaXN0IG9mIG9iamVjdHMgYXQgdGhvc2Ugb2Zmc2V0cy5cblx0ZnVuY3Rpb24gcGFyc2VDRkZJbmRleChkYXRhLCBzdGFydCwgY29udmVyc2lvbkZuKSB7XG5cdCAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuXHQgICAgdmFyIG9iamVjdHMgPSBbXTtcblx0ICAgIHZhciBjb3VudCA9IHBhcnNlLmdldENhcmQxNihkYXRhLCBzdGFydCk7XG5cdCAgICB2YXIgb2JqZWN0T2Zmc2V0O1xuXHQgICAgdmFyIGVuZE9mZnNldDtcblx0ICAgIGlmIChjb3VudCAhPT0gMCkge1xuXHQgICAgICAgIHZhciBvZmZzZXRTaXplID0gcGFyc2UuZ2V0Qnl0ZShkYXRhLCBzdGFydCArIDIpO1xuXHQgICAgICAgIG9iamVjdE9mZnNldCA9IHN0YXJ0ICsgKChjb3VudCArIDEpICogb2Zmc2V0U2l6ZSkgKyAyO1xuXHQgICAgICAgIHZhciBwb3MgPSBzdGFydCArIDM7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCArIDE7IGkgKz0gMSkge1xuXHQgICAgICAgICAgICBvZmZzZXRzLnB1c2gocGFyc2UuZ2V0T2Zmc2V0KGRhdGEsIHBvcywgb2Zmc2V0U2l6ZSkpO1xuXHQgICAgICAgICAgICBwb3MgKz0gb2Zmc2V0U2l6ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBUaGUgdG90YWwgc2l6ZSBvZiB0aGUgaW5kZXggYXJyYXkgaXMgNCBoZWFkZXIgYnl0ZXMgKyB0aGUgdmFsdWUgb2YgdGhlIGxhc3Qgb2Zmc2V0LlxuXHQgICAgICAgIGVuZE9mZnNldCA9IG9iamVjdE9mZnNldCArIG9mZnNldHNbY291bnRdO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBlbmRPZmZzZXQgPSBzdGFydCArIDI7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9mZnNldHMubGVuZ3RoIC0gMTsgaSQxICs9IDEpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZS5nZXRCeXRlcyhkYXRhLCBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2kkMV0sIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSQxICsgMV0pO1xuXHQgICAgICAgIGlmIChjb252ZXJzaW9uRm4pIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJzaW9uRm4odmFsdWUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG9iamVjdHMucHVzaCh2YWx1ZSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7b2JqZWN0czogb2JqZWN0cywgc3RhcnRPZmZzZXQ6IHN0YXJ0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldH07XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZUNGRkluZGV4TG93TWVtb3J5KGRhdGEsIHN0YXJ0KSB7XG5cdCAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuXHQgICAgdmFyIGNvdW50ID0gcGFyc2UuZ2V0Q2FyZDE2KGRhdGEsIHN0YXJ0KTtcblx0ICAgIHZhciBvYmplY3RPZmZzZXQ7XG5cdCAgICB2YXIgZW5kT2Zmc2V0O1xuXHQgICAgaWYgKGNvdW50ICE9PSAwKSB7XG5cdCAgICAgICAgdmFyIG9mZnNldFNpemUgPSBwYXJzZS5nZXRCeXRlKGRhdGEsIHN0YXJ0ICsgMik7XG5cdCAgICAgICAgb2JqZWN0T2Zmc2V0ID0gc3RhcnQgKyAoKGNvdW50ICsgMSkgKiBvZmZzZXRTaXplKSArIDI7XG5cdCAgICAgICAgdmFyIHBvcyA9IHN0YXJ0ICsgMztcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICsgMTsgaSArPSAxKSB7XG5cdCAgICAgICAgICAgIG9mZnNldHMucHVzaChwYXJzZS5nZXRPZmZzZXQoZGF0YSwgcG9zLCBvZmZzZXRTaXplKSk7XG5cdCAgICAgICAgICAgIHBvcyArPSBvZmZzZXRTaXplO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFRoZSB0b3RhbCBzaXplIG9mIHRoZSBpbmRleCBhcnJheSBpcyA0IGhlYWRlciBieXRlcyArIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBvZmZzZXQuXG5cdCAgICAgICAgZW5kT2Zmc2V0ID0gb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tjb3VudF07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGVuZE9mZnNldCA9IHN0YXJ0ICsgMjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHtvZmZzZXRzOiBvZmZzZXRzLCBzdGFydE9mZnNldDogc3RhcnQsIGVuZE9mZnNldDogZW5kT2Zmc2V0fTtcblx0fVxuXHRmdW5jdGlvbiBnZXRDZmZJbmRleE9iamVjdChpLCBvZmZzZXRzLCBkYXRhLCBzdGFydCwgY29udmVyc2lvbkZuKSB7XG5cdCAgICB2YXIgY291bnQgPSBwYXJzZS5nZXRDYXJkMTYoZGF0YSwgc3RhcnQpO1xuXHQgICAgdmFyIG9iamVjdE9mZnNldCA9IDA7XG5cdCAgICBpZiAoY291bnQgIT09IDApIHtcblx0ICAgICAgICB2YXIgb2Zmc2V0U2l6ZSA9IHBhcnNlLmdldEJ5dGUoZGF0YSwgc3RhcnQgKyAyKTtcblx0ICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArICgoY291bnQgKyAxKSAqIG9mZnNldFNpemUpICsgMjtcblx0ICAgIH1cblxuXHQgICAgdmFyIHZhbHVlID0gcGFyc2UuZ2V0Qnl0ZXMoZGF0YSwgb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tpXSwgb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tpICsgMV0pO1xuXHQgICAgaWYgKGNvbnZlcnNpb25Gbikge1xuXHQgICAgICAgIHZhbHVlID0gY29udmVyc2lvbkZuKHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdC8vIFBhcnNlIGEgYENGRmAgRElDVCByZWFsIHZhbHVlLlxuXHRmdW5jdGlvbiBwYXJzZUZsb2F0T3BlcmFuZChwYXJzZXIpIHtcblx0ICAgIHZhciBzID0gJyc7XG5cdCAgICB2YXIgZW9mID0gMTU7XG5cdCAgICB2YXIgbG9va3VwID0gWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJy4nLCAnRScsICdFLScsIG51bGwsICctJ107XG5cdCAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgIHZhciBiID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuXHQgICAgICAgIHZhciBuMSA9IGIgPj4gNDtcblx0ICAgICAgICB2YXIgbjIgPSBiICYgMTU7XG5cblx0ICAgICAgICBpZiAobjEgPT09IGVvZikge1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzICs9IGxvb2t1cFtuMV07XG5cblx0ICAgICAgICBpZiAobjIgPT09IGVvZikge1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzICs9IGxvb2t1cFtuMl07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBwYXJzZUZsb2F0KHMpO1xuXHR9XG5cblx0Ly8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9wZXJhbmQuXG5cdGZ1bmN0aW9uIHBhcnNlT3BlcmFuZChwYXJzZXIsIGIwKSB7XG5cdCAgICB2YXIgYjE7XG5cdCAgICB2YXIgYjI7XG5cdCAgICB2YXIgYjM7XG5cdCAgICB2YXIgYjQ7XG5cdCAgICBpZiAoYjAgPT09IDI4KSB7XG5cdCAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG5cdCAgICAgICAgYjIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG5cdCAgICAgICAgcmV0dXJuIGIxIDw8IDggfCBiMjtcblx0ICAgIH1cblxuXHQgICAgaWYgKGIwID09PSAyOSkge1xuXHQgICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuXHQgICAgICAgIGIyID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuXHQgICAgICAgIGIzID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuXHQgICAgICAgIGI0ID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuXHQgICAgICAgIHJldHVybiBiMSA8PCAyNCB8IGIyIDw8IDE2IHwgYjMgPDwgOCB8IGI0O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYjAgPT09IDMwKSB7XG5cdCAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXRPcGVyYW5kKHBhcnNlcik7XG5cdCAgICB9XG5cblx0ICAgIGlmIChiMCA+PSAzMiAmJiBiMCA8PSAyNDYpIHtcblx0ICAgICAgICByZXR1cm4gYjAgLSAxMzk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChiMCA+PSAyNDcgJiYgYjAgPD0gMjUwKSB7XG5cdCAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG5cdCAgICAgICAgcmV0dXJuIChiMCAtIDI0NykgKiAyNTYgKyBiMSArIDEwODtcblx0ICAgIH1cblxuXHQgICAgaWYgKGIwID49IDI1MSAmJiBiMCA8PSAyNTQpIHtcblx0ICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcblx0ICAgICAgICByZXR1cm4gLShiMCAtIDI1MSkgKiAyNTYgLSBiMSAtIDEwODtcblx0ICAgIH1cblxuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGIwICcgKyBiMCk7XG5cdH1cblxuXHQvLyBDb252ZXJ0IHRoZSBlbnRyaWVzIHJldHVybmVkIGJ5IGBwYXJzZURpY3RgIHRvIGEgcHJvcGVyIGRpY3Rpb25hcnkuXG5cdC8vIElmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIG9uZSwgaXQgaXMgdW5wYWNrZWQuXG5cdGZ1bmN0aW9uIGVudHJpZXNUb09iamVjdChlbnRyaWVzKSB7XG5cdCAgICB2YXIgbyA9IHt9O1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGtleSA9IGVudHJpZXNbaV1bMF07XG5cdCAgICAgICAgdmFyIHZhbHVlcyA9IGVudHJpZXNbaV1bMV07XG5cdCAgICAgICAgdmFyIHZhbHVlID0gKHZvaWQgMCk7XG5cdCAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbMF07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXM7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhaXNOYU4ob1trZXldKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCAnICsgbyArICcgYWxyZWFkeSBoYXMga2V5ICcgKyBrZXkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbztcblx0fVxuXG5cdC8vIFBhcnNlIGEgYENGRmAgRElDVCBvYmplY3QuXG5cdC8vIEEgZGljdGlvbmFyeSBjb250YWlucyBrZXktdmFsdWUgcGFpcnMgaW4gYSBjb21wYWN0IHRva2VuaXplZCBmb3JtYXQuXG5cdGZ1bmN0aW9uIHBhcnNlQ0ZGRGljdChkYXRhLCBzdGFydCwgc2l6ZSkge1xuXHQgICAgc3RhcnQgPSBzdGFydCAhPT0gdW5kZWZpbmVkID8gc3RhcnQgOiAwO1xuXHQgICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgdmFyIGVudHJpZXMgPSBbXTtcblx0ICAgIHZhciBvcGVyYW5kcyA9IFtdO1xuXHQgICAgc2l6ZSA9IHNpemUgIT09IHVuZGVmaW5lZCA/IHNpemUgOiBkYXRhLmxlbmd0aDtcblxuXHQgICAgd2hpbGUgKHBhcnNlci5yZWxhdGl2ZU9mZnNldCA8IHNpemUpIHtcblx0ICAgICAgICB2YXIgb3AgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG5cblx0ICAgICAgICAvLyBUaGUgZmlyc3QgYnl0ZSBmb3IgZWFjaCBkaWN0IGl0ZW0gZGlzdGluZ3Vpc2hlcyBiZXR3ZWVuIG9wZXJhdG9yIChrZXkpIGFuZCBvcGVyYW5kICh2YWx1ZSkuXG5cdCAgICAgICAgLy8gVmFsdWVzIDw9IDIxIGFyZSBvcGVyYXRvcnMuXG5cdCAgICAgICAgaWYgKG9wIDw9IDIxKSB7XG5cdCAgICAgICAgICAgIC8vIFR3by1ieXRlIG9wZXJhdG9ycyBoYXZlIGFuIGluaXRpYWwgZXNjYXBlIGJ5dGUgb2YgMTIuXG5cdCAgICAgICAgICAgIGlmIChvcCA9PT0gMTIpIHtcblx0ICAgICAgICAgICAgICAgIG9wID0gMTIwMCArIHBhcnNlci5wYXJzZUJ5dGUoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGVudHJpZXMucHVzaChbb3AsIG9wZXJhbmRzXSk7XG5cdCAgICAgICAgICAgIG9wZXJhbmRzID0gW107XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gU2luY2UgdGhlIG9wZXJhbmRzICh2YWx1ZXMpIGNvbWUgYmVmb3JlIHRoZSBvcGVyYXRvcnMgKGtleXMpLCB3ZSBzdG9yZSBhbGwgb3BlcmFuZHMgaW4gYSBsaXN0XG5cdCAgICAgICAgICAgIC8vIHVudGlsIHdlIGVuY291bnRlciBhbiBvcGVyYXRvci5cblx0ICAgICAgICAgICAgb3BlcmFuZHMucHVzaChwYXJzZU9wZXJhbmQocGFyc2VyLCBvcCkpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGVudHJpZXNUb09iamVjdChlbnRyaWVzKTtcblx0fVxuXG5cdC8vIEdpdmVuIGEgU3RyaW5nIEluZGV4IChTSUQpLCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBzdHJpbmcuXG5cdC8vIFN0cmluZ3MgYmVsb3cgaW5kZXggMzkyIGFyZSBzdGFuZGFyZCBDRkYgc3RyaW5ncyBhbmQgYXJlIG5vdCBlbmNvZGVkIGluIHRoZSBmb250LlxuXHRmdW5jdGlvbiBnZXRDRkZTdHJpbmcoc3RyaW5ncywgaW5kZXgpIHtcblx0ICAgIGlmIChpbmRleCA8PSAzOTApIHtcblx0ICAgICAgICBpbmRleCA9IGNmZlN0YW5kYXJkU3RyaW5nc1tpbmRleF07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGluZGV4ID0gc3RyaW5nc1tpbmRleCAtIDM5MV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBpbmRleDtcblx0fVxuXG5cdC8vIEludGVycHJldCBhIGRpY3Rpb25hcnkgYW5kIHJldHVybiBhIG5ldyBkaWN0aW9uYXJ5IHdpdGggcmVhZGFibGUga2V5cyBhbmQgdmFsdWVzIGZvciBtaXNzaW5nIGVudHJpZXMuXG5cdC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYG1ldGFgIHdoaWNoIGlzIGEgbGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYG9wZXJhbmRgLCBgbmFtZWAgYW5kIGBkZWZhdWx0YC5cblx0ZnVuY3Rpb24gaW50ZXJwcmV0RGljdChkaWN0LCBtZXRhLCBzdHJpbmdzKSB7XG5cdCAgICB2YXIgbmV3RGljdCA9IHt9O1xuXHQgICAgdmFyIHZhbHVlO1xuXG5cdCAgICAvLyBCZWNhdXNlIHdlIGFsc28gd2FudCB0byBpbmNsdWRlIG1pc3NpbmcgdmFsdWVzLCB3ZSBzdGFydCBvdXQgZnJvbSB0aGUgbWV0YSBsaXN0XG5cdCAgICAvLyBhbmQgbG9va3VwIHZhbHVlcyBpbiB0aGUgZGljdC5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBtID0gbWV0YVtpXTtcblxuXHQgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG0udHlwZSkpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuXHQgICAgICAgICAgICB2YWx1ZXMubGVuZ3RoID0gbS50eXBlLmxlbmd0aDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtLnR5cGUubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gZGljdFttLm9wXSAhPT0gdW5kZWZpbmVkID8gZGljdFttLm9wXVtqXSA6IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgbS52YWx1ZVtqXSAhPT0gdW5kZWZpbmVkID8gbS52YWx1ZVtqXSA6IG51bGw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAobS50eXBlW2pdID09PSAnU0lEJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhbHVlc1tqXSA9IHZhbHVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG5ld0RpY3RbbS5uYW1lXSA9IHZhbHVlcztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IGRpY3RbbS5vcF07XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IG0udmFsdWUgIT09IHVuZGVmaW5lZCA/IG0udmFsdWUgOiBudWxsO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKG0udHlwZSA9PT0gJ1NJRCcpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBuZXdEaWN0W20ubmFtZV0gPSB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBuZXdEaWN0O1xuXHR9XG5cblx0Ly8gUGFyc2UgdGhlIENGRiBoZWFkZXIuXG5cdGZ1bmN0aW9uIHBhcnNlQ0ZGSGVhZGVyKGRhdGEsIHN0YXJ0KSB7XG5cdCAgICB2YXIgaGVhZGVyID0ge307XG5cdCAgICBoZWFkZXIuZm9ybWF0TWFqb3IgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCk7XG5cdCAgICBoZWFkZXIuZm9ybWF0TWlub3IgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDEpO1xuXHQgICAgaGVhZGVyLnNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDIpO1xuXHQgICAgaGVhZGVyLm9mZnNldFNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDMpO1xuXHQgICAgaGVhZGVyLnN0YXJ0T2Zmc2V0ID0gc3RhcnQ7XG5cdCAgICBoZWFkZXIuZW5kT2Zmc2V0ID0gc3RhcnQgKyA0O1xuXHQgICAgcmV0dXJuIGhlYWRlcjtcblx0fVxuXG5cdHZhciBUT1BfRElDVF9NRVRBID0gW1xuXHQgICAge25hbWU6ICd2ZXJzaW9uJywgb3A6IDAsIHR5cGU6ICdTSUQnfSxcblx0ICAgIHtuYW1lOiAnbm90aWNlJywgb3A6IDEsIHR5cGU6ICdTSUQnfSxcblx0ICAgIHtuYW1lOiAnY29weXJpZ2h0Jywgb3A6IDEyMDAsIHR5cGU6ICdTSUQnfSxcblx0ICAgIHtuYW1lOiAnZnVsbE5hbWUnLCBvcDogMiwgdHlwZTogJ1NJRCd9LFxuXHQgICAge25hbWU6ICdmYW1pbHlOYW1lJywgb3A6IDMsIHR5cGU6ICdTSUQnfSxcblx0ICAgIHtuYW1lOiAnd2VpZ2h0Jywgb3A6IDQsIHR5cGU6ICdTSUQnfSxcblx0ICAgIHtuYW1lOiAnaXNGaXhlZFBpdGNoJywgb3A6IDEyMDEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG5cdCAgICB7bmFtZTogJ2l0YWxpY0FuZ2xlJywgb3A6IDEyMDIsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG5cdCAgICB7bmFtZTogJ3VuZGVybGluZVBvc2l0aW9uJywgb3A6IDEyMDMsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogLTEwMH0sXG5cdCAgICB7bmFtZTogJ3VuZGVybGluZVRoaWNrbmVzcycsIG9wOiAxMjA0LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDUwfSxcblx0ICAgIHtuYW1lOiAncGFpbnRUeXBlJywgb3A6IDEyMDUsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG5cdCAgICB7bmFtZTogJ2NoYXJzdHJpbmdUeXBlJywgb3A6IDEyMDYsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMn0sXG5cdCAgICB7XG5cdCAgICAgICAgbmFtZTogJ2ZvbnRNYXRyaXgnLFxuXHQgICAgICAgIG9wOiAxMjA3LFxuXHQgICAgICAgIHR5cGU6IFsncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnXSxcblx0ICAgICAgICB2YWx1ZTogWzAuMDAxLCAwLCAwLCAwLjAwMSwgMCwgMF1cblx0ICAgIH0sXG5cdCAgICB7bmFtZTogJ3VuaXF1ZUlkJywgb3A6IDEzLCB0eXBlOiAnbnVtYmVyJ30sXG5cdCAgICB7bmFtZTogJ2ZvbnRCQm94Jywgb3A6IDUsIHR5cGU6IFsnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJ10sIHZhbHVlOiBbMCwgMCwgMCwgMF19LFxuXHQgICAge25hbWU6ICdzdHJva2VXaWR0aCcsIG9wOiAxMjA4LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuXHQgICAge25hbWU6ICd4dWlkJywgb3A6IDE0LCB0eXBlOiBbXSwgdmFsdWU6IG51bGx9LFxuXHQgICAge25hbWU6ICdjaGFyc2V0Jywgb3A6IDE1LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuXHQgICAge25hbWU6ICdlbmNvZGluZycsIG9wOiAxNiwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcblx0ICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCBvcDogMTcsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG5cdCAgICB7bmFtZTogJ3ByaXZhdGUnLCBvcDogMTgsIHR5cGU6IFsnbnVtYmVyJywgJ29mZnNldCddLCB2YWx1ZTogWzAsIDBdfSxcblx0ICAgIHtuYW1lOiAncm9zJywgb3A6IDEyMzAsIHR5cGU6IFsnU0lEJywgJ1NJRCcsICdudW1iZXInXX0sXG5cdCAgICB7bmFtZTogJ2NpZEZvbnRWZXJzaW9uJywgb3A6IDEyMzEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG5cdCAgICB7bmFtZTogJ2NpZEZvbnRSZXZpc2lvbicsIG9wOiAxMjMyLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuXHQgICAge25hbWU6ICdjaWRGb250VHlwZScsIG9wOiAxMjMzLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuXHQgICAge25hbWU6ICdjaWRDb3VudCcsIG9wOiAxMjM0LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDg3MjB9LFxuXHQgICAge25hbWU6ICd1aWRCYXNlJywgb3A6IDEyMzUsIHR5cGU6ICdudW1iZXInfSxcblx0ICAgIHtuYW1lOiAnZmRBcnJheScsIG9wOiAxMjM2LCB0eXBlOiAnb2Zmc2V0J30sXG5cdCAgICB7bmFtZTogJ2ZkU2VsZWN0Jywgb3A6IDEyMzcsIHR5cGU6ICdvZmZzZXQnfSxcblx0ICAgIHtuYW1lOiAnZm9udE5hbWUnLCBvcDogMTIzOCwgdHlwZTogJ1NJRCd9XG5cdF07XG5cblx0dmFyIFBSSVZBVEVfRElDVF9NRVRBID0gW1xuXHQgICAge25hbWU6ICdzdWJycycsIG9wOiAxOSwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcblx0ICAgIHtuYW1lOiAnZGVmYXVsdFdpZHRoWCcsIG9wOiAyMCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcblx0ICAgIHtuYW1lOiAnbm9taW5hbFdpZHRoWCcsIG9wOiAyMSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfVxuXHRdO1xuXG5cdC8vIFBhcnNlIHRoZSBDRkYgdG9wIGRpY3Rpb25hcnkuIEEgQ0ZGIHRhYmxlIGNhbiBjb250YWluIG11bHRpcGxlIGZvbnRzLCBlYWNoIHdpdGggdGhlaXIgb3duIHRvcCBkaWN0aW9uYXJ5LlxuXHQvLyBUaGUgdG9wIGRpY3Rpb25hcnkgY29udGFpbnMgdGhlIGVzc2VudGlhbCBtZXRhZGF0YSBmb3IgdGhlIGZvbnQsIHRvZ2V0aGVyIHdpdGggdGhlIHByaXZhdGUgZGljdGlvbmFyeS5cblx0ZnVuY3Rpb24gcGFyc2VDRkZUb3BEaWN0KGRhdGEsIHN0cmluZ3MpIHtcblx0ICAgIHZhciBkaWN0ID0gcGFyc2VDRkZEaWN0KGRhdGEsIDAsIGRhdGEuYnl0ZUxlbmd0aCk7XG5cdCAgICByZXR1cm4gaW50ZXJwcmV0RGljdChkaWN0LCBUT1BfRElDVF9NRVRBLCBzdHJpbmdzKTtcblx0fVxuXG5cdC8vIFBhcnNlIHRoZSBDRkYgcHJpdmF0ZSBkaWN0aW9uYXJ5LiBXZSBkb24ndCBmdWxseSBwYXJzZSBvdXQgYWxsIHRoZSB2YWx1ZXMsIG9ubHkgdGhlIG9uZXMgd2UgbmVlZC5cblx0ZnVuY3Rpb24gcGFyc2VDRkZQcml2YXRlRGljdChkYXRhLCBzdGFydCwgc2l6ZSwgc3RyaW5ncykge1xuXHQgICAgdmFyIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpO1xuXHQgICAgcmV0dXJuIGludGVycHJldERpY3QoZGljdCwgUFJJVkFURV9ESUNUX01FVEEsIHN0cmluZ3MpO1xuXHR9XG5cblx0Ly8gUmV0dXJucyBhIGxpc3Qgb2YgXCJUb3AgRElDVFwicyBmb3VuZCB1c2luZyBhbiBJTkRFWCBsaXN0LlxuXHQvLyBVc2VkIHRvIHJlYWQgYm90aCB0aGUgdXN1YWwgaGlnaC1sZXZlbCBUb3AgRElDVHMgYW5kIGFsc28gdGhlIEZEQXJyYXlcblx0Ly8gZGlzY292ZXJlZCBpbnNpZGUgQ0lELWtleWVkIGZvbnRzLiAgV2hlbiBhIFRvcCBESUNUIGhhcyBhIHJlZmVyZW5jZSB0b1xuXHQvLyBhIFByaXZhdGUgRElDVCB0aGF0IGlzIHJlYWQgYW5kIHNhdmVkIGludG8gdGhlIFRvcCBESUNULlxuXHQvL1xuXHQvLyBJbiBhZGRpdGlvbiB0byB0aGUgZXhwZWN0ZWQvb3B0aW9uYWwgdmFsdWVzIGFzIG91dGxpbmVkIGluIFRPUF9ESUNUX01FVEFcblx0Ly8gdGhlIGZvbGxvd2luZyB2YWx1ZXMgbWlnaHQgYmUgc2F2ZWQgaW50byB0aGUgVG9wIERJQ1QuXG5cdC8vXG5cdC8vICAgIF9zdWJycyBbXSAgICAgICAgYXJyYXkgb2YgbG9jYWwgQ0ZGIHN1YnJvdXRpbmVzIGZyb20gUHJpdmF0ZSBESUNUXG5cdC8vICAgIF9zdWJyc0JpYXMgICAgICAgYmlhcyB2YWx1ZSBjb21wdXRlZCBmcm9tIG51bWJlciBvZiBzdWJyb3V0aW5lc1xuXHQvLyAgICAgICAgICAgICAgICAgICAgICAoc2VlIGNhbGNDRkZTdWJyb3V0aW5lQmlhcygpIGFuZCBwYXJzZUNGRkNoYXJzdHJpbmcoKSlcblx0Ly8gICAgX2RlZmF1bHRXaWR0aFggICBkZWZhdWx0IHdpZHRocyBmb3IgQ0ZGIGNoYXJhY3RlcnNcblx0Ly8gICAgX25vbWluYWxXaWR0aFggICBiaWFzIGFkZGVkIHRvIHdpZHRoIGVtYmVkZGVkIHdpdGhpbiBnbHlwaCBkZXNjcmlwdGlvblxuXHQvL1xuXHQvLyAgICBfcHJpdmF0ZURpY3QgICAgIHNhdmVkIGNvcHkgb2YgcGFyc2VkIFByaXZhdGUgRElDVCBmcm9tIFRvcCBESUNUXG5cdGZ1bmN0aW9uIGdhdGhlckNGRlRvcERpY3RzKGRhdGEsIHN0YXJ0LCBjZmZJbmRleCwgc3RyaW5ncykge1xuXHQgICAgdmFyIHRvcERpY3RBcnJheSA9IFtdO1xuXHQgICAgZm9yICh2YXIgaVRvcERpY3QgPSAwOyBpVG9wRGljdCA8IGNmZkluZGV4Lmxlbmd0aDsgaVRvcERpY3QgKz0gMSkge1xuXHQgICAgICAgIHZhciB0b3BEaWN0RGF0YSA9IG5ldyBEYXRhVmlldyhuZXcgVWludDhBcnJheShjZmZJbmRleFtpVG9wRGljdF0pLmJ1ZmZlcik7XG5cdCAgICAgICAgdmFyIHRvcERpY3QgPSBwYXJzZUNGRlRvcERpY3QodG9wRGljdERhdGEsIHN0cmluZ3MpO1xuXHQgICAgICAgIHRvcERpY3QuX3N1YnJzID0gW107XG5cdCAgICAgICAgdG9wRGljdC5fc3VicnNCaWFzID0gMDtcblx0ICAgICAgICB0b3BEaWN0Ll9kZWZhdWx0V2lkdGhYID0gMDtcblx0ICAgICAgICB0b3BEaWN0Ll9ub21pbmFsV2lkdGhYID0gMDtcblx0ICAgICAgICB2YXIgcHJpdmF0ZVNpemUgPSB0b3BEaWN0LnByaXZhdGVbMF07XG5cdCAgICAgICAgdmFyIHByaXZhdGVPZmZzZXQgPSB0b3BEaWN0LnByaXZhdGVbMV07XG5cdCAgICAgICAgaWYgKHByaXZhdGVTaXplICE9PSAwICYmIHByaXZhdGVPZmZzZXQgIT09IDApIHtcblx0ICAgICAgICAgICAgdmFyIHByaXZhdGVEaWN0ID0gcGFyc2VDRkZQcml2YXRlRGljdChkYXRhLCBwcml2YXRlT2Zmc2V0ICsgc3RhcnQsIHByaXZhdGVTaXplLCBzdHJpbmdzKTtcblx0ICAgICAgICAgICAgdG9wRGljdC5fZGVmYXVsdFdpZHRoWCA9IHByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG5cdCAgICAgICAgICAgIHRvcERpY3QuX25vbWluYWxXaWR0aFggPSBwcml2YXRlRGljdC5ub21pbmFsV2lkdGhYO1xuXHQgICAgICAgICAgICBpZiAocHJpdmF0ZURpY3Quc3VicnMgIT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzdWJyT2Zmc2V0ID0gcHJpdmF0ZU9mZnNldCArIHByaXZhdGVEaWN0LnN1YnJzO1xuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnJJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3Vick9mZnNldCArIHN0YXJ0KTtcblx0ICAgICAgICAgICAgICAgIHRvcERpY3QuX3N1YnJzID0gc3VickluZGV4Lm9iamVjdHM7XG5cdCAgICAgICAgICAgICAgICB0b3BEaWN0Ll9zdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXModG9wRGljdC5fc3VicnMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRvcERpY3QuX3ByaXZhdGVEaWN0ID0gcHJpdmF0ZURpY3Q7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRvcERpY3RBcnJheS5wdXNoKHRvcERpY3QpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRvcERpY3RBcnJheTtcblx0fVxuXG5cdC8vIFBhcnNlIHRoZSBDRkYgY2hhcnNldCB0YWJsZSwgd2hpY2ggY29udGFpbnMgaW50ZXJuYWwgbmFtZXMgZm9yIGFsbCB0aGUgZ2x5cGhzLlxuXHQvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiBnbHlwaCBuYW1lcy5cblx0Ly8gU2VlIEFkb2JlIFROICM1MTc2IGNoYXB0ZXIgMTMsIFwiQ2hhcnNldHNcIi5cblx0ZnVuY3Rpb24gcGFyc2VDRkZDaGFyc2V0KGRhdGEsIHN0YXJ0LCBuR2x5cGhzLCBzdHJpbmdzKSB7XG5cdCAgICB2YXIgc2lkO1xuXHQgICAgdmFyIGNvdW50O1xuXHQgICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXG5cdCAgICAvLyBUaGUgLm5vdGRlZiBnbHlwaCBpcyBub3QgaW5jbHVkZWQsIHNvIHN1YnRyYWN0IDEuXG5cdCAgICBuR2x5cGhzIC09IDE7XG5cdCAgICB2YXIgY2hhcnNldCA9IFsnLm5vdGRlZiddO1xuXG5cdCAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcblx0ICAgIGlmIChmb3JtYXQgPT09IDApIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5HbHlwaHM7IGkgKz0gMSkge1xuXHQgICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcblx0ICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcblx0ICAgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG5cdCAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuXHQgICAgICAgICAgICBjb3VudCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8PSBjb3VudDsgaSQxICs9IDEpIHtcblx0ICAgICAgICAgICAgICAgIGNoYXJzZXQucHVzaChnZXRDRkZTdHJpbmcoc3RyaW5ncywgc2lkKSk7XG5cdCAgICAgICAgICAgICAgICBzaWQgKz0gMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG5cdCAgICAgICAgd2hpbGUgKGNoYXJzZXQubGVuZ3RoIDw9IG5HbHlwaHMpIHtcblx0ICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG5cdCAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8PSBjb3VudDsgaSQyICs9IDEpIHtcblx0ICAgICAgICAgICAgICAgIGNoYXJzZXQucHVzaChnZXRDRkZTdHJpbmcoc3RyaW5ncywgc2lkKSk7XG5cdCAgICAgICAgICAgICAgICBzaWQgKz0gMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNoYXJzZXQgZm9ybWF0ICcgKyBmb3JtYXQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gY2hhcnNldDtcblx0fVxuXG5cdC8vIFBhcnNlIHRoZSBDRkYgZW5jb2RpbmcgZGF0YS4gT25seSBvbmUgZW5jb2RpbmcgY2FuIGJlIHNwZWNpZmllZCBwZXIgZm9udC5cblx0Ly8gU2VlIEFkb2JlIFROICM1MTc2IGNoYXB0ZXIgMTIsIFwiRW5jb2RpbmdzXCIuXG5cdGZ1bmN0aW9uIHBhcnNlQ0ZGRW5jb2RpbmcoZGF0YSwgc3RhcnQsIGNoYXJzZXQpIHtcblx0ICAgIHZhciBjb2RlO1xuXHQgICAgdmFyIGVuYyA9IHt9O1xuXHQgICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgdmFyIGZvcm1hdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG5cdCAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG5cdCAgICAgICAgdmFyIG5Db2RlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuQ29kZXM7IGkgKz0gMSkge1xuXHQgICAgICAgICAgICBjb2RlID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcblx0ICAgICAgICAgICAgZW5jW2NvZGVdID0gaTtcblx0ICAgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgIHZhciBuUmFuZ2VzID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcblx0ICAgICAgICBjb2RlID0gMTtcblx0ICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBuUmFuZ2VzOyBpJDEgKz0gMSkge1xuXHQgICAgICAgICAgICB2YXIgZmlyc3QgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuXHQgICAgICAgICAgICB2YXIgbkxlZnQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gZmlyc3Q7IGogPD0gZmlyc3QgKyBuTGVmdDsgaiArPSAxKSB7XG5cdCAgICAgICAgICAgICAgICBlbmNbal0gPSBjb2RlO1xuXHQgICAgICAgICAgICAgICAgY29kZSArPSAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcgZm9ybWF0ICcgKyBmb3JtYXQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbmV3IENmZkVuY29kaW5nKGVuYywgY2hhcnNldCk7XG5cdH1cblxuXHQvLyBUYWtlIGluIGNoYXJzdHJpbmcgY29kZSBhbmQgcmV0dXJuIGEgR2x5cGggb2JqZWN0LlxuXHQvLyBUaGUgZW5jb2RpbmcgaXMgZGVzY3JpYmVkIGluIHRoZSBUeXBlIDIgQ2hhcnN0cmluZyBGb3JtYXRcblx0Ly8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFyc3RyMi5odG1cblx0ZnVuY3Rpb24gcGFyc2VDRkZDaGFyc3RyaW5nKGZvbnQsIGdseXBoLCBjb2RlKSB7XG5cdCAgICB2YXIgYzF4O1xuXHQgICAgdmFyIGMxeTtcblx0ICAgIHZhciBjMng7XG5cdCAgICB2YXIgYzJ5O1xuXHQgICAgdmFyIHAgPSBuZXcgUGF0aCgpO1xuXHQgICAgdmFyIHN0YWNrID0gW107XG5cdCAgICB2YXIgblN0ZW1zID0gMDtcblx0ICAgIHZhciBoYXZlV2lkdGggPSBmYWxzZTtcblx0ICAgIHZhciBvcGVuID0gZmFsc2U7XG5cdCAgICB2YXIgeCA9IDA7XG5cdCAgICB2YXIgeSA9IDA7XG5cdCAgICB2YXIgc3VicnM7XG5cdCAgICB2YXIgc3VicnNCaWFzO1xuXHQgICAgdmFyIGRlZmF1bHRXaWR0aFg7XG5cdCAgICB2YXIgbm9taW5hbFdpZHRoWDtcblx0ICAgIGlmIChmb250LmlzQ0lERm9udCkge1xuXHQgICAgICAgIHZhciBmZEluZGV4ID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX2ZkU2VsZWN0W2dseXBoLmluZGV4XTtcblx0ICAgICAgICB2YXIgZmREaWN0ID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX2ZkQXJyYXlbZmRJbmRleF07XG5cdCAgICAgICAgc3VicnMgPSBmZERpY3QuX3N1YnJzO1xuXHQgICAgICAgIHN1YnJzQmlhcyA9IGZkRGljdC5fc3VicnNCaWFzO1xuXHQgICAgICAgIGRlZmF1bHRXaWR0aFggPSBmZERpY3QuX2RlZmF1bHRXaWR0aFg7XG5cdCAgICAgICAgbm9taW5hbFdpZHRoWCA9IGZkRGljdC5fbm9taW5hbFdpZHRoWDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgc3VicnMgPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fc3VicnM7XG5cdCAgICAgICAgc3VicnNCaWFzID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX3N1YnJzQmlhcztcblx0ICAgICAgICBkZWZhdWx0V2lkdGhYID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX2RlZmF1bHRXaWR0aFg7XG5cdCAgICAgICAgbm9taW5hbFdpZHRoWCA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9ub21pbmFsV2lkdGhYO1xuXHQgICAgfVxuXHQgICAgdmFyIHdpZHRoID0gZGVmYXVsdFdpZHRoWDtcblxuXHQgICAgZnVuY3Rpb24gbmV3Q29udG91cih4LCB5KSB7XG5cdCAgICAgICAgaWYgKG9wZW4pIHtcblx0ICAgICAgICAgICAgcC5jbG9zZVBhdGgoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwLm1vdmVUbyh4LCB5KTtcblx0ICAgICAgICBvcGVuID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcGFyc2VTdGVtcygpIHtcblx0ICAgICAgICB2YXIgaGFzV2lkdGhBcmc7XG5cblx0ICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIHN0ZW0gb3BlcmF0b3JzIG9uIHRoZSBzdGFjayBpcyBhbHdheXMgZXZlbi5cblx0ICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgdW5ldmVuLCB0aGF0IG1lYW5zIGEgd2lkdGggaXMgc3BlY2lmaWVkLlxuXHQgICAgICAgIGhhc1dpZHRoQXJnID0gc3RhY2subGVuZ3RoICUgMiAhPT0gMDtcblx0ICAgICAgICBpZiAoaGFzV2lkdGhBcmcgJiYgIWhhdmVXaWR0aCkge1xuXHQgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG5TdGVtcyArPSBzdGFjay5sZW5ndGggPj4gMTtcblx0ICAgICAgICBzdGFjay5sZW5ndGggPSAwO1xuXHQgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHBhcnNlKGNvZGUpIHtcblx0ICAgICAgICB2YXIgYjE7XG5cdCAgICAgICAgdmFyIGIyO1xuXHQgICAgICAgIHZhciBiMztcblx0ICAgICAgICB2YXIgYjQ7XG5cdCAgICAgICAgdmFyIGNvZGVJbmRleDtcblx0ICAgICAgICB2YXIgc3VickNvZGU7XG5cdCAgICAgICAgdmFyIGpweDtcblx0ICAgICAgICB2YXIganB5O1xuXHQgICAgICAgIHZhciBjM3g7XG5cdCAgICAgICAgdmFyIGMzeTtcblx0ICAgICAgICB2YXIgYzR4O1xuXHQgICAgICAgIHZhciBjNHk7XG5cblx0ICAgICAgICB2YXIgaSA9IDA7XG5cdCAgICAgICAgd2hpbGUgKGkgPCBjb2RlLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB2YXIgdiA9IGNvZGVbaV07XG5cdCAgICAgICAgICAgIGkgKz0gMTtcblx0ICAgICAgICAgICAgc3dpdGNoICh2KSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIGhzdGVtXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAzOiAvLyB2c3RlbVxuXHQgICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogLy8gdm1vdmV0b1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxICYmICFoYXZlV2lkdGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRvdXIoeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IC8vIHJsaW5ldG9cblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDY6IC8vIGhsaW5ldG9cblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IC8vIHZsaW5ldG9cblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDg6IC8vIHJyY3VydmV0b1xuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTA6IC8vIGNhbGxzdWJyXG5cdCAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gc3RhY2sucG9wKCkgKyBzdWJyc0JpYXM7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VickNvZGUgPSBzdWJyc1tjb2RlSW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZShzdWJyQ29kZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDExOiAvLyByZXR1cm5cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICBjYXNlIDEyOiAvLyBmbGV4IG9wZXJhdG9yc1xuXHQgICAgICAgICAgICAgICAgICAgIHYgPSBjb2RlW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcblx0ICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNTogLy8gZmxleFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeTMgZHg0IGR5NCBkeDUgZHk1IGR4NiBkeTYgZmQgZmxleCAoMTIgMzUpIHwtXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGpweSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg1XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGM0eSAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk2XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5zaGlmdCgpOyAgICAgICAgICAgICAgICAvLyBmbGV4IGRlcHRoXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM0OiAvLyBoZmxleFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR4MiBkeTIgZHgzIGR4NCBkeDUgZHg2IGhmbGV4ICgxMiAzNCkgfC1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTsgICAgICAgICAgICAgICAgICAgICAgLy8gZHkxXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnk7ICAgICAgICAgICAgICAgICAgICAvLyBkeTNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHk0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IHk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGR5NVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7ICAgICAgLy8gZHg2XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM2OiAvLyBoZmxleDFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeTEgZHgyIGR5MiBkeDMgZHg0IGR4NSBkeTUgZHg2IGhmbGV4MSAoMTIgMzYpIHwtXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHkzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5NFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg1XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpOyAgICAgIC8vIGR4NlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMzeCwgYzN5LCBjNHgsIGM0eSwgeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzogLy8gZmxleDFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeTEgZHgyIGR5MiBkeDMgZHkzIGR4NCBkeTQgZHg1IGR5NSBkNiBmbGV4MSAoMTIgMzcpIHwtXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGpweSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg1XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjNHggLSB4KSA+IE1hdGguYWJzKGM0eSAtIHkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjNHkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0dseXBoICcgKyBnbHlwaC5pbmRleCArICc6IHVua25vd24gb3BlcmF0b3IgJyArIDEyMDAgKyB2KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxNDogLy8gZW5kY2hhclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwICYmICFoYXZlV2lkdGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3Blbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcGVuID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE4OiAvLyBoc3RlbWhtXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxOTogLy8gaGludG1hc2tcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjA6IC8vIGNudHJtYXNrXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuXHQgICAgICAgICAgICAgICAgICAgIGkgKz0gKG5TdGVtcyArIDcpID4+IDM7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDIxOiAvLyBybW92ZXRvXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDIgJiYgIWhhdmVXaWR0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAyMjogLy8gaG1vdmV0b1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxICYmICFoYXZlV2lkdGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRvdXIoeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDIzOiAvLyB2c3RlbWhtXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAyNDogLy8gcmN1cnZlbGluZVxuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAyNTogLy8gcmxpbmVjdXJ2ZVxuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiA2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDI2OiAvLyB2dmN1cnZldG9cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICUgMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMng7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjc6IC8vIGhoY3VydmV0b1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJSAyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAyODogLy8gc2hvcnRpbnRcblx0ICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSkgPj4gMTYpO1xuXHQgICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjk6IC8vIGNhbGxnc3ViclxuXHQgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IHN0YWNrLnBvcCgpICsgZm9udC5nc3VicnNCaWFzO1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gZm9udC5nc3VicnNbY29kZUluZGV4XTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3VickNvZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2Uoc3VickNvZGUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAzMDogLy8gdmhjdXJ2ZXRvXG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDMxOiAvLyBodmN1cnZldG9cblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHYgPCAzMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnR2x5cGggJyArIGdseXBoLmluZGV4ICsgJzogdW5rbm93biBvcGVyYXRvciAnICsgdik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2IDwgMjQ3KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godiAtIDEzOSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2IDwgMjUxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCh2IC0gMjQ3KSAqIDI1NiArIGIxICsgMTA4KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goLSh2IC0gMjUxKSAqIDI1NiAtIGIxIC0gMTA4KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY29kZVtpICsgMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGIzID0gY29kZVtpICsgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGI0ID0gY29kZVtpICsgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gNDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgoKGIxIDw8IDI0KSB8IChiMiA8PCAxNikgfCAoYjMgPDwgOCkgfCBiNCkgLyA2NTUzNik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBwYXJzZShjb2RlKTtcblxuXHQgICAgZ2x5cGguYWR2YW5jZVdpZHRoID0gd2lkdGg7XG5cdCAgICByZXR1cm4gcDtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlQ0ZGRkRTZWxlY3QoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIGZkQXJyYXlDb3VudCkge1xuXHQgICAgdmFyIGZkU2VsZWN0ID0gW107XG5cdCAgICB2YXIgZmRJbmRleDtcblx0ICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIHZhciBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuXHQgICAgaWYgKGZvcm1hdCA9PT0gMCkge1xuXHQgICAgICAgIC8vIFNpbXBsZSBsaXN0IG9mIG5HbHlwaHMgZWxlbWVudHNcblx0ICAgICAgICBmb3IgKHZhciBpR2lkID0gMDsgaUdpZCA8IG5HbHlwaHM7IGlHaWQrKykge1xuXHQgICAgICAgICAgICBmZEluZGV4ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcblx0ICAgICAgICAgICAgaWYgKGZkSW5kZXggPj0gZmRBcnJheUNvdW50KSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiB0YWJsZSBDSUQgRm9udCBGRFNlbGVjdCBoYXMgYmFkIEZEIGluZGV4IHZhbHVlICcgKyBmZEluZGV4ICsgJyAoRkQgY291bnQgJyArIGZkQXJyYXlDb3VudCArICcpJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZmRTZWxlY3QucHVzaChmZEluZGV4KTtcblx0ICAgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMykge1xuXHQgICAgICAgIC8vIFJhbmdlc1xuXHQgICAgICAgIHZhciBuUmFuZ2VzID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG5cdCAgICAgICAgdmFyIGZpcnN0ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG5cdCAgICAgICAgaWYgKGZpcnN0ICE9PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IGZvcm1hdCAzIHJhbmdlIGhhcyBiYWQgaW5pdGlhbCBHSUQgJyArIGZpcnN0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG5leHQ7XG5cdCAgICAgICAgZm9yICh2YXIgaVJhbmdlID0gMDsgaVJhbmdlIDwgblJhbmdlczsgaVJhbmdlKyspIHtcblx0ICAgICAgICAgICAgZmRJbmRleCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG5cdCAgICAgICAgICAgIG5leHQgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcblx0ICAgICAgICAgICAgaWYgKGZkSW5kZXggPj0gZmRBcnJheUNvdW50KSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiB0YWJsZSBDSUQgRm9udCBGRFNlbGVjdCBoYXMgYmFkIEZEIGluZGV4IHZhbHVlICcgKyBmZEluZGV4ICsgJyAoRkQgY291bnQgJyArIGZkQXJyYXlDb3VudCArICcpJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKG5leHQgPiBuR2x5cGhzKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIEdJRCAnICsgbmV4dCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZm9yICg7IGZpcnN0IDwgbmV4dDsgZmlyc3QrKykge1xuXHQgICAgICAgICAgICAgICAgZmRTZWxlY3QucHVzaChmZEluZGV4KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmaXJzdCA9IG5leHQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChuZXh0ICE9PSBuR2x5cGhzKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IGZvcm1hdCAzIHJhbmdlIGhhcyBiYWQgZmluYWwgR0lEICcgKyBuZXh0KTtcblx0ICAgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IHRhYmxlIGhhcyB1bnN1cHBvcnRlZCBmb3JtYXQgJyArIGZvcm1hdCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZmRTZWxlY3Q7XG5cdH1cblxuXHQvLyBQYXJzZSB0aGUgYENGRmAgdGFibGUsIHdoaWNoIGNvbnRhaW5zIHRoZSBnbHlwaCBvdXRsaW5lcyBpbiBQb3N0U2NyaXB0IGZvcm1hdC5cblx0ZnVuY3Rpb24gcGFyc2VDRkZUYWJsZShkYXRhLCBzdGFydCwgZm9udCwgb3B0KSB7XG5cdCAgICBmb250LnRhYmxlcy5jZmYgPSB7fTtcblx0ICAgIHZhciBoZWFkZXIgPSBwYXJzZUNGRkhlYWRlcihkYXRhLCBzdGFydCk7XG5cdCAgICB2YXIgbmFtZUluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBoZWFkZXIuZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcblx0ICAgIHZhciB0b3BEaWN0SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIG5hbWVJbmRleC5lbmRPZmZzZXQpO1xuXHQgICAgdmFyIHN0cmluZ0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCB0b3BEaWN0SW5kZXguZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcblx0ICAgIHZhciBnbG9iYWxTdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0cmluZ0luZGV4LmVuZE9mZnNldCk7XG5cdCAgICBmb250LmdzdWJycyA9IGdsb2JhbFN1YnJJbmRleC5vYmplY3RzO1xuXHQgICAgZm9udC5nc3VicnNCaWFzID0gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKGZvbnQuZ3N1YnJzKTtcblxuXHQgICAgdmFyIHRvcERpY3RBcnJheSA9IGdhdGhlckNGRlRvcERpY3RzKGRhdGEsIHN0YXJ0LCB0b3BEaWN0SW5kZXgub2JqZWN0cywgc3RyaW5nSW5kZXgub2JqZWN0cyk7XG5cdCAgICBpZiAodG9wRGljdEFycmF5Lmxlbmd0aCAhPT0gMSkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIHRhYmxlIGhhcyB0b28gbWFueSBmb250cyBpbiBcXCdGb250U2V0XFwnIC0gY291bnQgb2YgZm9udHMgTmFtZUluZGV4Lmxlbmd0aCA9ICcgKyB0b3BEaWN0QXJyYXkubGVuZ3RoKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHRvcERpY3QgPSB0b3BEaWN0QXJyYXlbMF07XG5cdCAgICBmb250LnRhYmxlcy5jZmYudG9wRGljdCA9IHRvcERpY3Q7XG5cblx0ICAgIGlmICh0b3BEaWN0Ll9wcml2YXRlRGljdCkge1xuXHQgICAgICAgIGZvbnQuZGVmYXVsdFdpZHRoWCA9IHRvcERpY3QuX3ByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG5cdCAgICAgICAgZm9udC5ub21pbmFsV2lkdGhYID0gdG9wRGljdC5fcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRvcERpY3Qucm9zWzBdICE9PSB1bmRlZmluZWQgJiYgdG9wRGljdC5yb3NbMV0gIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGZvbnQuaXNDSURGb250ID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGZvbnQuaXNDSURGb250KSB7XG5cdCAgICAgICAgdmFyIGZkQXJyYXlPZmZzZXQgPSB0b3BEaWN0LmZkQXJyYXk7XG5cdCAgICAgICAgdmFyIGZkU2VsZWN0T2Zmc2V0ID0gdG9wRGljdC5mZFNlbGVjdDtcblx0ICAgICAgICBpZiAoZmRBcnJheU9mZnNldCA9PT0gMCB8fCBmZFNlbGVjdE9mZnNldCA9PT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvbnQgaXMgbWFya2VkIGFzIGEgQ0lEIGZvbnQsIGJ1dCBGREFycmF5IGFuZC9vciBGRFNlbGVjdCBpbmZvcm1hdGlvbiBpcyBtaXNzaW5nJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZkQXJyYXlPZmZzZXQgKz0gc3RhcnQ7XG5cdCAgICAgICAgdmFyIGZkQXJyYXlJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgZmRBcnJheU9mZnNldCk7XG5cdCAgICAgICAgdmFyIGZkQXJyYXkgPSBnYXRoZXJDRkZUb3BEaWN0cyhkYXRhLCBzdGFydCwgZmRBcnJheUluZGV4Lm9iamVjdHMsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuXHQgICAgICAgIHRvcERpY3QuX2ZkQXJyYXkgPSBmZEFycmF5O1xuXHQgICAgICAgIGZkU2VsZWN0T2Zmc2V0ICs9IHN0YXJ0O1xuXHQgICAgICAgIHRvcERpY3QuX2ZkU2VsZWN0ID0gcGFyc2VDRkZGRFNlbGVjdChkYXRhLCBmZFNlbGVjdE9mZnNldCwgZm9udC5udW1HbHlwaHMsIGZkQXJyYXkubGVuZ3RoKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHByaXZhdGVEaWN0T2Zmc2V0ID0gc3RhcnQgKyB0b3BEaWN0LnByaXZhdGVbMV07XG5cdCAgICB2YXIgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHByaXZhdGVEaWN0T2Zmc2V0LCB0b3BEaWN0LnByaXZhdGVbMF0sIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuXHQgICAgZm9udC5kZWZhdWx0V2lkdGhYID0gcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcblx0ICAgIGZvbnQubm9taW5hbFdpZHRoWCA9IHByaXZhdGVEaWN0Lm5vbWluYWxXaWR0aFg7XG5cblx0ICAgIGlmIChwcml2YXRlRGljdC5zdWJycyAhPT0gMCkge1xuXHQgICAgICAgIHZhciBzdWJyT2Zmc2V0ID0gcHJpdmF0ZURpY3RPZmZzZXQgKyBwcml2YXRlRGljdC5zdWJycztcblx0ICAgICAgICB2YXIgc3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdWJyT2Zmc2V0KTtcblx0ICAgICAgICBmb250LnN1YnJzID0gc3VickluZGV4Lm9iamVjdHM7XG5cdCAgICAgICAgZm9udC5zdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5zdWJycyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGZvbnQuc3VicnMgPSBbXTtcblx0ICAgICAgICBmb250LnN1YnJzQmlhcyA9IDA7XG5cdCAgICB9XG5cblx0ICAgIC8vIE9mZnNldHMgaW4gdGhlIHRvcCBkaWN0IGFyZSByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBDRkYgZGF0YSwgc28gYWRkIHRoZSBDRkYgc3RhcnQgb2Zmc2V0LlxuXHQgICAgdmFyIGNoYXJTdHJpbmdzSW5kZXg7XG5cdCAgICBpZiAob3B0Lmxvd01lbW9yeSkge1xuXHQgICAgICAgIGNoYXJTdHJpbmdzSW5kZXggPSBwYXJzZUNGRkluZGV4TG93TWVtb3J5KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyU3RyaW5ncyk7XG5cdCAgICAgICAgZm9udC5uR2x5cGhzID0gY2hhclN0cmluZ3NJbmRleC5vZmZzZXRzLmxlbmd0aDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgY2hhclN0cmluZ3NJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3RhcnQgKyB0b3BEaWN0LmNoYXJTdHJpbmdzKTtcblx0ICAgICAgICBmb250Lm5HbHlwaHMgPSBjaGFyU3RyaW5nc0luZGV4Lm9iamVjdHMubGVuZ3RoO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY2hhcnNldCA9IHBhcnNlQ0ZGQ2hhcnNldChkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhcnNldCwgZm9udC5uR2x5cGhzLCBzdHJpbmdJbmRleC5vYmplY3RzKTtcblx0ICAgIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAwKSB7XG5cdCAgICAgICAgLy8gU3RhbmRhcmQgZW5jb2Rpbmdcblx0ICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IENmZkVuY29kaW5nKGNmZlN0YW5kYXJkRW5jb2RpbmcsIGNoYXJzZXQpO1xuXHQgICAgfSBlbHNlIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAxKSB7XG5cdCAgICAgICAgLy8gRXhwZXJ0IGVuY29kaW5nXG5cdCAgICAgICAgZm9udC5jZmZFbmNvZGluZyA9IG5ldyBDZmZFbmNvZGluZyhjZmZFeHBlcnRFbmNvZGluZywgY2hhcnNldCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBwYXJzZUNGRkVuY29kaW5nKGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5lbmNvZGluZywgY2hhcnNldCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIFByZWZlciB0aGUgQ01BUCBlbmNvZGluZyB0byB0aGUgQ0ZGIGVuY29kaW5nLlxuXHQgICAgZm9udC5lbmNvZGluZyA9IGZvbnQuZW5jb2RpbmcgfHwgZm9udC5jZmZFbmNvZGluZztcblxuXHQgICAgZm9udC5nbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQoZm9udCk7XG5cdCAgICBpZiAob3B0Lmxvd01lbW9yeSkge1xuXHQgICAgICAgIGZvbnQuX3B1c2ggPSBmdW5jdGlvbihpKSB7XG5cdCAgICAgICAgICAgIHZhciBjaGFyU3RyaW5nID0gZ2V0Q2ZmSW5kZXhPYmplY3QoaSwgY2hhclN0cmluZ3NJbmRleC5vZmZzZXRzLCBkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3MpO1xuXHQgICAgICAgICAgICBmb250LmdseXBocy5wdXNoKGksIGdseXBoc2V0LmNmZkdseXBoTG9hZGVyKGZvbnQsIGksIHBhcnNlQ0ZGQ2hhcnN0cmluZywgY2hhclN0cmluZykpO1xuXHQgICAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9udC5uR2x5cGhzOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgdmFyIGNoYXJTdHJpbmcgPSBjaGFyU3RyaW5nc0luZGV4Lm9iamVjdHNbaV07XG5cdCAgICAgICAgICAgIGZvbnQuZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQuY2ZmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VDRkZDaGFyc3RyaW5nLCBjaGFyU3RyaW5nKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9XG5cblx0Ly8gQ29udmVydCBhIHN0cmluZyB0byBhIFN0cmluZyBJRCAoU0lEKS5cblx0Ly8gVGhlIGxpc3Qgb2Ygc3RyaW5ncyBpcyBtb2RpZmllZCBpbiBwbGFjZS5cblx0ZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHMsIHN0cmluZ3MpIHtcblx0ICAgIHZhciBzaWQ7XG5cblx0ICAgIC8vIElzIHRoZSBzdHJpbmcgaW4gdGhlIENGRiBzdGFuZGFyZCBzdHJpbmdzP1xuXHQgICAgdmFyIGkgPSBjZmZTdGFuZGFyZFN0cmluZ3MuaW5kZXhPZihzKTtcblx0ICAgIGlmIChpID49IDApIHtcblx0ICAgICAgICBzaWQgPSBpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBJcyB0aGUgc3RyaW5nIGFscmVhZHkgaW4gdGhlIHN0cmluZyBpbmRleD9cblx0ICAgIGkgPSBzdHJpbmdzLmluZGV4T2Yocyk7XG5cdCAgICBpZiAoaSA+PSAwKSB7XG5cdCAgICAgICAgc2lkID0gaSArIGNmZlN0YW5kYXJkU3RyaW5ncy5sZW5ndGg7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHNpZCA9IGNmZlN0YW5kYXJkU3RyaW5ncy5sZW5ndGggKyBzdHJpbmdzLmxlbmd0aDtcblx0ICAgICAgICBzdHJpbmdzLnB1c2gocyk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzaWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlSGVhZGVyKCkge1xuXHQgICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ0hlYWRlcicsIFtcblx0ICAgICAgICB7bmFtZTogJ21ham9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDF9LFxuXHQgICAgICAgIHtuYW1lOiAnbWlub3InLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdoZHJTaXplJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDR9LFxuXHQgICAgICAgIHtuYW1lOiAnbWFqb3InLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogMX1cblx0ICAgIF0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZU5hbWVJbmRleChmb250TmFtZXMpIHtcblx0ICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnTmFtZSBJTkRFWCcsIFtcblx0ICAgICAgICB7bmFtZTogJ25hbWVzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuXHQgICAgXSk7XG5cdCAgICB0Lm5hbWVzID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbnROYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHQubmFtZXMucHVzaCh7bmFtZTogJ25hbWVfJyArIGksIHR5cGU6ICdOQU1FJywgdmFsdWU6IGZvbnROYW1lc1tpXX0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdDtcblx0fVxuXG5cdC8vIEdpdmVuIGEgZGljdGlvbmFyeSdzIG1ldGFkYXRhLCBjcmVhdGUgYSBESUNUIHN0cnVjdHVyZS5cblx0ZnVuY3Rpb24gbWFrZURpY3QobWV0YSwgYXR0cnMsIHN0cmluZ3MpIHtcblx0ICAgIHZhciBtID0ge307XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgZW50cnkgPSBtZXRhW2ldO1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzW2VudHJ5Lm5hbWVdO1xuXHQgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcXVhbHModmFsdWUsIGVudHJ5LnZhbHVlKSkge1xuXHQgICAgICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ1NJRCcpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gZW5jb2RlU3RyaW5nKHZhbHVlLCBzdHJpbmdzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG1bZW50cnkub3BdID0ge25hbWU6IGVudHJ5Lm5hbWUsIHR5cGU6IGVudHJ5LnR5cGUsIHZhbHVlOiB2YWx1ZX07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbTtcblx0fVxuXG5cdC8vIFRoZSBUb3AgRElDVCBob3VzZXMgdGhlIGdsb2JhbCBmb250IGF0dHJpYnV0ZXMuXG5cdGZ1bmN0aW9uIG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKSB7XG5cdCAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ1RvcCBESUNUJywgW1xuXHQgICAgICAgIHtuYW1lOiAnZGljdCcsIHR5cGU6ICdESUNUJywgdmFsdWU6IHt9fVxuXHQgICAgXSk7XG5cdCAgICB0LmRpY3QgPSBtYWtlRGljdChUT1BfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG5cdCAgICByZXR1cm4gdDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCkge1xuXHQgICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdUb3AgRElDVCBJTkRFWCcsIFtcblx0ICAgICAgICB7bmFtZTogJ3RvcERpY3RzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuXHQgICAgXSk7XG5cdCAgICB0LnRvcERpY3RzID0gW3tuYW1lOiAndG9wRGljdF8wJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHRvcERpY3R9XTtcblx0ICAgIHJldHVybiB0O1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZVN0cmluZ0luZGV4KHN0cmluZ3MpIHtcblx0ICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnU3RyaW5nIElOREVYJywgW1xuXHQgICAgICAgIHtuYW1lOiAnc3RyaW5ncycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cblx0ICAgIF0pO1xuXHQgICAgdC5zdHJpbmdzID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB0LnN0cmluZ3MucHVzaCh7bmFtZTogJ3N0cmluZ18nICsgaSwgdHlwZTogJ1NUUklORycsIHZhbHVlOiBzdHJpbmdzW2ldfSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0O1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZUdsb2JhbFN1YnJJbmRleCgpIHtcblx0ICAgIC8vIEN1cnJlbnRseSB3ZSBkb24ndCB1c2Ugc3Vicm91dGluZXMuXG5cdCAgICByZXR1cm4gbmV3IHRhYmxlLlJlY29yZCgnR2xvYmFsIFN1YnIgSU5ERVgnLCBbXG5cdCAgICAgICAge25hbWU6ICdzdWJycycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cblx0ICAgIF0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZUNoYXJzZXRzKGdseXBoTmFtZXMsIHN0cmluZ3MpIHtcblx0ICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnQ2hhcnNldHMnLCBbXG5cdCAgICAgICAge25hbWU6ICdmb3JtYXQnLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogMH1cblx0ICAgIF0pO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGdseXBoTmFtZSA9IGdseXBoTmFtZXNbaV07XG5cdCAgICAgICAgdmFyIGdseXBoU0lEID0gZW5jb2RlU3RyaW5nKGdseXBoTmFtZSwgc3RyaW5ncyk7XG5cdCAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnU0lEJywgdmFsdWU6IGdseXBoU0lEfSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2x5cGhUb09wcyhnbHlwaCkge1xuXHQgICAgdmFyIG9wcyA9IFtdO1xuXHQgICAgdmFyIHBhdGggPSBnbHlwaC5wYXRoO1xuXHQgICAgb3BzLnB1c2goe25hbWU6ICd3aWR0aCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZ2x5cGguYWR2YW5jZVdpZHRofSk7XG5cdCAgICB2YXIgeCA9IDA7XG5cdCAgICB2YXIgeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGguY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgZHggPSAodm9pZCAwKTtcblx0ICAgICAgICB2YXIgZHkgPSAodm9pZCAwKTtcblx0ICAgICAgICB2YXIgY21kID0gcGF0aC5jb21tYW5kc1tpXTtcblx0ICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuXHQgICAgICAgICAgICAvLyBDRkYgb25seSBzdXBwb3J0cyBiw6l6aWVyIGN1cnZlcywgc28gY29udmVydCB0aGUgcXVhZCB0byBhIGLDqXppZXIuXG5cdCAgICAgICAgICAgIHZhciBfMTMgPSAxIC8gMztcblx0ICAgICAgICAgICAgdmFyIF8yMyA9IDIgLyAzO1xuXG5cdCAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGNyZWF0ZSBhIG5ldyBjb21tYW5kIHNvIHdlIGRvbid0IGNoYW5nZSB0aGUgb3JpZ2luYWwgcGF0aC5cblx0ICAgICAgICAgICAgLy8gU2luY2UgYWxsIGNvb3JkaW5hdGVzIGFyZSByZWxhdGl2ZSwgd2Ugcm91bmQoKSB0aGVtIEFTQVAgdG8gYXZvaWQgcHJvcGFnYXRpbmcgZXJyb3JzLlxuXHQgICAgICAgICAgICBjbWQgPSB7XG5cdCAgICAgICAgICAgICAgICB0eXBlOiAnQycsXG5cdCAgICAgICAgICAgICAgICB4OiBjbWQueCxcblx0ICAgICAgICAgICAgICAgIHk6IGNtZC55LFxuXHQgICAgICAgICAgICAgICAgeDE6IE1hdGgucm91bmQoXzEzICogeCArIF8yMyAqIGNtZC54MSksXG5cdCAgICAgICAgICAgICAgICB5MTogTWF0aC5yb3VuZChfMTMgKiB5ICsgXzIzICogY21kLnkxKSxcblx0ICAgICAgICAgICAgICAgIHgyOiBNYXRoLnJvdW5kKF8xMyAqIGNtZC54ICsgXzIzICogY21kLngxKSxcblx0ICAgICAgICAgICAgICAgIHkyOiBNYXRoLnJvdW5kKF8xMyAqIGNtZC55ICsgXzIzICogY21kLnkxKVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG5cdCAgICAgICAgICAgIGR4ID0gTWF0aC5yb3VuZChjbWQueCAtIHgpO1xuXHQgICAgICAgICAgICBkeSA9IE1hdGgucm91bmQoY21kLnkgLSB5KTtcblx0ICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHh9KTtcblx0ICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHl9KTtcblx0ICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdybW92ZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDIxfSk7XG5cdCAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKGNtZC54KTtcblx0ICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoY21kLnkpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuXHQgICAgICAgICAgICBkeCA9IE1hdGgucm91bmQoY21kLnggLSB4KTtcblx0ICAgICAgICAgICAgZHkgPSBNYXRoLnJvdW5kKGNtZC55IC0geSk7XG5cdCAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG5cdCAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHknLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5fSk7XG5cdCAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAncmxpbmV0bycsIHR5cGU6ICdPUCcsIHZhbHVlOiA1fSk7XG5cdCAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKGNtZC54KTtcblx0ICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoY21kLnkpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuXHQgICAgICAgICAgICB2YXIgZHgxID0gTWF0aC5yb3VuZChjbWQueDEgLSB4KTtcblx0ICAgICAgICAgICAgdmFyIGR5MSA9IE1hdGgucm91bmQoY21kLnkxIC0geSk7XG5cdCAgICAgICAgICAgIHZhciBkeDIgPSBNYXRoLnJvdW5kKGNtZC54MiAtIGNtZC54MSk7XG5cdCAgICAgICAgICAgIHZhciBkeTIgPSBNYXRoLnJvdW5kKGNtZC55MiAtIGNtZC55MSk7XG5cdCAgICAgICAgICAgIGR4ID0gTWF0aC5yb3VuZChjbWQueCAtIGNtZC54Mik7XG5cdCAgICAgICAgICAgIGR5ID0gTWF0aC5yb3VuZChjbWQueSAtIGNtZC55Mik7XG5cdCAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgxJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeDF9KTtcblx0ICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeTEnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5MX0pO1xuXHQgICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4MicsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHgyfSk7XG5cdCAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHkyJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeTJ9KTtcblx0ICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHh9KTtcblx0ICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHl9KTtcblx0ICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdycmN1cnZldG8nLCB0eXBlOiAnT1AnLCB2YWx1ZTogOH0pO1xuXHQgICAgICAgICAgICB4ID0gTWF0aC5yb3VuZChjbWQueCk7XG5cdCAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKGNtZC55KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDb250b3VycyBhcmUgY2xvc2VkIGF1dG9tYXRpY2FsbHkuXG5cdCAgICB9XG5cblx0ICAgIG9wcy5wdXNoKHtuYW1lOiAnZW5kY2hhcicsIHR5cGU6ICdPUCcsIHZhbHVlOiAxNH0pO1xuXHQgICAgcmV0dXJuIG9wcztcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VDaGFyU3RyaW5nc0luZGV4KGdseXBocykge1xuXHQgICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdDaGFyU3RyaW5ncyBJTkRFWCcsIFtcblx0ICAgICAgICB7bmFtZTogJ2NoYXJTdHJpbmdzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuXHQgICAgXSk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzLmdldChpKTtcblx0ICAgICAgICB2YXIgb3BzID0gZ2x5cGhUb09wcyhnbHlwaCk7XG5cdCAgICAgICAgdC5jaGFyU3RyaW5ncy5wdXNoKHtuYW1lOiBnbHlwaC5uYW1lLCB0eXBlOiAnQ0hBUlNUUklORycsIHZhbHVlOiBvcHN9KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlUHJpdmF0ZURpY3QoYXR0cnMsIHN0cmluZ3MpIHtcblx0ICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnUHJpdmF0ZSBESUNUJywgW1xuXHQgICAgICAgIHtuYW1lOiAnZGljdCcsIHR5cGU6ICdESUNUJywgdmFsdWU6IHt9fVxuXHQgICAgXSk7XG5cdCAgICB0LmRpY3QgPSBtYWtlRGljdChQUklWQVRFX0RJQ1RfTUVUQSwgYXR0cnMsIHN0cmluZ3MpO1xuXHQgICAgcmV0dXJuIHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlQ0ZGVGFibGUoZ2x5cGhzLCBvcHRpb25zKSB7XG5cdCAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnQ0ZGICcsIFtcblx0ICAgICAgICB7bmFtZTogJ2hlYWRlcicsIHR5cGU6ICdSRUNPUkQnfSxcblx0ICAgICAgICB7bmFtZTogJ25hbWVJbmRleCcsIHR5cGU6ICdSRUNPUkQnfSxcblx0ICAgICAgICB7bmFtZTogJ3RvcERpY3RJbmRleCcsIHR5cGU6ICdSRUNPUkQnfSxcblx0ICAgICAgICB7bmFtZTogJ3N0cmluZ0luZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuXHQgICAgICAgIHtuYW1lOiAnZ2xvYmFsU3VickluZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuXHQgICAgICAgIHtuYW1lOiAnY2hhcnNldHMnLCB0eXBlOiAnUkVDT1JEJ30sXG5cdCAgICAgICAge25hbWU6ICdjaGFyU3RyaW5nc0luZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuXHQgICAgICAgIHtuYW1lOiAncHJpdmF0ZURpY3QnLCB0eXBlOiAnUkVDT1JEJ31cblx0ICAgIF0pO1xuXG5cdCAgICB2YXIgZm9udFNjYWxlID0gMSAvIG9wdGlvbnMudW5pdHNQZXJFbTtcblx0ICAgIC8vIFdlIHVzZSBub24temVybyB2YWx1ZXMgZm9yIHRoZSBvZmZzZXRzIHNvIHRoYXQgdGhlIERJQ1QgZW5jb2RlcyB0aGVtLlxuXHQgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgc2l6ZSBvZiB0aGUgVG9wIERJQ1QgcGxheXMgYSByb2xlIGluIG9mZnNldCBjYWxjdWxhdGlvbixcblx0ICAgIC8vIGFuZCB0aGUgc2l6ZSBzaG91bGRuJ3QgY2hhbmdlIGFmdGVyIHdlJ3ZlIHdyaXR0ZW4gY29ycmVjdCBvZmZzZXRzLlxuXHQgICAgdmFyIGF0dHJzID0ge1xuXHQgICAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbixcblx0ICAgICAgICBmdWxsTmFtZTogb3B0aW9ucy5mdWxsTmFtZSxcblx0ICAgICAgICBmYW1pbHlOYW1lOiBvcHRpb25zLmZhbWlseU5hbWUsXG5cdCAgICAgICAgd2VpZ2h0OiBvcHRpb25zLndlaWdodE5hbWUsXG5cdCAgICAgICAgZm9udEJCb3g6IG9wdGlvbnMuZm9udEJCb3ggfHwgWzAsIDAsIDAsIDBdLFxuXHQgICAgICAgIGZvbnRNYXRyaXg6IFtmb250U2NhbGUsIDAsIDAsIGZvbnRTY2FsZSwgMCwgMF0sXG5cdCAgICAgICAgY2hhcnNldDogOTk5LFxuXHQgICAgICAgIGVuY29kaW5nOiAwLFxuXHQgICAgICAgIGNoYXJTdHJpbmdzOiA5OTksXG5cdCAgICAgICAgcHJpdmF0ZTogWzAsIDk5OV1cblx0ICAgIH07XG5cblx0ICAgIHZhciBwcml2YXRlQXR0cnMgPSB7fTtcblxuXHQgICAgdmFyIGdseXBoTmFtZXMgPSBbXTtcblx0ICAgIHZhciBnbHlwaDtcblxuXHQgICAgLy8gU2tpcCBmaXJzdCBnbHlwaCAoLm5vdGRlZilcblx0ICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuXHQgICAgICAgIGdseXBoTmFtZXMucHVzaChnbHlwaC5uYW1lKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHN0cmluZ3MgPSBbXTtcblxuXHQgICAgdC5oZWFkZXIgPSBtYWtlSGVhZGVyKCk7XG5cdCAgICB0Lm5hbWVJbmRleCA9IG1ha2VOYW1lSW5kZXgoW29wdGlvbnMucG9zdFNjcmlwdE5hbWVdKTtcblx0ICAgIHZhciB0b3BEaWN0ID0gbWFrZVRvcERpY3QoYXR0cnMsIHN0cmluZ3MpO1xuXHQgICAgdC50b3BEaWN0SW5kZXggPSBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpO1xuXHQgICAgdC5nbG9iYWxTdWJySW5kZXggPSBtYWtlR2xvYmFsU3VickluZGV4KCk7XG5cdCAgICB0LmNoYXJzZXRzID0gbWFrZUNoYXJzZXRzKGdseXBoTmFtZXMsIHN0cmluZ3MpO1xuXHQgICAgdC5jaGFyU3RyaW5nc0luZGV4ID0gbWFrZUNoYXJTdHJpbmdzSW5kZXgoZ2x5cGhzKTtcblx0ICAgIHQucHJpdmF0ZURpY3QgPSBtYWtlUHJpdmF0ZURpY3QocHJpdmF0ZUF0dHJzLCBzdHJpbmdzKTtcblxuXHQgICAgLy8gTmVlZHMgdG8gY29tZSBhdCB0aGUgZW5kLCB0byBlbmNvZGUgYWxsIGN1c3RvbSBzdHJpbmdzIHVzZWQgaW4gdGhlIGZvbnQuXG5cdCAgICB0LnN0cmluZ0luZGV4ID0gbWFrZVN0cmluZ0luZGV4KHN0cmluZ3MpO1xuXG5cdCAgICB2YXIgc3RhcnRPZmZzZXQgPSB0LmhlYWRlci5zaXplT2YoKSArXG5cdCAgICAgICAgdC5uYW1lSW5kZXguc2l6ZU9mKCkgK1xuXHQgICAgICAgIHQudG9wRGljdEluZGV4LnNpemVPZigpICtcblx0ICAgICAgICB0LnN0cmluZ0luZGV4LnNpemVPZigpICtcblx0ICAgICAgICB0Lmdsb2JhbFN1YnJJbmRleC5zaXplT2YoKTtcblx0ICAgIGF0dHJzLmNoYXJzZXQgPSBzdGFydE9mZnNldDtcblxuXHQgICAgLy8gV2UgdXNlIHRoZSBDRkYgc3RhbmRhcmQgZW5jb2Rpbmc7IHByb3BlciBlbmNvZGluZyB3aWxsIGJlIGhhbmRsZWQgaW4gY21hcC5cblx0ICAgIGF0dHJzLmVuY29kaW5nID0gMDtcblx0ICAgIGF0dHJzLmNoYXJTdHJpbmdzID0gYXR0cnMuY2hhcnNldCArIHQuY2hhcnNldHMuc2l6ZU9mKCk7XG5cdCAgICBhdHRycy5wcml2YXRlWzFdID0gYXR0cnMuY2hhclN0cmluZ3MgKyB0LmNoYXJTdHJpbmdzSW5kZXguc2l6ZU9mKCk7XG5cblx0ICAgIC8vIFJlY3JlYXRlIHRoZSBUb3AgRElDVCBJTkRFWCB3aXRoIHRoZSBjb3JyZWN0IG9mZnNldHMuXG5cdCAgICB0b3BEaWN0ID0gbWFrZVRvcERpY3QoYXR0cnMsIHN0cmluZ3MpO1xuXHQgICAgdC50b3BEaWN0SW5kZXggPSBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpO1xuXG5cdCAgICByZXR1cm4gdDtcblx0fVxuXG5cdHZhciBjZmYgPSB7IHBhcnNlOiBwYXJzZUNGRlRhYmxlLCBtYWtlOiBtYWtlQ0ZGVGFibGUgfTtcblxuXHQvLyBUaGUgYGhlYWRgIHRhYmxlIGNvbnRhaW5zIGdsb2JhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZm9udC5cblxuXHQvLyBQYXJzZSB0aGUgaGVhZGVyIGBoZWFkYCB0YWJsZVxuXHRmdW5jdGlvbiBwYXJzZUhlYWRUYWJsZShkYXRhLCBzdGFydCkge1xuXHQgICAgdmFyIGhlYWQgPSB7fTtcblx0ICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cdCAgICBoZWFkLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuXHQgICAgaGVhZC5mb250UmV2aXNpb24gPSBNYXRoLnJvdW5kKHAucGFyc2VGaXhlZCgpICogMTAwMCkgLyAxMDAwO1xuXHQgICAgaGVhZC5jaGVja1N1bUFkanVzdG1lbnQgPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgIGhlYWQubWFnaWNOdW1iZXIgPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgIGNoZWNrLmFyZ3VtZW50KGhlYWQubWFnaWNOdW1iZXIgPT09IDB4NUYwRjNDRjUsICdGb250IGhlYWRlciBoYXMgd3JvbmcgbWFnaWMgbnVtYmVyLicpO1xuXHQgICAgaGVhZC5mbGFncyA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIGhlYWQudW5pdHNQZXJFbSA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIGhlYWQuY3JlYXRlZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcblx0ICAgIGhlYWQubW9kaWZpZWQgPSBwLnBhcnNlTG9uZ0RhdGVUaW1lKCk7XG5cdCAgICBoZWFkLnhNaW4gPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGhlYWQueU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgaGVhZC54TWF4ID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBoZWFkLnlNYXggPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGhlYWQubWFjU3R5bGUgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICBoZWFkLmxvd2VzdFJlY1BQRU0gPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICBoZWFkLmZvbnREaXJlY3Rpb25IaW50ID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBoZWFkLmluZGV4VG9Mb2NGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGhlYWQuZ2x5cGhEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICByZXR1cm4gaGVhZDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VIZWFkVGFibGUob3B0aW9ucykge1xuXHQgICAgLy8gQXBwbGUgTWFjIHRpbWVzdGFtcCBlcG9jaCBpcyAwMS8wMS8xOTA0IG5vdCAwMS8wMS8xOTcwXG5cdCAgICB2YXIgdGltZXN0YW1wID0gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsgMjA4Mjg0NDgwMDtcblx0ICAgIHZhciBjcmVhdGVkVGltZXN0YW1wID0gdGltZXN0YW1wO1xuXG5cdCAgICBpZiAob3B0aW9ucy5jcmVhdGVkVGltZXN0YW1wKSB7XG5cdCAgICAgICAgY3JlYXRlZFRpbWVzdGFtcCA9IG9wdGlvbnMuY3JlYXRlZFRpbWVzdGFtcCArIDIwODI4NDQ4MDA7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2hlYWQnLCBbXG5cdCAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMTAwMDB9LFxuXHQgICAgICAgIHtuYW1lOiAnZm9udFJldmlzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMTAwMDB9LFxuXHQgICAgICAgIHtuYW1lOiAnY2hlY2tTdW1BZGp1c3RtZW50JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbWFnaWNOdW1iZXInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMHg1RjBGM0NGNX0sXG5cdCAgICAgICAge25hbWU6ICdmbGFncycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICd1bml0c1BlckVtJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxMDAwfSxcblx0ICAgICAgICB7bmFtZTogJ2NyZWF0ZWQnLCB0eXBlOiAnTE9OR0RBVEVUSU1FJywgdmFsdWU6IGNyZWF0ZWRUaW1lc3RhbXB9LFxuXHQgICAgICAgIHtuYW1lOiAnbW9kaWZpZWQnLCB0eXBlOiAnTE9OR0RBVEVUSU1FJywgdmFsdWU6IHRpbWVzdGFtcH0sXG5cdCAgICAgICAge25hbWU6ICd4TWluJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAneU1pbicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3hNYXgnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICd5TWF4JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbWFjU3R5bGUnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbG93ZXN0UmVjUFBFTScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdmb250RGlyZWN0aW9uSGludCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAyfSxcblx0ICAgICAgICB7bmFtZTogJ2luZGV4VG9Mb2NGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdnbHlwaERhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH1cblx0ICAgIF0sIG9wdGlvbnMpO1xuXHR9XG5cblx0dmFyIGhlYWQgPSB7IHBhcnNlOiBwYXJzZUhlYWRUYWJsZSwgbWFrZTogbWFrZUhlYWRUYWJsZSB9O1xuXG5cdC8vIFRoZSBgaGhlYWAgdGFibGUgY29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGhvcml6b250YWwgbGF5b3V0LlxuXG5cdC8vIFBhcnNlIHRoZSBob3Jpem9udGFsIGhlYWRlciBgaGhlYWAgdGFibGVcblx0ZnVuY3Rpb24gcGFyc2VIaGVhVGFibGUoZGF0YSwgc3RhcnQpIHtcblx0ICAgIHZhciBoaGVhID0ge307XG5cdCAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgaGhlYS52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcblx0ICAgIGhoZWEuYXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGhoZWEuZGVzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBoaGVhLmxpbmVHYXAgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGhoZWEuYWR2YW5jZVdpZHRoTWF4ID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgaGhlYS5taW5MZWZ0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGhoZWEubWluUmlnaHRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgaGhlYS54TWF4RXh0ZW50ID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBoaGVhLmNhcmV0U2xvcGVSaXNlID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBoaGVhLmNhcmV0U2xvcGVSdW4gPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGhoZWEuY2FyZXRPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIHAucmVsYXRpdmVPZmZzZXQgKz0gODtcblx0ICAgIGhoZWEubWV0cmljRGF0YUZvcm1hdCA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgaGhlYS5udW1iZXJPZkhNZXRyaWNzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgcmV0dXJuIGhoZWE7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlSGhlYVRhYmxlKG9wdGlvbnMpIHtcblx0ICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2hoZWEnLCBbXG5cdCAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMTAwMDB9LFxuXHQgICAgICAgIHtuYW1lOiAnYXNjZW5kZXInLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdkZXNjZW5kZXInLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdsaW5lR2FwJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnYWR2YW5jZVdpZHRoTWF4JywgdHlwZTogJ1VGV09SRCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ21pbkxlZnRTaWRlQmVhcmluZycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ21pblJpZ2h0U2lkZUJlYXJpbmcnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICd4TWF4RXh0ZW50JywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnY2FyZXRTbG9wZVJpc2UnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMX0sXG5cdCAgICAgICAge25hbWU6ICdjYXJldFNsb3BlUnVuJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnY2FyZXRPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdyZXNlcnZlZDEnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdyZXNlcnZlZDInLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdyZXNlcnZlZDMnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdyZXNlcnZlZDQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdtZXRyaWNEYXRhRm9ybWF0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbnVtYmVyT2ZITWV0cmljcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cblx0ICAgIF0sIG9wdGlvbnMpO1xuXHR9XG5cblx0dmFyIGhoZWEgPSB7IHBhcnNlOiBwYXJzZUhoZWFUYWJsZSwgbWFrZTogbWFrZUhoZWFUYWJsZSB9O1xuXG5cdC8vIFRoZSBgaG10eGAgdGFibGUgY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cblxuXHRmdW5jdGlvbiBwYXJzZUhtdHhUYWJsZUFsbChkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMpIHtcblx0ICAgIHZhciBhZHZhbmNlV2lkdGg7XG5cdCAgICB2YXIgbGVmdFNpZGVCZWFyaW5nO1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtR2x5cGhzOyBpICs9IDEpIHtcblx0ICAgICAgICAvLyBJZiB0aGUgZm9udCBpcyBtb25vc3BhY2VkLCBvbmx5IG9uZSBlbnRyeSBpcyBuZWVkZWQuIFRoaXMgbGFzdCBlbnRyeSBhcHBsaWVzIHRvIGFsbCBzdWJzZXF1ZW50IGdseXBocy5cblx0ICAgICAgICBpZiAoaSA8IG51bU1ldHJpY3MpIHtcblx0ICAgICAgICAgICAgYWR2YW5jZVdpZHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgICAgICBsZWZ0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuXHQgICAgICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IGFkdmFuY2VXaWR0aDtcblx0ICAgICAgICBnbHlwaC5sZWZ0U2lkZUJlYXJpbmcgPSBsZWZ0U2lkZUJlYXJpbmc7XG5cdCAgICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZUhtdHhUYWJsZU9uTG93TWVtb3J5KGZvbnQsIGRhdGEsIHN0YXJ0LCBudW1NZXRyaWNzLCBudW1HbHlwaHMpIHtcblx0ICAgIGZvbnQuX2htdHhUYWJsZURhdGEgPSB7fTtcblxuXHQgICAgdmFyIGFkdmFuY2VXaWR0aDtcblx0ICAgIHZhciBsZWZ0U2lkZUJlYXJpbmc7XG5cdCAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1HbHlwaHM7IGkgKz0gMSkge1xuXHQgICAgICAgIC8vIElmIHRoZSBmb250IGlzIG1vbm9zcGFjZWQsIG9ubHkgb25lIGVudHJ5IGlzIG5lZWRlZC4gVGhpcyBsYXN0IGVudHJ5IGFwcGxpZXMgdG8gYWxsIHN1YnNlcXVlbnQgZ2x5cGhzLlxuXHQgICAgICAgIGlmIChpIDwgbnVtTWV0cmljcykge1xuXHQgICAgICAgICAgICBhZHZhbmNlV2lkdGggPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgICAgIGxlZnRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZvbnQuX2htdHhUYWJsZURhdGFbaV0gPSB7XG5cdCAgICAgICAgICAgIGFkdmFuY2VXaWR0aDogYWR2YW5jZVdpZHRoLFxuXHQgICAgICAgICAgICBsZWZ0U2lkZUJlYXJpbmc6IGxlZnRTaWRlQmVhcmluZ1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdH1cblxuXHQvLyBQYXJzZSB0aGUgYGhtdHhgIHRhYmxlLCB3aGljaCBjb250YWlucyB0aGUgaG9yaXpvbnRhbCBtZXRyaWNzIGZvciBhbGwgZ2x5cGhzLlxuXHQvLyBUaGlzIGZ1bmN0aW9uIGF1Z21lbnRzIHRoZSBnbHlwaCBhcnJheSwgYWRkaW5nIHRoZSBhZHZhbmNlV2lkdGggYW5kIGxlZnRTaWRlQmVhcmluZyB0byBlYWNoIGdseXBoLlxuXHRmdW5jdGlvbiBwYXJzZUhtdHhUYWJsZShmb250LCBkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMsIG9wdCkge1xuXHQgICAgaWYgKG9wdC5sb3dNZW1vcnkpXG5cdCAgICAgICAgeyBwYXJzZUhtdHhUYWJsZU9uTG93TWVtb3J5KGZvbnQsIGRhdGEsIHN0YXJ0LCBudW1NZXRyaWNzLCBudW1HbHlwaHMpOyB9XG5cdCAgICBlbHNlXG5cdCAgICAgICAgeyBwYXJzZUhtdHhUYWJsZUFsbChkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMpOyB9XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlSG10eFRhYmxlKGdseXBocykge1xuXHQgICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ2htdHgnLCBbXSk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG5cdCAgICAgICAgdmFyIGFkdmFuY2VXaWR0aCA9IGdseXBoLmFkdmFuY2VXaWR0aCB8fCAwO1xuXHQgICAgICAgIHZhciBsZWZ0U2lkZUJlYXJpbmcgPSBnbHlwaC5sZWZ0U2lkZUJlYXJpbmcgfHwgMDtcblx0ICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnYWR2YW5jZVdpZHRoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGFkdmFuY2VXaWR0aH0pO1xuXHQgICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdsZWZ0U2lkZUJlYXJpbmdfJyArIGksIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiBsZWZ0U2lkZUJlYXJpbmd9KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHQ7XG5cdH1cblxuXHR2YXIgaG10eCA9IHsgcGFyc2U6IHBhcnNlSG10eFRhYmxlLCBtYWtlOiBtYWtlSG10eFRhYmxlIH07XG5cblx0Ly8gVGhlIGBsdGFnYCB0YWJsZSBzdG9yZXMgSUVURiBCQ1AtNDcgbGFuZ3VhZ2UgdGFncy4gSXQgYWxsb3dzIHN1cHBvcnRpbmdcblxuXHRmdW5jdGlvbiBtYWtlTHRhZ1RhYmxlKHRhZ3MpIHtcblx0ICAgIHZhciByZXN1bHQgPSBuZXcgdGFibGUuVGFibGUoJ2x0YWcnLCBbXG5cdCAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDF9LFxuXHQgICAgICAgIHtuYW1lOiAnZmxhZ3MnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdudW1UYWdzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IHRhZ3MubGVuZ3RofVxuXHQgICAgXSk7XG5cblx0ICAgIHZhciBzdHJpbmdQb29sID0gJyc7XG5cdCAgICB2YXIgc3RyaW5nUG9vbE9mZnNldCA9IDEyICsgdGFncy5sZW5ndGggKiA0O1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgdmFyIHBvcyA9IHN0cmluZ1Bvb2wuaW5kZXhPZih0YWdzW2ldKTtcblx0ICAgICAgICBpZiAocG9zIDwgMCkge1xuXHQgICAgICAgICAgICBwb3MgPSBzdHJpbmdQb29sLmxlbmd0aDtcblx0ICAgICAgICAgICAgc3RyaW5nUG9vbCArPSB0YWdzW2ldO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ29mZnNldCAnICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzdHJpbmdQb29sT2Zmc2V0ICsgcG9zfSk7XG5cdCAgICAgICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAnbGVuZ3RoICcgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHRhZ3NbaV0ubGVuZ3RofSk7XG5cdCAgICB9XG5cblx0ICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ3N0cmluZ1Bvb2wnLCB0eXBlOiAnQ0hBUkFSUkFZJywgdmFsdWU6IHN0cmluZ1Bvb2x9KTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZUx0YWdUYWJsZShkYXRhLCBzdGFydCkge1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMSwgJ1Vuc3VwcG9ydGVkIGx0YWcgdGFibGUgdmVyc2lvbi4nKTtcblx0ICAgIC8vIFRoZSAnbHRhZycgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCBkZWZpbmUgYW55IGZsYWdzOyBza2lwIHRoZSBmaWVsZC5cblx0ICAgIHAuc2tpcCgndUxvbmcnLCAxKTtcblx0ICAgIHZhciBudW1UYWdzID0gcC5wYXJzZVVMb25nKCk7XG5cblx0ICAgIHZhciB0YWdzID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhZ3M7IGkrKykge1xuXHQgICAgICAgIHZhciB0YWcgPSAnJztcblx0ICAgICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQgKyBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgdmFyIGxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICBmb3IgKHZhciBqID0gb2Zmc2V0OyBqIDwgb2Zmc2V0ICsgbGVuZ3RoOyArK2opIHtcblx0ICAgICAgICAgICAgdGFnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YS5nZXRJbnQ4KGopKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0YWdzLnB1c2godGFnKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRhZ3M7XG5cdH1cblxuXHR2YXIgbHRhZyA9IHsgbWFrZTogbWFrZUx0YWdUYWJsZSwgcGFyc2U6IHBhcnNlTHRhZ1RhYmxlIH07XG5cblx0Ly8gVGhlIGBtYXhwYCB0YWJsZSBlc3RhYmxpc2hlcyB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBmb3IgdGhlIGZvbnQuXG5cblx0Ly8gUGFyc2UgdGhlIG1heGltdW0gcHJvZmlsZSBgbWF4cGAgdGFibGUuXG5cdGZ1bmN0aW9uIHBhcnNlTWF4cFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG5cdCAgICB2YXIgbWF4cCA9IHt9O1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIG1heHAudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG5cdCAgICBtYXhwLm51bUdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIGlmIChtYXhwLnZlcnNpb24gPT09IDEuMCkge1xuXHQgICAgICAgIG1heHAubWF4UG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIG1heHAubWF4Q29udG91cnMgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgbWF4cC5tYXhDb21wb3NpdGVQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgbWF4cC5tYXhDb21wb3NpdGVDb250b3VycyA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICBtYXhwLm1heFpvbmVzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIG1heHAubWF4VHdpbGlnaHRQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgbWF4cC5tYXhTdG9yYWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIG1heHAubWF4RnVuY3Rpb25EZWZzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIG1heHAubWF4SW5zdHJ1Y3Rpb25EZWZzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIG1heHAubWF4U3RhY2tFbGVtZW50cyA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICBtYXhwLm1heFNpemVPZkluc3RydWN0aW9ucyA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICBtYXhwLm1heENvbXBvbmVudEVsZW1lbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIG1heHAubWF4Q29tcG9uZW50RGVwdGggPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBtYXhwO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZU1heHBUYWJsZShudW1HbHlwaHMpIHtcblx0ICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ21heHAnLCBbXG5cdCAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMDUwMDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbnVtR2x5cGhzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBudW1HbHlwaHN9XG5cdCAgICBdKTtcblx0fVxuXG5cdHZhciBtYXhwID0geyBwYXJzZTogcGFyc2VNYXhwVGFibGUsIG1ha2U6IG1ha2VNYXhwVGFibGUgfTtcblxuXHQvLyBUaGUgYG5hbWVgIG5hbWluZyB0YWJsZS5cblxuXHQvLyBOYW1lSURzIGZvciB0aGUgbmFtZSB0YWJsZS5cblx0dmFyIG5hbWVUYWJsZU5hbWVzID0gW1xuXHQgICAgJ2NvcHlyaWdodCcsICAgICAgICAgICAgICAvLyAwXG5cdCAgICAnZm9udEZhbWlseScsICAgICAgICAgICAgIC8vIDFcblx0ICAgICdmb250U3ViZmFtaWx5JywgICAgICAgICAgLy8gMlxuXHQgICAgJ3VuaXF1ZUlEJywgICAgICAgICAgICAgICAvLyAzXG5cdCAgICAnZnVsbE5hbWUnLCAgICAgICAgICAgICAgIC8vIDRcblx0ICAgICd2ZXJzaW9uJywgICAgICAgICAgICAgICAgLy8gNVxuXHQgICAgJ3Bvc3RTY3JpcHROYW1lJywgICAgICAgICAvLyA2XG5cdCAgICAndHJhZGVtYXJrJywgICAgICAgICAgICAgIC8vIDdcblx0ICAgICdtYW51ZmFjdHVyZXInLCAgICAgICAgICAgLy8gOFxuXHQgICAgJ2Rlc2lnbmVyJywgICAgICAgICAgICAgICAvLyA5XG5cdCAgICAnZGVzY3JpcHRpb24nLCAgICAgICAgICAgIC8vIDEwXG5cdCAgICAnbWFudWZhY3R1cmVyVVJMJywgICAgICAgIC8vIDExXG5cdCAgICAnZGVzaWduZXJVUkwnLCAgICAgICAgICAgIC8vIDEyXG5cdCAgICAnbGljZW5zZScsICAgICAgICAgICAgICAgIC8vIDEzXG5cdCAgICAnbGljZW5zZVVSTCcsICAgICAgICAgICAgIC8vIDE0XG5cdCAgICAncmVzZXJ2ZWQnLCAgICAgICAgICAgICAgIC8vIDE1XG5cdCAgICAncHJlZmVycmVkRmFtaWx5JywgICAgICAgIC8vIDE2XG5cdCAgICAncHJlZmVycmVkU3ViZmFtaWx5JywgICAgIC8vIDE3XG5cdCAgICAnY29tcGF0aWJsZUZ1bGxOYW1lJywgICAgIC8vIDE4XG5cdCAgICAnc2FtcGxlVGV4dCcsICAgICAgICAgICAgIC8vIDE5XG5cdCAgICAncG9zdFNjcmlwdEZpbmRGb250TmFtZScsIC8vIDIwXG5cdCAgICAnd3dzRmFtaWx5JywgICAgICAgICAgICAgIC8vIDIxXG5cdCAgICAnd3dzU3ViZmFtaWx5JyAgICAgICAgICAgIC8vIDIyXG5cdF07XG5cblx0dmFyIG1hY0xhbmd1YWdlcyA9IHtcblx0ICAgIDA6ICdlbicsXG5cdCAgICAxOiAnZnInLFxuXHQgICAgMjogJ2RlJyxcblx0ICAgIDM6ICdpdCcsXG5cdCAgICA0OiAnbmwnLFxuXHQgICAgNTogJ3N2Jyxcblx0ICAgIDY6ICdlcycsXG5cdCAgICA3OiAnZGEnLFxuXHQgICAgODogJ3B0Jyxcblx0ICAgIDk6ICdubycsXG5cdCAgICAxMDogJ2hlJyxcblx0ICAgIDExOiAnamEnLFxuXHQgICAgMTI6ICdhcicsXG5cdCAgICAxMzogJ2ZpJyxcblx0ICAgIDE0OiAnZWwnLFxuXHQgICAgMTU6ICdpcycsXG5cdCAgICAxNjogJ210Jyxcblx0ICAgIDE3OiAndHInLFxuXHQgICAgMTg6ICdocicsXG5cdCAgICAxOTogJ3poLUhhbnQnLFxuXHQgICAgMjA6ICd1cicsXG5cdCAgICAyMTogJ2hpJyxcblx0ICAgIDIyOiAndGgnLFxuXHQgICAgMjM6ICdrbycsXG5cdCAgICAyNDogJ2x0Jyxcblx0ICAgIDI1OiAncGwnLFxuXHQgICAgMjY6ICdodScsXG5cdCAgICAyNzogJ2VzJyxcblx0ICAgIDI4OiAnbHYnLFxuXHQgICAgMjk6ICdzZScsXG5cdCAgICAzMDogJ2ZvJyxcblx0ICAgIDMxOiAnZmEnLFxuXHQgICAgMzI6ICdydScsXG5cdCAgICAzMzogJ3poJyxcblx0ICAgIDM0OiAnbmwtQkUnLFxuXHQgICAgMzU6ICdnYScsXG5cdCAgICAzNjogJ3NxJyxcblx0ICAgIDM3OiAncm8nLFxuXHQgICAgMzg6ICdjeicsXG5cdCAgICAzOTogJ3NrJyxcblx0ICAgIDQwOiAnc2knLFxuXHQgICAgNDE6ICd5aScsXG5cdCAgICA0MjogJ3NyJyxcblx0ICAgIDQzOiAnbWsnLFxuXHQgICAgNDQ6ICdiZycsXG5cdCAgICA0NTogJ3VrJyxcblx0ICAgIDQ2OiAnYmUnLFxuXHQgICAgNDc6ICd1eicsXG5cdCAgICA0ODogJ2trJyxcblx0ICAgIDQ5OiAnYXotQ3lybCcsXG5cdCAgICA1MDogJ2F6LUFyYWInLFxuXHQgICAgNTE6ICdoeScsXG5cdCAgICA1MjogJ2thJyxcblx0ICAgIDUzOiAnbW8nLFxuXHQgICAgNTQ6ICdreScsXG5cdCAgICA1NTogJ3RnJyxcblx0ICAgIDU2OiAndGsnLFxuXHQgICAgNTc6ICdtbi1DTicsXG5cdCAgICA1ODogJ21uJyxcblx0ICAgIDU5OiAncHMnLFxuXHQgICAgNjA6ICdrcycsXG5cdCAgICA2MTogJ2t1Jyxcblx0ICAgIDYyOiAnc2QnLFxuXHQgICAgNjM6ICdibycsXG5cdCAgICA2NDogJ25lJyxcblx0ICAgIDY1OiAnc2EnLFxuXHQgICAgNjY6ICdtcicsXG5cdCAgICA2NzogJ2JuJyxcblx0ICAgIDY4OiAnYXMnLFxuXHQgICAgNjk6ICdndScsXG5cdCAgICA3MDogJ3BhJyxcblx0ICAgIDcxOiAnb3InLFxuXHQgICAgNzI6ICdtbCcsXG5cdCAgICA3MzogJ2tuJyxcblx0ICAgIDc0OiAndGEnLFxuXHQgICAgNzU6ICd0ZScsXG5cdCAgICA3NjogJ3NpJyxcblx0ICAgIDc3OiAnbXknLFxuXHQgICAgNzg6ICdrbScsXG5cdCAgICA3OTogJ2xvJyxcblx0ICAgIDgwOiAndmknLFxuXHQgICAgODE6ICdpZCcsXG5cdCAgICA4MjogJ3RsJyxcblx0ICAgIDgzOiAnbXMnLFxuXHQgICAgODQ6ICdtcy1BcmFiJyxcblx0ICAgIDg1OiAnYW0nLFxuXHQgICAgODY6ICd0aScsXG5cdCAgICA4NzogJ29tJyxcblx0ICAgIDg4OiAnc28nLFxuXHQgICAgODk6ICdzdycsXG5cdCAgICA5MDogJ3J3Jyxcblx0ICAgIDkxOiAncm4nLFxuXHQgICAgOTI6ICdueScsXG5cdCAgICA5MzogJ21nJyxcblx0ICAgIDk0OiAnZW8nLFxuXHQgICAgMTI4OiAnY3knLFxuXHQgICAgMTI5OiAnZXUnLFxuXHQgICAgMTMwOiAnY2EnLFxuXHQgICAgMTMxOiAnbGEnLFxuXHQgICAgMTMyOiAncXUnLFxuXHQgICAgMTMzOiAnZ24nLFxuXHQgICAgMTM0OiAnYXknLFxuXHQgICAgMTM1OiAndHQnLFxuXHQgICAgMTM2OiAndWcnLFxuXHQgICAgMTM3OiAnZHonLFxuXHQgICAgMTM4OiAnanYnLFxuXHQgICAgMTM5OiAnc3UnLFxuXHQgICAgMTQwOiAnZ2wnLFxuXHQgICAgMTQxOiAnYWYnLFxuXHQgICAgMTQyOiAnYnInLFxuXHQgICAgMTQzOiAnaXUnLFxuXHQgICAgMTQ0OiAnZ2QnLFxuXHQgICAgMTQ1OiAnZ3YnLFxuXHQgICAgMTQ2OiAnZ2EnLFxuXHQgICAgMTQ3OiAndG8nLFxuXHQgICAgMTQ4OiAnZWwtcG9seXRvbicsXG5cdCAgICAxNDk6ICdrbCcsXG5cdCAgICAxNTA6ICdheicsXG5cdCAgICAxNTE6ICdubidcblx0fTtcblxuXHQvLyBNYWNPUyBsYW5ndWFnZSBJRCDihpIgTWFjT1Mgc2NyaXB0IElEXG5cdC8vXG5cdC8vIE5vdGUgdGhhdCB0aGUgc2NyaXB0IElEIGlzIG5vdCBzdWZmaWNpZW50IHRvIGRldGVybWluZSB3aGF0IGVuY29kaW5nXG5cdC8vIHRvIHVzZSBpbiBUcnVlVHlwZSBmaWxlcy4gRm9yIHNvbWUgbGFuZ3VhZ2VzLCBNYWNPUyB1c2VkIGEgbW9kaWZpY2F0aW9uXG5cdC8vIG9mIGEgbWFpbnN0cmVhbSBzY3JpcHQuIEZvciBleGFtcGxlLCBhbiBJY2VsYW5kaWMgbmFtZSB3b3VsZCBiZSBzdG9yZWRcblx0Ly8gd2l0aCBzbVJvbWFuIGluIHRoZSBUcnVlVHlwZSBuYW1pbmcgdGFibGUsIGJ1dCB0aGUgYWN0dWFsIGVuY29kaW5nXG5cdC8vIGlzIGEgc3BlY2lhbCBJY2VsYW5kaWMgdmVyc2lvbiBvZiB0aGUgbm9ybWFsIE1hY2ludG9zaCBSb21hbiBlbmNvZGluZy5cblx0Ly8gQXMgYW5vdGhlciBleGFtcGxlLCBJbnVrdGl0dXQgdXNlcyBhbiA4LWJpdCBlbmNvZGluZyBmb3IgQ2FuYWRpYW4gQWJvcmlnaW5hbFxuXHQvLyBTeWxsYWJsZXMgYnV0IE1hY09TIGhhZCBydW4gb3V0IG9mIGF2YWlsYWJsZSBzY3JpcHQgY29kZXMsIHNvIHRoaXMgd2FzXG5cdC8vIGRvbmUgYXMgYSAocHJldHR5IHJhZGljYWwpIFwibW9kaWZpY2F0aW9uXCIgb2YgRXRoaW9waWMuXG5cdC8vXG5cdC8vIGh0dHA6Ly91bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9BUFBMRS9SZWFkbWUudHh0XG5cdHZhciBtYWNMYW5ndWFnZVRvU2NyaXB0ID0ge1xuXHQgICAgMDogMCwgIC8vIGxhbmdFbmdsaXNoIOKGkiBzbVJvbWFuXG5cdCAgICAxOiAwLCAgLy8gbGFuZ0ZyZW5jaCDihpIgc21Sb21hblxuXHQgICAgMjogMCwgIC8vIGxhbmdHZXJtYW4g4oaSIHNtUm9tYW5cblx0ICAgIDM6IDAsICAvLyBsYW5nSXRhbGlhbiDihpIgc21Sb21hblxuXHQgICAgNDogMCwgIC8vIGxhbmdEdXRjaCDihpIgc21Sb21hblxuXHQgICAgNTogMCwgIC8vIGxhbmdTd2VkaXNoIOKGkiBzbVJvbWFuXG5cdCAgICA2OiAwLCAgLy8gbGFuZ1NwYW5pc2gg4oaSIHNtUm9tYW5cblx0ICAgIDc6IDAsICAvLyBsYW5nRGFuaXNoIOKGkiBzbVJvbWFuXG5cdCAgICA4OiAwLCAgLy8gbGFuZ1BvcnR1Z3Vlc2Ug4oaSIHNtUm9tYW5cblx0ICAgIDk6IDAsICAvLyBsYW5nTm9yd2VnaWFuIOKGkiBzbVJvbWFuXG5cdCAgICAxMDogNSwgIC8vIGxhbmdIZWJyZXcg4oaSIHNtSGVicmV3XG5cdCAgICAxMTogMSwgIC8vIGxhbmdKYXBhbmVzZSDihpIgc21KYXBhbmVzZVxuXHQgICAgMTI6IDQsICAvLyBsYW5nQXJhYmljIOKGkiBzbUFyYWJpY1xuXHQgICAgMTM6IDAsICAvLyBsYW5nRmlubmlzaCDihpIgc21Sb21hblxuXHQgICAgMTQ6IDYsICAvLyBsYW5nR3JlZWsg4oaSIHNtR3JlZWtcblx0ICAgIDE1OiAwLCAgLy8gbGFuZ0ljZWxhbmRpYyDihpIgc21Sb21hbiAobW9kaWZpZWQpXG5cdCAgICAxNjogMCwgIC8vIGxhbmdNYWx0ZXNlIOKGkiBzbVJvbWFuXG5cdCAgICAxNzogMCwgIC8vIGxhbmdUdXJraXNoIOKGkiBzbVJvbWFuIChtb2RpZmllZClcblx0ICAgIDE4OiAwLCAgLy8gbGFuZ0Nyb2F0aWFuIOKGkiBzbVJvbWFuIChtb2RpZmllZClcblx0ICAgIDE5OiAyLCAgLy8gbGFuZ1RyYWRDaGluZXNlIOKGkiBzbVRyYWRDaGluZXNlXG5cdCAgICAyMDogNCwgIC8vIGxhbmdVcmR1IOKGkiBzbUFyYWJpY1xuXHQgICAgMjE6IDksICAvLyBsYW5nSGluZGkg4oaSIHNtRGV2YW5hZ2FyaVxuXHQgICAgMjI6IDIxLCAgLy8gbGFuZ1RoYWkg4oaSIHNtVGhhaVxuXHQgICAgMjM6IDMsICAvLyBsYW5nS29yZWFuIOKGkiBzbUtvcmVhblxuXHQgICAgMjQ6IDI5LCAgLy8gbGFuZ0xpdGh1YW5pYW4g4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuXHQgICAgMjU6IDI5LCAgLy8gbGFuZ1BvbGlzaCDihpIgc21DZW50cmFsRXVyb1JvbWFuXG5cdCAgICAyNjogMjksICAvLyBsYW5nSHVuZ2FyaWFuIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cblx0ICAgIDI3OiAyOSwgIC8vIGxhbmdFc3RvbmlhbiDihpIgc21DZW50cmFsRXVyb1JvbWFuXG5cdCAgICAyODogMjksICAvLyBsYW5nTGF0dmlhbiDihpIgc21DZW50cmFsRXVyb1JvbWFuXG5cdCAgICAyOTogMCwgIC8vIGxhbmdTYW1pIOKGkiBzbVJvbWFuXG5cdCAgICAzMDogMCwgIC8vIGxhbmdGYXJvZXNlIOKGkiBzbVJvbWFuIChtb2RpZmllZClcblx0ICAgIDMxOiA0LCAgLy8gbGFuZ0ZhcnNpIOKGkiBzbUFyYWJpYyAobW9kaWZpZWQpXG5cdCAgICAzMjogNywgIC8vIGxhbmdSdXNzaWFuIOKGkiBzbUN5cmlsbGljXG5cdCAgICAzMzogMjUsICAvLyBsYW5nU2ltcENoaW5lc2Ug4oaSIHNtU2ltcENoaW5lc2Vcblx0ICAgIDM0OiAwLCAgLy8gbGFuZ0ZsZW1pc2gg4oaSIHNtUm9tYW5cblx0ICAgIDM1OiAwLCAgLy8gbGFuZ0lyaXNoR2FlbGljIOKGkiBzbVJvbWFuIChtb2RpZmllZClcblx0ICAgIDM2OiAwLCAgLy8gbGFuZ0FsYmFuaWFuIOKGkiBzbVJvbWFuXG5cdCAgICAzNzogMCwgIC8vIGxhbmdSb21hbmlhbiDihpIgc21Sb21hbiAobW9kaWZpZWQpXG5cdCAgICAzODogMjksICAvLyBsYW5nQ3plY2gg4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuXHQgICAgMzk6IDI5LCAgLy8gbGFuZ1Nsb3ZhayDihpIgc21DZW50cmFsRXVyb1JvbWFuXG5cdCAgICA0MDogMCwgIC8vIGxhbmdTbG92ZW5pYW4g4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuXHQgICAgNDE6IDUsICAvLyBsYW5nWWlkZGlzaCDihpIgc21IZWJyZXdcblx0ICAgIDQyOiA3LCAgLy8gbGFuZ1NlcmJpYW4g4oaSIHNtQ3lyaWxsaWNcblx0ICAgIDQzOiA3LCAgLy8gbGFuZ01hY2Vkb25pYW4g4oaSIHNtQ3lyaWxsaWNcblx0ICAgIDQ0OiA3LCAgLy8gbGFuZ0J1bGdhcmlhbiDihpIgc21DeXJpbGxpY1xuXHQgICAgNDU6IDcsICAvLyBsYW5nVWtyYWluaWFuIOKGkiBzbUN5cmlsbGljIChtb2RpZmllZClcblx0ICAgIDQ2OiA3LCAgLy8gbGFuZ0J5ZWxvcnVzc2lhbiDihpIgc21DeXJpbGxpY1xuXHQgICAgNDc6IDcsICAvLyBsYW5nVXpiZWsg4oaSIHNtQ3lyaWxsaWNcblx0ICAgIDQ4OiA3LCAgLy8gbGFuZ0themFraCDihpIgc21DeXJpbGxpY1xuXHQgICAgNDk6IDcsICAvLyBsYW5nQXplcmJhaWphbmkg4oaSIHNtQ3lyaWxsaWNcblx0ICAgIDUwOiA0LCAgLy8gbGFuZ0F6ZXJiYWlqYW5BciDihpIgc21BcmFiaWNcblx0ICAgIDUxOiAyNCwgIC8vIGxhbmdBcm1lbmlhbiDihpIgc21Bcm1lbmlhblxuXHQgICAgNTI6IDIzLCAgLy8gbGFuZ0dlb3JnaWFuIOKGkiBzbUdlb3JnaWFuXG5cdCAgICA1MzogNywgIC8vIGxhbmdNb2xkYXZpYW4g4oaSIHNtQ3lyaWxsaWNcblx0ICAgIDU0OiA3LCAgLy8gbGFuZ0tpcmdoaXog4oaSIHNtQ3lyaWxsaWNcblx0ICAgIDU1OiA3LCAgLy8gbGFuZ1RhamlraSDihpIgc21DeXJpbGxpY1xuXHQgICAgNTY6IDcsICAvLyBsYW5nVHVya21lbiDihpIgc21DeXJpbGxpY1xuXHQgICAgNTc6IDI3LCAgLy8gbGFuZ01vbmdvbGlhbiDihpIgc21Nb25nb2xpYW5cblx0ICAgIDU4OiA3LCAgLy8gbGFuZ01vbmdvbGlhbkN5ciDihpIgc21DeXJpbGxpY1xuXHQgICAgNTk6IDQsICAvLyBsYW5nUGFzaHRvIOKGkiBzbUFyYWJpY1xuXHQgICAgNjA6IDQsICAvLyBsYW5nS3VyZGlzaCDihpIgc21BcmFiaWNcblx0ICAgIDYxOiA0LCAgLy8gbGFuZ0thc2htaXJpIOKGkiBzbUFyYWJpY1xuXHQgICAgNjI6IDQsICAvLyBsYW5nU2luZGhpIOKGkiBzbUFyYWJpY1xuXHQgICAgNjM6IDI2LCAgLy8gbGFuZ1RpYmV0YW4g4oaSIHNtVGliZXRhblxuXHQgICAgNjQ6IDksICAvLyBsYW5nTmVwYWxpIOKGkiBzbURldmFuYWdhcmlcblx0ICAgIDY1OiA5LCAgLy8gbGFuZ1NhbnNrcml0IOKGkiBzbURldmFuYWdhcmlcblx0ICAgIDY2OiA5LCAgLy8gbGFuZ01hcmF0aGkg4oaSIHNtRGV2YW5hZ2FyaVxuXHQgICAgNjc6IDEzLCAgLy8gbGFuZ0JlbmdhbGkg4oaSIHNtQmVuZ2FsaVxuXHQgICAgNjg6IDEzLCAgLy8gbGFuZ0Fzc2FtZXNlIOKGkiBzbUJlbmdhbGlcblx0ICAgIDY5OiAxMSwgIC8vIGxhbmdHdWphcmF0aSDihpIgc21HdWphcmF0aVxuXHQgICAgNzA6IDEwLCAgLy8gbGFuZ1B1bmphYmkg4oaSIHNtR3VybXVraGlcblx0ICAgIDcxOiAxMiwgIC8vIGxhbmdPcml5YSDihpIgc21Pcml5YVxuXHQgICAgNzI6IDE3LCAgLy8gbGFuZ01hbGF5YWxhbSDihpIgc21NYWxheWFsYW1cblx0ICAgIDczOiAxNiwgIC8vIGxhbmdLYW5uYWRhIOKGkiBzbUthbm5hZGFcblx0ICAgIDc0OiAxNCwgIC8vIGxhbmdUYW1pbCDihpIgc21UYW1pbFxuXHQgICAgNzU6IDE1LCAgLy8gbGFuZ1RlbHVndSDihpIgc21UZWx1Z3Vcblx0ICAgIDc2OiAxOCwgIC8vIGxhbmdTaW5oYWxlc2Ug4oaSIHNtU2luaGFsZXNlXG5cdCAgICA3NzogMTksICAvLyBsYW5nQnVybWVzZSDihpIgc21CdXJtZXNlXG5cdCAgICA3ODogMjAsICAvLyBsYW5nS2htZXIg4oaSIHNtS2htZXJcblx0ICAgIDc5OiAyMiwgIC8vIGxhbmdMYW8g4oaSIHNtTGFvXG5cdCAgICA4MDogMzAsICAvLyBsYW5nVmlldG5hbWVzZSDihpIgc21WaWV0bmFtZXNlXG5cdCAgICA4MTogMCwgIC8vIGxhbmdJbmRvbmVzaWFuIOKGkiBzbVJvbWFuXG5cdCAgICA4MjogMCwgIC8vIGxhbmdUYWdhbG9nIOKGkiBzbVJvbWFuXG5cdCAgICA4MzogMCwgIC8vIGxhbmdNYWxheVJvbWFuIOKGkiBzbVJvbWFuXG5cdCAgICA4NDogNCwgIC8vIGxhbmdNYWxheUFyYWJpYyDihpIgc21BcmFiaWNcblx0ICAgIDg1OiAyOCwgIC8vIGxhbmdBbWhhcmljIOKGkiBzbUV0aGlvcGljXG5cdCAgICA4NjogMjgsICAvLyBsYW5nVGlncmlueWEg4oaSIHNtRXRoaW9waWNcblx0ICAgIDg3OiAyOCwgIC8vIGxhbmdPcm9tbyDihpIgc21FdGhpb3BpY1xuXHQgICAgODg6IDAsICAvLyBsYW5nU29tYWxpIOKGkiBzbVJvbWFuXG5cdCAgICA4OTogMCwgIC8vIGxhbmdTd2FoaWxpIOKGkiBzbVJvbWFuXG5cdCAgICA5MDogMCwgIC8vIGxhbmdLaW55YXJ3YW5kYSDihpIgc21Sb21hblxuXHQgICAgOTE6IDAsICAvLyBsYW5nUnVuZGkg4oaSIHNtUm9tYW5cblx0ICAgIDkyOiAwLCAgLy8gbGFuZ055YW5qYSDihpIgc21Sb21hblxuXHQgICAgOTM6IDAsICAvLyBsYW5nTWFsYWdhc3kg4oaSIHNtUm9tYW5cblx0ICAgIDk0OiAwLCAgLy8gbGFuZ0VzcGVyYW50byDihpIgc21Sb21hblxuXHQgICAgMTI4OiAwLCAgLy8gbGFuZ1dlbHNoIOKGkiBzbVJvbWFuIChtb2RpZmllZClcblx0ICAgIDEyOTogMCwgIC8vIGxhbmdCYXNxdWUg4oaSIHNtUm9tYW5cblx0ICAgIDEzMDogMCwgIC8vIGxhbmdDYXRhbGFuIOKGkiBzbVJvbWFuXG5cdCAgICAxMzE6IDAsICAvLyBsYW5nTGF0aW4g4oaSIHNtUm9tYW5cblx0ICAgIDEzMjogMCwgIC8vIGxhbmdRdWVjaHVhIOKGkiBzbVJvbWFuXG5cdCAgICAxMzM6IDAsICAvLyBsYW5nR3VhcmFuaSDihpIgc21Sb21hblxuXHQgICAgMTM0OiAwLCAgLy8gbGFuZ0F5bWFyYSDihpIgc21Sb21hblxuXHQgICAgMTM1OiA3LCAgLy8gbGFuZ1RhdGFyIOKGkiBzbUN5cmlsbGljXG5cdCAgICAxMzY6IDQsICAvLyBsYW5nVWlnaHVyIOKGkiBzbUFyYWJpY1xuXHQgICAgMTM3OiAyNiwgIC8vIGxhbmdEem9uZ2toYSDihpIgc21UaWJldGFuXG5cdCAgICAxMzg6IDAsICAvLyBsYW5nSmF2YW5lc2VSb20g4oaSIHNtUm9tYW5cblx0ICAgIDEzOTogMCwgIC8vIGxhbmdTdW5kYW5lc2VSb20g4oaSIHNtUm9tYW5cblx0ICAgIDE0MDogMCwgIC8vIGxhbmdHYWxpY2lhbiDihpIgc21Sb21hblxuXHQgICAgMTQxOiAwLCAgLy8gbGFuZ0FmcmlrYWFucyDihpIgc21Sb21hblxuXHQgICAgMTQyOiAwLCAgLy8gbGFuZ0JyZXRvbiDihpIgc21Sb21hbiAobW9kaWZpZWQpXG5cdCAgICAxNDM6IDI4LCAgLy8gbGFuZ0ludWt0aXR1dCDihpIgc21FdGhpb3BpYyAobW9kaWZpZWQpXG5cdCAgICAxNDQ6IDAsICAvLyBsYW5nU2NvdHRpc2hHYWVsaWMg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuXHQgICAgMTQ1OiAwLCAgLy8gbGFuZ01hbnhHYWVsaWMg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuXHQgICAgMTQ2OiAwLCAgLy8gbGFuZ0lyaXNoR2FlbGljU2NyaXB0IOKGkiBzbVJvbWFuIChtb2RpZmllZClcblx0ICAgIDE0NzogMCwgIC8vIGxhbmdUb25nYW4g4oaSIHNtUm9tYW5cblx0ICAgIDE0ODogNiwgIC8vIGxhbmdHcmVla0FuY2llbnQg4oaSIHNtUm9tYW5cblx0ICAgIDE0OTogMCwgIC8vIGxhbmdHcmVlbmxhbmRpYyDihpIgc21Sb21hblxuXHQgICAgMTUwOiAwLCAgLy8gbGFuZ0F6ZXJiYWlqYW5Sb21hbiDihpIgc21Sb21hblxuXHQgICAgMTUxOiAwICAgLy8gbGFuZ055bm9yc2sg4oaSIHNtUm9tYW5cblx0fTtcblxuXHQvLyBXaGlsZSBNaWNyb3NvZnQgaW5kaWNhdGVzIGEgcmVnaW9uL2NvdW50cnkgZm9yIGFsbCBpdHMgbGFuZ3VhZ2Vcblx0Ly8gSURzLCB3ZSBvbWl0IHRoZSByZWdpb24gY29kZSBpZiBpdCdzIGVxdWFsIHRvIHRoZSBcIm1vc3QgbGlrZWx5XG5cdC8vIHJlZ2lvbiBzdWJ0YWdcIiBhY2NvcmRpbmcgdG8gVW5pY29kZSBDTERSLiBGb3Igc2NyaXB0cywgd2Ugb21pdFxuXHQvLyB0aGUgc3VidGFnIGlmIGl0IGlzIGVxdWFsIHRvIHRoZSBTdXBwcmVzcy1TY3JpcHQgZW50cnkgaW4gdGhlXG5cdC8vIElBTkEgbGFuZ3VhZ2Ugc3VidGFnIHJlZ2lzdHJ5IGZvciBJRVRGIEJDUCA0Ny5cblx0Ly9cblx0Ly8gRm9yIGV4YW1wbGUsIE1pY3Jvc29mdCBzdGF0ZXMgdGhhdCBpdHMgbGFuZ3VhZ2UgY29kZSAweDA0MUEgaXNcblx0Ly8gQ3JvYXRpYW4gaW4gQ3JvYXRpYS4gV2UgdHJhbnNmb3JtIHRoaXMgdG8gdGhlIEJDUCA0NyBsYW5ndWFnZSBjb2RlICdocidcblx0Ly8gYW5kIG5vdCAnaHItSFInIGJlY2F1c2UgQ3JvYXRpYSBpcyB0aGUgZGVmYXVsdCBjb3VudHJ5IGZvciBDcm9hdGlhbixcblx0Ly8gYWNjb3JkaW5nIHRvIFVuaWNvZGUgQ0xEUi4gQXMgYW5vdGhlciBleGFtcGxlLCBNaWNyb3NvZnQgc3RhdGVzXG5cdC8vIHRoYXQgMHgxMDFBIGlzIENyb2F0aWFuIChMYXRpbikgaW4gQm9zbmlhLUhlcnplZ292aW5hLiBXZSB0cmFuc2Zvcm1cblx0Ly8gdGhpcyB0byAnaHItQkEnIGFuZCBub3QgJ2hyLUxhdG4tQkEnIGJlY2F1c2UgTGF0aW4gaXMgdGhlIGRlZmF1bHQgc2NyaXB0XG5cdC8vIGZvciB0aGUgQ3JvYXRpYW4gbGFuZ3VhZ2UsIGFjY29yZGluZyB0byBJQU5BLlxuXHQvL1xuXHQvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL2NsZHIvY2hhcnRzL2xhdGVzdC9zdXBwbGVtZW50YWwvbGlrZWx5X3N1YnRhZ3MuaHRtbFxuXHQvLyBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL2xhbmd1YWdlLXN1YnRhZy1yZWdpc3RyeS9sYW5ndWFnZS1zdWJ0YWctcmVnaXN0cnlcblx0dmFyIHdpbmRvd3NMYW5ndWFnZXMgPSB7XG5cdCAgICAweDA0MzY6ICdhZicsXG5cdCAgICAweDA0MUM6ICdzcScsXG5cdCAgICAweDA0ODQ6ICdnc3cnLFxuXHQgICAgMHgwNDVFOiAnYW0nLFxuXHQgICAgMHgxNDAxOiAnYXItRFonLFxuXHQgICAgMHgzQzAxOiAnYXItQkgnLFxuXHQgICAgMHgwQzAxOiAnYXInLFxuXHQgICAgMHgwODAxOiAnYXItSVEnLFxuXHQgICAgMHgyQzAxOiAnYXItSk8nLFxuXHQgICAgMHgzNDAxOiAnYXItS1cnLFxuXHQgICAgMHgzMDAxOiAnYXItTEInLFxuXHQgICAgMHgxMDAxOiAnYXItTFknLFxuXHQgICAgMHgxODAxOiAnYXJ5Jyxcblx0ICAgIDB4MjAwMTogJ2FyLU9NJyxcblx0ICAgIDB4NDAwMTogJ2FyLVFBJyxcblx0ICAgIDB4MDQwMTogJ2FyLVNBJyxcblx0ICAgIDB4MjgwMTogJ2FyLVNZJyxcblx0ICAgIDB4MUMwMTogJ2FlYicsXG5cdCAgICAweDM4MDE6ICdhci1BRScsXG5cdCAgICAweDI0MDE6ICdhci1ZRScsXG5cdCAgICAweDA0MkI6ICdoeScsXG5cdCAgICAweDA0NEQ6ICdhcycsXG5cdCAgICAweDA4MkM6ICdhei1DeXJsJyxcblx0ICAgIDB4MDQyQzogJ2F6Jyxcblx0ICAgIDB4MDQ2RDogJ2JhJyxcblx0ICAgIDB4MDQyRDogJ2V1Jyxcblx0ICAgIDB4MDQyMzogJ2JlJyxcblx0ICAgIDB4MDg0NTogJ2JuJyxcblx0ICAgIDB4MDQ0NTogJ2JuLUlOJyxcblx0ICAgIDB4MjAxQTogJ2JzLUN5cmwnLFxuXHQgICAgMHgxNDFBOiAnYnMnLFxuXHQgICAgMHgwNDdFOiAnYnInLFxuXHQgICAgMHgwNDAyOiAnYmcnLFxuXHQgICAgMHgwNDAzOiAnY2EnLFxuXHQgICAgMHgwQzA0OiAnemgtSEsnLFxuXHQgICAgMHgxNDA0OiAnemgtTU8nLFxuXHQgICAgMHgwODA0OiAnemgnLFxuXHQgICAgMHgxMDA0OiAnemgtU0cnLFxuXHQgICAgMHgwNDA0OiAnemgtVFcnLFxuXHQgICAgMHgwNDgzOiAnY28nLFxuXHQgICAgMHgwNDFBOiAnaHInLFxuXHQgICAgMHgxMDFBOiAnaHItQkEnLFxuXHQgICAgMHgwNDA1OiAnY3MnLFxuXHQgICAgMHgwNDA2OiAnZGEnLFxuXHQgICAgMHgwNDhDOiAncHJzJyxcblx0ICAgIDB4MDQ2NTogJ2R2Jyxcblx0ICAgIDB4MDgxMzogJ25sLUJFJyxcblx0ICAgIDB4MDQxMzogJ25sJyxcblx0ICAgIDB4MEMwOTogJ2VuLUFVJyxcblx0ICAgIDB4MjgwOTogJ2VuLUJaJyxcblx0ICAgIDB4MTAwOTogJ2VuLUNBJyxcblx0ICAgIDB4MjQwOTogJ2VuLTAyOScsXG5cdCAgICAweDQwMDk6ICdlbi1JTicsXG5cdCAgICAweDE4MDk6ICdlbi1JRScsXG5cdCAgICAweDIwMDk6ICdlbi1KTScsXG5cdCAgICAweDQ0MDk6ICdlbi1NWScsXG5cdCAgICAweDE0MDk6ICdlbi1OWicsXG5cdCAgICAweDM0MDk6ICdlbi1QSCcsXG5cdCAgICAweDQ4MDk6ICdlbi1TRycsXG5cdCAgICAweDFDMDk6ICdlbi1aQScsXG5cdCAgICAweDJDMDk6ICdlbi1UVCcsXG5cdCAgICAweDA4MDk6ICdlbi1HQicsXG5cdCAgICAweDA0MDk6ICdlbicsXG5cdCAgICAweDMwMDk6ICdlbi1aVycsXG5cdCAgICAweDA0MjU6ICdldCcsXG5cdCAgICAweDA0Mzg6ICdmbycsXG5cdCAgICAweDA0NjQ6ICdmaWwnLFxuXHQgICAgMHgwNDBCOiAnZmknLFxuXHQgICAgMHgwODBDOiAnZnItQkUnLFxuXHQgICAgMHgwQzBDOiAnZnItQ0EnLFxuXHQgICAgMHgwNDBDOiAnZnInLFxuXHQgICAgMHgxNDBDOiAnZnItTFUnLFxuXHQgICAgMHgxODBDOiAnZnItTUMnLFxuXHQgICAgMHgxMDBDOiAnZnItQ0gnLFxuXHQgICAgMHgwNDYyOiAnZnknLFxuXHQgICAgMHgwNDU2OiAnZ2wnLFxuXHQgICAgMHgwNDM3OiAna2EnLFxuXHQgICAgMHgwQzA3OiAnZGUtQVQnLFxuXHQgICAgMHgwNDA3OiAnZGUnLFxuXHQgICAgMHgxNDA3OiAnZGUtTEknLFxuXHQgICAgMHgxMDA3OiAnZGUtTFUnLFxuXHQgICAgMHgwODA3OiAnZGUtQ0gnLFxuXHQgICAgMHgwNDA4OiAnZWwnLFxuXHQgICAgMHgwNDZGOiAna2wnLFxuXHQgICAgMHgwNDQ3OiAnZ3UnLFxuXHQgICAgMHgwNDY4OiAnaGEnLFxuXHQgICAgMHgwNDBEOiAnaGUnLFxuXHQgICAgMHgwNDM5OiAnaGknLFxuXHQgICAgMHgwNDBFOiAnaHUnLFxuXHQgICAgMHgwNDBGOiAnaXMnLFxuXHQgICAgMHgwNDcwOiAnaWcnLFxuXHQgICAgMHgwNDIxOiAnaWQnLFxuXHQgICAgMHgwNDVEOiAnaXUnLFxuXHQgICAgMHgwODVEOiAnaXUtTGF0bicsXG5cdCAgICAweDA4M0M6ICdnYScsXG5cdCAgICAweDA0MzQ6ICd4aCcsXG5cdCAgICAweDA0MzU6ICd6dScsXG5cdCAgICAweDA0MTA6ICdpdCcsXG5cdCAgICAweDA4MTA6ICdpdC1DSCcsXG5cdCAgICAweDA0MTE6ICdqYScsXG5cdCAgICAweDA0NEI6ICdrbicsXG5cdCAgICAweDA0M0Y6ICdraycsXG5cdCAgICAweDA0NTM6ICdrbScsXG5cdCAgICAweDA0ODY6ICdxdWMnLFxuXHQgICAgMHgwNDg3OiAncncnLFxuXHQgICAgMHgwNDQxOiAnc3cnLFxuXHQgICAgMHgwNDU3OiAna29rJyxcblx0ICAgIDB4MDQxMjogJ2tvJyxcblx0ICAgIDB4MDQ0MDogJ2t5Jyxcblx0ICAgIDB4MDQ1NDogJ2xvJyxcblx0ICAgIDB4MDQyNjogJ2x2Jyxcblx0ICAgIDB4MDQyNzogJ2x0Jyxcblx0ICAgIDB4MDgyRTogJ2RzYicsXG5cdCAgICAweDA0NkU6ICdsYicsXG5cdCAgICAweDA0MkY6ICdtaycsXG5cdCAgICAweDA4M0U6ICdtcy1CTicsXG5cdCAgICAweDA0M0U6ICdtcycsXG5cdCAgICAweDA0NEM6ICdtbCcsXG5cdCAgICAweDA0M0E6ICdtdCcsXG5cdCAgICAweDA0ODE6ICdtaScsXG5cdCAgICAweDA0N0E6ICdhcm4nLFxuXHQgICAgMHgwNDRFOiAnbXInLFxuXHQgICAgMHgwNDdDOiAnbW9oJyxcblx0ICAgIDB4MDQ1MDogJ21uJyxcblx0ICAgIDB4MDg1MDogJ21uLUNOJyxcblx0ICAgIDB4MDQ2MTogJ25lJyxcblx0ICAgIDB4MDQxNDogJ25iJyxcblx0ICAgIDB4MDgxNDogJ25uJyxcblx0ICAgIDB4MDQ4MjogJ29jJyxcblx0ICAgIDB4MDQ0ODogJ29yJyxcblx0ICAgIDB4MDQ2MzogJ3BzJyxcblx0ICAgIDB4MDQxNTogJ3BsJyxcblx0ICAgIDB4MDQxNjogJ3B0Jyxcblx0ICAgIDB4MDgxNjogJ3B0LVBUJyxcblx0ICAgIDB4MDQ0NjogJ3BhJyxcblx0ICAgIDB4MDQ2QjogJ3F1LUJPJyxcblx0ICAgIDB4MDg2QjogJ3F1LUVDJyxcblx0ICAgIDB4MEM2QjogJ3F1Jyxcblx0ICAgIDB4MDQxODogJ3JvJyxcblx0ICAgIDB4MDQxNzogJ3JtJyxcblx0ICAgIDB4MDQxOTogJ3J1Jyxcblx0ICAgIDB4MjQzQjogJ3NtbicsXG5cdCAgICAweDEwM0I6ICdzbWotTk8nLFxuXHQgICAgMHgxNDNCOiAnc21qJyxcblx0ICAgIDB4MEMzQjogJ3NlLUZJJyxcblx0ICAgIDB4MDQzQjogJ3NlJyxcblx0ICAgIDB4MDgzQjogJ3NlLVNFJyxcblx0ICAgIDB4MjAzQjogJ3NtcycsXG5cdCAgICAweDE4M0I6ICdzbWEtTk8nLFxuXHQgICAgMHgxQzNCOiAnc21zJyxcblx0ICAgIDB4MDQ0RjogJ3NhJyxcblx0ICAgIDB4MUMxQTogJ3NyLUN5cmwtQkEnLFxuXHQgICAgMHgwQzFBOiAnc3InLFxuXHQgICAgMHgxODFBOiAnc3ItTGF0bi1CQScsXG5cdCAgICAweDA4MUE6ICdzci1MYXRuJyxcblx0ICAgIDB4MDQ2QzogJ25zbycsXG5cdCAgICAweDA0MzI6ICd0bicsXG5cdCAgICAweDA0NUI6ICdzaScsXG5cdCAgICAweDA0MUI6ICdzaycsXG5cdCAgICAweDA0MjQ6ICdzbCcsXG5cdCAgICAweDJDMEE6ICdlcy1BUicsXG5cdCAgICAweDQwMEE6ICdlcy1CTycsXG5cdCAgICAweDM0MEE6ICdlcy1DTCcsXG5cdCAgICAweDI0MEE6ICdlcy1DTycsXG5cdCAgICAweDE0MEE6ICdlcy1DUicsXG5cdCAgICAweDFDMEE6ICdlcy1ETycsXG5cdCAgICAweDMwMEE6ICdlcy1FQycsXG5cdCAgICAweDQ0MEE6ICdlcy1TVicsXG5cdCAgICAweDEwMEE6ICdlcy1HVCcsXG5cdCAgICAweDQ4MEE6ICdlcy1ITicsXG5cdCAgICAweDA4MEE6ICdlcy1NWCcsXG5cdCAgICAweDRDMEE6ICdlcy1OSScsXG5cdCAgICAweDE4MEE6ICdlcy1QQScsXG5cdCAgICAweDNDMEE6ICdlcy1QWScsXG5cdCAgICAweDI4MEE6ICdlcy1QRScsXG5cdCAgICAweDUwMEE6ICdlcy1QUicsXG5cblx0ICAgIC8vIE1pY3Jvc29mdCBoYXMgZGVmaW5lZCB0d28gZGlmZmVyZW50IGxhbmd1YWdlIGNvZGVzIGZvclxuXHQgICAgLy8g4oCcU3BhbmlzaCB3aXRoIG1vZGVybiBzb3J0aW5n4oCdIGFuZCDigJxTcGFuaXNoIHdpdGggdHJhZGl0aW9uYWxcblx0ICAgIC8vIHNvcnRpbmfigJ0uIFRoaXMgbWFrZXMgc2Vuc2UgZm9yIGNvbGxhdGlvbiBBUElzLCBhbmQgaXQgd291bGQgYmVcblx0ICAgIC8vIHBvc3NpYmxlIHRvIGV4cHJlc3MgdGhpcyBpbiBCQ1AgNDcgbGFuZ3VhZ2UgdGFncyB2aWEgVW5pY29kZVxuXHQgICAgLy8gZXh0ZW5zaW9ucyAoZWcuLCBlcy11LWNvLXRyYWQgaXMgU3BhbmlzaCB3aXRoIHRyYWRpdGlvbmFsXG5cdCAgICAvLyBzb3J0aW5nKS4gSG93ZXZlciwgZm9yIHN0b3JpbmcgbmFtZXMgaW4gZm9udHMsIHRoZSBkaXN0aW5jdGlvblxuXHQgICAgLy8gZG9lcyBub3QgbWFrZSBzZW5zZSwgc28gd2UgZ2l2ZSDigJxlc+KAnSBpbiBib3RoIGNhc2VzLlxuXHQgICAgMHgwQzBBOiAnZXMnLFxuXHQgICAgMHgwNDBBOiAnZXMnLFxuXG5cdCAgICAweDU0MEE6ICdlcy1VUycsXG5cdCAgICAweDM4MEE6ICdlcy1VWScsXG5cdCAgICAweDIwMEE6ICdlcy1WRScsXG5cdCAgICAweDA4MUQ6ICdzdi1GSScsXG5cdCAgICAweDA0MUQ6ICdzdicsXG5cdCAgICAweDA0NUE6ICdzeXInLFxuXHQgICAgMHgwNDI4OiAndGcnLFxuXHQgICAgMHgwODVGOiAndHptJyxcblx0ICAgIDB4MDQ0OTogJ3RhJyxcblx0ICAgIDB4MDQ0NDogJ3R0Jyxcblx0ICAgIDB4MDQ0QTogJ3RlJyxcblx0ICAgIDB4MDQxRTogJ3RoJyxcblx0ICAgIDB4MDQ1MTogJ2JvJyxcblx0ICAgIDB4MDQxRjogJ3RyJyxcblx0ICAgIDB4MDQ0MjogJ3RrJyxcblx0ICAgIDB4MDQ4MDogJ3VnJyxcblx0ICAgIDB4MDQyMjogJ3VrJyxcblx0ICAgIDB4MDQyRTogJ2hzYicsXG5cdCAgICAweDA0MjA6ICd1cicsXG5cdCAgICAweDA4NDM6ICd1ei1DeXJsJyxcblx0ICAgIDB4MDQ0MzogJ3V6Jyxcblx0ICAgIDB4MDQyQTogJ3ZpJyxcblx0ICAgIDB4MDQ1MjogJ2N5Jyxcblx0ICAgIDB4MDQ4ODogJ3dvJyxcblx0ICAgIDB4MDQ4NTogJ3NhaCcsXG5cdCAgICAweDA0Nzg6ICdpaScsXG5cdCAgICAweDA0NkE6ICd5bydcblx0fTtcblxuXHQvLyBSZXR1cm5zIGEgSUVURiBCQ1AgNDcgbGFuZ3VhZ2UgY29kZSwgZm9yIGV4YW1wbGUgJ3poLUhhbnQnXG5cdC8vIGZvciAnQ2hpbmVzZSBpbiB0aGUgdHJhZGl0aW9uYWwgc2NyaXB0Jy5cblx0ZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VDb2RlKHBsYXRmb3JtSUQsIGxhbmd1YWdlSUQsIGx0YWcpIHtcblx0ICAgIHN3aXRjaCAocGxhdGZvcm1JRCkge1xuXHQgICAgICAgIGNhc2UgMDogIC8vIFVuaWNvZGVcblx0ICAgICAgICAgICAgaWYgKGxhbmd1YWdlSUQgPT09IDB4RkZGRikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICd1bmQnO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGx0YWcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsdGFnW2xhbmd1YWdlSURdO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIDE6ICAvLyBNYWNpbnRvc2hcblx0ICAgICAgICAgICAgcmV0dXJuIG1hY0xhbmd1YWdlc1tsYW5ndWFnZUlEXTtcblxuXHQgICAgICAgIGNhc2UgMzogIC8vIFdpbmRvd3Ncblx0ICAgICAgICAgICAgcmV0dXJuIHdpbmRvd3NMYW5ndWFnZXNbbGFuZ3VhZ2VJRF07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHR2YXIgdXRmMTYgPSAndXRmLTE2JztcblxuXHQvLyBNYWNPUyBzY3JpcHQgSUQg4oaSIGVuY29kaW5nLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgZGVmYXVsdCBjYXNlLFxuXHQvLyB3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBtYWNMYW5ndWFnZUVuY29kaW5ncy5cblx0dmFyIG1hY1NjcmlwdEVuY29kaW5ncyA9IHtcblx0ICAgIDA6ICdtYWNpbnRvc2gnLCAgICAgICAgICAgLy8gc21Sb21hblxuXHQgICAgMTogJ3gtbWFjLWphcGFuZXNlJywgICAgICAvLyBzbUphcGFuZXNlXG5cdCAgICAyOiAneC1tYWMtY2hpbmVzZXRyYWQnLCAgIC8vIHNtVHJhZENoaW5lc2Vcblx0ICAgIDM6ICd4LW1hYy1rb3JlYW4nLCAgICAgICAgLy8gc21Lb3JlYW5cblx0ICAgIDY6ICd4LW1hYy1ncmVlaycsICAgICAgICAgLy8gc21HcmVla1xuXHQgICAgNzogJ3gtbWFjLWN5cmlsbGljJywgICAgICAvLyBzbUN5cmlsbGljXG5cdCAgICA5OiAneC1tYWMtZGV2YW5hZ2FpJywgICAgIC8vIHNtRGV2YW5hZ2FyaVxuXHQgICAgMTA6ICd4LW1hYy1ndXJtdWtoaScsICAgICAvLyBzbUd1cm11a2hpXG5cdCAgICAxMTogJ3gtbWFjLWd1amFyYXRpJywgICAgIC8vIHNtR3VqYXJhdGlcblx0ICAgIDEyOiAneC1tYWMtb3JpeWEnLCAgICAgICAgLy8gc21Pcml5YVxuXHQgICAgMTM6ICd4LW1hYy1iZW5nYWxpJywgICAgICAvLyBzbUJlbmdhbGlcblx0ICAgIDE0OiAneC1tYWMtdGFtaWwnLCAgICAgICAgLy8gc21UYW1pbFxuXHQgICAgMTU6ICd4LW1hYy10ZWx1Z3UnLCAgICAgICAvLyBzbVRlbHVndVxuXHQgICAgMTY6ICd4LW1hYy1rYW5uYWRhJywgICAgICAvLyBzbUthbm5hZGFcblx0ICAgIDE3OiAneC1tYWMtbWFsYXlhbGFtJywgICAgLy8gc21NYWxheWFsYW1cblx0ICAgIDE4OiAneC1tYWMtc2luaGFsZXNlJywgICAgLy8gc21TaW5oYWxlc2Vcblx0ICAgIDE5OiAneC1tYWMtYnVybWVzZScsICAgICAgLy8gc21CdXJtZXNlXG5cdCAgICAyMDogJ3gtbWFjLWtobWVyJywgICAgICAgIC8vIHNtS2htZXJcblx0ICAgIDIxOiAneC1tYWMtdGhhaScsICAgICAgICAgLy8gc21UaGFpXG5cdCAgICAyMjogJ3gtbWFjLWxhbycsICAgICAgICAgIC8vIHNtTGFvXG5cdCAgICAyMzogJ3gtbWFjLWdlb3JnaWFuJywgICAgIC8vIHNtR2VvcmdpYW5cblx0ICAgIDI0OiAneC1tYWMtYXJtZW5pYW4nLCAgICAgLy8gc21Bcm1lbmlhblxuXHQgICAgMjU6ICd4LW1hYy1jaGluZXNlc2ltcCcsICAvLyBzbVNpbXBDaGluZXNlXG5cdCAgICAyNjogJ3gtbWFjLXRpYmV0YW4nLCAgICAgIC8vIHNtVGliZXRhblxuXHQgICAgMjc6ICd4LW1hYy1tb25nb2xpYW4nLCAgICAvLyBzbU1vbmdvbGlhblxuXHQgICAgMjg6ICd4LW1hYy1ldGhpb3BpYycsICAgICAvLyBzbUV0aGlvcGljXG5cdCAgICAyOTogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIHNtQ2VudHJhbEV1cm9Sb21hblxuXHQgICAgMzA6ICd4LW1hYy12aWV0bmFtZXNlJywgICAvLyBzbVZpZXRuYW1lc2Vcblx0ICAgIDMxOiAneC1tYWMtZXh0YXJhYmljJyAgICAgLy8gc21FeHRBcmFiaWNcblx0fTtcblxuXHQvLyBNYWNPUyBsYW5ndWFnZSBJRCDihpIgZW5jb2RpbmcuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBleGNlcHRpb25hbFxuXHQvLyBjYXNlcywgd2hpY2ggb3ZlcnJpZGUgbWFjU2NyaXB0RW5jb2RpbmdzLiBGb3Igd3JpdGluZyBNYWNPUyBuYW1pbmdcblx0Ly8gdGFibGVzLCB3ZSBuZWVkIHRvIGVtaXQgYSBNYWNPUyBzY3JpcHQgSUQuIFRoZXJlZm9yZSwgd2UgY2Fubm90XG5cdC8vIG1lcmdlIG1hY1NjcmlwdEVuY29kaW5ncyBpbnRvIG1hY0xhbmd1YWdlRW5jb2RpbmdzLlxuXHQvL1xuXHQvLyBodHRwOi8vdW5pY29kZS5vcmcvUHVibGljL01BUFBJTkdTL1ZFTkRPUlMvQVBQTEUvUmVhZG1lLnR4dFxuXHR2YXIgbWFjTGFuZ3VhZ2VFbmNvZGluZ3MgPSB7XG5cdCAgICAxNTogJ3gtbWFjLWljZWxhbmRpYycsICAgIC8vIGxhbmdJY2VsYW5kaWNcblx0ICAgIDE3OiAneC1tYWMtdHVya2lzaCcsICAgICAgLy8gbGFuZ1R1cmtpc2hcblx0ICAgIDE4OiAneC1tYWMtY3JvYXRpYW4nLCAgICAgLy8gbGFuZ0Nyb2F0aWFuXG5cdCAgICAyNDogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdMaXRodWFuaWFuXG5cdCAgICAyNTogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdQb2xpc2hcblx0ICAgIDI2OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ0h1bmdhcmlhblxuXHQgICAgMjc6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nRXN0b25pYW5cblx0ICAgIDI4OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ0xhdHZpYW5cblx0ICAgIDMwOiAneC1tYWMtaWNlbGFuZGljJywgICAgLy8gbGFuZ0Zhcm9lc2Vcblx0ICAgIDM3OiAneC1tYWMtcm9tYW5pYW4nLCAgICAgLy8gbGFuZ1JvbWFuaWFuXG5cdCAgICAzODogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdDemVjaFxuXHQgICAgMzk6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nU2xvdmFrXG5cdCAgICA0MDogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdTbG92ZW5pYW5cblx0ICAgIDE0MzogJ3gtbWFjLWludWl0JywgICAgICAgLy8gbGFuZ0ludWt0aXR1dFxuXHQgICAgMTQ2OiAneC1tYWMtZ2FlbGljJyAgICAgICAvLyBsYW5nSXJpc2hHYWVsaWNTY3JpcHRcblx0fTtcblxuXHRmdW5jdGlvbiBnZXRFbmNvZGluZyhwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlEKSB7XG5cdCAgICBzd2l0Y2ggKHBsYXRmb3JtSUQpIHtcblx0ICAgICAgICBjYXNlIDA6ICAvLyBVbmljb2RlXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNjtcblxuXHQgICAgICAgIGNhc2UgMTogIC8vIEFwcGxlIE1hY2ludG9zaFxuXHQgICAgICAgICAgICByZXR1cm4gbWFjTGFuZ3VhZ2VFbmNvZGluZ3NbbGFuZ3VhZ2VJRF0gfHwgbWFjU2NyaXB0RW5jb2RpbmdzW2VuY29kaW5nSURdO1xuXG5cdCAgICAgICAgY2FzZSAzOiAgLy8gTWljcm9zb2Z0IFdpbmRvd3Ncblx0ICAgICAgICAgICAgaWYgKGVuY29kaW5nSUQgPT09IDEgfHwgZW5jb2RpbmdJRCA9PT0gMTApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB1dGYxNjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gUGFyc2UgdGhlIG5hbWluZyBgbmFtZWAgdGFibGUuXG5cdC8vIEZJWE1FOiBGb3JtYXQgMSBhZGRpdGlvbmFsIGZpZWxkcyBhcmUgbm90IHN1cHBvcnRlZCB5ZXQuXG5cdC8vIGx0YWcgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGBsdGFnJyB0YWJsZSwgc3VjaCBhcyBbJ2VuJywgJ3poLUhhbnMnLCAnZGUtQ0gtMTkwNCddLlxuXHRmdW5jdGlvbiBwYXJzZU5hbWVUYWJsZShkYXRhLCBzdGFydCwgbHRhZykge1xuXHQgICAgdmFyIG5hbWUgPSB7fTtcblx0ICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cdCAgICB2YXIgZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgdmFyIGNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgdmFyIHN0cmluZ09mZnNldCA9IHAub2Zmc2V0ICsgcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHBsYXRmb3JtSUQgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgdmFyIGVuY29kaW5nSUQgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgdmFyIGxhbmd1YWdlSUQgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgdmFyIG5hbWVJRCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICB2YXIgcHJvcGVydHkgPSBuYW1lVGFibGVOYW1lc1tuYW1lSURdIHx8IG5hbWVJRDtcblx0ICAgICAgICB2YXIgYnl0ZUxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICB2YXIgb2Zmc2V0ID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIHZhciBsYW5ndWFnZSA9IGdldExhbmd1YWdlQ29kZShwbGF0Zm9ybUlELCBsYW5ndWFnZUlELCBsdGFnKTtcblx0ICAgICAgICB2YXIgZW5jb2RpbmcgPSBnZXRFbmNvZGluZyhwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlEKTtcblx0ICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiBsYW5ndWFnZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCk7XG5cdCAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gdXRmMTYpIHtcblx0ICAgICAgICAgICAgICAgIHRleHQgPSBkZWNvZGUuVVRGMTYoZGF0YSwgc3RyaW5nT2Zmc2V0ICsgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRleHQgPSBkZWNvZGUuTUFDU1RSSU5HKGRhdGEsIHN0cmluZ09mZnNldCArIG9mZnNldCwgYnl0ZUxlbmd0aCwgZW5jb2RpbmcpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRleHQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0cmFuc2xhdGlvbnMgPSBuYW1lW3Byb3BlcnR5XTtcblx0ICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9ucyA9IG5hbWVbcHJvcGVydHldID0ge307XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uc1tsYW5ndWFnZV0gPSB0ZXh0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgbGFuZ1RhZ0NvdW50ID0gMDtcblx0ICAgIGlmIChmb3JtYXQgPT09IDEpIHtcblx0ICAgICAgICAvLyBGSVhNRTogQWxzbyBoYW5kbGUgTWljcm9zb2Z0J3MgJ25hbWUnIHRhYmxlIDEuXG5cdCAgICAgICAgbGFuZ1RhZ0NvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIHsyMzogJ2Zvbyd9IOKGkiB7J2Zvbyc6IDIzfVxuXHQvLyBbJ2JhcicsICdiYXonXSDihpIgeydiYXInOiAwLCAnYmF6JzogMX1cblx0ZnVuY3Rpb24gcmV2ZXJzZURpY3QoZGljdCkge1xuXHQgICAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgICAgZm9yICh2YXIga2V5IGluIGRpY3QpIHtcblx0ICAgICAgICByZXN1bHRbZGljdFtrZXldXSA9IHBhcnNlSW50KGtleSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlTmFtZVJlY29yZChwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlELCBuYW1lSUQsIGxlbmd0aCwgb2Zmc2V0KSB7XG5cdCAgICByZXR1cm4gbmV3IHRhYmxlLlJlY29yZCgnTmFtZVJlY29yZCcsIFtcblx0ICAgICAgICB7bmFtZTogJ3BsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHBsYXRmb3JtSUR9LFxuXHQgICAgICAgIHtuYW1lOiAnZW5jb2RpbmdJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZW5jb2RpbmdJRH0sXG5cdCAgICAgICAge25hbWU6ICdsYW5ndWFnZUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsYW5ndWFnZUlEfSxcblx0ICAgICAgICB7bmFtZTogJ25hbWVJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfSxcblx0ICAgICAgICB7bmFtZTogJ2xlbmd0aCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGVuZ3RofSxcblx0ICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogb2Zmc2V0fVxuXHQgICAgXSk7XG5cdH1cblxuXHQvLyBGaW5kcyB0aGUgcG9zaXRpb24gb2YgbmVlZGxlIGluIGhheXN0YWNrLCBvciAtMSBpZiBub3QgdGhlcmUuXG5cdC8vIExpa2UgU3RyaW5nLmluZGV4T2YoKSwgYnV0IGZvciBhcnJheXMuXG5cdGZ1bmN0aW9uIGZpbmRTdWJBcnJheShuZWVkbGUsIGhheXN0YWNrKSB7XG5cdCAgICB2YXIgbmVlZGxlTGVuZ3RoID0gbmVlZGxlLmxlbmd0aDtcblx0ICAgIHZhciBsaW1pdCA9IGhheXN0YWNrLmxlbmd0aCAtIG5lZWRsZUxlbmd0aCArIDE7XG5cblx0ICAgIGxvb3A6XG5cdCAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCBsaW1pdDsgcG9zKyspIHtcblx0ICAgICAgICBmb3IgKDsgcG9zIDwgbGltaXQ7IHBvcysrKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbmVlZGxlTGVuZ3RoOyBrKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChoYXlzdGFja1twb3MgKyBrXSAhPT0gbmVlZGxlW2tdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29udGludWUgbG9vcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBwb3M7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gLTE7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRTdHJpbmdUb1Bvb2wocywgcG9vbCkge1xuXHQgICAgdmFyIG9mZnNldCA9IGZpbmRTdWJBcnJheShzLCBwb29sKTtcblx0ICAgIGlmIChvZmZzZXQgPCAwKSB7XG5cdCAgICAgICAgb2Zmc2V0ID0gcG9vbC5sZW5ndGg7XG5cdCAgICAgICAgdmFyIGkgPSAwO1xuXHQgICAgICAgIHZhciBsZW4gPSBzLmxlbmd0aDtcblx0ICAgICAgICBmb3IgKDsgaSA8IGxlbjsgKytpKSB7XG5cdCAgICAgICAgICAgIHBvb2wucHVzaChzW2ldKTtcblx0ICAgICAgICB9XG5cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG9mZnNldDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VOYW1lVGFibGUobmFtZXMsIGx0YWcpIHtcblx0ICAgIHZhciBuYW1lSUQ7XG5cdCAgICB2YXIgbmFtZUlEcyA9IFtdO1xuXG5cdCAgICB2YXIgbmFtZXNXaXRoTnVtZXJpY0tleXMgPSB7fTtcblx0ICAgIHZhciBuYW1lVGFibGVJZHMgPSByZXZlcnNlRGljdChuYW1lVGFibGVOYW1lcyk7XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gbmFtZXMpIHtcblx0ICAgICAgICB2YXIgaWQgPSBuYW1lVGFibGVJZHNba2V5XTtcblx0ICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICBpZCA9IGtleTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBuYW1lSUQgPSBwYXJzZUludChpZCk7XG5cblx0ICAgICAgICBpZiAoaXNOYU4obmFtZUlEKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hbWUgdGFibGUgZW50cnkgXCInICsga2V5ICsgJ1wiIGRvZXMgbm90IGV4aXN0LCBzZWUgbmFtZVRhYmxlTmFtZXMgZm9yIGNvbXBsZXRlIGxpc3QuJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbmFtZXNXaXRoTnVtZXJpY0tleXNbbmFtZUlEXSA9IG5hbWVzW2tleV07XG5cdCAgICAgICAgbmFtZUlEcy5wdXNoKG5hbWVJRCk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBtYWNMYW5ndWFnZUlkcyA9IHJldmVyc2VEaWN0KG1hY0xhbmd1YWdlcyk7XG5cdCAgICB2YXIgd2luZG93c0xhbmd1YWdlSWRzID0gcmV2ZXJzZURpY3Qod2luZG93c0xhbmd1YWdlcyk7XG5cblx0ICAgIHZhciBuYW1lUmVjb3JkcyA9IFtdO1xuXHQgICAgdmFyIHN0cmluZ1Bvb2wgPSBbXTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lSURzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgbmFtZUlEID0gbmFtZUlEc1tpXTtcblx0ICAgICAgICB2YXIgdHJhbnNsYXRpb25zID0gbmFtZXNXaXRoTnVtZXJpY0tleXNbbmFtZUlEXTtcblx0ICAgICAgICBmb3IgKHZhciBsYW5nIGluIHRyYW5zbGF0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgdGV4dCA9IHRyYW5zbGF0aW9uc1tsYW5nXTtcblxuXHQgICAgICAgICAgICAvLyBGb3IgTWFjT1MsIHdlIHRyeSB0byBlbWl0IHRoZSBuYW1lIGluIHRoZSBmb3JtIHRoYXQgd2FzIGludHJvZHVjZWRcblx0ICAgICAgICAgICAgLy8gaW4gdGhlIGluaXRpYWwgdmVyc2lvbiBvZiB0aGUgVHJ1ZVR5cGUgc3BlYyAoaW4gdGhlIGxhdGUgMTk4MHMpLlxuXHQgICAgICAgICAgICAvLyBIb3dldmVyLCB0aGlzIGNhbiBmYWlsIGZvciB2YXJpb3VzIHJlYXNvbnM6IHRoZSByZXF1ZXN0ZWQgQkNQIDQ3XG5cdCAgICAgICAgICAgIC8vIGxhbmd1YWdlIGNvZGUgbWlnaHQgbm90IGhhdmUgYW4gb2xkLXN0eWxlIE1hYyBlcXVpdmFsZW50O1xuXHQgICAgICAgICAgICAvLyB3ZSBtaWdodCBub3QgaGF2ZSBhIGNvZGVjIGZvciB0aGUgbmVlZGVkIGNoYXJhY3RlciBlbmNvZGluZztcblx0ICAgICAgICAgICAgLy8gb3IgdGhlIG5hbWUgbWlnaHQgY29udGFpbiBjaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGJlIGV4cHJlc3NlZFxuXHQgICAgICAgICAgICAvLyBpbiB0aGUgb2xkLXN0eWxlIE1hY2ludG9zaCBlbmNvZGluZy4gSW4gY2FzZSBvZiBmYWlsdXJlLCB3ZSBlbWl0XG5cdCAgICAgICAgICAgIC8vIHRoZSBuYW1lIGluIGEgbW9yZSBtb2Rlcm4gZmFzaGlvbiAoVW5pY29kZSBlbmNvZGluZyB3aXRoIEJDUCA0N1xuXHQgICAgICAgICAgICAvLyBsYW5ndWFnZSB0YWdzKSB0aGF0IGlzIHJlY29nbml6ZWQgYnkgTWFjT1MgMTAuNSwgcmVsZWFzZWQgaW4gMjAwOS5cblx0ICAgICAgICAgICAgLy8gSWYgZm9udHMgd2VyZSBvbmx5IHJlYWQgYnkgb3BlcmF0aW5nIHN5c3RlbXMsIHdlIGNvdWxkIHNpbXBseVxuXHQgICAgICAgICAgICAvLyBlbWl0IGFsbCBuYW1lcyBpbiB0aGUgbW9kZXJuIGZvcm07IHRoaXMgd291bGQgYmUgbXVjaCBlYXNpZXIuXG5cdCAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZXJlIGFyZSBtYW55IGFwcGxpY2F0aW9ucyBhbmQgbGlicmFyaWVzIHRoYXQgcmVhZFxuXHQgICAgICAgICAgICAvLyAnbmFtZScgdGFibGVzIGRpcmVjdGx5LCBhbmQgdGhlc2Ugd2lsbCB1c3VhbGx5IG9ubHkgcmVjb2duaXplXG5cdCAgICAgICAgICAgIC8vIHRoZSBhbmNpZW50IGZvcm0gKHNpbGVudGx5IHNraXBwaW5nIHRoZSB1bnJlY29nbml6ZWQgbmFtZXMpLlxuXHQgICAgICAgICAgICB2YXIgbWFjUGxhdGZvcm0gPSAxOyAgLy8gTWFjaW50b3NoXG5cdCAgICAgICAgICAgIHZhciBtYWNMYW5ndWFnZSA9IG1hY0xhbmd1YWdlSWRzW2xhbmddO1xuXHQgICAgICAgICAgICB2YXIgbWFjU2NyaXB0ID0gbWFjTGFuZ3VhZ2VUb1NjcmlwdFttYWNMYW5ndWFnZV07XG5cdCAgICAgICAgICAgIHZhciBtYWNFbmNvZGluZyA9IGdldEVuY29kaW5nKG1hY1BsYXRmb3JtLCBtYWNTY3JpcHQsIG1hY0xhbmd1YWdlKTtcblx0ICAgICAgICAgICAgdmFyIG1hY05hbWUgPSBlbmNvZGUuTUFDU1RSSU5HKHRleHQsIG1hY0VuY29kaW5nKTtcblx0ICAgICAgICAgICAgaWYgKG1hY05hbWUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgbWFjUGxhdGZvcm0gPSAwOyAgLy8gVW5pY29kZVxuXHQgICAgICAgICAgICAgICAgbWFjTGFuZ3VhZ2UgPSBsdGFnLmluZGV4T2YobGFuZyk7XG5cdCAgICAgICAgICAgICAgICBpZiAobWFjTGFuZ3VhZ2UgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbWFjTGFuZ3VhZ2UgPSBsdGFnLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICBsdGFnLnB1c2gobGFuZyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIG1hY1NjcmlwdCA9IDQ7ICAvLyBVbmljb2RlIDIuMCBhbmQgbGF0ZXJcblx0ICAgICAgICAgICAgICAgIG1hY05hbWUgPSBlbmNvZGUuVVRGMTYodGV4dCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgbWFjTmFtZU9mZnNldCA9IGFkZFN0cmluZ1RvUG9vbChtYWNOYW1lLCBzdHJpbmdQb29sKTtcblx0ICAgICAgICAgICAgbmFtZVJlY29yZHMucHVzaChtYWtlTmFtZVJlY29yZChtYWNQbGF0Zm9ybSwgbWFjU2NyaXB0LCBtYWNMYW5ndWFnZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lSUQsIG1hY05hbWUubGVuZ3RoLCBtYWNOYW1lT2Zmc2V0KSk7XG5cblx0ICAgICAgICAgICAgdmFyIHdpbkxhbmd1YWdlID0gd2luZG93c0xhbmd1YWdlSWRzW2xhbmddO1xuXHQgICAgICAgICAgICBpZiAod2luTGFuZ3VhZ2UgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpbk5hbWUgPSBlbmNvZGUuVVRGMTYodGV4dCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luTmFtZU9mZnNldCA9IGFkZFN0cmluZ1RvUG9vbCh3aW5OYW1lLCBzdHJpbmdQb29sKTtcblx0ICAgICAgICAgICAgICAgIG5hbWVSZWNvcmRzLnB1c2gobWFrZU5hbWVSZWNvcmQoMywgMSwgd2luTGFuZ3VhZ2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVJRCwgd2luTmFtZS5sZW5ndGgsIHdpbk5hbWVPZmZzZXQpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgbmFtZVJlY29yZHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuICgoYS5wbGF0Zm9ybUlEIC0gYi5wbGF0Zm9ybUlEKSB8fFxuXHQgICAgICAgICAgICAgICAgKGEuZW5jb2RpbmdJRCAtIGIuZW5jb2RpbmdJRCkgfHxcblx0ICAgICAgICAgICAgICAgIChhLmxhbmd1YWdlSUQgLSBiLmxhbmd1YWdlSUQpIHx8XG5cdCAgICAgICAgICAgICAgICAoYS5uYW1lSUQgLSBiLm5hbWVJRCkpO1xuXHQgICAgfSk7XG5cblx0ICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCduYW1lJywgW1xuXHQgICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBuYW1lUmVjb3Jkcy5sZW5ndGh9LFxuXHQgICAgICAgIHtuYW1lOiAnc3RyaW5nT2Zmc2V0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiA2ICsgbmFtZVJlY29yZHMubGVuZ3RoICogMTJ9XG5cdCAgICBdKTtcblxuXHQgICAgZm9yICh2YXIgciA9IDA7IHIgPCBuYW1lUmVjb3Jkcy5sZW5ndGg7IHIrKykge1xuXHQgICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdyZWNvcmRfJyArIHIsIHR5cGU6ICdSRUNPUkQnLCB2YWx1ZTogbmFtZVJlY29yZHNbcl19KTtcblx0ICAgIH1cblxuXHQgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3N0cmluZ3MnLCB0eXBlOiAnTElURVJBTCcsIHZhbHVlOiBzdHJpbmdQb29sfSk7XG5cdCAgICByZXR1cm4gdDtcblx0fVxuXG5cdHZhciBfbmFtZSA9IHsgcGFyc2U6IHBhcnNlTmFtZVRhYmxlLCBtYWtlOiBtYWtlTmFtZVRhYmxlIH07XG5cblx0Ly8gVGhlIGBPUy8yYCB0YWJsZSBjb250YWlucyBtZXRyaWNzIHJlcXVpcmVkIGluIE9wZW5UeXBlIGZvbnRzLlxuXG5cdHZhciB1bmljb2RlUmFuZ2VzID0gW1xuXHQgICAge2JlZ2luOiAweDAwMDAsIGVuZDogMHgwMDdGfSwgLy8gQmFzaWMgTGF0aW5cblx0ICAgIHtiZWdpbjogMHgwMDgwLCBlbmQ6IDB4MDBGRn0sIC8vIExhdGluLTEgU3VwcGxlbWVudFxuXHQgICAge2JlZ2luOiAweDAxMDAsIGVuZDogMHgwMTdGfSwgLy8gTGF0aW4gRXh0ZW5kZWQtQVxuXHQgICAge2JlZ2luOiAweDAxODAsIGVuZDogMHgwMjRGfSwgLy8gTGF0aW4gRXh0ZW5kZWQtQlxuXHQgICAge2JlZ2luOiAweDAyNTAsIGVuZDogMHgwMkFGfSwgLy8gSVBBIEV4dGVuc2lvbnNcblx0ICAgIHtiZWdpbjogMHgwMkIwLCBlbmQ6IDB4MDJGRn0sIC8vIFNwYWNpbmcgTW9kaWZpZXIgTGV0dGVyc1xuXHQgICAge2JlZ2luOiAweDAzMDAsIGVuZDogMHgwMzZGfSwgLy8gQ29tYmluaW5nIERpYWNyaXRpY2FsIE1hcmtzXG5cdCAgICB7YmVnaW46IDB4MDM3MCwgZW5kOiAweDAzRkZ9LCAvLyBHcmVlayBhbmQgQ29wdGljXG5cdCAgICB7YmVnaW46IDB4MkM4MCwgZW5kOiAweDJDRkZ9LCAvLyBDb3B0aWNcblx0ICAgIHtiZWdpbjogMHgwNDAwLCBlbmQ6IDB4MDRGRn0sIC8vIEN5cmlsbGljXG5cdCAgICB7YmVnaW46IDB4MDUzMCwgZW5kOiAweDA1OEZ9LCAvLyBBcm1lbmlhblxuXHQgICAge2JlZ2luOiAweDA1OTAsIGVuZDogMHgwNUZGfSwgLy8gSGVicmV3XG5cdCAgICB7YmVnaW46IDB4QTUwMCwgZW5kOiAweEE2M0Z9LCAvLyBWYWlcblx0ICAgIHtiZWdpbjogMHgwNjAwLCBlbmQ6IDB4MDZGRn0sIC8vIEFyYWJpY1xuXHQgICAge2JlZ2luOiAweDA3QzAsIGVuZDogMHgwN0ZGfSwgLy8gTktvXG5cdCAgICB7YmVnaW46IDB4MDkwMCwgZW5kOiAweDA5N0Z9LCAvLyBEZXZhbmFnYXJpXG5cdCAgICB7YmVnaW46IDB4MDk4MCwgZW5kOiAweDA5RkZ9LCAvLyBCZW5nYWxpXG5cdCAgICB7YmVnaW46IDB4MEEwMCwgZW5kOiAweDBBN0Z9LCAvLyBHdXJtdWtoaVxuXHQgICAge2JlZ2luOiAweDBBODAsIGVuZDogMHgwQUZGfSwgLy8gR3VqYXJhdGlcblx0ICAgIHtiZWdpbjogMHgwQjAwLCBlbmQ6IDB4MEI3Rn0sIC8vIE9yaXlhXG5cdCAgICB7YmVnaW46IDB4MEI4MCwgZW5kOiAweDBCRkZ9LCAvLyBUYW1pbFxuXHQgICAge2JlZ2luOiAweDBDMDAsIGVuZDogMHgwQzdGfSwgLy8gVGVsdWd1XG5cdCAgICB7YmVnaW46IDB4MEM4MCwgZW5kOiAweDBDRkZ9LCAvLyBLYW5uYWRhXG5cdCAgICB7YmVnaW46IDB4MEQwMCwgZW5kOiAweDBEN0Z9LCAvLyBNYWxheWFsYW1cblx0ICAgIHtiZWdpbjogMHgwRTAwLCBlbmQ6IDB4MEU3Rn0sIC8vIFRoYWlcblx0ICAgIHtiZWdpbjogMHgwRTgwLCBlbmQ6IDB4MEVGRn0sIC8vIExhb1xuXHQgICAge2JlZ2luOiAweDEwQTAsIGVuZDogMHgxMEZGfSwgLy8gR2VvcmdpYW5cblx0ICAgIHtiZWdpbjogMHgxQjAwLCBlbmQ6IDB4MUI3Rn0sIC8vIEJhbGluZXNlXG5cdCAgICB7YmVnaW46IDB4MTEwMCwgZW5kOiAweDExRkZ9LCAvLyBIYW5ndWwgSmFtb1xuXHQgICAge2JlZ2luOiAweDFFMDAsIGVuZDogMHgxRUZGfSwgLy8gTGF0aW4gRXh0ZW5kZWQgQWRkaXRpb25hbFxuXHQgICAge2JlZ2luOiAweDFGMDAsIGVuZDogMHgxRkZGfSwgLy8gR3JlZWsgRXh0ZW5kZWRcblx0ICAgIHtiZWdpbjogMHgyMDAwLCBlbmQ6IDB4MjA2Rn0sIC8vIEdlbmVyYWwgUHVuY3R1YXRpb25cblx0ICAgIHtiZWdpbjogMHgyMDcwLCBlbmQ6IDB4MjA5Rn0sIC8vIFN1cGVyc2NyaXB0cyBBbmQgU3Vic2NyaXB0c1xuXHQgICAge2JlZ2luOiAweDIwQTAsIGVuZDogMHgyMENGfSwgLy8gQ3VycmVuY3kgU3ltYm9sXG5cdCAgICB7YmVnaW46IDB4MjBEMCwgZW5kOiAweDIwRkZ9LCAvLyBDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3MgRm9yIFN5bWJvbHNcblx0ICAgIHtiZWdpbjogMHgyMTAwLCBlbmQ6IDB4MjE0Rn0sIC8vIExldHRlcmxpa2UgU3ltYm9sc1xuXHQgICAge2JlZ2luOiAweDIxNTAsIGVuZDogMHgyMThGfSwgLy8gTnVtYmVyIEZvcm1zXG5cdCAgICB7YmVnaW46IDB4MjE5MCwgZW5kOiAweDIxRkZ9LCAvLyBBcnJvd3Ncblx0ICAgIHtiZWdpbjogMHgyMjAwLCBlbmQ6IDB4MjJGRn0sIC8vIE1hdGhlbWF0aWNhbCBPcGVyYXRvcnNcblx0ICAgIHtiZWdpbjogMHgyMzAwLCBlbmQ6IDB4MjNGRn0sIC8vIE1pc2NlbGxhbmVvdXMgVGVjaG5pY2FsXG5cdCAgICB7YmVnaW46IDB4MjQwMCwgZW5kOiAweDI0M0Z9LCAvLyBDb250cm9sIFBpY3R1cmVzXG5cdCAgICB7YmVnaW46IDB4MjQ0MCwgZW5kOiAweDI0NUZ9LCAvLyBPcHRpY2FsIENoYXJhY3RlciBSZWNvZ25pdGlvblxuXHQgICAge2JlZ2luOiAweDI0NjAsIGVuZDogMHgyNEZGfSwgLy8gRW5jbG9zZWQgQWxwaGFudW1lcmljc1xuXHQgICAge2JlZ2luOiAweDI1MDAsIGVuZDogMHgyNTdGfSwgLy8gQm94IERyYXdpbmdcblx0ICAgIHtiZWdpbjogMHgyNTgwLCBlbmQ6IDB4MjU5Rn0sIC8vIEJsb2NrIEVsZW1lbnRzXG5cdCAgICB7YmVnaW46IDB4MjVBMCwgZW5kOiAweDI1RkZ9LCAvLyBHZW9tZXRyaWMgU2hhcGVzXG5cdCAgICB7YmVnaW46IDB4MjYwMCwgZW5kOiAweDI2RkZ9LCAvLyBNaXNjZWxsYW5lb3VzIFN5bWJvbHNcblx0ICAgIHtiZWdpbjogMHgyNzAwLCBlbmQ6IDB4MjdCRn0sIC8vIERpbmdiYXRzXG5cdCAgICB7YmVnaW46IDB4MzAwMCwgZW5kOiAweDMwM0Z9LCAvLyBDSksgU3ltYm9scyBBbmQgUHVuY3R1YXRpb25cblx0ICAgIHtiZWdpbjogMHgzMDQwLCBlbmQ6IDB4MzA5Rn0sIC8vIEhpcmFnYW5hXG5cdCAgICB7YmVnaW46IDB4MzBBMCwgZW5kOiAweDMwRkZ9LCAvLyBLYXRha2FuYVxuXHQgICAge2JlZ2luOiAweDMxMDAsIGVuZDogMHgzMTJGfSwgLy8gQm9wb21vZm9cblx0ICAgIHtiZWdpbjogMHgzMTMwLCBlbmQ6IDB4MzE4Rn0sIC8vIEhhbmd1bCBDb21wYXRpYmlsaXR5IEphbW9cblx0ICAgIHtiZWdpbjogMHhBODQwLCBlbmQ6IDB4QTg3Rn0sIC8vIFBoYWdzLXBhXG5cdCAgICB7YmVnaW46IDB4MzIwMCwgZW5kOiAweDMyRkZ9LCAvLyBFbmNsb3NlZCBDSksgTGV0dGVycyBBbmQgTW9udGhzXG5cdCAgICB7YmVnaW46IDB4MzMwMCwgZW5kOiAweDMzRkZ9LCAvLyBDSksgQ29tcGF0aWJpbGl0eVxuXHQgICAge2JlZ2luOiAweEFDMDAsIGVuZDogMHhEN0FGfSwgLy8gSGFuZ3VsIFN5bGxhYmxlc1xuXHQgICAge2JlZ2luOiAweEQ4MDAsIGVuZDogMHhERkZGfSwgLy8gTm9uLVBsYW5lIDAgKlxuXHQgICAge2JlZ2luOiAweDEwOTAwLCBlbmQ6IDB4MTA5MUZ9LCAvLyBQaG9lbmljaWFcblx0ICAgIHtiZWdpbjogMHg0RTAwLCBlbmQ6IDB4OUZGRn0sIC8vIENKSyBVbmlmaWVkIElkZW9ncmFwaHNcblx0ICAgIHtiZWdpbjogMHhFMDAwLCBlbmQ6IDB4RjhGRn0sIC8vIFByaXZhdGUgVXNlIEFyZWEgKHBsYW5lIDApXG5cdCAgICB7YmVnaW46IDB4MzFDMCwgZW5kOiAweDMxRUZ9LCAvLyBDSksgU3Ryb2tlc1xuXHQgICAge2JlZ2luOiAweEZCMDAsIGVuZDogMHhGQjRGfSwgLy8gQWxwaGFiZXRpYyBQcmVzZW50YXRpb24gRm9ybXNcblx0ICAgIHtiZWdpbjogMHhGQjUwLCBlbmQ6IDB4RkRGRn0sIC8vIEFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQVxuXHQgICAge2JlZ2luOiAweEZFMjAsIGVuZDogMHhGRTJGfSwgLy8gQ29tYmluaW5nIEhhbGYgTWFya3Ncblx0ICAgIHtiZWdpbjogMHhGRTEwLCBlbmQ6IDB4RkUxRn0sIC8vIFZlcnRpY2FsIEZvcm1zXG5cdCAgICB7YmVnaW46IDB4RkU1MCwgZW5kOiAweEZFNkZ9LCAvLyBTbWFsbCBGb3JtIFZhcmlhbnRzXG5cdCAgICB7YmVnaW46IDB4RkU3MCwgZW5kOiAweEZFRkZ9LCAvLyBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcblx0ICAgIHtiZWdpbjogMHhGRjAwLCBlbmQ6IDB4RkZFRn0sIC8vIEhhbGZ3aWR0aCBBbmQgRnVsbHdpZHRoIEZvcm1zXG5cdCAgICB7YmVnaW46IDB4RkZGMCwgZW5kOiAweEZGRkZ9LCAvLyBTcGVjaWFsc1xuXHQgICAge2JlZ2luOiAweDBGMDAsIGVuZDogMHgwRkZGfSwgLy8gVGliZXRhblxuXHQgICAge2JlZ2luOiAweDA3MDAsIGVuZDogMHgwNzRGfSwgLy8gU3lyaWFjXG5cdCAgICB7YmVnaW46IDB4MDc4MCwgZW5kOiAweDA3QkZ9LCAvLyBUaGFhbmFcblx0ICAgIHtiZWdpbjogMHgwRDgwLCBlbmQ6IDB4MERGRn0sIC8vIFNpbmhhbGFcblx0ICAgIHtiZWdpbjogMHgxMDAwLCBlbmQ6IDB4MTA5Rn0sIC8vIE15YW5tYXJcblx0ICAgIHtiZWdpbjogMHgxMjAwLCBlbmQ6IDB4MTM3Rn0sIC8vIEV0aGlvcGljXG5cdCAgICB7YmVnaW46IDB4MTNBMCwgZW5kOiAweDEzRkZ9LCAvLyBDaGVyb2tlZVxuXHQgICAge2JlZ2luOiAweDE0MDAsIGVuZDogMHgxNjdGfSwgLy8gVW5pZmllZCBDYW5hZGlhbiBBYm9yaWdpbmFsIFN5bGxhYmljc1xuXHQgICAge2JlZ2luOiAweDE2ODAsIGVuZDogMHgxNjlGfSwgLy8gT2doYW1cblx0ICAgIHtiZWdpbjogMHgxNkEwLCBlbmQ6IDB4MTZGRn0sIC8vIFJ1bmljXG5cdCAgICB7YmVnaW46IDB4MTc4MCwgZW5kOiAweDE3RkZ9LCAvLyBLaG1lclxuXHQgICAge2JlZ2luOiAweDE4MDAsIGVuZDogMHgxOEFGfSwgLy8gTW9uZ29saWFuXG5cdCAgICB7YmVnaW46IDB4MjgwMCwgZW5kOiAweDI4RkZ9LCAvLyBCcmFpbGxlIFBhdHRlcm5zXG5cdCAgICB7YmVnaW46IDB4QTAwMCwgZW5kOiAweEE0OEZ9LCAvLyBZaSBTeWxsYWJsZXNcblx0ICAgIHtiZWdpbjogMHgxNzAwLCBlbmQ6IDB4MTcxRn0sIC8vIFRhZ2Fsb2dcblx0ICAgIHtiZWdpbjogMHgxMDMwMCwgZW5kOiAweDEwMzJGfSwgLy8gT2xkIEl0YWxpY1xuXHQgICAge2JlZ2luOiAweDEwMzMwLCBlbmQ6IDB4MTAzNEZ9LCAvLyBHb3RoaWNcblx0ICAgIHtiZWdpbjogMHgxMDQwMCwgZW5kOiAweDEwNDRGfSwgLy8gRGVzZXJldFxuXHQgICAge2JlZ2luOiAweDFEMDAwLCBlbmQ6IDB4MUQwRkZ9LCAvLyBCeXphbnRpbmUgTXVzaWNhbCBTeW1ib2xzXG5cdCAgICB7YmVnaW46IDB4MUQ0MDAsIGVuZDogMHgxRDdGRn0sIC8vIE1hdGhlbWF0aWNhbCBBbHBoYW51bWVyaWMgU3ltYm9sc1xuXHQgICAge2JlZ2luOiAweEZGMDAwLCBlbmQ6IDB4RkZGRkR9LCAvLyBQcml2YXRlIFVzZSAocGxhbmUgMTUpXG5cdCAgICB7YmVnaW46IDB4RkUwMCwgZW5kOiAweEZFMEZ9LCAvLyBWYXJpYXRpb24gU2VsZWN0b3JzXG5cdCAgICB7YmVnaW46IDB4RTAwMDAsIGVuZDogMHhFMDA3Rn0sIC8vIFRhZ3Ncblx0ICAgIHtiZWdpbjogMHgxOTAwLCBlbmQ6IDB4MTk0Rn0sIC8vIExpbWJ1XG5cdCAgICB7YmVnaW46IDB4MTk1MCwgZW5kOiAweDE5N0Z9LCAvLyBUYWkgTGVcblx0ICAgIHtiZWdpbjogMHgxOTgwLCBlbmQ6IDB4MTlERn0sIC8vIE5ldyBUYWkgTHVlXG5cdCAgICB7YmVnaW46IDB4MUEwMCwgZW5kOiAweDFBMUZ9LCAvLyBCdWdpbmVzZVxuXHQgICAge2JlZ2luOiAweDJDMDAsIGVuZDogMHgyQzVGfSwgLy8gR2xhZ29saXRpY1xuXHQgICAge2JlZ2luOiAweDJEMzAsIGVuZDogMHgyRDdGfSwgLy8gVGlmaW5hZ2hcblx0ICAgIHtiZWdpbjogMHg0REMwLCBlbmQ6IDB4NERGRn0sIC8vIFlpamluZyBIZXhhZ3JhbSBTeW1ib2xzXG5cdCAgICB7YmVnaW46IDB4QTgwMCwgZW5kOiAweEE4MkZ9LCAvLyBTeWxvdGkgTmFncmlcblx0ICAgIHtiZWdpbjogMHgxMDAwMCwgZW5kOiAweDEwMDdGfSwgLy8gTGluZWFyIEIgU3lsbGFiYXJ5XG5cdCAgICB7YmVnaW46IDB4MTAxNDAsIGVuZDogMHgxMDE4Rn0sIC8vIEFuY2llbnQgR3JlZWsgTnVtYmVyc1xuXHQgICAge2JlZ2luOiAweDEwMzgwLCBlbmQ6IDB4MTAzOUZ9LCAvLyBVZ2FyaXRpY1xuXHQgICAge2JlZ2luOiAweDEwM0EwLCBlbmQ6IDB4MTAzREZ9LCAvLyBPbGQgUGVyc2lhblxuXHQgICAge2JlZ2luOiAweDEwNDUwLCBlbmQ6IDB4MTA0N0Z9LCAvLyBTaGF2aWFuXG5cdCAgICB7YmVnaW46IDB4MTA0ODAsIGVuZDogMHgxMDRBRn0sIC8vIE9zbWFueWFcblx0ICAgIHtiZWdpbjogMHgxMDgwMCwgZW5kOiAweDEwODNGfSwgLy8gQ3lwcmlvdCBTeWxsYWJhcnlcblx0ICAgIHtiZWdpbjogMHgxMEEwMCwgZW5kOiAweDEwQTVGfSwgLy8gS2hhcm9zaHRoaVxuXHQgICAge2JlZ2luOiAweDFEMzAwLCBlbmQ6IDB4MUQzNUZ9LCAvLyBUYWkgWHVhbiBKaW5nIFN5bWJvbHNcblx0ICAgIHtiZWdpbjogMHgxMjAwMCwgZW5kOiAweDEyM0ZGfSwgLy8gQ3VuZWlmb3JtXG5cdCAgICB7YmVnaW46IDB4MUQzNjAsIGVuZDogMHgxRDM3Rn0sIC8vIENvdW50aW5nIFJvZCBOdW1lcmFsc1xuXHQgICAge2JlZ2luOiAweDFCODAsIGVuZDogMHgxQkJGfSwgLy8gU3VuZGFuZXNlXG5cdCAgICB7YmVnaW46IDB4MUMwMCwgZW5kOiAweDFDNEZ9LCAvLyBMZXBjaGFcblx0ICAgIHtiZWdpbjogMHgxQzUwLCBlbmQ6IDB4MUM3Rn0sIC8vIE9sIENoaWtpXG5cdCAgICB7YmVnaW46IDB4QTg4MCwgZW5kOiAweEE4REZ9LCAvLyBTYXVyYXNodHJhXG5cdCAgICB7YmVnaW46IDB4QTkwMCwgZW5kOiAweEE5MkZ9LCAvLyBLYXlhaCBMaVxuXHQgICAge2JlZ2luOiAweEE5MzAsIGVuZDogMHhBOTVGfSwgLy8gUmVqYW5nXG5cdCAgICB7YmVnaW46IDB4QUEwMCwgZW5kOiAweEFBNUZ9LCAvLyBDaGFtXG5cdCAgICB7YmVnaW46IDB4MTAxOTAsIGVuZDogMHgxMDFDRn0sIC8vIEFuY2llbnQgU3ltYm9sc1xuXHQgICAge2JlZ2luOiAweDEwMUQwLCBlbmQ6IDB4MTAxRkZ9LCAvLyBQaGFpc3RvcyBEaXNjXG5cdCAgICB7YmVnaW46IDB4MTAyQTAsIGVuZDogMHgxMDJERn0sIC8vIENhcmlhblxuXHQgICAge2JlZ2luOiAweDFGMDMwLCBlbmQ6IDB4MUYwOUZ9ICAvLyBEb21pbm8gVGlsZXNcblx0XTtcblxuXHRmdW5jdGlvbiBnZXRVbmljb2RlUmFuZ2UodW5pY29kZSkge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmljb2RlUmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIHJhbmdlID0gdW5pY29kZVJhbmdlc1tpXTtcblx0ICAgICAgICBpZiAodW5pY29kZSA+PSByYW5nZS5iZWdpbiAmJiB1bmljb2RlIDwgcmFuZ2UuZW5kKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIC0xO1xuXHR9XG5cblx0Ly8gUGFyc2UgdGhlIE9TLzIgYW5kIFdpbmRvd3MgbWV0cmljcyBgT1MvMmAgdGFibGVcblx0ZnVuY3Rpb24gcGFyc2VPUzJUYWJsZShkYXRhLCBzdGFydCkge1xuXHQgICAgdmFyIG9zMiA9IHt9O1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIG9zMi52ZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgb3MyLnhBdmdDaGFyV2lkdGggPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIG9zMi51c1dlaWdodENsYXNzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgb3MyLnVzV2lkdGhDbGFzcyA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIG9zMi5mc1R5cGUgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICBvczIueVN1YnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBvczIueVN1YnNjcmlwdFlTaXplID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBvczIueVN1YnNjcmlwdFhPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIG9zMi55U3Vic2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgb3MyLnlTdXBlcnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBvczIueVN1cGVyc2NyaXB0WVNpemUgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIG9zMi55U3VwZXJzY3JpcHRYT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBvczIueVN1cGVyc2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgb3MyLnlTdHJpa2VvdXRTaXplID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBvczIueVN0cmlrZW91dFBvc2l0aW9uID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBvczIuc0ZhbWlseUNsYXNzID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBvczIucGFub3NlID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0ICAgICAgICBvczIucGFub3NlW2ldID0gcC5wYXJzZUJ5dGUoKTtcblx0ICAgIH1cblxuXHQgICAgb3MyLnVsVW5pY29kZVJhbmdlMSA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgb3MyLnVsVW5pY29kZVJhbmdlMiA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgb3MyLnVsVW5pY29kZVJhbmdlMyA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgb3MyLnVsVW5pY29kZVJhbmdlNCA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgb3MyLmFjaFZlbmRJRCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKSk7XG5cdCAgICBvczIuZnNTZWxlY3Rpb24gPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICBvczIudXNGaXJzdENoYXJJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIG9zMi51c0xhc3RDaGFySW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICBvczIuc1R5cG9Bc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgb3MyLnNUeXBvRGVzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBvczIuc1R5cG9MaW5lR2FwID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBvczIudXNXaW5Bc2NlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICBvczIudXNXaW5EZXNjZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgaWYgKG9zMi52ZXJzaW9uID49IDEpIHtcblx0ICAgICAgICBvczIudWxDb2RlUGFnZVJhbmdlMSA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChvczIudmVyc2lvbiA+PSAyKSB7XG5cdCAgICAgICAgb3MyLnN4SGVpZ2h0ID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICAgICAgb3MyLnNDYXBIZWlnaHQgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgICAgICBvczIudXNEZWZhdWx0Q2hhciA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICBvczIudXNCcmVha0NoYXIgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgb3MyLnVzTWF4Q29udGVudCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG9zMjtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VPUzJUYWJsZShvcHRpb25zKSB7XG5cdCAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdPUy8yJywgW1xuXHQgICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMHgwMDAzfSxcblx0ICAgICAgICB7bmFtZTogJ3hBdmdDaGFyV2lkdGgnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICd1c1dlaWdodENsYXNzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VzV2lkdGhDbGFzcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdmc1R5cGUnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFhTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY1MH0sXG5cdCAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WVNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNjk5fSxcblx0ICAgICAgICB7bmFtZTogJ3lTdWJzY3JpcHRYT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFlPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMTQwfSxcblx0ICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFhTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY1MH0sXG5cdCAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRZU2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiA2OTl9LFxuXHQgICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WE9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFlPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNDc5fSxcblx0ICAgICAgICB7bmFtZTogJ3lTdHJpa2VvdXRTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDQ5fSxcblx0ICAgICAgICB7bmFtZTogJ3lTdHJpa2VvdXRQb3NpdGlvbicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAyNTh9LFxuXHQgICAgICAgIHtuYW1lOiAnc0ZhbWlseUNsYXNzJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnYkZhbWlseVR5cGUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2JTZXJpZlN0eWxlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdiV2VpZ2h0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdiUHJvcG9ydGlvbicsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnYkNvbnRyYXN0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdiU3Ryb2tlVmFyaWF0aW9uJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdiQXJtU3R5bGUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2JMZXR0ZXJmb3JtJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdiTWlkbGluZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnYlhIZWlnaHQnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMycsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlNCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2FjaFZlbmRJRCcsIHR5cGU6ICdDSEFSQVJSQVknLCB2YWx1ZTogJ1hYWFgnfSxcblx0ICAgICAgICB7bmFtZTogJ2ZzU2VsZWN0aW9uJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VzRmlyc3RDaGFySW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndXNMYXN0Q2hhckluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3NUeXBvQXNjZW5kZXInLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdzVHlwb0Rlc2NlbmRlcicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3NUeXBvTGluZUdhcCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VzV2luQXNjZW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VzV2luRGVzY2VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICd1bENvZGVQYWdlUmFuZ2UxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndWxDb2RlUGFnZVJhbmdlMicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3N4SGVpZ2h0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnc0NhcEhlaWdodCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VzRGVmYXVsdENoYXInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndXNCcmVha0NoYXInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndXNNYXhDb250ZXh0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuXHQgICAgXSwgb3B0aW9ucyk7XG5cdH1cblxuXHR2YXIgb3MyID0geyBwYXJzZTogcGFyc2VPUzJUYWJsZSwgbWFrZTogbWFrZU9TMlRhYmxlLCB1bmljb2RlUmFuZ2VzOiB1bmljb2RlUmFuZ2VzLCBnZXRVbmljb2RlUmFuZ2U6IGdldFVuaWNvZGVSYW5nZSB9O1xuXG5cdC8vIFRoZSBgcG9zdGAgdGFibGUgc3RvcmVzIGFkZGl0aW9uYWwgUG9zdFNjcmlwdCBpbmZvcm1hdGlvbiwgc3VjaCBhcyBnbHlwaCBuYW1lcy5cblxuXHQvLyBQYXJzZSB0aGUgUG9zdFNjcmlwdCBgcG9zdGAgdGFibGVcblx0ZnVuY3Rpb24gcGFyc2VQb3N0VGFibGUoZGF0YSwgc3RhcnQpIHtcblx0ICAgIHZhciBwb3N0ID0ge307XG5cdCAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgcG9zdC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcblx0ICAgIHBvc3QuaXRhbGljQW5nbGUgPSBwLnBhcnNlRml4ZWQoKTtcblx0ICAgIHBvc3QudW5kZXJsaW5lUG9zaXRpb24gPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIHBvc3QudW5kZXJsaW5lVGhpY2tuZXNzID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBwb3N0LmlzRml4ZWRQaXRjaCA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgcG9zdC5taW5NZW1UeXBlNDIgPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgIHBvc3QubWF4TWVtVHlwZTQyID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICBwb3N0Lm1pbk1lbVR5cGUxID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICBwb3N0Lm1heE1lbVR5cGUxID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICBzd2l0Y2ggKHBvc3QudmVyc2lvbikge1xuXHQgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgcG9zdC5uYW1lcyA9IHN0YW5kYXJkTmFtZXMuc2xpY2UoKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICBwb3N0Lm51bWJlck9mR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgcG9zdC5nbHlwaE5hbWVJbmRleFtpXSA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHBvc3QubmFtZXMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSQxKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChwb3N0LmdseXBoTmFtZUluZGV4W2kkMV0gPj0gc3RhbmRhcmROYW1lcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZUxlbmd0aCA9IHAucGFyc2VDaGFyKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcG9zdC5uYW1lcy5wdXNoKHAucGFyc2VTdHJpbmcobmFtZUxlbmd0aCkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAyLjU6XG5cdCAgICAgICAgICAgIHBvc3QubnVtYmVyT2ZHbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgICAgIHBvc3Qub2Zmc2V0ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpJDIrKykge1xuXHQgICAgICAgICAgICAgICAgcG9zdC5vZmZzZXRbaSQyXSA9IHAucGFyc2VDaGFyKCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgIH1cblx0ICAgIHJldHVybiBwb3N0O1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZVBvc3RUYWJsZSgpIHtcblx0ICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3Bvc3QnLCBbXG5cdCAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMzAwMDB9LFxuXHQgICAgICAgIHtuYW1lOiAnaXRhbGljQW5nbGUnLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICd1bmRlcmxpbmVQb3NpdGlvbicsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VuZGVybGluZVRoaWNrbmVzcycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2lzRml4ZWRQaXRjaCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ21pbk1lbVR5cGU0MicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ21heE1lbVR5cGU0MicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ21pbk1lbVR5cGUxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbWF4TWVtVHlwZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH1cblx0ICAgIF0pO1xuXHR9XG5cblx0dmFyIHBvc3QgPSB7IHBhcnNlOiBwYXJzZVBvc3RUYWJsZSwgbWFrZTogbWFrZVBvc3RUYWJsZSB9O1xuXG5cdC8vIFRoZSBgR1NVQmAgdGFibGUgY29udGFpbnMgbGlnYXR1cmVzLCBhbW9uZyBvdGhlciB0aGluZ3MuXG5cblx0dmFyIHN1YnRhYmxlUGFyc2VycyA9IG5ldyBBcnJheSg5KTsgICAgICAgICAvLyBzdWJ0YWJsZVBhcnNlcnNbMF0gaXMgdW51c2VkXG5cblx0Ly8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNTU1xuXHRzdWJ0YWJsZVBhcnNlcnNbMV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDEoKSB7XG5cdCAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG5cdCAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICBpZiAoc3Vic3RGb3JtYXQgPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBzdWJzdEZvcm1hdDogMSxcblx0ICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG5cdCAgICAgICAgICAgIGRlbHRhR2x5cGhJZDogdGhpcy5wYXJzZVVTaG9ydCgpXG5cdCAgICAgICAgfTtcblx0ICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDIpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBzdWJzdEZvcm1hdDogMixcblx0ICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG5cdCAgICAgICAgICAgIHN1YnN0aXR1dGU6IHRoaXMucGFyc2VPZmZzZXQxNkxpc3QoKVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBjaGVjay5hc3NlcnQoZmFsc2UsICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBsb29rdXAgdHlwZSAxIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcblx0fTtcblxuXHQvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI01TXG5cdHN1YnRhYmxlUGFyc2Vyc1syXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMigpIHtcblx0ICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIGNoZWNrLmFyZ3VtZW50KHN1YnN0Rm9ybWF0ID09PSAxLCAnR1NVQiBNdWx0aXBsZSBTdWJzdGl0dXRpb24gU3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJyk7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcblx0ICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcblx0ICAgICAgICBzZXF1ZW5jZXM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cygpXG5cdCAgICB9O1xuXHR9O1xuXG5cdC8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jQVNcblx0c3VidGFibGVQYXJzZXJzWzNdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAzKCkge1xuXHQgICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgY2hlY2suYXJndW1lbnQoc3Vic3RGb3JtYXQgPT09IDEsICdHU1VCIEFsdGVybmF0ZSBTdWJzdGl0dXRpb24gU3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJyk7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcblx0ICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcblx0ICAgICAgICBhbHRlcm5hdGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoKVxuXHQgICAgfTtcblx0fTtcblxuXHQvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0xTXG5cdHN1YnRhYmxlUGFyc2Vyc1s0XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNCgpIHtcblx0ICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIGNoZWNrLmFyZ3VtZW50KHN1YnN0Rm9ybWF0ID09PSAxLCAnR1NVQiBsaWdhdHVyZSB0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuXHQgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuXHQgICAgICAgIGxpZ2F0dXJlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgbGlnR2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSxcblx0ICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VVU2hvcnQoKSAtIDEpXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSlcblx0ICAgIH07XG5cdH07XG5cblx0dmFyIGxvb2t1cFJlY29yZERlc2MgPSB7XG5cdCAgICBzZXF1ZW5jZUluZGV4OiBQYXJzZXIudVNob3J0LFxuXHQgICAgbG9va3VwTGlzdEluZGV4OiBQYXJzZXIudVNob3J0XG5cdH07XG5cblx0Ly8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNDU0Zcblx0c3VidGFibGVQYXJzZXJzWzVdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA1KCkge1xuXHQgICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuXHQgICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXG5cdCAgICBpZiAoc3Vic3RGb3JtYXQgPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG5cdCAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuXHQgICAgICAgICAgICBydWxlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGdseXBoQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3Vic3RDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KGdseXBoQ291bnQgLSAxKSxcblx0ICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChzdWJzdENvdW50LCBsb29rdXBSZWNvcmREZXNjKVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSlcblx0ICAgICAgICB9O1xuXHQgICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcblx0ICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG5cdCAgICAgICAgICAgIGNsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuXHQgICAgICAgICAgICBjbGFzc1NldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnN0Q291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGNsYXNzZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KGdseXBoQ291bnQgLSAxKSxcblx0ICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChzdWJzdENvdW50LCBsb29rdXBSZWNvcmREZXNjKVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSlcblx0ICAgICAgICB9O1xuXHQgICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMykge1xuXHQgICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIHZhciBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcblx0ICAgICAgICAgICAgY292ZXJhZ2VzOiB0aGlzLnBhcnNlTGlzdChnbHlwaENvdW50LCBQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcblx0ICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3Qoc3Vic3RDb3VudCwgbG9va3VwUmVjb3JkRGVzYylcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogbG9va3VwIHR5cGUgNSBmb3JtYXQgbXVzdCBiZSAxLCAyIG9yIDMuJyk7XG5cdH07XG5cblx0Ly8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNDQ1xuXHRzdWJ0YWJsZVBhcnNlcnNbNl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDYoKSB7XG5cdCAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG5cdCAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICBpZiAoc3Vic3RGb3JtYXQgPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBzdWJzdEZvcm1hdDogMSxcblx0ICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG5cdCAgICAgICAgICAgIGNoYWluUnVsZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFja3RyYWNrOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuXHQgICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlU2hvcnQoKSAtIDEpLFxuXHQgICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZDogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcblx0ICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChsb29rdXBSZWNvcmREZXNjKVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSlcblx0ICAgICAgICB9O1xuXHQgICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAyLFxuXHQgICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcblx0ICAgICAgICAgICAgYmFja3RyYWNrQ2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG5cdCAgICAgICAgICAgIGlucHV0Q2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG5cdCAgICAgICAgICAgIGxvb2thaGVhZENsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuXHQgICAgICAgICAgICBjaGFpbkNsYXNzU2V0OiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhY2t0cmFjazogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcblx0ICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy5wYXJzZVVTaG9ydExpc3QodGhpcy5wYXJzZVNob3J0KCkgLSAxKSxcblx0ICAgICAgICAgICAgICAgICAgICBsb29rYWhlYWQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG5cdCAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYylcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pXG5cdCAgICAgICAgfTtcblx0ICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDMpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBzdWJzdEZvcm1hdDogMyxcblx0ICAgICAgICAgICAgYmFja3RyYWNrQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuXHQgICAgICAgICAgICBpbnB1dENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcblx0ICAgICAgICAgICAgbG9va2FoZWFkQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuXHQgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChsb29rdXBSZWNvcmREZXNjKVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBjaGVjay5hc3NlcnQoZmFsc2UsICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBsb29rdXAgdHlwZSA2IGZvcm1hdCBtdXN0IGJlIDEsIDIgb3IgMy4nKTtcblx0fTtcblxuXHQvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0VTXG5cdHN1YnRhYmxlUGFyc2Vyc1s3XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNygpIHtcblx0ICAgIC8vIEV4dGVuc2lvbiBTdWJzdGl0dXRpb24gc3VidGFibGVcblx0ICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIGNoZWNrLmFyZ3VtZW50KHN1YnN0Rm9ybWF0ID09PSAxLCAnR1NVQiBFeHRlbnNpb24gU3Vic3RpdHV0aW9uIHN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMScpO1xuXHQgICAgdmFyIGV4dGVuc2lvbkxvb2t1cFR5cGUgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICB2YXIgZXh0ZW5zaW9uUGFyc2VyID0gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5wYXJzZVVMb25nKCkpO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICBzdWJzdEZvcm1hdDogMSxcblx0ICAgICAgICBsb29rdXBUeXBlOiBleHRlbnNpb25Mb29rdXBUeXBlLFxuXHQgICAgICAgIGV4dGVuc2lvbjogc3VidGFibGVQYXJzZXJzW2V4dGVuc2lvbkxvb2t1cFR5cGVdLmNhbGwoZXh0ZW5zaW9uUGFyc2VyKVxuXHQgICAgfTtcblx0fTtcblxuXHQvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI1JDQ1Ncblx0c3VidGFibGVQYXJzZXJzWzhdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA4KCkge1xuXHQgICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgY2hlY2suYXJndW1lbnQoc3Vic3RGb3JtYXQgPT09IDEsICdHU1VCIFJldmVyc2UgQ2hhaW5pbmcgQ29udGV4dHVhbCBTaW5nbGUgU3Vic3RpdHV0aW9uIFN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMScpO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG5cdCAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG5cdCAgICAgICAgYmFja3RyYWNrQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuXHQgICAgICAgIGxvb2thaGVhZENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcblx0ICAgICAgICBzdWJzdGl0dXRlczogdGhpcy5wYXJzZVVTaG9ydExpc3QoKVxuXHQgICAgfTtcblx0fTtcblxuXHQvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2dzdWIuaHRtXG5cdGZ1bmN0aW9uIHBhcnNlR3N1YlRhYmxlKGRhdGEsIHN0YXJ0KSB7XG5cdCAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG5cdCAgICB2YXIgcCA9IG5ldyBQYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKDEpO1xuXHQgICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxIHx8IHRhYmxlVmVyc2lvbiA9PT0gMS4xLCAnVW5zdXBwb3J0ZWQgR1NVQiB0YWJsZSB2ZXJzaW9uLicpO1xuXHQgICAgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcblx0ICAgICAgICAgICAgc2NyaXB0czogcC5wYXJzZVNjcmlwdExpc3QoKSxcblx0ICAgICAgICAgICAgZmVhdHVyZXM6IHAucGFyc2VGZWF0dXJlTGlzdCgpLFxuXHQgICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMpXG5cdCAgICAgICAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuXHQgICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuXHQgICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG5cdCAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycyksXG5cdCAgICAgICAgICAgIHZhcmlhdGlvbnM6IHAucGFyc2VGZWF0dXJlVmFyaWF0aW9uc0xpc3QoKVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cblx0fVxuXG5cdC8vIEdTVUIgV3JpdGluZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdHZhciBzdWJ0YWJsZU1ha2VycyA9IG5ldyBBcnJheSg5KTtcblxuXHRzdWJ0YWJsZU1ha2Vyc1sxXSA9IGZ1bmN0aW9uIG1ha2VMb29rdXAxKHN1YnRhYmxlKSB7XG5cdCAgICBpZiAoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdzdWJzdGl0dXRpb25UYWJsZScsIFtcblx0ICAgICAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG5cdCAgICAgICAgICAgIHtuYW1lOiAnY292ZXJhZ2UnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKX0sXG5cdCAgICAgICAgICAgIHtuYW1lOiAnZGVsdGFHbHlwaElEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzdWJ0YWJsZS5kZWx0YUdseXBoSWR9XG5cdCAgICAgICAgXSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3N1YnN0aXR1dGlvblRhYmxlJywgW1xuXHQgICAgICAgICAgICB7bmFtZTogJ3N1YnN0Rm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAyfSxcblx0ICAgICAgICAgICAge25hbWU6ICdjb3ZlcmFnZScsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpfVxuXHQgICAgICAgIF0uY29uY2F0KHRhYmxlLnVzaG9ydExpc3QoJ3N1YnN0aXR1dGUnLCBzdWJ0YWJsZS5zdWJzdGl0dXRlKSkpO1xuXHQgICAgfVxuXHR9O1xuXG5cdHN1YnRhYmxlTWFrZXJzWzJdID0gZnVuY3Rpb24gbWFrZUxvb2t1cDIoc3VidGFibGUpIHtcblx0ICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMSwgJ0xvb2t1cCB0eXBlIDIgc3Vic3RGb3JtYXQgbXVzdCBiZSAxLicpO1xuXHQgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG5cdCAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG5cdCAgICAgICAge25hbWU6ICdjb3ZlcmFnZScsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpfVxuXHQgICAgXS5jb25jYXQodGFibGUudGFibGVMaXN0KCdzZXFTZXQnLCBzdWJ0YWJsZS5zZXF1ZW5jZXMsIGZ1bmN0aW9uKHNlcXVlbmNlU2V0KSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc2VxdWVuY2VTZXRUYWJsZScsIHRhYmxlLnVzaG9ydExpc3QoJ3NlcXVlbmNlJywgc2VxdWVuY2VTZXQpKTtcblx0ICAgIH0pKSk7XG5cdH07XG5cblx0c3VidGFibGVNYWtlcnNbM10gPSBmdW5jdGlvbiBtYWtlTG9va3VwMyhzdWJ0YWJsZSkge1xuXHQgICAgY2hlY2suYXNzZXJ0KHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxLCAnTG9va3VwIHR5cGUgMyBzdWJzdEZvcm1hdCBtdXN0IGJlIDEuJyk7XG5cdCAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdzdWJzdGl0dXRpb25UYWJsZScsIFtcblx0ICAgICAgICB7bmFtZTogJ3N1YnN0Rm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfSxcblx0ICAgICAgICB7bmFtZTogJ2NvdmVyYWdlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSl9XG5cdCAgICBdLmNvbmNhdCh0YWJsZS50YWJsZUxpc3QoJ2FsdFNldCcsIHN1YnRhYmxlLmFsdGVybmF0ZVNldHMsIGZ1bmN0aW9uKGFsdGVybmF0ZVNldCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2FsdGVybmF0ZVNldFRhYmxlJywgdGFibGUudXNob3J0TGlzdCgnYWx0ZXJuYXRlJywgYWx0ZXJuYXRlU2V0KSk7XG5cdCAgICB9KSkpO1xuXHR9O1xuXG5cdHN1YnRhYmxlTWFrZXJzWzRdID0gZnVuY3Rpb24gbWFrZUxvb2t1cDQoc3VidGFibGUpIHtcblx0ICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMSwgJ0xvb2t1cCB0eXBlIDQgc3Vic3RGb3JtYXQgbXVzdCBiZSAxLicpO1xuXHQgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG5cdCAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG5cdCAgICAgICAge25hbWU6ICdjb3ZlcmFnZScsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpfVxuXHQgICAgXS5jb25jYXQodGFibGUudGFibGVMaXN0KCdsaWdTZXQnLCBzdWJ0YWJsZS5saWdhdHVyZVNldHMsIGZ1bmN0aW9uKGxpZ2F0dXJlU2V0KSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnbGlnYXR1cmVTZXRUYWJsZScsIHRhYmxlLnRhYmxlTGlzdCgnbGlnYXR1cmUnLCBsaWdhdHVyZVNldCwgZnVuY3Rpb24obGlnYXR1cmUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnbGlnYXR1cmVUYWJsZScsXG5cdCAgICAgICAgICAgICAgICBbe25hbWU6ICdsaWdHbHlwaCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGlnYXR1cmUubGlnR2x5cGh9XVxuXHQgICAgICAgICAgICAgICAgLmNvbmNhdCh0YWJsZS51c2hvcnRMaXN0KCdjb21wb25lbnQnLCBsaWdhdHVyZS5jb21wb25lbnRzLCBsaWdhdHVyZS5jb21wb25lbnRzLmxlbmd0aCArIDEpKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgIH0pKTtcblx0ICAgIH0pKSk7XG5cdH07XG5cblx0c3VidGFibGVNYWtlcnNbNl0gPSBmdW5jdGlvbiBtYWtlTG9va3VwNihzdWJ0YWJsZSkge1xuXHQgICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxKSB7XG5cdCAgICAgICAgdmFyIHJldHVyblRhYmxlID0gbmV3IHRhYmxlLlRhYmxlKCdjaGFpbkNvbnRleHRUYWJsZScsIFtcblx0ICAgICAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3VidGFibGUuc3Vic3RGb3JtYXR9LFxuXHQgICAgICAgICAgICB7bmFtZTogJ2NvdmVyYWdlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSl9XG5cdCAgICAgICAgXS5jb25jYXQodGFibGUudGFibGVMaXN0KCdjaGFpblJ1bGVTZXQnLCBzdWJ0YWJsZS5jaGFpblJ1bGVTZXRzLCBmdW5jdGlvbihjaGFpblJ1bGVTZXQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnY2hhaW5SdWxlU2V0VGFibGUnLCB0YWJsZS50YWJsZUxpc3QoJ2NoYWluUnVsZScsIGNoYWluUnVsZVNldCwgZnVuY3Rpb24oY2hhaW5SdWxlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGFibGVEYXRhID0gdGFibGUudXNob3J0TGlzdCgnYmFja3RyYWNrR2x5cGgnLCBjaGFpblJ1bGUuYmFja3RyYWNrLCBjaGFpblJ1bGUuYmFja3RyYWNrLmxlbmd0aClcblx0ICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHRhYmxlLnVzaG9ydExpc3QoJ2lucHV0R2x5cGgnLCBjaGFpblJ1bGUuaW5wdXQsIGNoYWluUnVsZS5pbnB1dC5sZW5ndGggKyAxKSlcblx0ICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHRhYmxlLnVzaG9ydExpc3QoJ2xvb2thaGVhZEdseXBoJywgY2hhaW5SdWxlLmxvb2thaGVhZCwgY2hhaW5SdWxlLmxvb2thaGVhZC5sZW5ndGgpKVxuXHQgICAgICAgICAgICAgICAgICAgIC5jb25jYXQodGFibGUudXNob3J0TGlzdCgnc3Vic3RpdHV0aW9uJywgW10sIGNoYWluUnVsZS5sb29rdXBSZWNvcmRzLmxlbmd0aCkpO1xuXG5cdCAgICAgICAgICAgICAgICBjaGFpblJ1bGUubG9va3VwUmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQsIGkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0YWJsZURhdGEgPSB0YWJsZURhdGFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh7bmFtZTogJ3NlcXVlbmNlSW5kZXgnICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiByZWNvcmQuc2VxdWVuY2VJbmRleH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoe25hbWU6ICdsb29rdXBMaXN0SW5kZXgnICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiByZWNvcmQubG9va3VwTGlzdEluZGV4fSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2NoYWluUnVsZVRhYmxlJywgdGFibGVEYXRhKTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH0pKSk7XG5cdCAgICAgICAgcmV0dXJuIHJldHVyblRhYmxlO1xuXHQgICAgfSBlbHNlIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMikge1xuXHQgICAgICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJ2xvb2t1cCB0eXBlIDYgZm9ybWF0IDIgaXMgbm90IHlldCBzdXBwb3J0ZWQuJyk7XG5cdCAgICB9IGVsc2UgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAzKSB7XG5cdCAgICAgICAgdmFyIHRhYmxlRGF0YSA9IFtcblx0ICAgICAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3VidGFibGUuc3Vic3RGb3JtYXR9IF07XG5cblx0ICAgICAgICB0YWJsZURhdGEucHVzaCh7bmFtZTogJ2JhY2t0cmFja0dseXBoQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHN1YnRhYmxlLmJhY2t0cmFja0NvdmVyYWdlLmxlbmd0aH0pO1xuXHQgICAgICAgIHN1YnRhYmxlLmJhY2t0cmFja0NvdmVyYWdlLmZvckVhY2goZnVuY3Rpb24gKGNvdmVyYWdlLCBpKSB7XG5cdCAgICAgICAgICAgIHRhYmxlRGF0YS5wdXNoKHtuYW1lOiAnYmFja3RyYWNrQ292ZXJhZ2UnICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShjb3ZlcmFnZSl9KTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0YWJsZURhdGEucHVzaCh7bmFtZTogJ2lucHV0R2x5cGhDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3VidGFibGUuaW5wdXRDb3ZlcmFnZS5sZW5ndGh9KTtcblx0ICAgICAgICBzdWJ0YWJsZS5pbnB1dENvdmVyYWdlLmZvckVhY2goZnVuY3Rpb24gKGNvdmVyYWdlLCBpKSB7XG5cdCAgICAgICAgICAgIHRhYmxlRGF0YS5wdXNoKHtuYW1lOiAnaW5wdXRDb3ZlcmFnZScgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKGNvdmVyYWdlKX0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRhYmxlRGF0YS5wdXNoKHtuYW1lOiAnbG9va2FoZWFkR2x5cGhDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UubGVuZ3RofSk7XG5cdCAgICAgICAgc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UuZm9yRWFjaChmdW5jdGlvbiAoY292ZXJhZ2UsIGkpIHtcblx0ICAgICAgICAgICAgdGFibGVEYXRhLnB1c2goe25hbWU6ICdsb29rYWhlYWRDb3ZlcmFnZScgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKGNvdmVyYWdlKX0pO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgdGFibGVEYXRhLnB1c2goe25hbWU6ICdzdWJzdGl0dXRpb25Db3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3VidGFibGUubG9va3VwUmVjb3Jkcy5sZW5ndGh9KTtcblx0ICAgICAgICBzdWJ0YWJsZS5sb29rdXBSZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCwgaSkge1xuXHQgICAgICAgICAgICB0YWJsZURhdGEgPSB0YWJsZURhdGFcblx0ICAgICAgICAgICAgICAgIC5jb25jYXQoe25hbWU6ICdzZXF1ZW5jZUluZGV4JyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogcmVjb3JkLnNlcXVlbmNlSW5kZXh9KVxuXHQgICAgICAgICAgICAgICAgLmNvbmNhdCh7bmFtZTogJ2xvb2t1cExpc3RJbmRleCcgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHJlY29yZC5sb29rdXBMaXN0SW5kZXh9KTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHZhciByZXR1cm5UYWJsZSQxID0gbmV3IHRhYmxlLlRhYmxlKCdjaGFpbkNvbnRleHRUYWJsZScsIHRhYmxlRGF0YSk7XG5cblx0ICAgICAgICByZXR1cm4gcmV0dXJuVGFibGUkMTtcblx0ICAgIH1cblxuXHQgICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnbG9va3VwIHR5cGUgNiBmb3JtYXQgbXVzdCBiZSAxLCAyIG9yIDMuJyk7XG5cdH07XG5cblx0ZnVuY3Rpb24gbWFrZUdzdWJUYWJsZShnc3ViKSB7XG5cdCAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdHU1VCJywgW1xuXHQgICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAweDEwMDAwfSxcblx0ICAgICAgICB7bmFtZTogJ3NjcmlwdHMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLlNjcmlwdExpc3QoZ3N1Yi5zY3JpcHRzKX0sXG5cdCAgICAgICAge25hbWU6ICdmZWF0dXJlcycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuRmVhdHVyZUxpc3QoZ3N1Yi5mZWF0dXJlcyl9LFxuXHQgICAgICAgIHtuYW1lOiAnbG9va3VwcycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuTG9va3VwTGlzdChnc3ViLmxvb2t1cHMsIHN1YnRhYmxlTWFrZXJzKX1cblx0ICAgIF0pO1xuXHR9XG5cblx0dmFyIGdzdWIgPSB7IHBhcnNlOiBwYXJzZUdzdWJUYWJsZSwgbWFrZTogbWFrZUdzdWJUYWJsZSB9O1xuXG5cdC8vIFRoZSBgR1BPU2AgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycywgYW1vbmcgb3RoZXIgdGhpbmdzLlxuXG5cdC8vIFBhcnNlIHRoZSBtZXRhZGF0YSBgbWV0YWAgdGFibGUuXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb250cy9UcnVlVHlwZS1SZWZlcmVuY2UtTWFudWFsL1JNMDYvQ2hhcDZtZXRhLmh0bWxcblx0ZnVuY3Rpb24gcGFyc2VNZXRhVGFibGUoZGF0YSwgc3RhcnQpIHtcblx0ICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cdCAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBNRVRBIHRhYmxlIHZlcnNpb24uJyk7XG5cdCAgICBwLnBhcnNlVUxvbmcoKTsgLy8gZmxhZ3MgLSBjdXJyZW50bHkgdW51c2VkIGFuZCBzZXQgdG8gMFxuXHQgICAgcC5wYXJzZVVMb25nKCk7IC8vIHRhYmxlT2Zmc2V0XG5cdCAgICB2YXIgbnVtRGF0YU1hcHMgPSBwLnBhcnNlVUxvbmcoKTtcblxuXHQgICAgdmFyIHRhZ3MgPSB7fTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGF0YU1hcHM7IGkrKykge1xuXHQgICAgICAgIHZhciB0YWcgPSBwLnBhcnNlVGFnKCk7XG5cdCAgICAgICAgdmFyIGRhdGFPZmZzZXQgPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgICAgICB2YXIgZGF0YUxlbmd0aCA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgICAgIHZhciB0ZXh0ID0gZGVjb2RlLlVURjgoZGF0YSwgc3RhcnQgKyBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoKTtcblxuXHQgICAgICAgIHRhZ3NbdGFnXSA9IHRleHQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGFncztcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VNZXRhVGFibGUodGFncykge1xuXHQgICAgdmFyIG51bVRhZ3MgPSBPYmplY3Qua2V5cyh0YWdzKS5sZW5ndGg7XG5cdCAgICB2YXIgc3RyaW5nUG9vbCA9ICcnO1xuXHQgICAgdmFyIHN0cmluZ1Bvb2xPZmZzZXQgPSAxNiArIG51bVRhZ3MgKiAxMjtcblxuXHQgICAgdmFyIHJlc3VsdCA9IG5ldyB0YWJsZS5UYWJsZSgnbWV0YScsIFtcblx0ICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMX0sXG5cdCAgICAgICAge25hbWU6ICdmbGFncycsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBzdHJpbmdQb29sT2Zmc2V0fSxcblx0ICAgICAgICB7bmFtZTogJ251bVRhZ3MnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogbnVtVGFnc31cblx0ICAgIF0pO1xuXG5cdCAgICBmb3IgKHZhciB0YWcgaW4gdGFncykge1xuXHQgICAgICAgIHZhciBwb3MgPSBzdHJpbmdQb29sLmxlbmd0aDtcblx0ICAgICAgICBzdHJpbmdQb29sICs9IHRhZ3NbdGFnXTtcblxuXHQgICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ3RhZyAnICsgdGFnLCB0eXBlOiAnVEFHJywgdmFsdWU6IHRhZ30pO1xuXHQgICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ29mZnNldCAnICsgdGFnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogc3RyaW5nUG9vbE9mZnNldCArIHBvc30pO1xuXHQgICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ2xlbmd0aCAnICsgdGFnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogdGFnc1t0YWddLmxlbmd0aH0pO1xuXHQgICAgfVxuXG5cdCAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdzdHJpbmdQb29sJywgdHlwZTogJ0NIQVJBUlJBWScsIHZhbHVlOiBzdHJpbmdQb29sfSk7XG5cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHR2YXIgbWV0YSA9IHsgcGFyc2U6IHBhcnNlTWV0YVRhYmxlLCBtYWtlOiBtYWtlTWV0YVRhYmxlIH07XG5cblx0Ly8gVGhlIGBzZm50YCB3cmFwcGVyIHByb3ZpZGVzIG9yZ2FuaXphdGlvbiBmb3IgdGhlIHRhYmxlcyBpbiB0aGUgZm9udC5cblxuXHRmdW5jdGlvbiBsb2cyKHYpIHtcblx0ICAgIHJldHVybiBNYXRoLmxvZyh2KSAvIE1hdGgubG9nKDIpIHwgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXB1dGVDaGVja1N1bShieXRlcykge1xuXHQgICAgd2hpbGUgKGJ5dGVzLmxlbmd0aCAlIDQgIT09IDApIHtcblx0ICAgICAgICBieXRlcy5wdXNoKDApO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgc3VtID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDQpIHtcblx0ICAgICAgICBzdW0gKz0gKGJ5dGVzW2ldIDw8IDI0KSArXG5cdCAgICAgICAgICAgIChieXRlc1tpICsgMV0gPDwgMTYpICtcblx0ICAgICAgICAgICAgKGJ5dGVzW2kgKyAyXSA8PCA4KSArXG5cdCAgICAgICAgICAgIChieXRlc1tpICsgM10pO1xuXHQgICAgfVxuXG5cdCAgICBzdW0gJT0gTWF0aC5wb3coMiwgMzIpO1xuXHQgICAgcmV0dXJuIHN1bTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VUYWJsZVJlY29yZCh0YWcsIGNoZWNrU3VtLCBvZmZzZXQsIGxlbmd0aCkge1xuXHQgICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ1RhYmxlIFJlY29yZCcsIFtcblx0ICAgICAgICB7bmFtZTogJ3RhZycsIHR5cGU6ICdUQUcnLCB2YWx1ZTogdGFnICE9PSB1bmRlZmluZWQgPyB0YWcgOiAnJ30sXG5cdCAgICAgICAge25hbWU6ICdjaGVja1N1bScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBjaGVja1N1bSAhPT0gdW5kZWZpbmVkID8gY2hlY2tTdW0gOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBvZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9mZnNldCA6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbGVuZ3RoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGxlbmd0aCAhPT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogMH1cblx0ICAgIF0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZVNmbnRUYWJsZSh0YWJsZXMpIHtcblx0ICAgIHZhciBzZm50ID0gbmV3IHRhYmxlLlRhYmxlKCdzZm50JywgW1xuXHQgICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdUQUcnLCB2YWx1ZTogJ09UVE8nfSxcblx0ICAgICAgICB7bmFtZTogJ251bVRhYmxlcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdzZWFyY2hSYW5nZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdlbnRyeVNlbGVjdG9yJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3JhbmdlU2hpZnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG5cdCAgICBdKTtcblx0ICAgIHNmbnQudGFibGVzID0gdGFibGVzO1xuXHQgICAgc2ZudC5udW1UYWJsZXMgPSB0YWJsZXMubGVuZ3RoO1xuXHQgICAgdmFyIGhpZ2hlc3RQb3dlck9mMiA9IE1hdGgucG93KDIsIGxvZzIoc2ZudC5udW1UYWJsZXMpKTtcblx0ICAgIHNmbnQuc2VhcmNoUmFuZ2UgPSAxNiAqIGhpZ2hlc3RQb3dlck9mMjtcblx0ICAgIHNmbnQuZW50cnlTZWxlY3RvciA9IGxvZzIoaGlnaGVzdFBvd2VyT2YyKTtcblx0ICAgIHNmbnQucmFuZ2VTaGlmdCA9IHNmbnQubnVtVGFibGVzICogMTYgLSBzZm50LnNlYXJjaFJhbmdlO1xuXG5cdCAgICB2YXIgcmVjb3JkRmllbGRzID0gW107XG5cdCAgICB2YXIgdGFibGVGaWVsZHMgPSBbXTtcblxuXHQgICAgdmFyIG9mZnNldCA9IHNmbnQuc2l6ZU9mKCkgKyAobWFrZVRhYmxlUmVjb3JkKCkuc2l6ZU9mKCkgKiBzZm50Lm51bVRhYmxlcyk7XG5cdCAgICB3aGlsZSAob2Zmc2V0ICUgNCAhPT0gMCkge1xuXHQgICAgICAgIG9mZnNldCArPSAxO1xuXHQgICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6ICdwYWRkaW5nJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0pO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYmxlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciB0ID0gdGFibGVzW2ldO1xuXHQgICAgICAgIGNoZWNrLmFyZ3VtZW50KHQudGFibGVOYW1lLmxlbmd0aCA9PT0gNCwgJ1RhYmxlIG5hbWUnICsgdC50YWJsZU5hbWUgKyAnIGlzIGludmFsaWQuJyk7XG5cdCAgICAgICAgdmFyIHRhYmxlTGVuZ3RoID0gdC5zaXplT2YoKTtcblx0ICAgICAgICB2YXIgdGFibGVSZWNvcmQgPSBtYWtlVGFibGVSZWNvcmQodC50YWJsZU5hbWUsIGNvbXB1dGVDaGVja1N1bSh0LmVuY29kZSgpKSwgb2Zmc2V0LCB0YWJsZUxlbmd0aCk7XG5cdCAgICAgICAgcmVjb3JkRmllbGRzLnB1c2goe25hbWU6IHRhYmxlUmVjb3JkLnRhZyArICcgVGFibGUgUmVjb3JkJywgdHlwZTogJ1JFQ09SRCcsIHZhbHVlOiB0YWJsZVJlY29yZH0pO1xuXHQgICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6IHQudGFibGVOYW1lICsgJyB0YWJsZScsIHR5cGU6ICdSRUNPUkQnLCB2YWx1ZTogdH0pO1xuXHQgICAgICAgIG9mZnNldCArPSB0YWJsZUxlbmd0aDtcblx0ICAgICAgICBjaGVjay5hcmd1bWVudCghaXNOYU4ob2Zmc2V0KSwgJ1NvbWV0aGluZyB3ZW50IHdyb25nIGNhbGN1bGF0aW5nIHRoZSBvZmZzZXQuJyk7XG5cdCAgICAgICAgd2hpbGUgKG9mZnNldCAlIDQgIT09IDApIHtcblx0ICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG5cdCAgICAgICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6ICdwYWRkaW5nJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gVGFibGUgcmVjb3JkcyBuZWVkIHRvIGJlIHNvcnRlZCBhbHBoYWJldGljYWxseS5cblx0ICAgIHJlY29yZEZpZWxkcy5zb3J0KGZ1bmN0aW9uKHIxLCByMikge1xuXHQgICAgICAgIGlmIChyMS52YWx1ZS50YWcgPiByMi52YWx1ZS50YWcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBzZm50LmZpZWxkcyA9IHNmbnQuZmllbGRzLmNvbmNhdChyZWNvcmRGaWVsZHMpO1xuXHQgICAgc2ZudC5maWVsZHMgPSBzZm50LmZpZWxkcy5jb25jYXQodGFibGVGaWVsZHMpO1xuXHQgICAgcmV0dXJuIHNmbnQ7XG5cdH1cblxuXHQvLyBHZXQgdGhlIG1ldHJpY3MgZm9yIGEgY2hhcmFjdGVyLiBJZiB0aGUgc3RyaW5nIGhhcyBtb3JlIHRoYW4gb25lIGNoYXJhY3RlclxuXHQvLyB0aGlzIGZ1bmN0aW9uIHJldHVybnMgbWV0cmljcyBmb3IgdGhlIGZpcnN0IGF2YWlsYWJsZSBjaGFyYWN0ZXIuXG5cdC8vIFlvdSBjYW4gcHJvdmlkZSBvcHRpb25hbCBmYWxsYmFjayBtZXRyaWNzIGlmIG5vIGNoYXJhY3RlcnMgYXJlIGF2YWlsYWJsZS5cblx0ZnVuY3Rpb24gbWV0cmljc0ZvckNoYXIoZm9udCwgY2hhcnMsIG5vdEZvdW5kTWV0cmljcykge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBnbHlwaEluZGV4ID0gZm9udC5jaGFyVG9HbHlwaEluZGV4KGNoYXJzW2ldKTtcblx0ICAgICAgICBpZiAoZ2x5cGhJbmRleCA+IDApIHtcblx0ICAgICAgICAgICAgdmFyIGdseXBoID0gZm9udC5nbHlwaHMuZ2V0KGdseXBoSW5kZXgpO1xuXHQgICAgICAgICAgICByZXR1cm4gZ2x5cGguZ2V0TWV0cmljcygpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG5vdEZvdW5kTWV0cmljcztcblx0fVxuXG5cdGZ1bmN0aW9uIGF2ZXJhZ2UodnMpIHtcblx0ICAgIHZhciBzdW0gPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2cy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHN1bSArPSB2c1tpXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHN1bSAvIHZzLmxlbmd0aDtcblx0fVxuXG5cdC8vIENvbnZlcnQgdGhlIGZvbnQgb2JqZWN0IHRvIGEgU0ZOVCBkYXRhIHN0cnVjdHVyZS5cblx0Ly8gVGhpcyBzdHJ1Y3R1cmUgY29udGFpbnMgYWxsIHRoZSBuZWNlc3NhcnkgdGFibGVzIGFuZCBtZXRhZGF0YSB0byBjcmVhdGUgYSBiaW5hcnkgT1RGIGZpbGUuXG5cdGZ1bmN0aW9uIGZvbnRUb1NmbnRUYWJsZShmb250KSB7XG5cdCAgICB2YXIgeE1pbnMgPSBbXTtcblx0ICAgIHZhciB5TWlucyA9IFtdO1xuXHQgICAgdmFyIHhNYXhzID0gW107XG5cdCAgICB2YXIgeU1heHMgPSBbXTtcblx0ICAgIHZhciBhZHZhbmNlV2lkdGhzID0gW107XG5cdCAgICB2YXIgbGVmdFNpZGVCZWFyaW5ncyA9IFtdO1xuXHQgICAgdmFyIHJpZ2h0U2lkZUJlYXJpbmdzID0gW107XG5cdCAgICB2YXIgZmlyc3RDaGFySW5kZXg7XG5cdCAgICB2YXIgbGFzdENoYXJJbmRleCA9IDA7XG5cdCAgICB2YXIgdWxVbmljb2RlUmFuZ2UxID0gMDtcblx0ICAgIHZhciB1bFVuaWNvZGVSYW5nZTIgPSAwO1xuXHQgICAgdmFyIHVsVW5pY29kZVJhbmdlMyA9IDA7XG5cdCAgICB2YXIgdWxVbmljb2RlUmFuZ2U0ID0gMDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250LmdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBnbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChpKTtcblx0ICAgICAgICB2YXIgdW5pY29kZSA9IGdseXBoLnVuaWNvZGUgfCAwO1xuXG5cdCAgICAgICAgaWYgKGlzTmFOKGdseXBoLmFkdmFuY2VXaWR0aCkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHbHlwaCAnICsgZ2x5cGgubmFtZSArICcgKCcgKyBpICsgJyk6IGFkdmFuY2VXaWR0aCBpcyBub3QgYSBudW1iZXIuJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGZpcnN0Q2hhckluZGV4ID4gdW5pY29kZSB8fCBmaXJzdENoYXJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIC8vIGlnbm9yZSAubm90ZGVmIGNoYXJcblx0ICAgICAgICAgICAgaWYgKHVuaWNvZGUgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICBmaXJzdENoYXJJbmRleCA9IHVuaWNvZGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAobGFzdENoYXJJbmRleCA8IHVuaWNvZGUpIHtcblx0ICAgICAgICAgICAgbGFzdENoYXJJbmRleCA9IHVuaWNvZGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHBvc2l0aW9uID0gb3MyLmdldFVuaWNvZGVSYW5nZSh1bmljb2RlKTtcblx0ICAgICAgICBpZiAocG9zaXRpb24gPCAzMikge1xuXHQgICAgICAgICAgICB1bFVuaWNvZGVSYW5nZTEgfD0gMSA8PCBwb3NpdGlvbjtcblx0ICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgNjQpIHtcblx0ICAgICAgICAgICAgdWxVbmljb2RlUmFuZ2UyIHw9IDEgPDwgcG9zaXRpb24gLSAzMjtcblx0ICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgOTYpIHtcblx0ICAgICAgICAgICAgdWxVbmljb2RlUmFuZ2UzIHw9IDEgPDwgcG9zaXRpb24gLSA2NDtcblx0ICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgMTIzKSB7XG5cdCAgICAgICAgICAgIHVsVW5pY29kZVJhbmdlNCB8PSAxIDw8IHBvc2l0aW9uIC0gOTY7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmljb2RlIHJhbmdlcyBiaXRzID4gMTIzIGFyZSByZXNlcnZlZCBmb3IgaW50ZXJuYWwgdXNhZ2UnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU2tpcCBub24taW1wb3J0YW50IGNoYXJhY3RlcnMuXG5cdCAgICAgICAgaWYgKGdseXBoLm5hbWUgPT09ICcubm90ZGVmJykgeyBjb250aW51ZTsgfVxuXHQgICAgICAgIHZhciBtZXRyaWNzID0gZ2x5cGguZ2V0TWV0cmljcygpO1xuXHQgICAgICAgIHhNaW5zLnB1c2gobWV0cmljcy54TWluKTtcblx0ICAgICAgICB5TWlucy5wdXNoKG1ldHJpY3MueU1pbik7XG5cdCAgICAgICAgeE1heHMucHVzaChtZXRyaWNzLnhNYXgpO1xuXHQgICAgICAgIHlNYXhzLnB1c2gobWV0cmljcy55TWF4KTtcblx0ICAgICAgICBsZWZ0U2lkZUJlYXJpbmdzLnB1c2gobWV0cmljcy5sZWZ0U2lkZUJlYXJpbmcpO1xuXHQgICAgICAgIHJpZ2h0U2lkZUJlYXJpbmdzLnB1c2gobWV0cmljcy5yaWdodFNpZGVCZWFyaW5nKTtcblx0ICAgICAgICBhZHZhbmNlV2lkdGhzLnB1c2goZ2x5cGguYWR2YW5jZVdpZHRoKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGdsb2JhbHMgPSB7XG5cdCAgICAgICAgeE1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeE1pbnMpLFxuXHQgICAgICAgIHlNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHlNaW5zKSxcblx0ICAgICAgICB4TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB4TWF4cyksXG5cdCAgICAgICAgeU1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeU1heHMpLFxuXHQgICAgICAgIGFkdmFuY2VXaWR0aE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgYWR2YW5jZVdpZHRocyksXG5cdCAgICAgICAgYWR2YW5jZVdpZHRoQXZnOiBhdmVyYWdlKGFkdmFuY2VXaWR0aHMpLFxuXHQgICAgICAgIG1pbkxlZnRTaWRlQmVhcmluZzogTWF0aC5taW4uYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG5cdCAgICAgICAgbWF4TGVmdFNpZGVCZWFyaW5nOiBNYXRoLm1heC5hcHBseShudWxsLCBsZWZ0U2lkZUJlYXJpbmdzKSxcblx0ICAgICAgICBtaW5SaWdodFNpZGVCZWFyaW5nOiBNYXRoLm1pbi5hcHBseShudWxsLCByaWdodFNpZGVCZWFyaW5ncylcblx0ICAgIH07XG5cdCAgICBnbG9iYWxzLmFzY2VuZGVyID0gZm9udC5hc2NlbmRlcjtcblx0ICAgIGdsb2JhbHMuZGVzY2VuZGVyID0gZm9udC5kZXNjZW5kZXI7XG5cblx0ICAgIHZhciBoZWFkVGFibGUgPSBoZWFkLm1ha2Uoe1xuXHQgICAgICAgIGZsYWdzOiAzLCAvLyAwMDAwMDAxMSAoYmFzZWxpbmUgZm9yIGZvbnQgYXQgeT0wOyBsZWZ0IHNpZGViZWFyaW5nIHBvaW50IGF0IHg9MClcblx0ICAgICAgICB1bml0c1BlckVtOiBmb250LnVuaXRzUGVyRW0sXG5cdCAgICAgICAgeE1pbjogZ2xvYmFscy54TWluLFxuXHQgICAgICAgIHlNaW46IGdsb2JhbHMueU1pbixcblx0ICAgICAgICB4TWF4OiBnbG9iYWxzLnhNYXgsXG5cdCAgICAgICAgeU1heDogZ2xvYmFscy55TWF4LFxuXHQgICAgICAgIGxvd2VzdFJlY1BQRU06IDMsXG5cdCAgICAgICAgY3JlYXRlZFRpbWVzdGFtcDogZm9udC5jcmVhdGVkVGltZXN0YW1wXG5cdCAgICB9KTtcblxuXHQgICAgdmFyIGhoZWFUYWJsZSA9IGhoZWEubWFrZSh7XG5cdCAgICAgICAgYXNjZW5kZXI6IGdsb2JhbHMuYXNjZW5kZXIsXG5cdCAgICAgICAgZGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcblx0ICAgICAgICBhZHZhbmNlV2lkdGhNYXg6IGdsb2JhbHMuYWR2YW5jZVdpZHRoTWF4LFxuXHQgICAgICAgIG1pbkxlZnRTaWRlQmVhcmluZzogZ2xvYmFscy5taW5MZWZ0U2lkZUJlYXJpbmcsXG5cdCAgICAgICAgbWluUmlnaHRTaWRlQmVhcmluZzogZ2xvYmFscy5taW5SaWdodFNpZGVCZWFyaW5nLFxuXHQgICAgICAgIHhNYXhFeHRlbnQ6IGdsb2JhbHMubWF4TGVmdFNpZGVCZWFyaW5nICsgKGdsb2JhbHMueE1heCAtIGdsb2JhbHMueE1pbiksXG5cdCAgICAgICAgbnVtYmVyT2ZITWV0cmljczogZm9udC5nbHlwaHMubGVuZ3RoXG5cdCAgICB9KTtcblxuXHQgICAgdmFyIG1heHBUYWJsZSA9IG1heHAubWFrZShmb250LmdseXBocy5sZW5ndGgpO1xuXG5cdCAgICB2YXIgb3MyVGFibGUgPSBvczIubWFrZShPYmplY3QuYXNzaWduKHtcblx0ICAgICAgICB4QXZnQ2hhcldpZHRoOiBNYXRoLnJvdW5kKGdsb2JhbHMuYWR2YW5jZVdpZHRoQXZnKSxcblx0ICAgICAgICB1c0ZpcnN0Q2hhckluZGV4OiBmaXJzdENoYXJJbmRleCxcblx0ICAgICAgICB1c0xhc3RDaGFySW5kZXg6IGxhc3RDaGFySW5kZXgsXG5cdCAgICAgICAgdWxVbmljb2RlUmFuZ2UxOiB1bFVuaWNvZGVSYW5nZTEsXG5cdCAgICAgICAgdWxVbmljb2RlUmFuZ2UyOiB1bFVuaWNvZGVSYW5nZTIsXG5cdCAgICAgICAgdWxVbmljb2RlUmFuZ2UzOiB1bFVuaWNvZGVSYW5nZTMsXG5cdCAgICAgICAgdWxVbmljb2RlUmFuZ2U0OiB1bFVuaWNvZGVSYW5nZTQsXG5cdCAgICAgICAgLy8gU2VlIGh0dHA6Ly90eXBvcGhpbGUuY29tL25vZGUvMTMwODEgZm9yIG1vcmUgaW5mbyBvbiB2ZXJ0aWNhbCBtZXRyaWNzLlxuXHQgICAgICAgIC8vIFdlIGdldCBtZXRyaWNzIGZvciB0eXBpY2FsIGNoYXJhY3RlcnMgKHN1Y2ggYXMgXCJ4XCIgZm9yIHhIZWlnaHQpLlxuXHQgICAgICAgIC8vIFdlIHByb3ZpZGUgc29tZSBmYWxsYmFjayBjaGFyYWN0ZXJzIGlmIGNoYXJhY3RlcnMgYXJlIHVuYXZhaWxhYmxlOiB0aGVpclxuXHQgICAgICAgIC8vIG9yZGVyaW5nIHdhcyBjaG9zZW4gZXhwZXJpbWVudGFsbHkuXG5cdCAgICAgICAgc1R5cG9Bc2NlbmRlcjogZ2xvYmFscy5hc2NlbmRlcixcblx0ICAgICAgICBzVHlwb0Rlc2NlbmRlcjogZ2xvYmFscy5kZXNjZW5kZXIsXG5cdCAgICAgICAgc1R5cG9MaW5lR2FwOiAwLFxuXHQgICAgICAgIHVzV2luQXNjZW50OiBnbG9iYWxzLnlNYXgsXG5cdCAgICAgICAgdXNXaW5EZXNjZW50OiBNYXRoLmFicyhnbG9iYWxzLnlNaW4pLFxuXHQgICAgICAgIHVsQ29kZVBhZ2VSYW5nZTE6IDEsIC8vIEZJWE1FOiBoYXJkLWNvZGUgTGF0aW4gMSBzdXBwb3J0IGZvciBub3dcblx0ICAgICAgICBzeEhlaWdodDogbWV0cmljc0ZvckNoYXIoZm9udCwgJ3h5dncnLCB7eU1heDogTWF0aC5yb3VuZChnbG9iYWxzLmFzY2VuZGVyIC8gMil9KS55TWF4LFxuXHQgICAgICAgIHNDYXBIZWlnaHQ6IG1ldHJpY3NGb3JDaGFyKGZvbnQsICdISUtMRUZKTU5UWkJEUFJBR09RU1VWV1hZJywgZ2xvYmFscykueU1heCxcblx0ICAgICAgICB1c0RlZmF1bHRDaGFyOiBmb250Lmhhc0NoYXIoJyAnKSA/IDMyIDogMCwgLy8gVXNlIHNwYWNlIGFzIHRoZSBkZWZhdWx0IGNoYXJhY3RlciwgaWYgYXZhaWxhYmxlLlxuXHQgICAgICAgIHVzQnJlYWtDaGFyOiBmb250Lmhhc0NoYXIoJyAnKSA/IDMyIDogMCwgLy8gVXNlIHNwYWNlIGFzIHRoZSBicmVhayBjaGFyYWN0ZXIsIGlmIGF2YWlsYWJsZS5cblx0ICAgIH0sIGZvbnQudGFibGVzLm9zMikpO1xuXG5cdCAgICB2YXIgaG10eFRhYmxlID0gaG10eC5tYWtlKGZvbnQuZ2x5cGhzKTtcblx0ICAgIHZhciBjbWFwVGFibGUgPSBjbWFwLm1ha2UoZm9udC5nbHlwaHMpO1xuXG5cdCAgICB2YXIgZW5nbGlzaEZhbWlseU5hbWUgPSBmb250LmdldEVuZ2xpc2hOYW1lKCdmb250RmFtaWx5Jyk7XG5cdCAgICB2YXIgZW5nbGlzaFN0eWxlTmFtZSA9IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ2ZvbnRTdWJmYW1pbHknKTtcblx0ICAgIHZhciBlbmdsaXNoRnVsbE5hbWUgPSBlbmdsaXNoRmFtaWx5TmFtZSArICcgJyArIGVuZ2xpc2hTdHlsZU5hbWU7XG5cdCAgICB2YXIgcG9zdFNjcmlwdE5hbWUgPSBmb250LmdldEVuZ2xpc2hOYW1lKCdwb3N0U2NyaXB0TmFtZScpO1xuXHQgICAgaWYgKCFwb3N0U2NyaXB0TmFtZSkge1xuXHQgICAgICAgIHBvc3RTY3JpcHROYW1lID0gZW5nbGlzaEZhbWlseU5hbWUucmVwbGFjZSgvXFxzL2csICcnKSArICctJyArIGVuZ2xpc2hTdHlsZU5hbWU7XG5cdCAgICB9XG5cblx0ICAgIHZhciBuYW1lcyA9IHt9O1xuXHQgICAgZm9yICh2YXIgbiBpbiBmb250Lm5hbWVzKSB7XG5cdCAgICAgICAgbmFtZXNbbl0gPSBmb250Lm5hbWVzW25dO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIW5hbWVzLnVuaXF1ZUlEKSB7XG5cdCAgICAgICAgbmFtZXMudW5pcXVlSUQgPSB7ZW46IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ21hbnVmYWN0dXJlcicpICsgJzonICsgZW5nbGlzaEZ1bGxOYW1lfTtcblx0ICAgIH1cblxuXHQgICAgaWYgKCFuYW1lcy5wb3N0U2NyaXB0TmFtZSkge1xuXHQgICAgICAgIG5hbWVzLnBvc3RTY3JpcHROYW1lID0ge2VuOiBwb3N0U2NyaXB0TmFtZX07XG5cdCAgICB9XG5cblx0ICAgIGlmICghbmFtZXMucHJlZmVycmVkRmFtaWx5KSB7XG5cdCAgICAgICAgbmFtZXMucHJlZmVycmVkRmFtaWx5ID0gZm9udC5uYW1lcy5mb250RmFtaWx5O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIW5hbWVzLnByZWZlcnJlZFN1YmZhbWlseSkge1xuXHQgICAgICAgIG5hbWVzLnByZWZlcnJlZFN1YmZhbWlseSA9IGZvbnQubmFtZXMuZm9udFN1YmZhbWlseTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGxhbmd1YWdlVGFncyA9IFtdO1xuXHQgICAgdmFyIG5hbWVUYWJsZSA9IF9uYW1lLm1ha2UobmFtZXMsIGxhbmd1YWdlVGFncyk7XG5cdCAgICB2YXIgbHRhZ1RhYmxlID0gKGxhbmd1YWdlVGFncy5sZW5ndGggPiAwID8gbHRhZy5tYWtlKGxhbmd1YWdlVGFncykgOiB1bmRlZmluZWQpO1xuXG5cdCAgICB2YXIgcG9zdFRhYmxlID0gcG9zdC5tYWtlKCk7XG5cdCAgICB2YXIgY2ZmVGFibGUgPSBjZmYubWFrZShmb250LmdseXBocywge1xuXHQgICAgICAgIHZlcnNpb246IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ3ZlcnNpb24nKSxcblx0ICAgICAgICBmdWxsTmFtZTogZW5nbGlzaEZ1bGxOYW1lLFxuXHQgICAgICAgIGZhbWlseU5hbWU6IGVuZ2xpc2hGYW1pbHlOYW1lLFxuXHQgICAgICAgIHdlaWdodE5hbWU6IGVuZ2xpc2hTdHlsZU5hbWUsXG5cdCAgICAgICAgcG9zdFNjcmlwdE5hbWU6IHBvc3RTY3JpcHROYW1lLFxuXHQgICAgICAgIHVuaXRzUGVyRW06IGZvbnQudW5pdHNQZXJFbSxcblx0ICAgICAgICBmb250QkJveDogWzAsIGdsb2JhbHMueU1pbiwgZ2xvYmFscy5hc2NlbmRlciwgZ2xvYmFscy5hZHZhbmNlV2lkdGhNYXhdXG5cdCAgICB9KTtcblxuXHQgICAgdmFyIG1ldGFUYWJsZSA9IChmb250Lm1ldGFzICYmIE9iamVjdC5rZXlzKGZvbnQubWV0YXMpLmxlbmd0aCA+IDApID8gbWV0YS5tYWtlKGZvbnQubWV0YXMpIDogdW5kZWZpbmVkO1xuXG5cdCAgICAvLyBUaGUgb3JkZXIgZG9lcyBub3QgbWF0dGVyIGJlY2F1c2UgbWFrZVNmbnRUYWJsZSgpIHdpbGwgc29ydCB0aGVtLlxuXHQgICAgdmFyIHRhYmxlcyA9IFtoZWFkVGFibGUsIGhoZWFUYWJsZSwgbWF4cFRhYmxlLCBvczJUYWJsZSwgbmFtZVRhYmxlLCBjbWFwVGFibGUsIHBvc3RUYWJsZSwgY2ZmVGFibGUsIGhtdHhUYWJsZV07XG5cdCAgICBpZiAobHRhZ1RhYmxlKSB7XG5cdCAgICAgICAgdGFibGVzLnB1c2gobHRhZ1RhYmxlKTtcblx0ICAgIH1cblx0ICAgIC8vIE9wdGlvbmFsIHRhYmxlc1xuXHQgICAgaWYgKGZvbnQudGFibGVzLmdzdWIpIHtcblx0ICAgICAgICB0YWJsZXMucHVzaChnc3ViLm1ha2UoZm9udC50YWJsZXMuZ3N1YikpO1xuXHQgICAgfVxuXHQgICAgaWYgKG1ldGFUYWJsZSkge1xuXHQgICAgICAgIHRhYmxlcy5wdXNoKG1ldGFUYWJsZSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBzZm50VGFibGUgPSBtYWtlU2ZudFRhYmxlKHRhYmxlcyk7XG5cblx0ICAgIC8vIENvbXB1dGUgdGhlIGZvbnQncyBjaGVja1N1bSBhbmQgc3RvcmUgaXQgaW4gaGVhZC5jaGVja1N1bUFkanVzdG1lbnQuXG5cdCAgICB2YXIgYnl0ZXMgPSBzZm50VGFibGUuZW5jb2RlKCk7XG5cdCAgICB2YXIgY2hlY2tTdW0gPSBjb21wdXRlQ2hlY2tTdW0oYnl0ZXMpO1xuXHQgICAgdmFyIHRhYmxlRmllbGRzID0gc2ZudFRhYmxlLmZpZWxkcztcblx0ICAgIHZhciBjaGVja1N1bUFkanVzdGVkID0gZmFsc2U7XG5cdCAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0YWJsZUZpZWxkcy5sZW5ndGg7IGkkMSArPSAxKSB7XG5cdCAgICAgICAgaWYgKHRhYmxlRmllbGRzW2kkMV0ubmFtZSA9PT0gJ2hlYWQgdGFibGUnKSB7XG5cdCAgICAgICAgICAgIHRhYmxlRmllbGRzW2kkMV0udmFsdWUuY2hlY2tTdW1BZGp1c3RtZW50ID0gMHhCMUIwQUZCQSAtIGNoZWNrU3VtO1xuXHQgICAgICAgICAgICBjaGVja1N1bUFkanVzdGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoIWNoZWNrU3VtQWRqdXN0ZWQpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlYWQgdGFibGUgd2l0aCBjaGVja1N1bSB0byBhZGp1c3QuJyk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzZm50VGFibGU7XG5cdH1cblxuXHR2YXIgc2ZudCA9IHsgbWFrZTogbWFrZVNmbnRUYWJsZSwgZm9udFRvVGFibGU6IGZvbnRUb1NmbnRUYWJsZSwgY29tcHV0ZUNoZWNrU3VtOiBjb21wdXRlQ2hlY2tTdW0gfTtcblxuXHQvLyBUaGUgTGF5b3V0IG9iamVjdCBpcyB0aGUgcHJvdG90eXBlIG9mIFN1YnN0aXR1dGlvbiBvYmplY3RzLCBhbmQgcHJvdmlkZXNcblxuXHRmdW5jdGlvbiBzZWFyY2hUYWcoYXJyLCB0YWcpIHtcblx0ICAgIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuXHQgICAgdmFyIGltaW4gPSAwO1xuXHQgICAgdmFyIGltYXggPSBhcnIubGVuZ3RoIC0gMTtcblx0ICAgIHdoaWxlIChpbWluIDw9IGltYXgpIHtcblx0ICAgICAgICB2YXIgaW1pZCA9IChpbWluICsgaW1heCkgPj4+IDE7XG5cdCAgICAgICAgdmFyIHZhbCA9IGFycltpbWlkXS50YWc7XG5cdCAgICAgICAgaWYgKHZhbCA9PT0gdGFnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBpbWlkO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodmFsIDwgdGFnKSB7XG5cdCAgICAgICAgICAgIGltaW4gPSBpbWlkICsgMTtcblx0ICAgICAgICB9IGVsc2UgeyBpbWF4ID0gaW1pZCAtIDE7IH1cblx0ICAgIH1cblx0ICAgIC8vIE5vdCBmb3VuZDogcmV0dXJuIC0xLWluc2VydGlvbiBwb2ludFxuXHQgICAgcmV0dXJuIC1pbWluIC0gMTtcblx0fVxuXG5cdGZ1bmN0aW9uIGJpblNlYXJjaChhcnIsIHZhbHVlKSB7XG5cdCAgICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cblx0ICAgIHZhciBpbWluID0gMDtcblx0ICAgIHZhciBpbWF4ID0gYXJyLmxlbmd0aCAtIDE7XG5cdCAgICB3aGlsZSAoaW1pbiA8PSBpbWF4KSB7XG5cdCAgICAgICAgdmFyIGltaWQgPSAoaW1pbiArIGltYXgpID4+PiAxO1xuXHQgICAgICAgIHZhciB2YWwgPSBhcnJbaW1pZF07XG5cdCAgICAgICAgaWYgKHZhbCA9PT0gdmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGltaWQ7XG5cdCAgICAgICAgfSBlbHNlIGlmICh2YWwgPCB2YWx1ZSkge1xuXHQgICAgICAgICAgICBpbWluID0gaW1pZCArIDE7XG5cdCAgICAgICAgfSBlbHNlIHsgaW1heCA9IGltaWQgLSAxOyB9XG5cdCAgICB9XG5cdCAgICAvLyBOb3QgZm91bmQ6IHJldHVybiAtMS1pbnNlcnRpb24gcG9pbnRcblx0ICAgIHJldHVybiAtaW1pbiAtIDE7XG5cdH1cblxuXHQvLyBiaW5hcnkgc2VhcmNoIGluIGEgbGlzdCBvZiByYW5nZXMgKGNvdmVyYWdlLCBjbGFzcyBkZWZpbml0aW9uKVxuXHRmdW5jdGlvbiBzZWFyY2hSYW5nZShyYW5nZXMsIHZhbHVlKSB7XG5cdCAgICAvLyBqc2hpbnQgYml0d2lzZTogZmFsc2Vcblx0ICAgIHZhciByYW5nZTtcblx0ICAgIHZhciBpbWluID0gMDtcblx0ICAgIHZhciBpbWF4ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG5cdCAgICB3aGlsZSAoaW1pbiA8PSBpbWF4KSB7XG5cdCAgICAgICAgdmFyIGltaWQgPSAoaW1pbiArIGltYXgpID4+PiAxO1xuXHQgICAgICAgIHJhbmdlID0gcmFuZ2VzW2ltaWRdO1xuXHQgICAgICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuXHQgICAgICAgIGlmIChzdGFydCA9PT0gdmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPCB2YWx1ZSkge1xuXHQgICAgICAgICAgICBpbWluID0gaW1pZCArIDE7XG5cdCAgICAgICAgfSBlbHNlIHsgaW1heCA9IGltaWQgLSAxOyB9XG5cdCAgICB9XG5cdCAgICBpZiAoaW1pbiA+IDApIHtcblx0ICAgICAgICByYW5nZSA9IHJhbmdlc1tpbWluIC0gMV07XG5cdCAgICAgICAgaWYgKHZhbHVlID4gcmFuZ2UuZW5kKSB7IHJldHVybiAwOyB9XG5cdCAgICAgICAgcmV0dXJuIHJhbmdlO1xuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEBleHBvcnRzIG9wZW50eXBlLkxheW91dFxuXHQgKiBAY2xhc3Ncblx0ICovXG5cdGZ1bmN0aW9uIExheW91dChmb250LCB0YWJsZU5hbWUpIHtcblx0ICAgIHRoaXMuZm9udCA9IGZvbnQ7XG5cdCAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcblx0fVxuXG5cdExheW91dC5wcm90b3R5cGUgPSB7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmluYXJ5IHNlYXJjaCBhbiBvYmplY3QgYnkgXCJ0YWdcIiBwcm9wZXJ0eVxuXHQgICAgICogQGluc3RhbmNlXG5cdCAgICAgKiBAZnVuY3Rpb24gc2VhcmNoVGFnXG5cdCAgICAgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuTGF5b3V0XG5cdCAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyXG5cdCAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZ1xuXHQgICAgICogQHJldHVybiB7bnVtYmVyfVxuXHQgICAgICovXG5cdCAgICBzZWFyY2hUYWc6IHNlYXJjaFRhZyxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCaW5hcnkgc2VhcmNoIGluIGEgbGlzdCBvZiBudW1iZXJzXG5cdCAgICAgKiBAaW5zdGFuY2Vcblx0ICAgICAqIEBmdW5jdGlvbiBiaW5TZWFyY2hcblx0ICAgICAqIEBtZW1iZXJvZiBvcGVudHlwZS5MYXlvdXRcblx0ICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnJcblx0ICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcblx0ICAgICAqIEByZXR1cm4ge251bWJlcn1cblx0ICAgICAqL1xuXHQgICAgYmluU2VhcmNoOiBiaW5TZWFyY2gsXG5cblx0ICAgIC8qKlxuXHQgICAgICogR2V0IG9yIGNyZWF0ZSB0aGUgTGF5b3V0IHRhYmxlIChHU1VCLCBHUE9TIGV0YykuXG5cdCAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjcmVhdGUgLSBXaGV0aGVyIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBHU1VCIG9yIEdQT1MgdGFibGUuXG5cdCAgICAgKi9cblx0ICAgIGdldFRhYmxlOiBmdW5jdGlvbihjcmVhdGUpIHtcblx0ICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV07XG5cdCAgICAgICAgaWYgKCFsYXlvdXQgJiYgY3JlYXRlKSB7XG5cdCAgICAgICAgICAgIGxheW91dCA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdID0gdGhpcy5jcmVhdGVEZWZhdWx0VGFibGUoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxheW91dDtcblx0ICAgIH0sXG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJucyBhbGwgc2NyaXB0cyBpbiB0aGUgc3Vic3RpdHV0aW9uIHRhYmxlLlxuXHQgICAgICogQGluc3RhbmNlXG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAqL1xuXHQgICAgZ2V0U2NyaXB0TmFtZXM6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldFRhYmxlKCk7XG5cdCAgICAgICAgaWYgKCFsYXlvdXQpIHsgcmV0dXJuIFtdOyB9XG5cdCAgICAgICAgcmV0dXJuIGxheW91dC5zY3JpcHRzLm1hcChmdW5jdGlvbihzY3JpcHQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNjcmlwdC50YWc7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgdGhlIGJlc3QgYmV0IGZvciBhIHNjcmlwdCBuYW1lLlxuXHQgICAgICogUmV0dXJucyAnREZMVCcgaWYgaXQgZXhpc3RzLlxuXHQgICAgICogSWYgbm90LCByZXR1cm5zICdsYXRuJyBpZiBpdCBleGlzdHMuXG5cdCAgICAgKiBJZiBuZWl0aGVyIGV4aXN0LCByZXR1cm5zIHVuZGVmaW5lZC5cblx0ICAgICAqL1xuXHQgICAgZ2V0RGVmYXVsdFNjcmlwdE5hbWU6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldFRhYmxlKCk7XG5cdCAgICAgICAgaWYgKCFsYXlvdXQpIHsgcmV0dXJuOyB9XG5cdCAgICAgICAgdmFyIGhhc0xhdG4gPSBmYWxzZTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dC5zY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lID0gbGF5b3V0LnNjcmlwdHNbaV0udGFnO1xuXHQgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ0RGTFQnKSB7IHJldHVybiBuYW1lOyB9XG5cdCAgICAgICAgICAgIGlmIChuYW1lID09PSAnbGF0bicpIHsgaGFzTGF0biA9IHRydWU7IH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGhhc0xhdG4pIHsgcmV0dXJuICdsYXRuJzsgfVxuXHQgICAgfSxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIGFsbCBMYW5nU3lzUmVjb3JkcyBpbiB0aGUgZ2l2ZW4gc2NyaXB0LlxuXHQgICAgICogQGluc3RhbmNlXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhpcyBzY3JpcHQgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGFnIGFuZCBzY3JpcHQgcHJvcGVydGllcy5cblx0ICAgICAqL1xuXHQgICAgZ2V0U2NyaXB0VGFibGU6IGZ1bmN0aW9uKHNjcmlwdCwgY3JlYXRlKSB7XG5cdCAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0VGFibGUoY3JlYXRlKTtcblx0ICAgICAgICBpZiAobGF5b3V0KSB7XG5cdCAgICAgICAgICAgIHNjcmlwdCA9IHNjcmlwdCB8fCAnREZMVCc7XG5cdCAgICAgICAgICAgIHZhciBzY3JpcHRzID0gbGF5b3V0LnNjcmlwdHM7XG5cdCAgICAgICAgICAgIHZhciBwb3MgPSBzZWFyY2hUYWcobGF5b3V0LnNjcmlwdHMsIHNjcmlwdCk7XG5cdCAgICAgICAgICAgIGlmIChwb3MgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdHNbcG9zXS5zY3JpcHQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2NyID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHRhZzogc2NyaXB0LFxuXHQgICAgICAgICAgICAgICAgICAgIHNjcmlwdDoge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czoge3Jlc2VydmVkOiAwLCByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZiwgZmVhdHVyZUluZGV4ZXM6IFtdfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ1N5c1JlY29yZHM6IFtdXG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIHNjcmlwdHMuc3BsaWNlKC0xIC0gcG9zLCAwLCBzY3IpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNjci5zY3JpcHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9LFxuXG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgYSBsYW5ndWFnZSBzeXN0ZW0gdGFibGVcblx0ICAgICAqIEBpbnN0YW5jZVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGxmdCddXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhpcyBsYW5nU3lzVGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cblx0ICAgICAqIEByZXR1cm4ge09iamVjdH1cblx0ICAgICAqL1xuXHQgICAgZ2V0TGFuZ1N5c1RhYmxlOiBmdW5jdGlvbihzY3JpcHQsIGxhbmd1YWdlLCBjcmVhdGUpIHtcblx0ICAgICAgICB2YXIgc2NyaXB0VGFibGUgPSB0aGlzLmdldFNjcmlwdFRhYmxlKHNjcmlwdCwgY3JlYXRlKTtcblx0ICAgICAgICBpZiAoc2NyaXB0VGFibGUpIHtcblx0ICAgICAgICAgICAgaWYgKCFsYW5ndWFnZSB8fCBsYW5ndWFnZSA9PT0gJ2RmbHQnIHx8IGxhbmd1YWdlID09PSAnREZMVCcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRUYWJsZS5kZWZhdWx0TGFuZ1N5cztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcG9zID0gc2VhcmNoVGFnKHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzLCBsYW5ndWFnZSk7XG5cdCAgICAgICAgICAgIGlmIChwb3MgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzW3Bvc10ubGFuZ1N5cztcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChjcmVhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBsYW5nU3lzUmVjb3JkID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHRhZzogbGFuZ3VhZ2UsXG5cdCAgICAgICAgICAgICAgICAgICAgbGFuZ1N5czoge3Jlc2VydmVkOiAwLCByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZiwgZmVhdHVyZUluZGV4ZXM6IFtdfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzLnNwbGljZSgtMSAtIHBvcywgMCwgbGFuZ1N5c1JlY29yZCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ1N5c1JlY29yZC5sYW5nU3lzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXQgYSBzcGVjaWZpYyBmZWF0dXJlIHRhYmxlLlxuXHQgICAgICogQGluc3RhbmNlXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gT25lIG9mIHRoZSBjb2RlcyBsaXN0ZWQgYXQgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9mZWF0dXJlbGlzdC5odG1cblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGUgZmVhdHVyZSB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fVxuXHQgICAgICovXG5cdCAgICBnZXRGZWF0dXJlVGFibGU6IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIGNyZWF0ZSkge1xuXHQgICAgICAgIHZhciBsYW5nU3lzVGFibGUgPSB0aGlzLmdldExhbmdTeXNUYWJsZShzY3JpcHQsIGxhbmd1YWdlLCBjcmVhdGUpO1xuXHQgICAgICAgIGlmIChsYW5nU3lzVGFibGUpIHtcblx0ICAgICAgICAgICAgdmFyIGZlYXR1cmVSZWNvcmQ7XG5cdCAgICAgICAgICAgIHZhciBmZWF0SW5kZXhlcyA9IGxhbmdTeXNUYWJsZS5mZWF0dXJlSW5kZXhlcztcblx0ICAgICAgICAgICAgdmFyIGFsbEZlYXR1cmVzID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV0uZmVhdHVyZXM7XG5cdCAgICAgICAgICAgIC8vIFRoZSBGZWF0dXJlSW5kZXggYXJyYXkgb2YgaW5kaWNlcyBpcyBpbiBhcmJpdHJhcnkgb3JkZXIsXG5cdCAgICAgICAgICAgIC8vIGV2ZW4gaWYgYWxsRmVhdHVyZXMgaXMgc29ydGVkIGFscGhhYmV0aWNhbGx5IGJ5IGZlYXR1cmUgdGFnLlxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmZWF0dXJlUmVjb3JkID0gYWxsRmVhdHVyZXNbZmVhdEluZGV4ZXNbaV1dO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVSZWNvcmQudGFnID09PSBmZWF0dXJlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVSZWNvcmQuZmVhdHVyZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoY3JlYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbGxGZWF0dXJlcy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAvLyBBdXRvbWF0aWMgb3JkZXJpbmcgb2YgZmVhdHVyZXMgd291bGQgcmVxdWlyZSB0byBzaGlmdCBmZWF0dXJlIGluZGV4ZXMgaW4gdGhlIHNjcmlwdCBsaXN0LlxuXHQgICAgICAgICAgICAgICAgY2hlY2suYXNzZXJ0KGluZGV4ID09PSAwIHx8IGZlYXR1cmUgPj0gYWxsRmVhdHVyZXNbaW5kZXggLSAxXS50YWcsICdGZWF0dXJlcyBtdXN0IGJlIGFkZGVkIGluIGFscGhhYmV0aWNhbCBvcmRlci4nKTtcblx0ICAgICAgICAgICAgICAgIGZlYXR1cmVSZWNvcmQgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGFnOiBmZWF0dXJlLFxuXHQgICAgICAgICAgICAgICAgICAgIGZlYXR1cmU6IHsgcGFyYW1zOiAwLCBsb29rdXBMaXN0SW5kZXhlczogW10gfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzLnB1c2goZmVhdHVyZVJlY29yZCk7XG5cdCAgICAgICAgICAgICAgICBmZWF0SW5kZXhlcy5wdXNoKGluZGV4KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlUmVjb3JkLmZlYXR1cmU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9LFxuXG5cdCAgICAvKipcblx0ICAgICAqIEdldCB0aGUgbG9va3VwIHRhYmxlcyBvZiBhIGdpdmVuIHR5cGUgZm9yIGEgc2NyaXB0L2xhbmd1YWdlL2ZlYXR1cmUuXG5cdCAgICAgKiBAaW5zdGFuY2Vcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RsZnQnXVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIGNvZGVcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb29rdXBUeXBlIC0gMSB0byA5XG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhlIGxvb2t1cCB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LCB3aXRoIG5vIHN1YnRhYmxlcy5cblx0ICAgICAqIEByZXR1cm4ge09iamVjdFtdfVxuXHQgICAgICovXG5cdCAgICBnZXRMb29rdXBUYWJsZXM6IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIGxvb2t1cFR5cGUsIGNyZWF0ZSkge1xuXHQgICAgICAgIHZhciBmZWF0dXJlVGFibGUgPSB0aGlzLmdldEZlYXR1cmVUYWJsZShzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCBjcmVhdGUpO1xuXHQgICAgICAgIHZhciB0YWJsZXMgPSBbXTtcblx0ICAgICAgICBpZiAoZmVhdHVyZVRhYmxlKSB7XG5cdCAgICAgICAgICAgIHZhciBsb29rdXBUYWJsZTtcblx0ICAgICAgICAgICAgdmFyIGxvb2t1cExpc3RJbmRleGVzID0gZmVhdHVyZVRhYmxlLmxvb2t1cExpc3RJbmRleGVzO1xuXHQgICAgICAgICAgICB2YXIgYWxsTG9va3VwcyA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdLmxvb2t1cHM7XG5cdCAgICAgICAgICAgIC8vIGxvb2t1cExpc3RJbmRleGVzIGFyZSBpbiBubyBwYXJ0aWN1bGFyIG9yZGVyLCBzbyB1c2UgbmFpdmUgc2VhcmNoLlxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvb2t1cExpc3RJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBsb29rdXBUYWJsZSA9IGFsbExvb2t1cHNbbG9va3VwTGlzdEluZGV4ZXNbaV1dO1xuXHQgICAgICAgICAgICAgICAgaWYgKGxvb2t1cFRhYmxlLmxvb2t1cFR5cGUgPT09IGxvb2t1cFR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0YWJsZXMucHVzaChsb29rdXBUYWJsZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRhYmxlcy5sZW5ndGggPT09IDAgJiYgY3JlYXRlKSB7XG5cdCAgICAgICAgICAgICAgICBsb29rdXBUYWJsZSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuXHQgICAgICAgICAgICAgICAgICAgIGxvb2t1cEZsYWc6IDAsXG5cdCAgICAgICAgICAgICAgICAgICAgc3VidGFibGVzOiBbXSxcblx0ICAgICAgICAgICAgICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1bmRlZmluZWRcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbGxMb29rdXBzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIGFsbExvb2t1cHMucHVzaChsb29rdXBUYWJsZSk7XG5cdCAgICAgICAgICAgICAgICBsb29rdXBMaXN0SW5kZXhlcy5wdXNoKGluZGV4KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbbG9va3VwVGFibGVdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0YWJsZXM7XG5cdCAgICB9LFxuXG5cdCAgICAvKipcblx0ICAgICAqIEZpbmQgYSBnbHlwaCBpbiBhIGNsYXNzIGRlZmluaXRpb24gdGFibGVcblx0ICAgICAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9jaGFwdGVyMiNjbGFzcy1kZWZpbml0aW9uLXRhYmxlXG5cdCAgICAgKiBAcGFyYW0ge29iamVjdH0gY2xhc3NEZWZUYWJsZSAtIGFuIE9wZW5UeXBlIExheW91dCBjbGFzcyBkZWZpbml0aW9uIHRhYmxlXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhJbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgZ2x5cGggdG8gZmluZFxuXHQgICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgbm90IGZvdW5kXG5cdCAgICAgKi9cblx0ICAgIGdldEdseXBoQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzRGVmVGFibGUsIGdseXBoSW5kZXgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGNsYXNzRGVmVGFibGUuZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgIGlmIChjbGFzc0RlZlRhYmxlLnN0YXJ0R2x5cGggPD0gZ2x5cGhJbmRleCAmJiBnbHlwaEluZGV4IDwgY2xhc3NEZWZUYWJsZS5zdGFydEdseXBoICsgY2xhc3NEZWZUYWJsZS5jbGFzc2VzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc0RlZlRhYmxlLmNsYXNzZXNbZ2x5cGhJbmRleCAtIGNsYXNzRGVmVGFibGUuc3RhcnRHbHlwaF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VhcmNoUmFuZ2UoY2xhc3NEZWZUYWJsZS5yYW5nZXMsIGdseXBoSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlID8gcmFuZ2UuY2xhc3NJZCA6IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBGaW5kIGEgZ2x5cGggaW4gYSBjb3ZlcmFnZSB0YWJsZVxuXHQgICAgICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2NoYXB0ZXIyI2NvdmVyYWdlLXRhYmxlXG5cdCAgICAgKiBAcGFyYW0ge29iamVjdH0gY292ZXJhZ2VUYWJsZSAtIGFuIE9wZW5UeXBlIExheW91dCBjb3ZlcmFnZSB0YWJsZVxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IGdseXBoSW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGdseXBoIHRvIGZpbmRcblx0ICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0xIGlmIG5vdCBmb3VuZFxuXHQgICAgICovXG5cdCAgICBnZXRDb3ZlcmFnZUluZGV4OiBmdW5jdGlvbihjb3ZlcmFnZVRhYmxlLCBnbHlwaEluZGV4KSB7XG5cdCAgICAgICAgc3dpdGNoIChjb3ZlcmFnZVRhYmxlLmZvcm1hdCkge1xuXHQgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBiaW5TZWFyY2goY292ZXJhZ2VUYWJsZS5nbHlwaHMsIGdseXBoSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IC0xO1xuXHQgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWFyY2hSYW5nZShjb3ZlcmFnZVRhYmxlLnJhbmdlcywgZ2x5cGhJbmRleCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UgPyByYW5nZS5pbmRleCArIGdseXBoSW5kZXggLSByYW5nZS5zdGFydCA6IC0xO1xuXHQgICAgICAgIH1cblx0ICAgIH0sXG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBnbHlwaCBpbmRleGVzIG9mIGEgY292ZXJhZ2UgdGFibGUuXG5cdCAgICAgKiBGb3JtYXQgMTogdGhlIGxpc3QgaXMgc3RvcmVkIHJhd1xuXHQgICAgICogRm9ybWF0IDI6IGNvbXBhY3QgbGlzdCBhcyByYW5nZSByZWNvcmRzLlxuXHQgICAgICogQGluc3RhbmNlXG5cdCAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvdmVyYWdlVGFibGVcblx0ICAgICAqIEByZXR1cm4ge0FycmF5fVxuXHQgICAgICovXG5cdCAgICBleHBhbmRDb3ZlcmFnZTogZnVuY3Rpb24oY292ZXJhZ2VUYWJsZSkge1xuXHQgICAgICAgIGlmIChjb3ZlcmFnZVRhYmxlLmZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgICAgICByZXR1cm4gY292ZXJhZ2VUYWJsZS5nbHlwaHM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGdseXBocyA9IFtdO1xuXHQgICAgICAgICAgICB2YXIgcmFuZ2VzID0gY292ZXJhZ2VUYWJsZS5yYW5nZXM7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcblx0ICAgICAgICAgICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPD0gZW5kOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBnbHlwaHMucHVzaChqKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZ2x5cGhzO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHR9O1xuXG5cdC8vIFRoZSBQb3NpdGlvbiBvYmplY3QgcHJvdmlkZXMgdXRpbGl0eSBtZXRob2RzIHRvIG1hbmlwdWxhdGVcblxuXHQvKipcblx0ICogQGV4cG9ydHMgb3BlbnR5cGUuUG9zaXRpb25cblx0ICogQGNsYXNzXG5cdCAqIEBleHRlbmRzIG9wZW50eXBlLkxheW91dFxuXHQgKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gUG9zaXRpb24oZm9udCkge1xuXHQgICAgTGF5b3V0LmNhbGwodGhpcywgZm9udCwgJ2dwb3MnKTtcblx0fVxuXG5cdFBvc2l0aW9uLnByb3RvdHlwZSA9IExheW91dC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIEluaXQgc29tZSBkYXRhIGZvciBmYXN0ZXIgYW5kIGVhc2llciBhY2Nlc3MgbGF0ZXIuXG5cdCAqL1xuXHRQb3NpdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHNjcmlwdCA9IHRoaXMuZ2V0RGVmYXVsdFNjcmlwdE5hbWUoKTtcblx0ICAgIHRoaXMuZGVmYXVsdEtlcm5pbmdUYWJsZXMgPSB0aGlzLmdldEtlcm5pbmdUYWJsZXMoc2NyaXB0KTtcblx0fTtcblxuXHQvKipcblx0ICogRmluZCBhIGdseXBoIHBhaXIgaW4gYSBsaXN0IG9mIGxvb2t1cCB0YWJsZXMgb2YgdHlwZSAyIGFuZCByZXRyaWV2ZSB0aGUgeEFkdmFuY2Uga2VybmluZyB2YWx1ZS5cblx0ICpcblx0ICogQHBhcmFtIHtpbnRlZ2VyfSBsZWZ0SW5kZXggLSBsZWZ0IGdseXBoIGluZGV4XG5cdCAqIEBwYXJhbSB7aW50ZWdlcn0gcmlnaHRJbmRleCAtIHJpZ2h0IGdseXBoIGluZGV4XG5cdCAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuXHQgKi9cblx0UG9zaXRpb24ucHJvdG90eXBlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uKGtlcm5pbmdMb29rdXBzLCBsZWZ0SW5kZXgsIHJpZ2h0SW5kZXgpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2VybmluZ0xvb2t1cHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgc3VidGFibGVzID0ga2VybmluZ0xvb2t1cHNbaV0uc3VidGFibGVzO1xuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3VidGFibGVzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tqXTtcblx0ICAgICAgICAgICAgdmFyIGNvdkluZGV4ID0gdGhpcy5nZXRDb3ZlcmFnZUluZGV4KHN1YnRhYmxlLmNvdmVyYWdlLCBsZWZ0SW5kZXgpO1xuXHQgICAgICAgICAgICBpZiAoY292SW5kZXggPCAwKSB7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgIHN3aXRjaCAoc3VidGFibGUucG9zRm9ybWF0KSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIFBhaXIgQWRqdXN0bWVudCBQb3NpdGlvbmluZyBGb3JtYXQgMVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYWlyU2V0ID0gc3VidGFibGUucGFpclNldHNbY292SW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcGFpclNldC5sZW5ndGg7IGsrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJTZXRba107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWlyLnNlY29uZEdseXBoID09PSByaWdodEluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpci52YWx1ZTEgJiYgcGFpci52YWx1ZTEueEFkdmFuY2UgfHwgMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgICAvLyBsZWZ0IGdseXBoIGZvdW5kLCBub3QgcmlnaHQgZ2x5cGggLSB0cnkgbmV4dCBzdWJ0YWJsZVxuXHQgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBQYWlyIEFkanVzdG1lbnQgUG9zaXRpb25pbmcgRm9ybWF0IDJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3MxID0gdGhpcy5nZXRHbHlwaENsYXNzKHN1YnRhYmxlLmNsYXNzRGVmMSwgbGVmdEluZGV4KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3MyID0gdGhpcy5nZXRHbHlwaENsYXNzKHN1YnRhYmxlLmNsYXNzRGVmMiwgcmlnaHRJbmRleCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXIkMSA9IHN1YnRhYmxlLmNsYXNzUmVjb3Jkc1tjbGFzczFdW2NsYXNzMl07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIkMS52YWx1ZTEgJiYgcGFpciQxLnZhbHVlMS54QWR2YW5jZSB8fCAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIExpc3QgYWxsIGtlcm5pbmcgbG9va3VwIHRhYmxlcy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXSAtIHVzZSBmb250LnBvc2l0aW9uLmdldERlZmF1bHRTY3JpcHROYW1lKCkgZm9yIGEgYmV0dGVyIGRlZmF1bHQgdmFsdWVcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfSBUaGUgbGlzdCBvZiBrZXJuaW5nIGxvb2t1cCB0YWJsZXMgKG1heSBiZSBlbXB0eSksIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBHUE9TIHRhYmxlIChhbmQgd2Ugc2hvdWxkIHVzZSB0aGUga2VybiB0YWJsZSlcblx0ICovXG5cdFBvc2l0aW9uLnByb3RvdHlwZS5nZXRLZXJuaW5nVGFibGVzID0gZnVuY3Rpb24oc2NyaXB0LCBsYW5ndWFnZSkge1xuXHQgICAgaWYgKHRoaXMuZm9udC50YWJsZXMuZ3Bvcykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCAna2VybicsIDIpO1xuXHQgICAgfVxuXHR9O1xuXG5cdC8vIFRoZSBTdWJzdGl0dXRpb24gb2JqZWN0IHByb3ZpZGVzIHV0aWxpdHkgbWV0aG9kcyB0byBtYW5pcHVsYXRlXG5cblx0LyoqXG5cdCAqIEBleHBvcnRzIG9wZW50eXBlLlN1YnN0aXR1dGlvblxuXHQgKiBAY2xhc3Ncblx0ICogQGV4dGVuZHMgb3BlbnR5cGUuTGF5b3V0XG5cdCAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTdWJzdGl0dXRpb24oZm9udCkge1xuXHQgICAgTGF5b3V0LmNhbGwodGhpcywgZm9udCwgJ2dzdWInKTtcblx0fVxuXG5cdC8vIENoZWNrIGlmIDIgYXJyYXlzIG9mIHByaW1pdGl2ZXMgYXJlIGVxdWFsLlxuXHRmdW5jdGlvbiBhcnJheXNFcXVhbChhcjEsIGFyMikge1xuXHQgICAgdmFyIG4gPSBhcjEubGVuZ3RoO1xuXHQgICAgaWYgKG4gIT09IGFyMi5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgIGlmIChhcjFbaV0gIT09IGFyMltpXSkgeyByZXR1cm4gZmFsc2U7IH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gRmluZCB0aGUgZmlyc3Qgc3VidGFibGUgb2YgYSBsb29rdXAgdGFibGUgaW4gYSBwYXJ0aWN1bGFyIGZvcm1hdC5cblx0ZnVuY3Rpb24gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIGZvcm1hdCwgZGVmYXVsdFN1YnRhYmxlKSB7XG5cdCAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGUuc3VidGFibGVzO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG5cdCAgICAgICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSBmb3JtYXQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHN1YnRhYmxlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChkZWZhdWx0U3VidGFibGUpIHtcblx0ICAgICAgICBzdWJ0YWJsZXMucHVzaChkZWZhdWx0U3VidGFibGUpO1xuXHQgICAgICAgIHJldHVybiBkZWZhdWx0U3VidGFibGU7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZSA9IExheW91dC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGRlZmF1bHQgR1NVQiB0YWJsZS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBnc3ViIC0gVGhlIEdTVUIgdGFibGUuXG5cdCAqL1xuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmNyZWF0ZURlZmF1bHRUYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgLy8gR2VuZXJhdGUgYSBkZWZhdWx0IGVtcHR5IEdTVUIgdGFibGUgd2l0aCBqdXN0IGEgREZMVCBzY3JpcHQgYW5kIGRmbHQgbGFuZyBzeXMuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIHZlcnNpb246IDEsXG5cdCAgICAgICAgc2NyaXB0czogW3tcblx0ICAgICAgICAgICAgdGFnOiAnREZMVCcsXG5cdCAgICAgICAgICAgIHNjcmlwdDoge1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdExhbmdTeXM6IHsgcmVzZXJ2ZWQ6IDAsIHJlcUZlYXR1cmVJbmRleDogMHhmZmZmLCBmZWF0dXJlSW5kZXhlczogW10gfSxcblx0ICAgICAgICAgICAgICAgIGxhbmdTeXNSZWNvcmRzOiBbXVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfV0sXG5cdCAgICAgICAgZmVhdHVyZXM6IFtdLFxuXHQgICAgICAgIGxvb2t1cHM6IFtdXG5cdCAgICB9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBMaXN0IGFsbCBzaW5nbGUgc3Vic3RpdHV0aW9ucyAobG9va3VwIHR5cGUgMSkgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1jaGFyYWN0ZXIgZmVhdHVyZSBuYW1lICgnYWFsdCcsICdzYWx0JywgJ3NzMDEnLi4uKVxuXHQgKiBAcmV0dXJuIHtBcnJheX0gc3Vic3RpdHV0aW9ucyAtIFRoZSBsaXN0IG9mIHN1YnN0aXR1dGlvbnMuXG5cdCAqL1xuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldFNpbmdsZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcblx0ICAgIHZhciBzdWJzdGl0dXRpb25zID0gW107XG5cdCAgICB2YXIgbG9va3VwVGFibGVzID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMSk7XG5cdCAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuXHQgICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG5cdCAgICAgICAgICAgIHZhciBqID0gKHZvaWQgMCk7XG5cdCAgICAgICAgICAgIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gc3VidGFibGUuZGVsdGFHbHlwaElkO1xuXHQgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tqXTtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goeyBzdWI6IGdseXBoLCBieTogZ2x5cGggKyBkZWx0YSB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRlID0gc3VidGFibGUuc3Vic3RpdHV0ZTtcblx0ICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goeyBzdWI6IGdseXBoc1tqXSwgYnk6IHN1YnN0aXR1dGVbal0gfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc3Vic3RpdHV0aW9ucztcblx0fTtcblxuXHQvKipcblx0ICogTGlzdCBhbGwgbXVsdGlwbGUgc3Vic3RpdHV0aW9ucyAobG9va3VwIHR5cGUgMikgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1jaGFyYWN0ZXIgZmVhdHVyZSBuYW1lICgnY2NtcCcsICdzdGNoJylcblx0ICogQHJldHVybiB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgLSBUaGUgbGlzdCBvZiBzdWJzdGl0dXRpb25zLlxuXHQgKi9cblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRNdWx0aXBsZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcblx0ICAgIHZhciBzdWJzdGl0dXRpb25zID0gW107XG5cdCAgICB2YXIgbG9va3VwVGFibGVzID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMik7XG5cdCAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuXHQgICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcy5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG5cdCAgICAgICAgICAgIHZhciBqID0gKHZvaWQgMCk7XG5cblx0ICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2pdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50cyA9IHN1YnRhYmxlLnNlcXVlbmNlc1tqXTtcblx0ICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7IHN1YjogZ2x5cGgsIGJ5OiByZXBsYWNlbWVudHMgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc3Vic3RpdHV0aW9ucztcblx0fTtcblxuXHQvKipcblx0ICogTGlzdCBhbGwgYWx0ZXJuYXRlcyAobG9va3VwIHR5cGUgMykgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1jaGFyYWN0ZXIgZmVhdHVyZSBuYW1lICgnYWFsdCcsICdzYWx0Jy4uLilcblx0ICogQHJldHVybiB7QXJyYXl9IGFsdGVybmF0ZXMgLSBUaGUgbGlzdCBvZiBhbHRlcm5hdGVzXG5cdCAqL1xuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldEFsdGVybmF0ZXMgPSBmdW5jdGlvbihmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG5cdCAgICB2YXIgYWx0ZXJuYXRlcyA9IFtdO1xuXHQgICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDMpO1xuXHQgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbG9va3VwVGFibGVzLmxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcblx0ICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuXHQgICAgICAgICAgICB2YXIgYWx0ZXJuYXRlU2V0cyA9IHN1YnRhYmxlLmFsdGVybmF0ZVNldHM7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBhbHRlcm5hdGVzLnB1c2goeyBzdWI6IGdseXBoc1tqXSwgYnk6IGFsdGVybmF0ZVNldHNbal0gfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYWx0ZXJuYXRlcztcblx0fTtcblxuXHQvKipcblx0ICogTGlzdCBhbGwgbGlnYXR1cmVzIChsb29rdXAgdHlwZSA0KSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cblx0ICogVGhlIHJlc3VsdCBpcyBhbiBhcnJheSBvZiBsaWdhdHVyZSBvYmplY3RzIGxpa2UgeyBzdWI6IFtpZHNdLCBieTogaWQgfVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2xpZ2EnLCAncmxpZycsICdkbGlnJy4uLilcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cblx0ICogQHJldHVybiB7QXJyYXl9IGxpZ2F0dXJlcyAtIFRoZSBsaXN0IG9mIGxpZ2F0dXJlcy5cblx0ICovXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0TGlnYXR1cmVzID0gZnVuY3Rpb24oZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuXHQgICAgdmFyIGxpZ2F0dXJlcyA9IFtdO1xuXHQgICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDQpO1xuXHQgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbG9va3VwVGFibGVzLmxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcblx0ICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuXHQgICAgICAgICAgICB2YXIgbGlnYXR1cmVTZXRzID0gc3VidGFibGUubGlnYXR1cmVTZXRzO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHN0YXJ0R2x5cGggPSBnbHlwaHNbal07XG5cdCAgICAgICAgICAgICAgICB2YXIgbGlnU2V0ID0gbGlnYXR1cmVTZXRzW2pdO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsaWdTZXQubGVuZ3RoOyBrKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGlnID0gbGlnU2V0W2tdO1xuXHQgICAgICAgICAgICAgICAgICAgIGxpZ2F0dXJlcy5wdXNoKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBbc3RhcnRHbHlwaF0uY29uY2F0KGxpZy5jb21wb25lbnRzKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnk6IGxpZy5saWdHbHlwaFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpZ2F0dXJlcztcblx0fTtcblxuXHQvKipcblx0ICogQWRkIG9yIG1vZGlmeSBhIHNpbmdsZSBzdWJzdGl0dXRpb24gKGxvb2t1cCB0eXBlIDEpXG5cdCAqIEZvcm1hdCAyLCBtb3JlIGZsZXhpYmxlLCBpcyBhbHdheXMgdXNlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdWJzdGl0dXRpb24gLSB7IHN1YjogaWQsIGJ5OiBpZCB9IChmb3JtYXQgMSBpcyBub3Qgc3VwcG9ydGVkKVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuXHQgKi9cblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRTaW5nbGUgPSBmdW5jdGlvbihmZWF0dXJlLCBzdWJzdGl0dXRpb24sIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcblx0ICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDEsIHRydWUpWzBdO1xuXHQgICAgdmFyIHN1YnRhYmxlID0gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIDIsIHsgICAgICAgICAgICAgICAgLy8gbG9va3VwIHR5cGUgMSBzdWJ0YWJsZSwgZm9ybWF0IDIsIGNvdmVyYWdlIGZvcm1hdCAxXG5cdCAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG5cdCAgICAgICAgY292ZXJhZ2U6IHtmb3JtYXQ6IDEsIGdseXBoczogW119LFxuXHQgICAgICAgIHN1YnN0aXR1dGU6IFtdXG5cdCAgICB9KTtcblx0ICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsICdTaW5nbGU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgKyBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQpO1xuXHQgICAgdmFyIGNvdmVyYWdlR2x5cGggPSBzdWJzdGl0dXRpb24uc3ViO1xuXHQgICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG5cdCAgICBpZiAocG9zIDwgMCkge1xuXHQgICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuXHQgICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcblx0ICAgICAgICBzdWJ0YWJsZS5zdWJzdGl0dXRlLnNwbGljZShwb3MsIDAsIDApO1xuXHQgICAgfVxuXHQgICAgc3VidGFibGUuc3Vic3RpdHV0ZVtwb3NdID0gc3Vic3RpdHV0aW9uLmJ5O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgb3IgbW9kaWZ5IGEgbXVsdGlwbGUgc3Vic3RpdHV0aW9uIChsb29rdXAgdHlwZSAyKVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2NjbXAnLCAnc3RjaCcpXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdWJzdGl0dXRpb24gLSB7IHN1YjogaWQsIGJ5OiBbaWRdIH0gZm9yIGZvcm1hdCAyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuXHQgKi9cblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRNdWx0aXBsZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIHN1YnN0aXR1dGlvbiwgc2NyaXB0LCBsYW5ndWFnZSkge1xuXHQgICAgY2hlY2suYXNzZXJ0KHN1YnN0aXR1dGlvbi5ieSBpbnN0YW5jZW9mIEFycmF5ICYmIHN1YnN0aXR1dGlvbi5ieS5sZW5ndGggPiAxLCAnTXVsdGlwbGU6IFwiYnlcIiBtdXN0IGJlIGFuIGFycmF5IG9mIHR3byBvciBtb3JlIGlkcycpO1xuXHQgICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMiwgdHJ1ZSlbMF07XG5cdCAgICB2YXIgc3VidGFibGUgPSBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgMSwgeyAgICAgICAgICAgICAgICAvLyBsb29rdXAgdHlwZSAyIHN1YnRhYmxlLCBmb3JtYXQgMSwgY292ZXJhZ2UgZm9ybWF0IDFcblx0ICAgICAgICBzdWJzdEZvcm1hdDogMSxcblx0ICAgICAgICBjb3ZlcmFnZToge2Zvcm1hdDogMSwgZ2x5cGhzOiBbXX0sXG5cdCAgICAgICAgc2VxdWVuY2VzOiBbXVxuXHQgICAgfSk7XG5cdCAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLCAnTXVsdGlwbGU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgKyBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQpO1xuXHQgICAgdmFyIGNvdmVyYWdlR2x5cGggPSBzdWJzdGl0dXRpb24uc3ViO1xuXHQgICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG5cdCAgICBpZiAocG9zIDwgMCkge1xuXHQgICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuXHQgICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcblx0ICAgICAgICBzdWJ0YWJsZS5zZXF1ZW5jZXMuc3BsaWNlKHBvcywgMCwgMCk7XG5cdCAgICB9XG5cdCAgICBzdWJ0YWJsZS5zZXF1ZW5jZXNbcG9zXSA9IHN1YnN0aXR1dGlvbi5ieTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkIG9yIG1vZGlmeSBhbiBhbHRlcm5hdGUgc3Vic3RpdHV0aW9uIChsb29rdXAgdHlwZSAzKVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2xpZ2EnLCAncmxpZycsICdkbGlnJy4uLilcblx0ICogQHBhcmFtIHtPYmplY3R9IHN1YnN0aXR1dGlvbiAtIHsgc3ViOiBpZCwgYnk6IFtpZHNdIH1cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cblx0ICovXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkQWx0ZXJuYXRlID0gZnVuY3Rpb24oZmVhdHVyZSwgc3Vic3RpdHV0aW9uLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG5cdCAgICB2YXIgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAzLCB0cnVlKVswXTtcblx0ICAgIHZhciBzdWJ0YWJsZSA9IGdldFN1YnN0Rm9ybWF0KGxvb2t1cFRhYmxlLCAxLCB7ICAgICAgICAgICAgICAgIC8vIGxvb2t1cCB0eXBlIDMgc3VidGFibGUsIGZvcm1hdCAxLCBjb3ZlcmFnZSBmb3JtYXQgMVxuXHQgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuXHQgICAgICAgIGNvdmVyYWdlOiB7Zm9ybWF0OiAxLCBnbHlwaHM6IFtdfSxcblx0ICAgICAgICBhbHRlcm5hdGVTZXRzOiBbXVxuXHQgICAgfSk7XG5cdCAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLCAnQWx0ZXJuYXRlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAnICsgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0KTtcblx0ICAgIHZhciBjb3ZlcmFnZUdseXBoID0gc3Vic3RpdHV0aW9uLnN1Yjtcblx0ICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuXHQgICAgaWYgKHBvcyA8IDApIHtcblx0ICAgICAgICBwb3MgPSAtMSAtIHBvcztcblx0ICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG5cdCAgICAgICAgc3VidGFibGUuYWx0ZXJuYXRlU2V0cy5zcGxpY2UocG9zLCAwLCAwKTtcblx0ICAgIH1cblx0ICAgIHN1YnRhYmxlLmFsdGVybmF0ZVNldHNbcG9zXSA9IHN1YnN0aXR1dGlvbi5ieTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkIGEgbGlnYXR1cmUgKGxvb2t1cCB0eXBlIDQpXG5cdCAqIExpZ2F0dXJlcyB3aXRoIG1vcmUgY29tcG9uZW50cyBtdXN0IGJlIHN0b3JlZCBhaGVhZCBvZiB0aG9zZSB3aXRoIGZld2VyIGNvbXBvbmVudHMgaW4gb3JkZXIgdG8gYmUgZm91bmRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsaWdhdHVyZSAtIHsgc3ViOiBbaWRzXSwgYnk6IGlkIH1cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cblx0ICovXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkTGlnYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlLCBsaWdhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuXHQgICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgNCwgdHJ1ZSlbMF07XG5cdCAgICB2YXIgc3VidGFibGUgPSBsb29rdXBUYWJsZS5zdWJ0YWJsZXNbMF07XG5cdCAgICBpZiAoIXN1YnRhYmxlKSB7XG5cdCAgICAgICAgc3VidGFibGUgPSB7ICAgICAgICAgICAgICAgIC8vIGxvb2t1cCB0eXBlIDQgc3VidGFibGUsIGZvcm1hdCAxLCBjb3ZlcmFnZSBmb3JtYXQgMVxuXHQgICAgICAgICAgICBzdWJzdEZvcm1hdDogMSxcblx0ICAgICAgICAgICAgY292ZXJhZ2U6IHsgZm9ybWF0OiAxLCBnbHlwaHM6IFtdIH0sXG5cdCAgICAgICAgICAgIGxpZ2F0dXJlU2V0czogW11cblx0ICAgICAgICB9O1xuXHQgICAgICAgIGxvb2t1cFRhYmxlLnN1YnRhYmxlc1swXSA9IHN1YnRhYmxlO1xuXHQgICAgfVxuXHQgICAgY2hlY2suYXNzZXJ0KHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCA9PT0gMSwgJ0xpZ2F0dXJlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAnICsgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0KTtcblx0ICAgIHZhciBjb3ZlcmFnZUdseXBoID0gbGlnYXR1cmUuc3ViWzBdO1xuXHQgICAgdmFyIGxpZ0NvbXBvbmVudHMgPSBsaWdhdHVyZS5zdWIuc2xpY2UoMSk7XG5cdCAgICB2YXIgbGlnYXR1cmVUYWJsZSA9IHtcblx0ICAgICAgICBsaWdHbHlwaDogbGlnYXR1cmUuYnksXG5cdCAgICAgICAgY29tcG9uZW50czogbGlnQ29tcG9uZW50c1xuXHQgICAgfTtcblx0ICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuXHQgICAgaWYgKHBvcyA+PSAwKSB7XG5cdCAgICAgICAgLy8gbGlnYXR1cmVTZXQgYWxyZWFkeSBleGlzdHNcblx0ICAgICAgICB2YXIgbGlnYXR1cmVTZXQgPSBzdWJ0YWJsZS5saWdhdHVyZVNldHNbcG9zXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpZ2F0dXJlU2V0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIC8vIElmIGxpZ2F0dXJlIGFscmVhZHkgZXhpc3RzLCByZXR1cm4uXG5cdCAgICAgICAgICAgIGlmIChhcnJheXNFcXVhbChsaWdhdHVyZVNldFtpXS5jb21wb25lbnRzLCBsaWdDb21wb25lbnRzKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGxpZ2F0dXJlIGRvZXMgbm90IGV4aXN0OiBhZGQgaXQuXG5cdCAgICAgICAgbGlnYXR1cmVTZXQucHVzaChsaWdhdHVyZVRhYmxlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxpZ2F0dXJlU2V0IGFuZCBhZGQgY292ZXJhZ2UgZm9yIHRoZSBmaXJzdCBnbHlwaC5cblx0ICAgICAgICBwb3MgPSAtMSAtIHBvcztcblx0ICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG5cdCAgICAgICAgc3VidGFibGUubGlnYXR1cmVTZXRzLnNwbGljZShwb3MsIDAsIFtsaWdhdHVyZVRhYmxlXSk7XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIExpc3QgYWxsIGZlYXR1cmUgZGF0YSBmb3IgYSBnaXZlbiBzY3JpcHQgYW5kIGxhbmd1YWdlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuXHQgKiBAcmV0dXJuIHtBcnJheX0gc3Vic3RpdHV0aW9ucyAtIFRoZSBsaXN0IG9mIHN1YnN0aXR1dGlvbnMuXG5cdCAqL1xuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldEZlYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG5cdCAgICBpZiAoL3NzXFxkXFxkLy50ZXN0KGZlYXR1cmUpKSB7XG5cdCAgICAgICAgLy8gc3MwMSAtIHNzMjBcblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRTaW5nbGUoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSk7XG5cdCAgICB9XG5cdCAgICBzd2l0Y2ggKGZlYXR1cmUpIHtcblx0ICAgICAgICBjYXNlICdhYWx0Jzpcblx0ICAgICAgICBjYXNlICdzYWx0Jzpcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2luZ2xlKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpXG5cdCAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLmdldEFsdGVybmF0ZXMoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkpO1xuXHQgICAgICAgIGNhc2UgJ2RsaWcnOlxuXHQgICAgICAgIGNhc2UgJ2xpZ2EnOlxuXHQgICAgICAgIGNhc2UgJ3JsaWcnOlxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMaWdhdHVyZXMoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSk7XG5cdCAgICAgICAgY2FzZSAnY2NtcCc6XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE11bHRpcGxlKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpXG5cdCAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuZ2V0TGlnYXR1cmVzKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpKTtcblx0ICAgICAgICBjYXNlICdzdGNoJzpcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TXVsdGlwbGUoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBzdWJzdGl0dXRpb24gdG8gYSBmZWF0dXJlIGZvciBhIGdpdmVuIHNjcmlwdCBhbmQgbGFuZ3VhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdWIgLSB0aGUgc3Vic3RpdHV0aW9uIHRvIGFkZCAoYW4gb2JqZWN0IGxpa2UgeyBzdWI6IGlkIG9yIFtpZHNdLCBieTogaWQgb3IgW2lkc10gfSlcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cblx0ICovXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG5cdCAgICBpZiAoL3NzXFxkXFxkLy50ZXN0KGZlYXR1cmUpKSB7XG5cdCAgICAgICAgLy8gc3MwMSAtIHNzMjBcblx0ICAgICAgICByZXR1cm4gdGhpcy5hZGRTaW5nbGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcblx0ICAgIH1cblx0ICAgIHN3aXRjaCAoZmVhdHVyZSkge1xuXHQgICAgICAgIGNhc2UgJ2FhbHQnOlxuXHQgICAgICAgIGNhc2UgJ3NhbHQnOlxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHN1Yi5ieSA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFNpbmdsZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEFsdGVybmF0ZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuXHQgICAgICAgIGNhc2UgJ2RsaWcnOlxuXHQgICAgICAgIGNhc2UgJ2xpZ2EnOlxuXHQgICAgICAgIGNhc2UgJ3JsaWcnOlxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRMaWdhdHVyZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuXHQgICAgICAgIGNhc2UgJ2NjbXAnOlxuXHQgICAgICAgICAgICBpZiAoc3ViLmJ5IGluc3RhbmNlb2YgQXJyYXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZE11bHRpcGxlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGlnYXR1cmUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdH07XG5cblx0ZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuXHQgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXHR9XG5cblx0ZnVuY3Rpb24gbm9kZUJ1ZmZlclRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG5cdCAgICB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmxlbmd0aCk7XG5cdCAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgdmlld1tpXSA9IGJ1ZmZlcltpXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGFiO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXJyYXlCdWZmZXJUb05vZGVCdWZmZXIoYWIpIHtcblx0ICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKGFiLmJ5dGVMZW5ndGgpO1xuXHQgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgIGJ1ZmZlcltpXSA9IHZpZXdbaV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBidWZmZXI7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja0FyZ3VtZW50KGV4cHJlc3Npb24sIG1lc3NhZ2UpIHtcblx0ICAgIGlmICghZXhwcmVzc2lvbikge1xuXHQgICAgICAgIHRocm93IG1lc3NhZ2U7XG5cdCAgICB9XG5cdH1cblxuXHQvLyBUaGUgYGdseWZgIHRhYmxlIGRlc2NyaWJlcyB0aGUgZ2x5cGhzIGluIFRydWVUeXBlIG91dGxpbmUgZm9ybWF0LlxuXG5cdC8vIFBhcnNlIHRoZSBjb29yZGluYXRlIGRhdGEgZm9yIGEgZ2x5cGguXG5cdGZ1bmN0aW9uIHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHByZXZpb3VzVmFsdWUsIHNob3J0VmVjdG9yQml0TWFzaywgc2FtZUJpdE1hc2spIHtcblx0ICAgIHZhciB2O1xuXHQgICAgaWYgKChmbGFnICYgc2hvcnRWZWN0b3JCaXRNYXNrKSA+IDApIHtcblx0ICAgICAgICAvLyBUaGUgY29vcmRpbmF0ZSBpcyAxIGJ5dGUgbG9uZy5cblx0ICAgICAgICB2ID0gcC5wYXJzZUJ5dGUoKTtcblx0ICAgICAgICAvLyBUaGUgYHNhbWVgIGJpdCBpcyByZS11c2VkIGZvciBzaG9ydCB2YWx1ZXMgdG8gc2lnbmlmeSB0aGUgc2lnbiBvZiB0aGUgdmFsdWUuXG5cdCAgICAgICAgaWYgKChmbGFnICYgc2FtZUJpdE1hc2spID09PSAwKSB7XG5cdCAgICAgICAgICAgIHYgPSAtdjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2ID0gcHJldmlvdXNWYWx1ZSArIHY7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vICBUaGUgY29vcmRpbmF0ZSBpcyAyIGJ5dGVzIGxvbmcuXG5cdCAgICAgICAgLy8gSWYgdGhlIGBzYW1lYCBiaXQgaXMgc2V0LCB0aGUgY29vcmRpbmF0ZSBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgY29vcmRpbmF0ZS5cblx0ICAgICAgICBpZiAoKGZsYWcgJiBzYW1lQml0TWFzaykgPiAwKSB7XG5cdCAgICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBjb29yZGluYXRlIGFzIGEgc2lnbmVkIDE2LWJpdCBkZWx0YSB2YWx1ZS5cblx0ICAgICAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyBwLnBhcnNlU2hvcnQoKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB2O1xuXHR9XG5cblx0Ly8gUGFyc2UgYSBUcnVlVHlwZSBnbHlwaC5cblx0ZnVuY3Rpb24gcGFyc2VHbHlwaChnbHlwaCwgZGF0YSwgc3RhcnQpIHtcblx0ICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cdCAgICBnbHlwaC5udW1iZXJPZkNvbnRvdXJzID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBnbHlwaC5feE1pbiA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgZ2x5cGguX3lNaW4gPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGdseXBoLl94TWF4ID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBnbHlwaC5feU1heCA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgdmFyIGZsYWdzO1xuXHQgICAgdmFyIGZsYWc7XG5cblx0ICAgIGlmIChnbHlwaC5udW1iZXJPZkNvbnRvdXJzID4gMCkge1xuXHQgICAgICAgIC8vIFRoaXMgZ2x5cGggaXMgbm90IGEgY29tcG9zaXRlLlxuXHQgICAgICAgIHZhciBlbmRQb2ludEluZGljZXMgPSBnbHlwaC5lbmRQb2ludEluZGljZXMgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoLm51bWJlck9mQ29udG91cnM7IGkgKz0gMSkge1xuXHQgICAgICAgICAgICBlbmRQb2ludEluZGljZXMucHVzaChwLnBhcnNlVVNob3J0KCkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGdseXBoLmluc3RydWN0aW9uTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIGdseXBoLmluc3RydWN0aW9ucyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGdseXBoLmluc3RydWN0aW9uTGVuZ3RoOyBpJDEgKz0gMSkge1xuXHQgICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMucHVzaChwLnBhcnNlQnl0ZSgpKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgbnVtYmVyT2ZDb29yZGluYXRlcyA9IGVuZFBvaW50SW5kaWNlc1tlbmRQb2ludEluZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuXHQgICAgICAgIGZsYWdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQyICs9IDEpIHtcblx0ICAgICAgICAgICAgZmxhZyA9IHAucGFyc2VCeXRlKCk7XG5cdCAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG5cdCAgICAgICAgICAgIC8vIElmIGJpdCAzIGlzIHNldCwgd2UgcmVwZWF0IHRoaXMgZmxhZyBuIHRpbWVzLCB3aGVyZSBuIGlzIHRoZSBuZXh0IGJ5dGUuXG5cdCAgICAgICAgICAgIGlmICgoZmxhZyAmIDgpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlcGVhdENvdW50ID0gcC5wYXJzZUJ5dGUoKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVwZWF0Q291bnQ7IGogKz0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaSQyICs9IDE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBjaGVjay5hcmd1bWVudChmbGFncy5sZW5ndGggPT09IG51bWJlck9mQ29vcmRpbmF0ZXMsICdCYWQgZmxhZ3MuJyk7XG5cblx0ICAgICAgICBpZiAoZW5kUG9pbnRJbmRpY2VzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuXHQgICAgICAgICAgICB2YXIgcG9pbnQ7XG5cdCAgICAgICAgICAgIC8vIFgvWSBjb29yZGluYXRlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIHBvaW50LCBleGNlcHQgZm9yIHRoZSBmaXJzdCBwb2ludCB3aGljaCBpcyByZWxhdGl2ZSB0byAwLDAuXG5cdCAgICAgICAgICAgIGlmIChudW1iZXJPZkNvb3JkaW5hdGVzID4gMCkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQzICs9IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaSQzXTtcblx0ICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgIHBvaW50Lm9uQ3VydmUgPSAhIShmbGFnICYgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcG9pbnQubGFzdFBvaW50T2ZDb250b3VyID0gZW5kUG9pbnRJbmRpY2VzLmluZGV4T2YoaSQzKSA+PSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIHB4ID0gMDtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkkNCA9IDA7IGkkNCA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkkNCArPSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2kkNF07XG5cdCAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaSQ0XTtcblx0ICAgICAgICAgICAgICAgICAgICBwb2ludC54ID0gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHgsIDIsIDE2KTtcblx0ICAgICAgICAgICAgICAgICAgICBweCA9IHBvaW50Lng7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciBweSA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDUgKz0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpJDVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2kkNV07XG5cdCAgICAgICAgICAgICAgICAgICAgcG9pbnQueSA9IHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHB5LCA0LCAzMik7XG5cdCAgICAgICAgICAgICAgICAgICAgcHkgPSBwb2ludC55O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gcG9pbnRzO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoZ2x5cGgubnVtYmVyT2ZDb250b3VycyA9PT0gMCkge1xuXHQgICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBnbHlwaC5pc0NvbXBvc2l0ZSA9IHRydWU7XG5cdCAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG5cdCAgICAgICAgZ2x5cGguY29tcG9uZW50cyA9IFtdO1xuXHQgICAgICAgIHZhciBtb3JlQ29tcG9uZW50cyA9IHRydWU7XG5cdCAgICAgICAgd2hpbGUgKG1vcmVDb21wb25lbnRzKSB7XG5cdCAgICAgICAgICAgIGZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgICAgICB2YXIgY29tcG9uZW50ID0ge1xuXHQgICAgICAgICAgICAgICAgZ2x5cGhJbmRleDogcC5wYXJzZVVTaG9ydCgpLFxuXHQgICAgICAgICAgICAgICAgeFNjYWxlOiAxLFxuXHQgICAgICAgICAgICAgICAgc2NhbGUwMTogMCxcblx0ICAgICAgICAgICAgICAgIHNjYWxlMTA6IDAsXG5cdCAgICAgICAgICAgICAgICB5U2NhbGU6IDEsXG5cdCAgICAgICAgICAgICAgICBkeDogMCxcblx0ICAgICAgICAgICAgICAgIGR5OiAwXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAxKSA+IDApIHtcblx0ICAgICAgICAgICAgICAgIC8vIFRoZSBhcmd1bWVudHMgYXJlIHdvcmRzXG5cdCAgICAgICAgICAgICAgICBpZiAoKGZsYWdzICYgMikgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBvZmZzZXRcblx0ICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHkgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBtYXRjaGVkIHBvaW50c1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzID0gW3AucGFyc2VVU2hvcnQoKSwgcC5wYXJzZVVTaG9ydCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgYnl0ZXNcblx0ICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAyKSA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG9mZnNldFxuXHQgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keCA9IHAucGFyc2VDaGFyKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR5ID0gcC5wYXJzZUNoYXIoKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBtYXRjaGVkIHBvaW50c1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzID0gW3AucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKChmbGFncyAmIDgpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNjYWxlXG5cdCAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gY29tcG9uZW50LnlTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgNjQpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBYIC8gWSBzY2FsZVxuXHQgICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG5cdCAgICAgICAgICAgICAgICBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiAxMjgpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIDJ4MiB0cmFuc2Zvcm1hdGlvblxuXHQgICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG5cdCAgICAgICAgICAgICAgICBjb21wb25lbnQuc2NhbGUwMSA9IHAucGFyc2VGMkRvdDE0KCk7XG5cdCAgICAgICAgICAgICAgICBjb21wb25lbnQuc2NhbGUxMCA9IHAucGFyc2VGMkRvdDE0KCk7XG5cdCAgICAgICAgICAgICAgICBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGdseXBoLmNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuXHQgICAgICAgICAgICBtb3JlQ29tcG9uZW50cyA9ICEhKGZsYWdzICYgMzIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZmxhZ3MgJiAweDEwMCkge1xuXHQgICAgICAgICAgICAvLyBXZSBoYXZlIGluc3RydWN0aW9uc1xuXHQgICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkkNiA9IDA7IGkkNiA8IGdseXBoLmluc3RydWN0aW9uTGVuZ3RoOyBpJDYgKz0gMSkge1xuXHQgICAgICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zLnB1c2gocC5wYXJzZUJ5dGUoKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH1cblxuXHQvLyBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgcG9pbnRzIGFuZCByZXR1cm4gYSBuZXcgYXJyYXkuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50cyhwb2ludHMsIHRyYW5zZm9ybSkge1xuXHQgICAgdmFyIG5ld1BvaW50cyA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgcHQgPSBwb2ludHNbaV07XG5cdCAgICAgICAgdmFyIG5ld1B0ID0ge1xuXHQgICAgICAgICAgICB4OiB0cmFuc2Zvcm0ueFNjYWxlICogcHQueCArIHRyYW5zZm9ybS5zY2FsZTAxICogcHQueSArIHRyYW5zZm9ybS5keCxcblx0ICAgICAgICAgICAgeTogdHJhbnNmb3JtLnNjYWxlMTAgKiBwdC54ICsgdHJhbnNmb3JtLnlTY2FsZSAqIHB0LnkgKyB0cmFuc2Zvcm0uZHksXG5cdCAgICAgICAgICAgIG9uQ3VydmU6IHB0Lm9uQ3VydmUsXG5cdCAgICAgICAgICAgIGxhc3RQb2ludE9mQ29udG91cjogcHQubGFzdFBvaW50T2ZDb250b3VyXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBuZXdQb2ludHMucHVzaChuZXdQdCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBuZXdQb2ludHM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDb250b3Vycyhwb2ludHMpIHtcblx0ICAgIHZhciBjb250b3VycyA9IFtdO1xuXHQgICAgdmFyIGN1cnJlbnRDb250b3VyID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcblx0ICAgICAgICBjdXJyZW50Q29udG91ci5wdXNoKHB0KTtcblx0ICAgICAgICBpZiAocHQubGFzdFBvaW50T2ZDb250b3VyKSB7XG5cdCAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuXHQgICAgICAgICAgICBjdXJyZW50Q29udG91ciA9IFtdO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgY2hlY2suYXJndW1lbnQoY3VycmVudENvbnRvdXIubGVuZ3RoID09PSAwLCAnVGhlcmUgYXJlIHN0aWxsIHBvaW50cyBsZWZ0IGluIHRoZSBjdXJyZW50IGNvbnRvdXIuJyk7XG5cdCAgICByZXR1cm4gY29udG91cnM7XG5cdH1cblxuXHQvLyBDb252ZXJ0IHRoZSBUcnVlVHlwZSBnbHlwaCBvdXRsaW5lIHRvIGEgUGF0aC5cblx0ZnVuY3Rpb24gZ2V0UGF0aChwb2ludHMpIHtcblx0ICAgIHZhciBwID0gbmV3IFBhdGgoKTtcblx0ICAgIGlmICghcG9pbnRzKSB7XG5cdCAgICAgICAgcmV0dXJuIHA7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjb250b3VycyA9IGdldENvbnRvdXJzKHBvaW50cyk7XG5cblx0ICAgIGZvciAodmFyIGNvbnRvdXJJbmRleCA9IDA7IGNvbnRvdXJJbmRleCA8IGNvbnRvdXJzLmxlbmd0aDsgKytjb250b3VySW5kZXgpIHtcblx0ICAgICAgICB2YXIgY29udG91ciA9IGNvbnRvdXJzW2NvbnRvdXJJbmRleF07XG5cblx0ICAgICAgICB2YXIgcHJldiA9IG51bGw7XG5cdCAgICAgICAgdmFyIGN1cnIgPSBjb250b3VyW2NvbnRvdXIubGVuZ3RoIC0gMV07XG5cdCAgICAgICAgdmFyIG5leHQgPSBjb250b3VyWzBdO1xuXG5cdCAgICAgICAgaWYgKGN1cnIub25DdXJ2ZSkge1xuXHQgICAgICAgICAgICBwLm1vdmVUbyhjdXJyLngsIGN1cnIueSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKG5leHQub25DdXJ2ZSkge1xuXHQgICAgICAgICAgICAgICAgcC5tb3ZlVG8obmV4dC54LCBuZXh0LnkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gSWYgYm90aCBmaXJzdCBhbmQgbGFzdCBwb2ludHMgYXJlIG9mZi1jdXJ2ZSwgc3RhcnQgYXQgdGhlaXIgbWlkZGxlLlxuXHQgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0ge3g6IChjdXJyLnggKyBuZXh0LngpICogMC41LCB5OiAoY3Vyci55ICsgbmV4dC55KSAqIDAuNX07XG5cdCAgICAgICAgICAgICAgICBwLm1vdmVUbyhzdGFydC54LCBzdGFydC55KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udG91ci5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICBwcmV2ID0gY3Vycjtcblx0ICAgICAgICAgICAgY3VyciA9IG5leHQ7XG5cdCAgICAgICAgICAgIG5leHQgPSBjb250b3VyWyhpICsgMSkgJSBjb250b3VyLmxlbmd0aF07XG5cblx0ICAgICAgICAgICAgaWYgKGN1cnIub25DdXJ2ZSkge1xuXHQgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHN0cmFpZ2h0IGxpbmUuXG5cdCAgICAgICAgICAgICAgICBwLmxpbmVUbyhjdXJyLngsIGN1cnIueSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJldjIgPSBwcmV2O1xuXHQgICAgICAgICAgICAgICAgdmFyIG5leHQyID0gbmV4dDtcblxuXHQgICAgICAgICAgICAgICAgaWYgKCFwcmV2Lm9uQ3VydmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcmV2MiA9IHsgeDogKGN1cnIueCArIHByZXYueCkgKiAwLjUsIHk6IChjdXJyLnkgKyBwcmV2LnkpICogMC41IH07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmICghbmV4dC5vbkN1cnZlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbmV4dDIgPSB7IHg6IChjdXJyLnggKyBuZXh0LngpICogMC41LCB5OiAoY3Vyci55ICsgbmV4dC55KSAqIDAuNSB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBwLnF1YWRyYXRpY0N1cnZlVG8oY3Vyci54LCBjdXJyLnksIG5leHQyLngsIG5leHQyLnkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcC5jbG9zZVBhdGgoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBwO1xuXHR9XG5cblx0ZnVuY3Rpb24gYnVpbGRQYXRoKGdseXBocywgZ2x5cGgpIHtcblx0ICAgIGlmIChnbHlwaC5pc0NvbXBvc2l0ZSkge1xuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGguY29tcG9uZW50cy5sZW5ndGg7IGogKz0gMSkge1xuXHQgICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gZ2x5cGguY29tcG9uZW50c1tqXTtcblx0ICAgICAgICAgICAgdmFyIGNvbXBvbmVudEdseXBoID0gZ2x5cGhzLmdldChjb21wb25lbnQuZ2x5cGhJbmRleCk7XG5cdCAgICAgICAgICAgIC8vIEZvcmNlIHRoZSB0dGZHbHlwaExvYWRlciB0byBwYXJzZSB0aGUgZ2x5cGguXG5cdCAgICAgICAgICAgIGNvbXBvbmVudEdseXBoLmdldFBhdGgoKTtcblx0ICAgICAgICAgICAgaWYgKGNvbXBvbmVudEdseXBoLnBvaW50cykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gKHZvaWQgMCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50Lm1hdGNoZWRQb2ludHMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBwb3NpdGlvbmVkIGJ5IG9mZnNldFxuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKGNvbXBvbmVudEdseXBoLnBvaW50cywgY29tcG9uZW50KTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IHBvc2l0aW9uZWQgYnkgbWF0Y2hlZCBwb2ludHNcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzBdID4gZ2x5cGgucG9pbnRzLmxlbmd0aCAtIDEpIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIChjb21wb25lbnQubWF0Y2hlZFBvaW50c1sxXSA+IGNvbXBvbmVudEdseXBoLnBvaW50cy5sZW5ndGggLSAxKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignTWF0Y2hlZCBwb2ludHMgb3V0IG9mIHJhbmdlIGluICcgKyBnbHlwaC5uYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0UHQgPSBnbHlwaC5wb2ludHNbY29tcG9uZW50Lm1hdGNoZWRQb2ludHNbMF1dO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRQdCA9IGNvbXBvbmVudEdseXBoLnBvaW50c1tjb21wb25lbnQubWF0Y2hlZFBvaW50c1sxXV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeFNjYWxlOiBjb21wb25lbnQueFNjYWxlLCBzY2FsZTAxOiBjb21wb25lbnQuc2NhbGUwMSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUxMDogY29tcG9uZW50LnNjYWxlMTAsIHlTY2FsZTogY29tcG9uZW50LnlTY2FsZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZHg6IDAsIGR5OiAwXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICBzZWNvbmRQdCA9IHRyYW5zZm9ybVBvaW50cyhbc2Vjb25kUHRdLCB0cmFuc2Zvcm0pWzBdO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5keCA9IGZpcnN0UHQueCAtIHNlY29uZFB0Lng7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmR5ID0gZmlyc3RQdC55IC0gc2Vjb25kUHQueTtcblx0ICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyhjb21wb25lbnRHbHlwaC5wb2ludHMsIHRyYW5zZm9ybSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBnbHlwaC5wb2ludHMuY29uY2F0KHRyYW5zZm9ybWVkUG9pbnRzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGdldFBhdGgoZ2x5cGgucG9pbnRzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlR2x5ZlRhYmxlQWxsKGRhdGEsIHN0YXJ0LCBsb2NhLCBmb250KSB7XG5cdCAgICB2YXIgZ2x5cGhzID0gbmV3IGdseXBoc2V0LkdseXBoU2V0KGZvbnQpO1xuXG5cdCAgICAvLyBUaGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsb2NhIHRhYmxlIGlzIGludmFsaWQuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2EubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIG9mZnNldCA9IGxvY2FbaV07XG5cdCAgICAgICAgdmFyIG5leHRPZmZzZXQgPSBsb2NhW2kgKyAxXTtcblx0ICAgICAgICBpZiAob2Zmc2V0ICE9PSBuZXh0T2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LnR0ZkdseXBoTG9hZGVyKGZvbnQsIGksIHBhcnNlR2x5cGgsIGRhdGEsIHN0YXJ0ICsgb2Zmc2V0LCBidWlsZFBhdGgpKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBnbHlwaHMucHVzaChpLCBnbHlwaHNldC5nbHlwaExvYWRlcihmb250LCBpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZ2x5cGhzO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VHbHlmVGFibGVPbkxvd01lbW9yeShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuXHQgICAgdmFyIGdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldChmb250KTtcblxuXHQgICAgZm9udC5fcHVzaCA9IGZ1bmN0aW9uKGkpIHtcblx0ICAgICAgICB2YXIgb2Zmc2V0ID0gbG9jYVtpXTtcblx0ICAgICAgICB2YXIgbmV4dE9mZnNldCA9IGxvY2FbaSArIDFdO1xuXHQgICAgICAgIGlmIChvZmZzZXQgIT09IG5leHRPZmZzZXQpIHtcblx0ICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQudHRmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VHbHlwaCwgZGF0YSwgc3RhcnQgKyBvZmZzZXQsIGJ1aWxkUGF0aCkpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LmdseXBoTG9hZGVyKGZvbnQsIGkpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICByZXR1cm4gZ2x5cGhzO1xuXHR9XG5cblx0Ly8gUGFyc2UgYWxsIHRoZSBnbHlwaHMgYWNjb3JkaW5nIHRvIHRoZSBvZmZzZXRzIGZyb20gdGhlIGBsb2NhYCB0YWJsZS5cblx0ZnVuY3Rpb24gcGFyc2VHbHlmVGFibGUoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQsIG9wdCkge1xuXHQgICAgaWYgKG9wdC5sb3dNZW1vcnkpXG5cdCAgICAgICAgeyByZXR1cm4gcGFyc2VHbHlmVGFibGVPbkxvd01lbW9yeShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCk7IH1cblx0ICAgIGVsc2Vcblx0ICAgICAgICB7IHJldHVybiBwYXJzZUdseWZUYWJsZUFsbChkYXRhLCBzdGFydCwgbG9jYSwgZm9udCk7IH1cblx0fVxuXG5cdHZhciBnbHlmID0geyBnZXRQYXRoOiBnZXRQYXRoLCBwYXJzZTogcGFyc2VHbHlmVGFibGV9O1xuXG5cdC8qIEEgVHJ1ZVR5cGUgZm9udCBoaW50aW5nIGludGVycHJldGVyLlxuXHQqXG5cdCogKGMpIDIwMTcgQXhlbCBLaXR0ZW5iZXJnZXJcblx0KlxuXHQqIFRoaXMgaW50ZXJwcmV0ZXIgaGFzIGJlZW4gaW1wbGVtZW50ZWQgYWNjb3JkaW5nIHRvIHRoaXMgZG9jdW1lbnRhdGlvbjpcblx0KiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA1L0NoYXA1Lmh0bWxcblx0KlxuXHQqIEFjY29yZGluZyB0byB0aGUgZG9jdW1lbnRhdGlvbiBGMjRET1Q2IHZhbHVlcyBhcmUgdXNlZCBmb3IgcGl4ZWxzLlxuXHQqIFRoYXQgbWVhbnMgY2FsY3VsYXRpb24gaXMgMS82NCBwaXhlbCBhY2N1cmF0ZSBhbmQgdXNlcyBpbnRlZ2VyIG9wZXJhdGlvbnMuXG5cdCogSG93ZXZlciwgSmF2YXNjcmlwdCBoYXMgZmxvYXRpbmcgcG9pbnQgb3BlcmF0aW9ucyBieSBkZWZhdWx0IGFuZCBvbmx5XG5cdCogdGhvc2UgYXJlIGF2YWlsYWJsZS4gT25lIGNvdWxkIG1ha2UgYSBjYXNlIHRvIHNpbXVsYXRlIHRoZSAxLzY0IGFjY3VyYWN5XG5cdCogZXhhY3RseSBieSB0cnVuY2F0aW5nIGFmdGVyIGV2ZXJ5IGRpdmlzaW9uIG9wZXJhdGlvblxuXHQqIChmb3IgZXhhbXBsZSB3aXRoIDw8IDApIHRvIGdldCBwaXhlbCBleGFjdGx5IHJlc3VsdHMgYXMgb3RoZXIgVHJ1ZVR5cGVcblx0KiBpbXBsZW1lbnRhdGlvbnMuIEl0IG1heSBtYWtlIHNlbnNlIHNpbmNlIHNvbWUgZm9udHMgYXJlIHBpeGVsIG9wdGltaXplZFxuXHQqIGJ5IGhhbmQgdXNpbmcgREVMVEFQIGluc3RydWN0aW9ucy4gVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gZG9lc24ndFxuXHQqIGFuZCByYXRoZXIgdXNlcyBmdWxsIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbi5cblx0KlxuXHQqIHhTY2FsZSwgeVNjYWxlIGFuZCByb3RhdGlvbiBpcyBjdXJyZW50bHkgaWdub3JlZC5cblx0KlxuXHQqIEEgZmV3IG5vbi10cml2aWFsIGluc3RydWN0aW9ucyBhcmUgbWlzc2luZyBhcyBJIGRpZG4ndCBlbmNvdW50ZXIgeWV0XG5cdCogYSBmb250IHRoYXQgdXNlZCB0aGVtIHRvIHRlc3QgYSBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvbi5cblx0KlxuXHQqIFNvbWUgZm9udHMgc2VlbSB0byB1c2UgdW5kb2N1bWVudGVkIGZlYXR1cmVzIHJlZ2FyZGluZyB0aGUgdHdpbGlnaHQgem9uZS5cblx0KiBPbmx5IHNvbWUgb2YgdGhlbSBhcmUgaW1wbGVtZW50ZWQgYXMgdGhleSB3ZXJlIGVuY291bnRlcmVkLlxuXHQqXG5cdCogVGhlIGV4cG9ydHMuREVCVUcgc3RhdGVtZW50cyBhcmUgcmVtb3ZlZCBvbiB0aGUgbWluaWZpZWQgZGlzdHJpYnV0aW9uIGZpbGUuXG5cdCovXG5cblx0dmFyIGluc3RydWN0aW9uVGFibGU7XG5cdHZhciBleGVjO1xuXHR2YXIgZXhlY0dseXBoO1xuXHR2YXIgZXhlY0NvbXBvbmVudDtcblxuXHQvKlxuXHQqIENyZWF0ZXMgYSBoaW50aW5nIG9iamVjdC5cblx0KlxuXHQqIFRoZXJlIG91Z2h0IHRvIGJlIGV4YWN0bHkgb25lXG5cdCogZm9yIGVhY2ggdHJ1ZXR5cGUgZm9udCB0aGF0IGlzIHVzZWQgZm9yIGhpbnRpbmcuXG5cdCovXG5cdGZ1bmN0aW9uIEhpbnRpbmcoZm9udCkge1xuXHQgICAgLy8gdGhlIGZvbnQgdGhpcyBoaW50aW5nIG9iamVjdCBpcyBmb3Jcblx0ICAgIHRoaXMuZm9udCA9IGZvbnQ7XG5cblx0ICAgIHRoaXMuZ2V0Q29tbWFuZHMgPSBmdW5jdGlvbiAoaFBvaW50cykge1xuXHQgICAgICAgIHJldHVybiBnbHlmLmdldFBhdGgoaFBvaW50cykuY29tbWFuZHM7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBjYWNoZWQgc3RhdGVzXG5cdCAgICB0aGlzLl9mcGdtU3RhdGUgID1cblx0ICAgIHRoaXMuX3ByZXBTdGF0ZSAgPVxuXHQgICAgICAgIHVuZGVmaW5lZDtcblxuXHQgICAgLy8gZXJyb3JTdGF0ZVxuXHQgICAgLy8gMCAuLi4gYWxsIG9rYXlcblx0ICAgIC8vIDEgLi4uIGhhZCBhbiBlcnJvciBpbiBhIGdseWYsXG5cdCAgICAvLyAgICAgICBjb250aW51ZSB3b3JraW5nIGJ1dCBzdG9wIHNwYW1taW5nXG5cdCAgICAvLyAgICAgICB0aGUgY29uc29sZVxuXHQgICAgLy8gMiAuLi4gZXJyb3IgYXQgcHJlcCwgc3RvcCBoaW50aW5nIGF0IHRoaXMgcHBlbVxuXHQgICAgLy8gMyAuLi4gZXJyb3IgYXQgZnBlZywgc3RvcCBoaW50aW5nIGZvciB0aGlzIGZvbnQgYXQgYWxsXG5cdCAgICB0aGlzLl9lcnJvclN0YXRlID0gMDtcblx0fVxuXG5cdC8qXG5cdCogTm90IHJvdW5kaW5nLlxuXHQqL1xuXHRmdW5jdGlvbiByb3VuZE9mZih2KSB7XG5cdCAgICByZXR1cm4gdjtcblx0fVxuXG5cdC8qXG5cdCogUm91bmRpbmcgdG8gZ3JpZC5cblx0Ki9cblx0ZnVuY3Rpb24gcm91bmRUb0dyaWQodikge1xuXHQgICAgLy9Sb3VuZGluZyBpbiBUVCBpcyBzdXBwb3NlZCB0byBcInN5bW1ldHJpY2FsIGFyb3VuZCB6ZXJvXCJcblx0ICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLnJvdW5kKE1hdGguYWJzKHYpKTtcblx0fVxuXG5cdC8qXG5cdCogUm91bmRpbmcgdG8gZG91YmxlIGdyaWQuXG5cdCovXG5cdGZ1bmN0aW9uIHJvdW5kVG9Eb3VibGVHcmlkKHYpIHtcblx0ICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLnJvdW5kKE1hdGguYWJzKHYgKiAyKSkgLyAyO1xuXHR9XG5cblx0Lypcblx0KiBSb3VuZGluZyB0byBoYWxmIGdyaWQuXG5cdCovXG5cdGZ1bmN0aW9uIHJvdW5kVG9IYWxmR3JpZCh2KSB7XG5cdCAgICByZXR1cm4gTWF0aC5zaWduKHYpICogKE1hdGgucm91bmQoTWF0aC5hYnModikgKyAwLjUpIC0gMC41KTtcblx0fVxuXG5cdC8qXG5cdCogUm91bmRpbmcgdG8gdXAgdG8gZ3JpZC5cblx0Ki9cblx0ZnVuY3Rpb24gcm91bmRVcFRvR3JpZCh2KSB7XG5cdCAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5jZWlsKE1hdGguYWJzKHYpKTtcblx0fVxuXG5cdC8qXG5cdCogUm91bmRpbmcgdG8gZG93biB0byBncmlkLlxuXHQqL1xuXHRmdW5jdGlvbiByb3VuZERvd25Ub0dyaWQodikge1xuXHQgICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGguZmxvb3IoTWF0aC5hYnModikpO1xuXHR9XG5cblx0Lypcblx0KiBTdXBlciByb3VuZGluZy5cblx0Ki9cblx0dmFyIHJvdW5kU3VwZXIgPSBmdW5jdGlvbiAodikge1xuXHQgICAgdmFyIHBlcmlvZCA9IHRoaXMuc3JQZXJpb2Q7XG5cdCAgICB2YXIgcGhhc2UgPSB0aGlzLnNyUGhhc2U7XG5cdCAgICB2YXIgdGhyZXNob2xkID0gdGhpcy5zclRocmVzaG9sZDtcblx0ICAgIHZhciBzaWduID0gMTtcblxuXHQgICAgaWYgKHYgPCAwKSB7XG5cdCAgICAgICAgdiA9IC12O1xuXHQgICAgICAgIHNpZ24gPSAtMTtcblx0ICAgIH1cblxuXHQgICAgdiArPSB0aHJlc2hvbGQgLSBwaGFzZTtcblxuXHQgICAgdiA9IE1hdGgudHJ1bmModiAvIHBlcmlvZCkgKiBwZXJpb2Q7XG5cblx0ICAgIHYgKz0gcGhhc2U7XG5cblx0ICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8veGdyaWRmaXQuc291cmNlZm9yZ2UubmV0L3JvdW5kLmh0bWxcblx0ICAgIGlmICh2IDwgMCkgeyByZXR1cm4gcGhhc2UgKiBzaWduOyB9XG5cblx0ICAgIHJldHVybiB2ICogc2lnbjtcblx0fTtcblxuXHQvKlxuXHQqIFVuaXQgdmVjdG9yIG9mIHgtYXhpcy5cblx0Ki9cblx0dmFyIHhVbml0VmVjdG9yID0ge1xuXHQgICAgeDogMSxcblxuXHQgICAgeTogMCxcblxuXHQgICAgYXhpczogJ3gnLFxuXG5cdCAgICAvLyBHZXRzIHRoZSBwcm9qZWN0ZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuXHQgICAgLy8gbzEvbzIgLi4uIGlmIHRydWUsIHJlc3BlY3RpdmUgb3JpZ2luYWwgcG9zaXRpb24gaXMgdXNlZC5cblx0ICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAocDEsIHAyLCBvMSwgbzIpIHtcblx0ICAgICAgICByZXR1cm4gKG8xID8gcDEueG8gOiBwMS54KSAtIChvMiA/IHAyLnhvIDogcDIueCk7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBNb3ZlcyBwb2ludCBwIHNvIHRoZSBtb3ZlZCBwb3NpdGlvbiBoYXMgdGhlIHNhbWUgcmVsYXRpdmVcblx0ICAgIC8vIHBvc2l0aW9uIHRvIHRoZSBtb3ZlZCBwb3NpdGlvbnMgb2YgcnAxIGFuZCBycDIgdGhhbiB0aGVcblx0ICAgIC8vIG9yaWdpbmFsIHBvc2l0aW9ucyBoYWQuXG5cdCAgICAvL1xuXHQgICAgLy8gU2VlIEFQUEVORElYIG9uIElOVEVSUE9MQVRFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuXHQgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIChwLCBycDEsIHJwMiwgcHYpIHtcblx0ICAgICAgICB2YXIgZG8xO1xuXHQgICAgICAgIHZhciBkbzI7XG5cdCAgICAgICAgdmFyIGRvYTE7XG5cdCAgICAgICAgdmFyIGRvYTI7XG5cdCAgICAgICAgdmFyIGRtMTtcblx0ICAgICAgICB2YXIgZG0yO1xuXHQgICAgICAgIHZhciBkdDtcblxuXHQgICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcblx0ICAgICAgICAgICAgZG8xID0gcC54byAtIHJwMS54bztcblx0ICAgICAgICAgICAgZG8yID0gcC54byAtIHJwMi54bztcblx0ICAgICAgICAgICAgZG0xID0gcnAxLnggLSBycDEueG87XG5cdCAgICAgICAgICAgIGRtMiA9IHJwMi54IC0gcnAyLnhvO1xuXHQgICAgICAgICAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcblx0ICAgICAgICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG5cdCAgICAgICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cblx0ICAgICAgICAgICAgaWYgKGR0ID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBwLnggPSBwLnhvICsgKGRtMSArIGRtMikgLyAyO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcC54ID0gcC54byArIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdDtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGRvMSA9IHB2LmRpc3RhbmNlKHAsIHJwMSwgdHJ1ZSwgdHJ1ZSk7XG5cdCAgICAgICAgZG8yID0gcHYuZGlzdGFuY2UocCwgcnAyLCB0cnVlLCB0cnVlKTtcblx0ICAgICAgICBkbTEgPSBwdi5kaXN0YW5jZShycDEsIHJwMSwgZmFsc2UsIHRydWUpO1xuXHQgICAgICAgIGRtMiA9IHB2LmRpc3RhbmNlKHJwMiwgcnAyLCBmYWxzZSwgdHJ1ZSk7XG5cdCAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG5cdCAgICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG5cdCAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuXHQgICAgICAgIGlmIChkdCA9PT0gMCkge1xuXHQgICAgICAgICAgICB4VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICsgZG0yKSAvIDIsIHB2LCB0cnVlKTtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHhVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdCwgcHYsIHRydWUpO1xuXHQgICAgfSxcblxuXHQgICAgLy8gU2xvcGUgb2YgbGluZSBub3JtYWwgdG8gdGhpc1xuXHQgICAgbm9ybWFsU2xvcGU6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcblxuXHQgICAgLy8gU2V0cyB0aGUgcG9pbnQgJ3AnIHJlbGF0aXZlIHRvIHBvaW50ICdycCdcblx0ICAgIC8vIGJ5IHRoZSBkaXN0YW5jZSAnZCcuXG5cdCAgICAvL1xuXHQgICAgLy8gU2VlIEFQUEVORElYIG9uIFNFVFJFTEFUSVZFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuXHQgICAgLy9cblx0ICAgIC8vIHAgICAuLi4gcG9pbnQgdG8gc2V0XG5cdCAgICAvLyBycCAgLi4uIHJlZmVyZW5jZSBwb2ludFxuXHQgICAgLy8gZCAgIC4uLiBkaXN0YW5jZSBvbiBwcm9qZWN0aW9uIHZlY3RvclxuXHQgICAgLy8gcHYgIC4uLiBwcm9qZWN0aW9uIHZlY3RvciAodW5kZWZpbmVkID0gdGhpcylcblx0ICAgIC8vIG9yZyAuLi4gaWYgdHJ1ZSwgdXNlcyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2YgcnAgYXMgcmVmZXJlbmNlLlxuXHQgICAgc2V0UmVsYXRpdmU6IGZ1bmN0aW9uIChwLCBycCwgZCwgcHYsIG9yZykge1xuXHQgICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcblx0ICAgICAgICAgICAgcC54ID0gKG9yZyA/IHJwLnhvIDogcnAueCkgKyBkO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHJweCA9IG9yZyA/IHJwLnhvIDogcnAueDtcblx0ICAgICAgICB2YXIgcnB5ID0gb3JnID8gcnAueW8gOiBycC55O1xuXHQgICAgICAgIHZhciBycGR4ID0gcnB4ICsgZCAqIHB2Lng7XG5cdCAgICAgICAgdmFyIHJwZHkgPSBycHkgKyBkICogcHYueTtcblxuXHQgICAgICAgIHAueCA9IHJwZHggKyAocC55IC0gcnBkeSkgLyBwdi5ub3JtYWxTbG9wZTtcblx0ICAgIH0sXG5cblx0ICAgIC8vIFNsb3BlIG9mIHZlY3RvciBsaW5lLlxuXHQgICAgc2xvcGU6IDAsXG5cblx0ICAgIC8vIFRvdWNoZXMgdGhlIHBvaW50IHAuXG5cdCAgICB0b3VjaDogZnVuY3Rpb24gKHApIHtcblx0ICAgICAgICBwLnhUb3VjaGVkID0gdHJ1ZTtcblx0ICAgIH0sXG5cblx0ICAgIC8vIFRlc3RzIGlmIGEgcG9pbnQgcCBpcyB0b3VjaGVkLlxuXHQgICAgdG91Y2hlZDogZnVuY3Rpb24gKHApIHtcblx0ICAgICAgICByZXR1cm4gcC54VG91Y2hlZDtcblx0ICAgIH0sXG5cblx0ICAgIC8vIFVudG91Y2hlcyB0aGUgcG9pbnQgcC5cblx0ICAgIHVudG91Y2g6IGZ1bmN0aW9uIChwKSB7XG5cdCAgICAgICAgcC54VG91Y2hlZCA9IGZhbHNlO1xuXHQgICAgfVxuXHR9O1xuXG5cdC8qXG5cdCogVW5pdCB2ZWN0b3Igb2YgeS1heGlzLlxuXHQqL1xuXHR2YXIgeVVuaXRWZWN0b3IgPSB7XG5cdCAgICB4OiAwLFxuXG5cdCAgICB5OiAxLFxuXG5cdCAgICBheGlzOiAneScsXG5cblx0ICAgIC8vIEdldHMgdGhlIHByb2plY3RlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG5cdCAgICAvLyBvMS9vMiAuLi4gaWYgdHJ1ZSwgcmVzcGVjdGl2ZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyB1c2VkLlxuXHQgICAgZGlzdGFuY2U6IGZ1bmN0aW9uIChwMSwgcDIsIG8xLCBvMikge1xuXHQgICAgICAgIHJldHVybiAobzEgPyBwMS55byA6IHAxLnkpIC0gKG8yID8gcDIueW8gOiBwMi55KTtcblx0ICAgIH0sXG5cblx0ICAgIC8vIE1vdmVzIHBvaW50IHAgc28gdGhlIG1vdmVkIHBvc2l0aW9uIGhhcyB0aGUgc2FtZSByZWxhdGl2ZVxuXHQgICAgLy8gcG9zaXRpb24gdG8gdGhlIG1vdmVkIHBvc2l0aW9ucyBvZiBycDEgYW5kIHJwMiB0aGFuIHRoZVxuXHQgICAgLy8gb3JpZ2luYWwgcG9zaXRpb25zIGhhZC5cblx0ICAgIC8vXG5cdCAgICAvLyBTZWUgQVBQRU5ESVggb24gSU5URVJQT0xBVEUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG5cdCAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gKHAsIHJwMSwgcnAyLCBwdikge1xuXHQgICAgICAgIHZhciBkbzE7XG5cdCAgICAgICAgdmFyIGRvMjtcblx0ICAgICAgICB2YXIgZG9hMTtcblx0ICAgICAgICB2YXIgZG9hMjtcblx0ICAgICAgICB2YXIgZG0xO1xuXHQgICAgICAgIHZhciBkbTI7XG5cdCAgICAgICAgdmFyIGR0O1xuXG5cdCAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuXHQgICAgICAgICAgICBkbzEgPSBwLnlvIC0gcnAxLnlvO1xuXHQgICAgICAgICAgICBkbzIgPSBwLnlvIC0gcnAyLnlvO1xuXHQgICAgICAgICAgICBkbTEgPSBycDEueSAtIHJwMS55bztcblx0ICAgICAgICAgICAgZG0yID0gcnAyLnkgLSBycDIueW87XG5cdCAgICAgICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuXHQgICAgICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcblx0ICAgICAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuXHQgICAgICAgICAgICBpZiAoZHQgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHAueSA9IHAueW8gKyAoZG0xICsgZG0yKSAvIDI7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBwLnkgPSBwLnlvICsgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0O1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZG8xID0gcHYuZGlzdGFuY2UocCwgcnAxLCB0cnVlLCB0cnVlKTtcblx0ICAgICAgICBkbzIgPSBwdi5kaXN0YW5jZShwLCBycDIsIHRydWUsIHRydWUpO1xuXHQgICAgICAgIGRtMSA9IHB2LmRpc3RhbmNlKHJwMSwgcnAxLCBmYWxzZSwgdHJ1ZSk7XG5cdCAgICAgICAgZG0yID0gcHYuZGlzdGFuY2UocnAyLCBycDIsIGZhbHNlLCB0cnVlKTtcblx0ICAgICAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcblx0ICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcblx0ICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG5cdCAgICAgICAgaWYgKGR0ID09PSAwKSB7XG5cdCAgICAgICAgICAgIHlVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKyBkbTIpIC8gMiwgcHYsIHRydWUpO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgeVVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0LCBwdiwgdHJ1ZSk7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBTbG9wZSBvZiBsaW5lIG5vcm1hbCB0byB0aGlzLlxuXHQgICAgbm9ybWFsU2xvcGU6IDAsXG5cblx0ICAgIC8vIFNldHMgdGhlIHBvaW50ICdwJyByZWxhdGl2ZSB0byBwb2ludCAncnAnXG5cdCAgICAvLyBieSB0aGUgZGlzdGFuY2UgJ2QnXG5cdCAgICAvL1xuXHQgICAgLy8gU2VlIEFQUEVORElYIG9uIFNFVFJFTEFUSVZFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuXHQgICAgLy9cblx0ICAgIC8vIHAgICAuLi4gcG9pbnQgdG8gc2V0XG5cdCAgICAvLyBycCAgLi4uIHJlZmVyZW5jZSBwb2ludFxuXHQgICAgLy8gZCAgIC4uLiBkaXN0YW5jZSBvbiBwcm9qZWN0aW9uIHZlY3RvclxuXHQgICAgLy8gcHYgIC4uLiBwcm9qZWN0aW9uIHZlY3RvciAodW5kZWZpbmVkID0gdGhpcylcblx0ICAgIC8vIG9yZyAuLi4gaWYgdHJ1ZSwgdXNlcyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2YgcnAgYXMgcmVmZXJlbmNlLlxuXHQgICAgc2V0UmVsYXRpdmU6IGZ1bmN0aW9uIChwLCBycCwgZCwgcHYsIG9yZykge1xuXHQgICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcblx0ICAgICAgICAgICAgcC55ID0gKG9yZyA/IHJwLnlvIDogcnAueSkgKyBkO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHJweCA9IG9yZyA/IHJwLnhvIDogcnAueDtcblx0ICAgICAgICB2YXIgcnB5ID0gb3JnID8gcnAueW8gOiBycC55O1xuXHQgICAgICAgIHZhciBycGR4ID0gcnB4ICsgZCAqIHB2Lng7XG5cdCAgICAgICAgdmFyIHJwZHkgPSBycHkgKyBkICogcHYueTtcblxuXHQgICAgICAgIHAueSA9IHJwZHkgKyBwdi5ub3JtYWxTbG9wZSAqIChwLnggLSBycGR4KTtcblx0ICAgIH0sXG5cblx0ICAgIC8vIFNsb3BlIG9mIHZlY3RvciBsaW5lLlxuXHQgICAgc2xvcGU6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcblxuXHQgICAgLy8gVG91Y2hlcyB0aGUgcG9pbnQgcC5cblx0ICAgIHRvdWNoOiBmdW5jdGlvbiAocCkge1xuXHQgICAgICAgIHAueVRvdWNoZWQgPSB0cnVlO1xuXHQgICAgfSxcblxuXHQgICAgLy8gVGVzdHMgaWYgYSBwb2ludCBwIGlzIHRvdWNoZWQuXG5cdCAgICB0b3VjaGVkOiBmdW5jdGlvbiAocCkge1xuXHQgICAgICAgIHJldHVybiBwLnlUb3VjaGVkO1xuXHQgICAgfSxcblxuXHQgICAgLy8gVW50b3VjaGVzIHRoZSBwb2ludCBwLlxuXHQgICAgdW50b3VjaDogZnVuY3Rpb24gKHApIHtcblx0ICAgICAgICBwLnlUb3VjaGVkID0gZmFsc2U7XG5cdCAgICB9XG5cdH07XG5cblx0T2JqZWN0LmZyZWV6ZSh4VW5pdFZlY3Rvcik7XG5cdE9iamVjdC5mcmVlemUoeVVuaXRWZWN0b3IpO1xuXG5cdC8qXG5cdCogQ3JlYXRlcyBhIHVuaXQgdmVjdG9yIHRoYXQgaXMgbm90IHgtIG9yIHktYXhpcy5cblx0Ki9cblx0ZnVuY3Rpb24gVW5pdFZlY3Rvcih4LCB5KSB7XG5cdCAgICB0aGlzLnggPSB4O1xuXHQgICAgdGhpcy55ID0geTtcblx0ICAgIHRoaXMuYXhpcyA9IHVuZGVmaW5lZDtcblx0ICAgIHRoaXMuc2xvcGUgPSB5IC8geDtcblx0ICAgIHRoaXMubm9ybWFsU2xvcGUgPSAteCAvIHk7XG5cdCAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuXHR9XG5cblx0Lypcblx0KiBHZXRzIHRoZSBwcm9qZWN0ZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuXHQqIG8xL28yIC4uLiBpZiB0cnVlLCByZXNwZWN0aXZlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHVzZWQuXG5cdCovXG5cdFVuaXRWZWN0b3IucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24ocDEsIHAyLCBvMSwgbzIpIHtcblx0ICAgIHJldHVybiAoXG5cdCAgICAgICAgdGhpcy54ICogeFVuaXRWZWN0b3IuZGlzdGFuY2UocDEsIHAyLCBvMSwgbzIpICtcblx0ICAgICAgICB0aGlzLnkgKiB5VW5pdFZlY3Rvci5kaXN0YW5jZShwMSwgcDIsIG8xLCBvMilcblx0ICAgICk7XG5cdH07XG5cblx0Lypcblx0KiBNb3ZlcyBwb2ludCBwIHNvIHRoZSBtb3ZlZCBwb3NpdGlvbiBoYXMgdGhlIHNhbWUgcmVsYXRpdmVcblx0KiBwb3NpdGlvbiB0byB0aGUgbW92ZWQgcG9zaXRpb25zIG9mIHJwMSBhbmQgcnAyIHRoYW4gdGhlXG5cdCogb3JpZ2luYWwgcG9zaXRpb25zIGhhZC5cblx0KlxuXHQqIFNlZSBBUFBFTkRJWCBvbiBJTlRFUlBPTEFURSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cblx0Ki9cblx0VW5pdFZlY3Rvci5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihwLCBycDEsIHJwMiwgcHYpIHtcblx0ICAgIHZhciBkbTE7XG5cdCAgICB2YXIgZG0yO1xuXHQgICAgdmFyIGRvMTtcblx0ICAgIHZhciBkbzI7XG5cdCAgICB2YXIgZG9hMTtcblx0ICAgIHZhciBkb2EyO1xuXHQgICAgdmFyIGR0O1xuXG5cdCAgICBkbzEgPSBwdi5kaXN0YW5jZShwLCBycDEsIHRydWUsIHRydWUpO1xuXHQgICAgZG8yID0gcHYuZGlzdGFuY2UocCwgcnAyLCB0cnVlLCB0cnVlKTtcblx0ICAgIGRtMSA9IHB2LmRpc3RhbmNlKHJwMSwgcnAxLCBmYWxzZSwgdHJ1ZSk7XG5cdCAgICBkbTIgPSBwdi5kaXN0YW5jZShycDIsIHJwMiwgZmFsc2UsIHRydWUpO1xuXHQgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG5cdCAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcblx0ICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cblx0ICAgIGlmIChkdCA9PT0gMCkge1xuXHQgICAgICAgIHRoaXMuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSArIGRtMikgLyAyLCBwdiwgdHJ1ZSk7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdCwgcHYsIHRydWUpO1xuXHR9O1xuXG5cdC8qXG5cdCogU2V0cyB0aGUgcG9pbnQgJ3AnIHJlbGF0aXZlIHRvIHBvaW50ICdycCdcblx0KiBieSB0aGUgZGlzdGFuY2UgJ2QnXG5cdCpcblx0KiBTZWUgQVBQRU5ESVggb24gU0VUUkVMQVRJVkUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG5cdCpcblx0KiBwICAgLi4uICBwb2ludCB0byBzZXRcblx0KiBycCAgLi4uIHJlZmVyZW5jZSBwb2ludFxuXHQqIGQgICAuLi4gZGlzdGFuY2Ugb24gcHJvamVjdGlvbiB2ZWN0b3Jcblx0KiBwdiAgLi4uIHByb2plY3Rpb24gdmVjdG9yICh1bmRlZmluZWQgPSB0aGlzKVxuXHQqIG9yZyAuLi4gaWYgdHJ1ZSwgdXNlcyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2YgcnAgYXMgcmVmZXJlbmNlLlxuXHQqL1xuXHRVbml0VmVjdG9yLnByb3RvdHlwZS5zZXRSZWxhdGl2ZSA9IGZ1bmN0aW9uKHAsIHJwLCBkLCBwdiwgb3JnKSB7XG5cdCAgICBwdiA9IHB2IHx8IHRoaXM7XG5cblx0ICAgIHZhciBycHggPSBvcmcgPyBycC54byA6IHJwLng7XG5cdCAgICB2YXIgcnB5ID0gb3JnID8gcnAueW8gOiBycC55O1xuXHQgICAgdmFyIHJwZHggPSBycHggKyBkICogcHYueDtcblx0ICAgIHZhciBycGR5ID0gcnB5ICsgZCAqIHB2Lnk7XG5cblx0ICAgIHZhciBwdm5zID0gcHYubm9ybWFsU2xvcGU7XG5cdCAgICB2YXIgZnZzID0gdGhpcy5zbG9wZTtcblxuXHQgICAgdmFyIHB4ID0gcC54O1xuXHQgICAgdmFyIHB5ID0gcC55O1xuXG5cdCAgICBwLnggPSAoZnZzICogcHggLSBwdm5zICogcnBkeCArIHJwZHkgLSBweSkgLyAoZnZzIC0gcHZucyk7XG5cdCAgICBwLnkgPSBmdnMgKiAocC54IC0gcHgpICsgcHk7XG5cdH07XG5cblx0Lypcblx0KiBUb3VjaGVzIHRoZSBwb2ludCBwLlxuXHQqL1xuXHRVbml0VmVjdG9yLnByb3RvdHlwZS50b3VjaCA9IGZ1bmN0aW9uKHApIHtcblx0ICAgIHAueFRvdWNoZWQgPSB0cnVlO1xuXHQgICAgcC55VG91Y2hlZCA9IHRydWU7XG5cdH07XG5cblx0Lypcblx0KiBSZXR1cm5zIGEgdW5pdCB2ZWN0b3Igd2l0aCB4L3kgY29vcmRpbmF0ZXMuXG5cdCovXG5cdGZ1bmN0aW9uIGdldFVuaXRWZWN0b3IoeCwgeSkge1xuXHQgICAgdmFyIGQgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cblx0ICAgIHggLz0gZDtcblx0ICAgIHkgLz0gZDtcblxuXHQgICAgaWYgKHggPT09IDEgJiYgeSA9PT0gMCkgeyByZXR1cm4geFVuaXRWZWN0b3I7IH1cblx0ICAgIGVsc2UgaWYgKHggPT09IDAgJiYgeSA9PT0gMSkgeyByZXR1cm4geVVuaXRWZWN0b3I7IH1cblx0ICAgIGVsc2UgeyByZXR1cm4gbmV3IFVuaXRWZWN0b3IoeCwgeSk7IH1cblx0fVxuXG5cdC8qXG5cdCogQ3JlYXRlcyBhIHBvaW50IGluIHRoZSBoaW50aW5nIGVuZ2luZS5cblx0Ki9cblx0ZnVuY3Rpb24gSFBvaW50KFxuXHQgICAgeCxcblx0ICAgIHksXG5cdCAgICBsYXN0UG9pbnRPZkNvbnRvdXIsXG5cdCAgICBvbkN1cnZlXG5cdCkge1xuXHQgICAgdGhpcy54ID0gdGhpcy54byA9IE1hdGgucm91bmQoeCAqIDY0KSAvIDY0OyAvLyBoaW50ZWQgeCB2YWx1ZSBhbmQgb3JpZ2luYWwgeC12YWx1ZVxuXHQgICAgdGhpcy55ID0gdGhpcy55byA9IE1hdGgucm91bmQoeSAqIDY0KSAvIDY0OyAvLyBoaW50ZWQgeSB2YWx1ZSBhbmQgb3JpZ2luYWwgeS12YWx1ZVxuXG5cdCAgICB0aGlzLmxhc3RQb2ludE9mQ29udG91ciA9IGxhc3RQb2ludE9mQ29udG91cjtcblx0ICAgIHRoaXMub25DdXJ2ZSA9IG9uQ3VydmU7XG5cdCAgICB0aGlzLnByZXZQb2ludE9uQ29udG91ciA9IHVuZGVmaW5lZDtcblx0ICAgIHRoaXMubmV4dFBvaW50T25Db250b3VyID0gdW5kZWZpbmVkO1xuXHQgICAgdGhpcy54VG91Y2hlZCA9IGZhbHNlO1xuXHQgICAgdGhpcy55VG91Y2hlZCA9IGZhbHNlO1xuXG5cdCAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG5cdH1cblxuXHQvKlxuXHQqIFJldHVybnMgdGhlIG5leHQgdG91Y2hlZCBwb2ludCBvbiB0aGUgY29udG91ci5cblx0KlxuXHQqIHYgIC4uLiB1bml0IHZlY3RvciB0byB0ZXN0IHRvdWNoIGF4aXMuXG5cdCovXG5cdEhQb2ludC5wcm90b3R5cGUubmV4dFRvdWNoZWQgPSBmdW5jdGlvbih2KSB7XG5cdCAgICB2YXIgcCA9IHRoaXMubmV4dFBvaW50T25Db250b3VyO1xuXG5cdCAgICB3aGlsZSAoIXYudG91Y2hlZChwKSAmJiBwICE9PSB0aGlzKSB7IHAgPSBwLm5leHRQb2ludE9uQ29udG91cjsgfVxuXG5cdCAgICByZXR1cm4gcDtcblx0fTtcblxuXHQvKlxuXHQqIFJldHVybnMgdGhlIHByZXZpb3VzIHRvdWNoZWQgcG9pbnQgb24gdGhlIGNvbnRvdXJcblx0KlxuXHQqIHYgIC4uLiB1bml0IHZlY3RvciB0byB0ZXN0IHRvdWNoIGF4aXMuXG5cdCovXG5cdEhQb2ludC5wcm90b3R5cGUucHJldlRvdWNoZWQgPSBmdW5jdGlvbih2KSB7XG5cdCAgICB2YXIgcCA9IHRoaXMucHJldlBvaW50T25Db250b3VyO1xuXG5cdCAgICB3aGlsZSAoIXYudG91Y2hlZChwKSAmJiBwICE9PSB0aGlzKSB7IHAgPSBwLnByZXZQb2ludE9uQ29udG91cjsgfVxuXG5cdCAgICByZXR1cm4gcDtcblx0fTtcblxuXHQvKlxuXHQqIFRoZSB6ZXJvIHBvaW50LlxuXHQqL1xuXHR2YXIgSFBaZXJvID0gT2JqZWN0LmZyZWV6ZShuZXcgSFBvaW50KDAsIDApKTtcblxuXHQvKlxuXHQqIFRoZSBkZWZhdWx0IHN0YXRlIG9mIHRoZSBpbnRlcnByZXRlci5cblx0KlxuXHQqIE5vdGU6IEZyZWV6aW5nIHRoZSBkZWZhdWx0U3RhdGUgYW5kIHRoZW4gZGVyaXZpbmcgZnJvbSBpdFxuXHQqIG1ha2VzIHRoZSBWOCBKYXZhc2NyaXB0IGVuZ2luZSBnb2luZyBhd2t3YXJkLFxuXHQqIHNvIHRoaXMgaXMgYXZvaWRlZCwgYWxiZWl0IHRoZSBkZWZhdWx0U3RhdGUgc2hvdWxkbid0XG5cdCogZXZlciBjaGFuZ2UuXG5cdCovXG5cdHZhciBkZWZhdWx0U3RhdGUgPSB7XG5cdCAgICBjdkN1dEluOiAxNyAvIDE2LCAgICAvLyBjb250cm9sIHZhbHVlIGN1dCBpblxuXHQgICAgZGVsdGFCYXNlOiA5LFxuXHQgICAgZGVsdGFTaGlmdDogMC4xMjUsXG5cdCAgICBsb29wOiAxLCAgICAgICAgICAgICAvLyBsb29wcyBzb21lIGluc3RydWN0aW9uc1xuXHQgICAgbWluRGlzOiAxLCAgICAgICAgICAgLy8gbWluaW11bSBkaXN0YW5jZVxuXHQgICAgYXV0b0ZsaXA6IHRydWVcblx0fTtcblxuXHQvKlxuXHQqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBpbnRlcnByZXRlci5cblx0KlxuXHQqIGVudiAgLi4uICdmcGdtJyBvciAncHJlcCcgb3IgJ2dseWYnXG5cdCogcHJvZyAuLi4gdGhlIHByb2dyYW1cblx0Ki9cblx0ZnVuY3Rpb24gU3RhdGUoZW52LCBwcm9nKSB7XG5cdCAgICB0aGlzLmVudiA9IGVudjtcblx0ICAgIHRoaXMuc3RhY2sgPSBbXTtcblx0ICAgIHRoaXMucHJvZyA9IHByb2c7XG5cblx0ICAgIHN3aXRjaCAoZW52KSB7XG5cdCAgICAgICAgY2FzZSAnZ2x5ZicgOlxuXHQgICAgICAgICAgICB0aGlzLnpwMCA9IHRoaXMuenAxID0gdGhpcy56cDIgPSAxO1xuXHQgICAgICAgICAgICB0aGlzLnJwMCA9IHRoaXMucnAxID0gdGhpcy5ycDIgPSAwO1xuXHQgICAgICAgICAgICAvKiBmYWxsIHRocm91Z2ggKi9cblx0ICAgICAgICBjYXNlICdwcmVwJyA6XG5cdCAgICAgICAgICAgIHRoaXMuZnYgPSB0aGlzLnB2ID0gdGhpcy5kcHYgPSB4VW5pdFZlY3Rvcjtcblx0ICAgICAgICAgICAgdGhpcy5yb3VuZCA9IHJvdW5kVG9HcmlkO1xuXHQgICAgfVxuXHR9XG5cblx0Lypcblx0KiBFeGVjdXRlcyBhIGdseXBoIHByb2dyYW0uXG5cdCpcblx0KiBUaGlzIGRvZXMgdGhlIGhpbnRpbmcgZm9yIGVhY2ggZ2x5cGguXG5cdCpcblx0KiBSZXR1cm5zIGFuIGFycmF5IG9mIG1vdmVkIHBvaW50cy5cblx0KlxuXHQqIGdseXBoOiB0aGUgZ2x5cGggdG8gaGludFxuXHQqIHBwZW06IHRoZSBzaXplIHRoZSBnbHlwaCBpcyByZW5kZXJlZCBmb3Jcblx0Ki9cblx0SGludGluZy5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGdseXBoLCBwcGVtKSB7XG5cdCAgICBpZiAodHlwZW9mIHBwZW0gIT09ICdudW1iZXInKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBzaXplIGlzIG5vdCBhIG51bWJlciEnKTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmVjZWl2ZWQgYSBmYXRhbCBlcnJvciwgZG9uJ3QgZG8gYW55IGhpbnRpbmcgYW55bW9yZS5cblx0ICAgIGlmICh0aGlzLl9lcnJvclN0YXRlID4gMikgeyByZXR1cm47IH1cblxuXHQgICAgdmFyIGZvbnQgPSB0aGlzLmZvbnQ7XG5cdCAgICB2YXIgcHJlcFN0YXRlID0gdGhpcy5fcHJlcFN0YXRlO1xuXG5cdCAgICBpZiAoIXByZXBTdGF0ZSB8fCBwcmVwU3RhdGUucHBlbSAhPT0gcHBlbSkge1xuXHQgICAgICAgIHZhciBmcGdtU3RhdGUgPSB0aGlzLl9mcGdtU3RhdGU7XG5cblx0ICAgICAgICBpZiAoIWZwZ21TdGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBFeGVjdXRlcyB0aGUgZnBnbSBzdGF0ZS5cblx0ICAgICAgICAgICAgLy8gVGhpcyBpcyB1c2VkIGJ5IGZvbnRzIHRvIGRlZmluZSBmdW5jdGlvbnMuXG5cdCAgICAgICAgICAgIFN0YXRlLnByb3RvdHlwZSA9IGRlZmF1bHRTdGF0ZTtcblxuXHQgICAgICAgICAgICBmcGdtU3RhdGUgPVxuXHQgICAgICAgICAgICB0aGlzLl9mcGdtU3RhdGUgPVxuXHQgICAgICAgICAgICAgICAgbmV3IFN0YXRlKCdmcGdtJywgZm9udC50YWJsZXMuZnBnbSk7XG5cblx0ICAgICAgICAgICAgZnBnbVN0YXRlLmZ1bmNzID0gWyBdO1xuXHQgICAgICAgICAgICBmcGdtU3RhdGUuZm9udCA9IGZvbnQ7XG5cblx0ICAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIEZQR00tLS0nKTtcblx0ICAgICAgICAgICAgICAgIGZwZ21TdGF0ZS5zdGVwID0gLTE7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgZXhlYyhmcGdtU3RhdGUpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGludGluZyBlcnJvciBpbiBGUEdNOicgKyBlKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAzO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gRXhlY3V0ZXMgdGhlIHByZXAgcHJvZ3JhbSBmb3IgdGhpcyBwcGVtIHNldHRpbmcuXG5cdCAgICAgICAgLy8gVGhpcyBpcyB1c2VkIGJ5IGZvbnRzIHRvIHNldCBjdnQgdmFsdWVzXG5cdCAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHRvIGJlIHJlbmRlcmVkIGZvbnQgc2l6ZS5cblxuXHQgICAgICAgIFN0YXRlLnByb3RvdHlwZSA9IGZwZ21TdGF0ZTtcblx0ICAgICAgICBwcmVwU3RhdGUgPVxuXHQgICAgICAgIHRoaXMuX3ByZXBTdGF0ZSA9XG5cdCAgICAgICAgICAgIG5ldyBTdGF0ZSgncHJlcCcsIGZvbnQudGFibGVzLnByZXApO1xuXG5cdCAgICAgICAgcHJlcFN0YXRlLnBwZW0gPSBwcGVtO1xuXG5cdCAgICAgICAgLy8gQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGN2dCB0YWJsZVxuXHQgICAgICAgIC8vIGFuZCBzY2FsZXMgaXQgdG8gdGhlIGN1cnJlbnQgcHBlbSBzZXR0aW5nLlxuXHQgICAgICAgIHZhciBvQ3Z0ID0gZm9udC50YWJsZXMuY3Z0O1xuXHQgICAgICAgIGlmIChvQ3Z0KSB7XG5cdCAgICAgICAgICAgIHZhciBjdnQgPSBwcmVwU3RhdGUuY3Z0ID0gbmV3IEFycmF5KG9DdnQubGVuZ3RoKTtcblx0ICAgICAgICAgICAgdmFyIHNjYWxlID0gcHBlbSAvIGZvbnQudW5pdHNQZXJFbTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvQ3Z0Lmxlbmd0aDsgYysrKSB7XG5cdCAgICAgICAgICAgICAgICBjdnRbY10gPSBvQ3Z0W2NdICogc2NhbGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBwcmVwU3RhdGUuY3Z0ID0gW107XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcblx0ICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgUFJFUC0tLScpO1xuXHQgICAgICAgICAgICBwcmVwU3RhdGUuc3RlcCA9IC0xO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGV4ZWMocHJlcFN0YXRlKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvclN0YXRlIDwgMikge1xuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0hpbnRpbmcgZXJyb3IgaW4gUFJFUDonICsgZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDI7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA+IDEpIHsgcmV0dXJuOyB9XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgICAgcmV0dXJuIGV4ZWNHbHlwaChnbHlwaCwgcHJlcFN0YXRlKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA8IDEpIHtcblx0ICAgICAgICAgICAgY29uc29sZS5sb2coJ0hpbnRpbmcgZXJyb3I6JyArIGUpO1xuXHQgICAgICAgICAgICBjb25zb2xlLmxvZygnTm90ZTogZnVydGhlciBoaW50aW5nIGVycm9ycyBhcmUgc2lsZW5jZWQnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDE7XG5cdCAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH1cblx0fTtcblxuXHQvKlxuXHQqIEV4ZWN1dGVzIHRoZSBoaW50aW5nIHByb2dyYW0gZm9yIGEgZ2x5cGguXG5cdCovXG5cdGV4ZWNHbHlwaCA9IGZ1bmN0aW9uKGdseXBoLCBwcmVwU3RhdGUpIHtcblx0ICAgIC8vIG9yaWdpbmFsIHBvaW50IHBvc2l0aW9uc1xuXHQgICAgdmFyIHhTY2FsZSA9IHByZXBTdGF0ZS5wcGVtIC8gcHJlcFN0YXRlLmZvbnQudW5pdHNQZXJFbTtcblx0ICAgIHZhciB5U2NhbGUgPSB4U2NhbGU7XG5cdCAgICB2YXIgY29tcG9uZW50cyA9IGdseXBoLmNvbXBvbmVudHM7XG5cdCAgICB2YXIgY29udG91cnM7XG5cdCAgICB2YXIgZ1pvbmU7XG5cdCAgICB2YXIgc3RhdGU7XG5cblx0ICAgIFN0YXRlLnByb3RvdHlwZSA9IHByZXBTdGF0ZTtcblx0ICAgIGlmICghY29tcG9uZW50cykge1xuXHQgICAgICAgIHN0YXRlID0gbmV3IFN0YXRlKCdnbHlmJywgZ2x5cGguaW5zdHJ1Y3Rpb25zKTtcblx0ICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuXHQgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBHTFlQSC0tLScpO1xuXHQgICAgICAgICAgICBzdGF0ZS5zdGVwID0gLTE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGV4ZWNDb21wb25lbnQoZ2x5cGgsIHN0YXRlLCB4U2NhbGUsIHlTY2FsZSk7XG5cdCAgICAgICAgZ1pvbmUgPSBzdGF0ZS5nWm9uZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIGZvbnQgPSBwcmVwU3RhdGUuZm9udDtcblx0ICAgICAgICBnWm9uZSA9IFtdO1xuXHQgICAgICAgIGNvbnRvdXJzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcblx0ICAgICAgICAgICAgdmFyIGNnID0gZm9udC5nbHlwaHMuZ2V0KGMuZ2x5cGhJbmRleCk7XG5cblx0ICAgICAgICAgICAgc3RhdGUgPSBuZXcgU3RhdGUoJ2dseWYnLCBjZy5pbnN0cnVjdGlvbnMpO1xuXG5cdCAgICAgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBDT01QICcgKyBpICsgJy0tLScpO1xuXHQgICAgICAgICAgICAgICAgc3RhdGUuc3RlcCA9IC0xO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZXhlY0NvbXBvbmVudChjZywgc3RhdGUsIHhTY2FsZSwgeVNjYWxlKTtcblx0ICAgICAgICAgICAgLy8gYXBwZW5kcyB0aGUgY29tcHV0ZWQgcG9pbnRzIHRvIHRoZSByZXN1bHQgYXJyYXlcblx0ICAgICAgICAgICAgLy8gcG9zdCBwcm9jZXNzZXMgdGhlIGNvbXBvbmVudCBwb2ludHNcblx0ICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5yb3VuZChjLmR4ICogeFNjYWxlKTtcblx0ICAgICAgICAgICAgdmFyIGR5ID0gTWF0aC5yb3VuZChjLmR5ICogeVNjYWxlKTtcblx0ICAgICAgICAgICAgdmFyIGd6ID0gc3RhdGUuZ1pvbmU7XG5cdCAgICAgICAgICAgIHZhciBjYyA9IHN0YXRlLmNvbnRvdXJzO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBwaSA9IDA7IHBpIDwgZ3oubGVuZ3RoOyBwaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcCA9IGd6W3BpXTtcblx0ICAgICAgICAgICAgICAgIHAueFRvdWNoZWQgPSBwLnlUb3VjaGVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBwLnhvID0gcC54ID0gcC54ICsgZHg7XG5cdCAgICAgICAgICAgICAgICBwLnlvID0gcC55ID0gcC55ICsgZHk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgZ0xlbiA9IGdab25lLmxlbmd0aDtcblx0ICAgICAgICAgICAgZ1pvbmUucHVzaC5hcHBseShnWm9uZSwgZ3opO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNjLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBjb250b3Vycy5wdXNoKGNjW2pdICsgZ0xlbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZ2x5cGguaW5zdHJ1Y3Rpb25zICYmICFzdGF0ZS5pbmhpYml0R3JpZEZpdCkge1xuXHQgICAgICAgICAgICAvLyB0aGUgY29tcG9zaXRlIGhhcyBpbnN0cnVjdGlvbnMgb24gaXRzIG93blxuXHQgICAgICAgICAgICBzdGF0ZSA9IG5ldyBTdGF0ZSgnZ2x5ZicsIGdseXBoLmluc3RydWN0aW9ucyk7XG5cblx0ICAgICAgICAgICAgc3RhdGUuZ1pvbmUgPSBzdGF0ZS56MCA9IHN0YXRlLnoxID0gc3RhdGUuejIgPSBnWm9uZTtcblxuXHQgICAgICAgICAgICBzdGF0ZS5jb250b3VycyA9IGNvbnRvdXJzO1xuXG5cdCAgICAgICAgICAgIC8vIG5vdGU6IEhQWmVybyBjYW5ub3QgYmUgdXNlZCBoZXJlLCBzaW5jZVxuXHQgICAgICAgICAgICAvLyAgICAgICB0aGUgcG9pbnQgbWlnaHQgYmUgbW9kaWZpZWRcblx0ICAgICAgICAgICAgZ1pvbmUucHVzaChcblx0ICAgICAgICAgICAgICAgIG5ldyBIUG9pbnQoMCwgMCksXG5cdCAgICAgICAgICAgICAgICBuZXcgSFBvaW50KE1hdGgucm91bmQoZ2x5cGguYWR2YW5jZVdpZHRoICogeFNjYWxlKSwgMClcblx0ICAgICAgICAgICAgKTtcblxuXHQgICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgQ09NUE9TSVRFLS0tJyk7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwID0gLTE7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBleGVjKHN0YXRlKTtcblxuXHQgICAgICAgICAgICBnWm9uZS5sZW5ndGggLT0gMjtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBnWm9uZTtcblx0fTtcblxuXHQvKlxuXHQqIEV4ZWN1dGVzIHRoZSBoaW50aW5nIHByb2dyYW0gZm9yIGEgY29tcG9uZW50IG9mIGEgbXVsdGktY29tcG9uZW50IGdseXBoXG5cdCogb3Igb2YgdGhlIGdseXBoIGl0c2VsZiBmb3IgYSBub24tY29tcG9uZW50IGdseXBoLlxuXHQqL1xuXHRleGVjQ29tcG9uZW50ID0gZnVuY3Rpb24oZ2x5cGgsIHN0YXRlLCB4U2NhbGUsIHlTY2FsZSlcblx0e1xuXHQgICAgdmFyIHBvaW50cyA9IGdseXBoLnBvaW50cyB8fCBbXTtcblx0ICAgIHZhciBwTGVuID0gcG9pbnRzLmxlbmd0aDtcblx0ICAgIHZhciBnWm9uZSA9IHN0YXRlLmdab25lID0gc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gW107XG5cdCAgICB2YXIgY29udG91cnMgPSBzdGF0ZS5jb250b3VycyA9IFtdO1xuXG5cdCAgICAvLyBTY2FsZXMgdGhlIG9yaWdpbmFsIHBvaW50cyBhbmRcblx0ICAgIC8vIG1ha2VzIGNvcGllcyBmb3IgdGhlIGhpbnRlZCBwb2ludHMuXG5cdCAgICB2YXIgY3A7IC8vIGN1cnJlbnQgcG9pbnRcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKSB7XG5cdCAgICAgICAgY3AgPSBwb2ludHNbaV07XG5cblx0ICAgICAgICBnWm9uZVtpXSA9IG5ldyBIUG9pbnQoXG5cdCAgICAgICAgICAgIGNwLnggKiB4U2NhbGUsXG5cdCAgICAgICAgICAgIGNwLnkgKiB5U2NhbGUsXG5cdCAgICAgICAgICAgIGNwLmxhc3RQb2ludE9mQ29udG91cixcblx0ICAgICAgICAgICAgY3Aub25DdXJ2ZVxuXHQgICAgICAgICk7XG5cdCAgICB9XG5cblx0ICAgIC8vIENoYWluIGxpbmtzIHRoZSBjb250b3Vycy5cblx0ICAgIHZhciBzcDsgLy8gc3RhcnQgcG9pbnRcblx0ICAgIHZhciBucDsgLy8gbmV4dCBwb2ludFxuXG5cdCAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwTGVuOyBpJDErKykge1xuXHQgICAgICAgIGNwID0gZ1pvbmVbaSQxXTtcblxuXHQgICAgICAgIGlmICghc3ApIHtcblx0ICAgICAgICAgICAgc3AgPSBjcDtcblx0ICAgICAgICAgICAgY29udG91cnMucHVzaChpJDEpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjcC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcblx0ICAgICAgICAgICAgY3AubmV4dFBvaW50T25Db250b3VyID0gc3A7XG5cdCAgICAgICAgICAgIHNwLnByZXZQb2ludE9uQ29udG91ciA9IGNwO1xuXHQgICAgICAgICAgICBzcCA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBucCA9IGdab25lW2kkMSArIDFdO1xuXHQgICAgICAgICAgICBjcC5uZXh0UG9pbnRPbkNvbnRvdXIgPSBucDtcblx0ICAgICAgICAgICAgbnAucHJldlBvaW50T25Db250b3VyID0gY3A7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoc3RhdGUuaW5oaWJpdEdyaWRGaXQpIHsgcmV0dXJuOyB9XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG5cdCAgICAgICAgY29uc29sZS5sb2coJ1BST0NFU1NJTkcgR0xZUEgnLCBzdGF0ZS5zdGFjayk7XG5cdCAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcExlbjsgaSQyKyspIHtcblx0ICAgICAgICAgICAgY29uc29sZS5sb2coaSQyLCBnWm9uZVtpJDJdLngsIGdab25lW2kkMl0ueSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBnWm9uZS5wdXNoKFxuXHQgICAgICAgIG5ldyBIUG9pbnQoMCwgMCksXG5cdCAgICAgICAgbmV3IEhQb2ludChNYXRoLnJvdW5kKGdseXBoLmFkdmFuY2VXaWR0aCAqIHhTY2FsZSksIDApXG5cdCAgICApO1xuXG5cdCAgICBleGVjKHN0YXRlKTtcblxuXHQgICAgLy8gUmVtb3ZlcyB0aGUgZXh0cmEgcG9pbnRzLlxuXHQgICAgZ1pvbmUubGVuZ3RoIC09IDI7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG5cdCAgICAgICAgY29uc29sZS5sb2coJ0ZJTklTSEVEIEdMWVBIJywgc3RhdGUuc3RhY2spO1xuXHQgICAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IHBMZW47IGkkMysrKSB7XG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKGkkMywgZ1pvbmVbaSQzXS54LCBnWm9uZVtpJDNdLnkpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fTtcblxuXHQvKlxuXHQqIEV4ZWN1dGVzIHRoZSBwcm9ncmFtIGxvYWRlZCBpbiBzdGF0ZS5cblx0Ki9cblx0ZXhlYyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdCAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG5cblx0ICAgIGlmICghcHJvZykgeyByZXR1cm47IH1cblxuXHQgICAgdmFyIHBMZW4gPSBwcm9nLmxlbmd0aDtcblx0ICAgIHZhciBpbnM7XG5cblx0ICAgIGZvciAoc3RhdGUuaXAgPSAwOyBzdGF0ZS5pcCA8IHBMZW47IHN0YXRlLmlwKyspIHtcblx0ICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBzdGF0ZS5zdGVwKys7IH1cblx0ICAgICAgICBpbnMgPSBpbnN0cnVjdGlvblRhYmxlW3Byb2dbc3RhdGUuaXBdXTtcblxuXHQgICAgICAgIGlmICghaW5zKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcblx0ICAgICAgICAgICAgICAgICd1bmtub3duIGluc3RydWN0aW9uOiAweCcgK1xuXHQgICAgICAgICAgICAgICAgTnVtYmVyKHByb2dbc3RhdGUuaXBdKS50b1N0cmluZygxNilcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpbnMoc3RhdGUpO1xuXG5cdCAgICAgICAgLy8gdmVyeSBleHRlbnNpdmUgZGVidWdnaW5nIGZvciBlYWNoIHN0ZXBcblx0ICAgICAgICAvKlxuXHQgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG5cdCAgICAgICAgICAgIHZhciBkYTtcblx0ICAgICAgICAgICAgaWYgKHN0YXRlLmdab25lKSB7XG5cdCAgICAgICAgICAgICAgICBkYSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5nWm9uZS5sZW5ndGg7IGkrKylcblx0ICAgICAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICAgICAgICBkYS5wdXNoKGkgKyAnICcgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5nWm9uZVtpXS54ICogNjQgKyAnICcgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5nWm9uZVtpXS55ICogNjQgKyAnICcgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUuZ1pvbmVbaV0ueFRvdWNoZWQgPyAneCcgOiAnJykgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUuZ1pvbmVbaV0ueVRvdWNoZWQgPyAneScgOiAnJylcblx0ICAgICAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0daJywgZGEpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHN0YXRlLnRab25lKSB7XG5cdCAgICAgICAgICAgICAgICBkYSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS50Wm9uZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGRhLnB1c2goaSArICcgJyArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRab25lW2ldLnggKiA2NCArICcgJyArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRab25lW2ldLnkgKiA2NCArICcgJyArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS50Wm9uZVtpXS54VG91Y2hlZCA/ICd4JyA6ICcnKSArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS50Wm9uZVtpXS55VG91Y2hlZCA/ICd5JyA6ICcnKVxuXHQgICAgICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVFonLCBkYSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoc3RhdGUuc3RhY2subGVuZ3RoID4gMTApIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YWNrLmxlbmd0aCxcblx0ICAgICAgICAgICAgICAgICAgICAnLi4uJywgc3RhdGUuc3RhY2suc2xpY2Uoc3RhdGUuc3RhY2subGVuZ3RoIC0gMTApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuc3RhY2subGVuZ3RoLCBzdGF0ZS5zdGFjayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgKi9cblx0ICAgIH1cblx0fTtcblxuXHQvKlxuXHQqIEluaXRpYWxpemVzIHRoZSB0d2lsaWdodCB6b25lLlxuXHQqXG5cdCogVGhpcyBpcyBvbmx5IGRvbmUgaWYgYSBTWlB4IGluc3RydWN0aW9uXG5cdCogcmVmZXJzIHRvIHRoZSB0d2lsaWdodCB6b25lLlxuXHQqL1xuXHRmdW5jdGlvbiBpbml0VFpvbmUoc3RhdGUpXG5cdHtcblx0ICAgIHZhciB0Wm9uZSA9IHN0YXRlLnRab25lID0gbmV3IEFycmF5KHN0YXRlLmdab25lLmxlbmd0aCk7XG5cblx0ICAgIC8vIG5vIGlkZWEgaWYgdGhpcyBpcyBhY3R1YWxseSBjb3JyZWN0Li4uXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRab25lLmxlbmd0aDsgaSsrKVxuXHQgICAge1xuXHQgICAgICAgIHRab25lW2ldID0gbmV3IEhQb2ludCgwLCAwKTtcblx0ICAgIH1cblx0fVxuXG5cdC8qXG5cdCogU2tpcHMgdGhlIGluc3RydWN0aW9uIHBvaW50ZXIgYWhlYWQgb3ZlciBhbiBJRi9FTFNFIGJsb2NrLlxuXHQqIGhhbmRsZUVsc2UgLi4gaWYgdHJ1ZSBicmVha3Mgb24gbWF0Y2hpbmcgRUxTRVxuXHQqL1xuXHRmdW5jdGlvbiBza2lwKHN0YXRlLCBoYW5kbGVFbHNlKVxuXHR7XG5cdCAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG5cdCAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcblx0ICAgIHZhciBuZXN0aW5nID0gMTtcblx0ICAgIHZhciBpbnM7XG5cblx0ICAgIGRvIHtcblx0ICAgICAgICBpbnMgPSBwcm9nWysraXBdO1xuXHQgICAgICAgIGlmIChpbnMgPT09IDB4NTgpIC8vIElGXG5cdCAgICAgICAgICAgIHsgbmVzdGluZysrOyB9XG5cdCAgICAgICAgZWxzZSBpZiAoaW5zID09PSAweDU5KSAvLyBFSUZcblx0ICAgICAgICAgICAgeyBuZXN0aW5nLS07IH1cblx0ICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NDApIC8vIE5QVVNIQlxuXHQgICAgICAgICAgICB7IGlwICs9IHByb2dbaXAgKyAxXSArIDE7IH1cblx0ICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NDEpIC8vIE5QVVNIV1xuXHQgICAgICAgICAgICB7IGlwICs9IDIgKiBwcm9nW2lwICsgMV0gKyAxOyB9XG5cdCAgICAgICAgZWxzZSBpZiAoaW5zID49IDB4QjAgJiYgaW5zIDw9IDB4QjcpIC8vIFBVU0hCXG5cdCAgICAgICAgICAgIHsgaXAgKz0gaW5zIC0gMHhCMCArIDE7IH1cblx0ICAgICAgICBlbHNlIGlmIChpbnMgPj0gMHhCOCAmJiBpbnMgPD0gMHhCRikgLy8gUFVTSFdcblx0ICAgICAgICAgICAgeyBpcCArPSAoaW5zIC0gMHhCOCArIDEpICogMjsgfVxuXHQgICAgICAgIGVsc2UgaWYgKGhhbmRsZUVsc2UgJiYgbmVzdGluZyA9PT0gMSAmJiBpbnMgPT09IDB4MUIpIC8vIEVMU0Vcblx0ICAgICAgICAgICAgeyBicmVhazsgfVxuXHQgICAgfSB3aGlsZSAobmVzdGluZyA+IDApO1xuXG5cdCAgICBzdGF0ZS5pcCA9IGlwO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxuXHQqICAgICAgICAgIEFuZCB0aGVuIGEgbG90IG9mIGluc3RydWN0aW9ucy4uLiAgICAgICAgICAgICAgICAqXG5cdCotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvLyBTVlRDQVthXSBTZXQgZnJlZWRvbSBhbmQgcHJvamVjdGlvbiBWZWN0b3JzIFRvIENvb3JkaW5hdGUgQXhpc1xuXHQvLyAweDAwLTB4MDFcblx0ZnVuY3Rpb24gU1ZUQ0Eodiwgc3RhdGUpIHtcblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTVlRDQVsnICsgdi5heGlzICsgJ10nKTsgfVxuXG5cdCAgICBzdGF0ZS5mdiA9IHN0YXRlLnB2ID0gc3RhdGUuZHB2ID0gdjtcblx0fVxuXG5cdC8vIFNQVlRDQVthXSBTZXQgUHJvamVjdGlvbiBWZWN0b3IgdG8gQ29vcmRpbmF0ZSBBeGlzXG5cdC8vIDB4MDItMHgwM1xuXHRmdW5jdGlvbiBTUFZUQ0Eodiwgc3RhdGUpIHtcblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUFZUQ0FbJyArIHYuYXhpcyArICddJyk7IH1cblxuXHQgICAgc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSB2O1xuXHR9XG5cblx0Ly8gU0ZWVENBW2FdIFNldCBGcmVlZG9tIFZlY3RvciB0byBDb29yZGluYXRlIEF4aXNcblx0Ly8gMHgwNC0weDA1XG5cdGZ1bmN0aW9uIFNGVlRDQSh2LCBzdGF0ZSkge1xuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NGVlRDQVsnICsgdi5heGlzICsgJ10nKTsgfVxuXG5cdCAgICBzdGF0ZS5mdiA9IHY7XG5cdH1cblxuXHQvLyBTUFZUTFthXSBTZXQgUHJvamVjdGlvbiBWZWN0b3IgVG8gTGluZVxuXHQvLyAweDA2LTB4MDdcblx0ZnVuY3Rpb24gU1BWVEwoYSwgc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIHAyaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHAxaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHAyID0gc3RhdGUuejJbcDJpXTtcblx0ICAgIHZhciBwMSA9IHN0YXRlLnoxW3AxaV07XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKCdTUFZUTFsnICsgYSArICddJywgcDJpLCBwMWkpOyB9XG5cblx0ICAgIHZhciBkeDtcblx0ICAgIHZhciBkeTtcblxuXHQgICAgaWYgKCFhKSB7XG5cdCAgICAgICAgZHggPSBwMS54IC0gcDIueDtcblx0ICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBkeCA9IHAyLnkgLSBwMS55O1xuXHQgICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLnB2ID0gc3RhdGUuZHB2ID0gZ2V0VW5pdFZlY3RvcihkeCwgZHkpO1xuXHR9XG5cblx0Ly8gU0ZWVExbYV0gU2V0IEZyZWVkb20gVmVjdG9yIFRvIExpbmVcblx0Ly8gMHgwOC0weDA5XG5cdGZ1bmN0aW9uIFNGVlRMKGEsIHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBwMmkgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBwMWkgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBwMiA9IHN0YXRlLnoyW3AyaV07XG5cdCAgICB2YXIgcDEgPSBzdGF0ZS56MVtwMWldO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygnU0ZWVExbJyArIGEgKyAnXScsIHAyaSwgcDFpKTsgfVxuXG5cdCAgICB2YXIgZHg7XG5cdCAgICB2YXIgZHk7XG5cblx0ICAgIGlmICghYSkge1xuXHQgICAgICAgIGR4ID0gcDEueCAtIHAyLng7XG5cdCAgICAgICAgZHkgPSBwMS55IC0gcDIueTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZHggPSBwMi55IC0gcDEueTtcblx0ICAgICAgICBkeSA9IHAxLnggLSBwMi54O1xuXHQgICAgfVxuXG5cdCAgICBzdGF0ZS5mdiA9IGdldFVuaXRWZWN0b3IoZHgsIGR5KTtcblx0fVxuXG5cdC8vIFNQVkZTW10gU2V0IFByb2plY3Rpb24gVmVjdG9yIEZyb20gU3RhY2tcblx0Ly8gMHgwQVxuXHRmdW5jdGlvbiBTUFZGUyhzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgeSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHggPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NQVkZTW10nLCB5LCB4KTsgfVxuXG5cdCAgICBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IGdldFVuaXRWZWN0b3IoeCwgeSk7XG5cdH1cblxuXHQvLyBTRlZGU1tdIFNldCBGcmVlZG9tIFZlY3RvciBGcm9tIFN0YWNrXG5cdC8vIDB4MEJcblx0ZnVuY3Rpb24gU0ZWRlMoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIHkgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciB4ID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUFZGU1tdJywgeSwgeCk7IH1cblxuXHQgICAgc3RhdGUuZnYgPSBnZXRVbml0VmVjdG9yKHgsIHkpO1xuXHR9XG5cblx0Ly8gR1BWW10gR2V0IFByb2plY3Rpb24gVmVjdG9yXG5cdC8vIDB4MENcblx0ZnVuY3Rpb24gR1BWKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR1BWW10nKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKHB2LnggKiAweDQwMDApO1xuXHQgICAgc3RhY2sucHVzaChwdi55ICogMHg0MDAwKTtcblx0fVxuXG5cdC8vIEdGVltdIEdldCBGcmVlZG9tIFZlY3RvclxuXHQvLyAweDBDXG5cdGZ1bmN0aW9uIEdGVihzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dGVltdJyk7IH1cblxuXHQgICAgc3RhY2sucHVzaChmdi54ICogMHg0MDAwKTtcblx0ICAgIHN0YWNrLnB1c2goZnYueSAqIDB4NDAwMCk7XG5cdH1cblxuXHQvLyBTRlZUUFZbXSBTZXQgRnJlZWRvbSBWZWN0b3IgVG8gUHJvamVjdGlvbiBWZWN0b3Jcblx0Ly8gMHgwRVxuXHRmdW5jdGlvbiBTRlZUUFYoc3RhdGUpIHtcblx0ICAgIHN0YXRlLmZ2ID0gc3RhdGUucHY7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRlZUUFZbXScpOyB9XG5cdH1cblxuXHQvLyBJU0VDVFtdIG1vdmVzIHBvaW50IHAgdG8gdGhlIEludGVyU0VDVGlvbiBvZiB0d28gbGluZXNcblx0Ly8gMHgwRlxuXHRmdW5jdGlvbiBJU0VDVChzdGF0ZSlcblx0e1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgcGEwaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHBhMWkgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBwYjBpID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcGIxaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgejAgPSBzdGF0ZS56MDtcblx0ICAgIHZhciB6MSA9IHN0YXRlLnoxO1xuXHQgICAgdmFyIHBhMCA9IHowW3BhMGldO1xuXHQgICAgdmFyIHBhMSA9IHowW3BhMWldO1xuXHQgICAgdmFyIHBiMCA9IHoxW3BiMGldO1xuXHQgICAgdmFyIHBiMSA9IHoxW3BiMWldO1xuXHQgICAgdmFyIHAgPSBzdGF0ZS56MltwaV07XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKCdJU0VDVFtdLCAnLCBwYTBpLCBwYTFpLCBwYjBpLCBwYjFpLCBwaSk7IH1cblxuXHQgICAgLy8gbWF0aCBmcm9tXG5cdCAgICAvLyBlbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZSVFMiU4MCU5M2xpbmVfaW50ZXJzZWN0aW9uI0dpdmVuX3R3b19wb2ludHNfb25fZWFjaF9saW5lXG5cblx0ICAgIHZhciB4MSA9IHBhMC54O1xuXHQgICAgdmFyIHkxID0gcGEwLnk7XG5cdCAgICB2YXIgeDIgPSBwYTEueDtcblx0ICAgIHZhciB5MiA9IHBhMS55O1xuXHQgICAgdmFyIHgzID0gcGIwLng7XG5cdCAgICB2YXIgeTMgPSBwYjAueTtcblx0ICAgIHZhciB4NCA9IHBiMS54O1xuXHQgICAgdmFyIHk0ID0gcGIxLnk7XG5cblx0ICAgIHZhciBkaXYgPSAoeDEgLSB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgLSB4NCk7XG5cdCAgICB2YXIgZjEgPSB4MSAqIHkyIC0geTEgKiB4Mjtcblx0ICAgIHZhciBmMiA9IHgzICogeTQgLSB5MyAqIHg0O1xuXG5cdCAgICBwLnggPSAoZjEgKiAoeDMgLSB4NCkgLSBmMiAqICh4MSAtIHgyKSkgLyBkaXY7XG5cdCAgICBwLnkgPSAoZjEgKiAoeTMgLSB5NCkgLSBmMiAqICh5MSAtIHkyKSkgLyBkaXY7XG5cdH1cblxuXHQvLyBTUlAwW10gU2V0IFJlZmVyZW5jZSBQb2ludCAwXG5cdC8vIDB4MTBcblx0ZnVuY3Rpb24gU1JQMChzdGF0ZSkge1xuXHQgICAgc3RhdGUucnAwID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUlAwW10nLCBzdGF0ZS5ycDApOyB9XG5cdH1cblxuXHQvLyBTUlAxW10gU2V0IFJlZmVyZW5jZSBQb2ludCAxXG5cdC8vIDB4MTFcblx0ZnVuY3Rpb24gU1JQMShzdGF0ZSkge1xuXHQgICAgc3RhdGUucnAxID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUlAxW10nLCBzdGF0ZS5ycDEpOyB9XG5cdH1cblxuXHQvLyBTUlAxW10gU2V0IFJlZmVyZW5jZSBQb2ludCAyXG5cdC8vIDB4MTJcblx0ZnVuY3Rpb24gU1JQMihzdGF0ZSkge1xuXHQgICAgc3RhdGUucnAyID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUlAyW10nLCBzdGF0ZS5ycDIpOyB9XG5cdH1cblxuXHQvLyBTWlAwW10gU2V0IFpvbmUgUG9pbnRlciAwXG5cdC8vIDB4MTNcblx0ZnVuY3Rpb24gU1pQMChzdGF0ZSkge1xuXHQgICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NaUDBbXScsIG4pOyB9XG5cblx0ICAgIHN0YXRlLnpwMCA9IG47XG5cblx0ICAgIHN3aXRjaCAobikge1xuXHQgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG5cdCAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUudFpvbmU7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMSA6XG5cdCAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUuZ1pvbmU7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGRlZmF1bHQgOlxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG5cdCAgICB9XG5cdH1cblxuXHQvLyBTWlAxW10gU2V0IFpvbmUgUG9pbnRlciAxXG5cdC8vIDB4MTRcblx0ZnVuY3Rpb24gU1pQMShzdGF0ZSkge1xuXHQgICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NaUDFbXScsIG4pOyB9XG5cblx0ICAgIHN0YXRlLnpwMSA9IG47XG5cblx0ICAgIHN3aXRjaCAobikge1xuXHQgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG5cdCAgICAgICAgICAgIHN0YXRlLnoxID0gc3RhdGUudFpvbmU7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMSA6XG5cdCAgICAgICAgICAgIHN0YXRlLnoxID0gc3RhdGUuZ1pvbmU7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGRlZmF1bHQgOlxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG5cdCAgICB9XG5cdH1cblxuXHQvLyBTWlAyW10gU2V0IFpvbmUgUG9pbnRlciAyXG5cdC8vIDB4MTVcblx0ZnVuY3Rpb24gU1pQMihzdGF0ZSkge1xuXHQgICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NaUDJbXScsIG4pOyB9XG5cblx0ICAgIHN0YXRlLnpwMiA9IG47XG5cblx0ICAgIHN3aXRjaCAobikge1xuXHQgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG5cdCAgICAgICAgICAgIHN0YXRlLnoyID0gc3RhdGUudFpvbmU7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMSA6XG5cdCAgICAgICAgICAgIHN0YXRlLnoyID0gc3RhdGUuZ1pvbmU7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGRlZmF1bHQgOlxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG5cdCAgICB9XG5cdH1cblxuXHQvLyBTWlBTW10gU2V0IFpvbmUgUG9pbnRlclNcblx0Ly8gMHgxNlxuXHRmdW5jdGlvbiBTWlBTKHN0YXRlKSB7XG5cdCAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQU1tdJywgbik7IH1cblxuXHQgICAgc3RhdGUuenAwID0gc3RhdGUuenAxID0gc3RhdGUuenAyID0gbjtcblxuXHQgICAgc3dpdGNoIChuKSB7XG5cdCAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cblx0ICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gc3RhdGUudFpvbmU7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMSA6XG5cdCAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IHN0YXRlLmdab25lO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0IDpcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuXHQgICAgfVxuXHR9XG5cblx0Ly8gU0xPT1BbXSBTZXQgTE9PUCB2YXJpYWJsZVxuXHQvLyAweDE3XG5cdGZ1bmN0aW9uIFNMT09QKHN0YXRlKSB7XG5cdCAgICBzdGF0ZS5sb29wID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTTE9PUFtdJywgc3RhdGUubG9vcCk7IH1cblx0fVxuXG5cdC8vIFJUR1tdIFJvdW5kIFRvIEdyaWRcblx0Ly8gMHgxOFxuXHRmdW5jdGlvbiBSVEcoc3RhdGUpIHtcblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVEdbXScpOyB9XG5cblx0ICAgIHN0YXRlLnJvdW5kID0gcm91bmRUb0dyaWQ7XG5cdH1cblxuXHQvLyBSVEhHW10gUm91bmQgVG8gSGFsZiBHcmlkXG5cdC8vIDB4MTlcblx0ZnVuY3Rpb24gUlRIRyhzdGF0ZSkge1xuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JUSEdbXScpOyB9XG5cblx0ICAgIHN0YXRlLnJvdW5kID0gcm91bmRUb0hhbGZHcmlkO1xuXHR9XG5cblx0Ly8gU01EW10gU2V0IE1pbmltdW0gRGlzdGFuY2Vcblx0Ly8gMHgxQVxuXHRmdW5jdGlvbiBTTUQoc3RhdGUpIHtcblx0ICAgIHZhciBkID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTTURbXScsIGQpOyB9XG5cblx0ICAgIHN0YXRlLm1pbkRpcyA9IGQgLyAweDQwO1xuXHR9XG5cblx0Ly8gRUxTRVtdIEVMU0UgY2xhdXNlXG5cdC8vIDB4MUJcblx0ZnVuY3Rpb24gRUxTRShzdGF0ZSkge1xuXHQgICAgLy8gVGhpcyBpbnN0cnVjdGlvbiBoYXMgYmVlbiByZWFjaGVkIGJ5IGV4ZWN1dGluZyBhIHRoZW4gYnJhbmNoXG5cdCAgICAvLyBzbyBpdCBqdXN0IHNraXBzIGFoZWFkIHVudGlsIG1hdGNoaW5nIEVJRi5cblx0ICAgIC8vXG5cdCAgICAvLyBJbiBjYXNlIHRoZSBJRiB3YXMgbmVnYXRpdmUgdGhlIElGW10gaW5zdHJ1Y3Rpb24gYWxyZWFkeVxuXHQgICAgLy8gc2tpcHBlZCBmb3J3YXJkIG92ZXIgdGhlIEVMU0VbXVxuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRUxTRVtdJyk7IH1cblxuXHQgICAgc2tpcChzdGF0ZSwgZmFsc2UpO1xuXHR9XG5cblx0Ly8gSk1QUltdIEp1TVAgUmVsYXRpdmVcblx0Ly8gMHgxQ1xuXHRmdW5jdGlvbiBKTVBSKHN0YXRlKSB7XG5cdCAgICB2YXIgbyA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnSk1QUltdJywgbyk7IH1cblxuXHQgICAgLy8gQSBqdW1wIGJ5IDEgd291bGQgZG8gbm90aGluZy5cblx0ICAgIHN0YXRlLmlwICs9IG8gLSAxO1xuXHR9XG5cblx0Ly8gU0NWVENJW10gU2V0IENvbnRyb2wgVmFsdWUgVGFibGUgQ3V0LUluXG5cdC8vIDB4MURcblx0ZnVuY3Rpb24gU0NWVENJKHN0YXRlKSB7XG5cdCAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0NWVENJW10nLCBuKTsgfVxuXG5cdCAgICBzdGF0ZS5jdkN1dEluID0gbiAvIDB4NDA7XG5cdH1cblxuXHQvLyBEVVBbXSBEVVBsaWNhdGUgdG9wIHN0YWNrIGVsZW1lbnRcblx0Ly8gMHgyMFxuXHRmdW5jdGlvbiBEVVAoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRFVQW10nKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKTtcblx0fVxuXG5cdC8vIFBPUFtdIFBPUCB0b3Agc3RhY2sgZWxlbWVudFxuXHQvLyAweDIxXG5cdGZ1bmN0aW9uIFBPUChzdGF0ZSkge1xuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1BPUFtdJyk7IH1cblxuXHQgICAgc3RhdGUuc3RhY2sucG9wKCk7XG5cdH1cblxuXHQvLyBDTEVBUltdIENMRUFSIHRoZSBzdGFja1xuXHQvLyAweDIyXG5cdGZ1bmN0aW9uIENMRUFSKHN0YXRlKSB7XG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0xFQVJbXScpOyB9XG5cblx0ICAgIHN0YXRlLnN0YWNrLmxlbmd0aCA9IDA7XG5cdH1cblxuXHQvLyBTV0FQW10gU1dBUCB0aGUgdG9wIHR3byBlbGVtZW50cyBvbiB0aGUgc3RhY2tcblx0Ly8gMHgyM1xuXHRmdW5jdGlvbiBTV0FQKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuXHQgICAgdmFyIGEgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBiID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTV0FQW10nKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKGEpO1xuXHQgICAgc3RhY2sucHVzaChiKTtcblx0fVxuXG5cdC8vIERFUFRIW10gREVQVEggb2YgdGhlIHN0YWNrXG5cdC8vIDB4MjRcblx0ZnVuY3Rpb24gREVQVEgoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVQVEhbXScpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goc3RhY2subGVuZ3RoKTtcblx0fVxuXG5cdC8vIExPT1BDQUxMW10gTE9PUENBTEwgZnVuY3Rpb25cblx0Ly8gMHgyQVxuXHRmdW5jdGlvbiBMT09QQ0FMTChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgZm4gPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBjID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdMT09QQ0FMTFtdJywgZm4sIGMpOyB9XG5cblx0ICAgIC8vIHNhdmVzIGNhbGxlcnMgcHJvZ3JhbVxuXHQgICAgdmFyIGNpcCA9IHN0YXRlLmlwO1xuXHQgICAgdmFyIGNwcm9nID0gc3RhdGUucHJvZztcblxuXHQgICAgc3RhdGUucHJvZyA9IHN0YXRlLmZ1bmNzW2ZuXTtcblxuXHQgICAgLy8gZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7IGkrKykge1xuXHQgICAgICAgIGV4ZWMoc3RhdGUpO1xuXG5cdCAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coXG5cdCAgICAgICAgICAgICsrc3RhdGUuc3RlcCxcblx0ICAgICAgICAgICAgaSArIDEgPCBjID8gJ25leHQgbG9vcGNhbGwnIDogJ2RvbmUgbG9vcGNhbGwnLFxuXHQgICAgICAgICAgICBpXG5cdCAgICAgICAgKTsgfVxuXHQgICAgfVxuXG5cdCAgICAvLyByZXN0b3JlcyB0aGUgY2FsbGVycyBwcm9ncmFtXG5cdCAgICBzdGF0ZS5pcCA9IGNpcDtcblx0ICAgIHN0YXRlLnByb2cgPSBjcHJvZztcblx0fVxuXG5cdC8vIENBTExbXSBDQUxMIGZ1bmN0aW9uXG5cdC8vIDB4MkJcblx0ZnVuY3Rpb24gQ0FMTChzdGF0ZSkge1xuXHQgICAgdmFyIGZuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdDQUxMW10nLCBmbik7IH1cblxuXHQgICAgLy8gc2F2ZXMgY2FsbGVycyBwcm9ncmFtXG5cdCAgICB2YXIgY2lwID0gc3RhdGUuaXA7XG5cdCAgICB2YXIgY3Byb2cgPSBzdGF0ZS5wcm9nO1xuXG5cdCAgICBzdGF0ZS5wcm9nID0gc3RhdGUuZnVuY3NbZm5dO1xuXG5cdCAgICAvLyBleGVjdXRlcyB0aGUgZnVuY3Rpb25cblx0ICAgIGV4ZWMoc3RhdGUpO1xuXG5cdCAgICAvLyByZXN0b3JlcyB0aGUgY2FsbGVycyBwcm9ncmFtXG5cdCAgICBzdGF0ZS5pcCA9IGNpcDtcblx0ICAgIHN0YXRlLnByb2cgPSBjcHJvZztcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coKytzdGF0ZS5zdGVwLCAncmV0dXJuaW5nIGZyb20nLCBmbik7IH1cblx0fVxuXG5cdC8vIENJTkRFWFtdIENvcHkgdGhlIElOREVYZWQgZWxlbWVudCB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xuXHQvLyAweDI1XG5cdGZ1bmN0aW9uIENJTkRFWChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgayA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0lOREVYW10nLCBrKTsgfVxuXG5cdCAgICAvLyBJbiBjYXNlIG9mIGsgPT0gMSwgaXQgY29waWVzIHRoZSBsYXN0IGVsZW1lbnQgYWZ0ZXIgcG9wcGluZ1xuXHQgICAgLy8gdGh1cyBzdGFjay5sZW5ndGggLSBrLlxuXHQgICAgc3RhY2sucHVzaChzdGFja1tzdGFjay5sZW5ndGggLSBrXSk7XG5cdH1cblxuXHQvLyBNSU5ERVhbXSBNb3ZlIHRoZSBJTkRFWGVkIGVsZW1lbnQgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2tcblx0Ly8gMHgyNlxuXHRmdW5jdGlvbiBNSU5ERVgoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIGsgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01JTkRFWFtdJywgayk7IH1cblxuXHQgICAgc3RhY2sucHVzaChzdGFjay5zcGxpY2Uoc3RhY2subGVuZ3RoIC0gaywgMSlbMF0pO1xuXHR9XG5cblx0Ly8gRkRFRltdIEZ1bmN0aW9uIERFRmluaXRpb25cblx0Ly8gMHgyQ1xuXHRmdW5jdGlvbiBGREVGKHN0YXRlKSB7XG5cdCAgICBpZiAoc3RhdGUuZW52ICE9PSAnZnBnbScpIHsgdGhyb3cgbmV3IEVycm9yKCdGREVGIG5vdCBhbGxvd2VkIGhlcmUnKTsgfVxuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG5cdCAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcblxuXHQgICAgdmFyIGZuID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgaXBCZWdpbiA9IGlwO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRkRFRltdJywgZm4pOyB9XG5cblx0ICAgIHdoaWxlIChwcm9nWysraXBdICE9PSAweDJEKXsgfVxuXG5cdCAgICBzdGF0ZS5pcCA9IGlwO1xuXHQgICAgc3RhdGUuZnVuY3NbZm5dID0gcHJvZy5zbGljZShpcEJlZ2luICsgMSwgaXApO1xuXHR9XG5cblx0Ly8gTURBUFthXSBNb3ZlIERpcmVjdCBBYnNvbHV0ZSBQb2ludFxuXHQvLyAweDJFLTB4MkZcblx0ZnVuY3Rpb24gTURBUChyb3VuZCwgc3RhdGUpIHtcblx0ICAgIHZhciBwaSA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHAgPSBzdGF0ZS56MFtwaV07XG5cdCAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcblx0ICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTURBUFsnICsgcm91bmQgKyAnXScsIHBpKTsgfVxuXG5cdCAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHAsIEhQWmVybyk7XG5cblx0ICAgIGlmIChyb3VuZCkgeyBkID0gc3RhdGUucm91bmQoZCk7IH1cblxuXHQgICAgZnYuc2V0UmVsYXRpdmUocCwgSFBaZXJvLCBkLCBwdik7XG5cdCAgICBmdi50b3VjaChwKTtcblxuXHQgICAgc3RhdGUucnAwID0gc3RhdGUucnAxID0gcGk7XG5cdH1cblxuXHQvLyBJVVBbYV0gSW50ZXJwb2xhdGUgVW50b3VjaGVkIFBvaW50cyB0aHJvdWdoIHRoZSBvdXRsaW5lXG5cdC8vIDB4MzBcblx0ZnVuY3Rpb24gSVVQKHYsIHN0YXRlKSB7XG5cdCAgICB2YXIgejIgPSBzdGF0ZS56Mjtcblx0ICAgIHZhciBwTGVuID0gejIubGVuZ3RoIC0gMjtcblx0ICAgIHZhciBjcDtcblx0ICAgIHZhciBwcDtcblx0ICAgIHZhciBucDtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0lVUFsnICsgdi5heGlzICsgJ10nKTsgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBMZW47IGkrKykge1xuXHQgICAgICAgIGNwID0gejJbaV07IC8vIGN1cnJlbnQgcG9pbnRcblxuXHQgICAgICAgIC8vIGlmIHRoaXMgcG9pbnQgaGFzIGJlZW4gdG91Y2hlZCBnbyBvblxuXHQgICAgICAgIGlmICh2LnRvdWNoZWQoY3ApKSB7IGNvbnRpbnVlOyB9XG5cblx0ICAgICAgICBwcCA9IGNwLnByZXZUb3VjaGVkKHYpO1xuXG5cdCAgICAgICAgLy8gbm8gcG9pbnQgb24gdGhlIGNvbnRvdXIgaGFzIGJlZW4gdG91Y2hlZD9cblx0ICAgICAgICBpZiAocHAgPT09IGNwKSB7IGNvbnRpbnVlOyB9XG5cblx0ICAgICAgICBucCA9IGNwLm5leHRUb3VjaGVkKHYpO1xuXG5cdCAgICAgICAgaWYgKHBwID09PSBucCkge1xuXHQgICAgICAgICAgICAvLyBvbmx5IG9uZSBwb2ludCBvbiB0aGUgY29udG91ciBoYXMgYmVlbiB0b3VjaGVkXG5cdCAgICAgICAgICAgIC8vIHNvIHNpbXBseSBtb3ZlcyB0aGUgcG9pbnQgbGlrZSB0aGF0XG5cblx0ICAgICAgICAgICAgdi5zZXRSZWxhdGl2ZShjcCwgY3AsIHYuZGlzdGFuY2UocHAsIHBwLCBmYWxzZSwgdHJ1ZSksIHYsIHRydWUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHYuaW50ZXJwb2xhdGUoY3AsIHBwLCBucCwgdik7XG5cdCAgICB9XG5cdH1cblxuXHQvLyBTSFBbXSBTSGlmdCBQb2ludCB1c2luZyByZWZlcmVuY2UgcG9pbnRcblx0Ly8gMHgzMi0weDMzXG5cdGZ1bmN0aW9uIFNIUChhLCBzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgcnBpID0gYSA/IHN0YXRlLnJwMSA6IHN0YXRlLnJwMjtcblx0ICAgIHZhciBycCA9IChhID8gc3RhdGUuejAgOiBzdGF0ZS56MSlbcnBpXTtcblx0ICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuXHQgICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cdCAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG5cdCAgICB2YXIgejIgPSBzdGF0ZS56MjtcblxuXHQgICAgd2hpbGUgKGxvb3AtLSlcblx0ICAgIHtcblx0ICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICB2YXIgcCA9IHoyW3BpXTtcblxuXHQgICAgICAgIHZhciBkID0gcHYuZGlzdGFuY2UocnAsIHJwLCBmYWxzZSwgdHJ1ZSk7XG5cdCAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuXHQgICAgICAgIGZ2LnRvdWNoKHApO1xuXG5cdCAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcblx0ICAgICAgICAgICAgY29uc29sZS5sb2coXG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuXHQgICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID9cblx0ICAgICAgICAgICAgICAgICAgICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6XG5cdCAgICAgICAgICAgICAgICAgICAnJ1xuXHQgICAgICAgICAgICAgICAgKSArXG5cdCAgICAgICAgICAgICAgICAnU0hQWycgKyAoYSA/ICdycDEnIDogJ3JwMicpICsgJ10nLCBwaVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgc3RhdGUubG9vcCA9IDE7XG5cdH1cblxuXHQvLyBTSENbXSBTSGlmdCBDb250b3VyIHVzaW5nIHJlZmVyZW5jZSBwb2ludFxuXHQvLyAweDM2LTB4Mzdcblx0ZnVuY3Rpb24gU0hDKGEsIHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBycGkgPSBhID8gc3RhdGUucnAxIDogc3RhdGUucnAyO1xuXHQgICAgdmFyIHJwID0gKGEgPyBzdGF0ZS56MCA6IHN0YXRlLnoxKVtycGldO1xuXHQgICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG5cdCAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblx0ICAgIHZhciBjaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHNwID0gc3RhdGUuejJbc3RhdGUuY29udG91cnNbY2ldXTtcblx0ICAgIHZhciBwID0gc3A7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTSENbJyArIGEgKyAnXScsIGNpKTsgfVxuXG5cdCAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHJwLCBycCwgZmFsc2UsIHRydWUpO1xuXG5cdCAgICBkbyB7XG5cdCAgICAgICAgaWYgKHAgIT09IHJwKSB7IGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQsIHB2KTsgfVxuXHQgICAgICAgIHAgPSBwLm5leHRQb2ludE9uQ29udG91cjtcblx0ICAgIH0gd2hpbGUgKHAgIT09IHNwKTtcblx0fVxuXG5cdC8vIFNIWltdIFNIaWZ0IFpvbmUgdXNpbmcgcmVmZXJlbmNlIHBvaW50XG5cdC8vIDB4MzYtMHgzN1xuXHRmdW5jdGlvbiBTSFooYSwgc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIHJwaSA9IGEgPyBzdGF0ZS5ycDEgOiBzdGF0ZS5ycDI7XG5cdCAgICB2YXIgcnAgPSAoYSA/IHN0YXRlLnowIDogc3RhdGUuejEpW3JwaV07XG5cdCAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcblx0ICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG5cdCAgICB2YXIgZSA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0haWycgKyBhICsgJ10nLCBlKTsgfVxuXG5cdCAgICB2YXIgejtcblx0ICAgIHN3aXRjaCAoZSkge1xuXHQgICAgICAgIGNhc2UgMCA6IHogPSBzdGF0ZS50Wm9uZTsgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAxIDogeiA9IHN0YXRlLmdab25lOyBicmVhaztcblx0ICAgICAgICBkZWZhdWx0IDogdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUnKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHA7XG5cdCAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHJwLCBycCwgZmFsc2UsIHRydWUpO1xuXHQgICAgdmFyIHBMZW4gPSB6Lmxlbmd0aCAtIDI7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBMZW47IGkrKylcblx0ICAgIHtcblx0ICAgICAgICBwID0geltpXTtcblx0ICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkLCBwdik7XG5cdCAgICAgICAgLy9pZiAocCAhPT0gcnApIGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQsIHB2KTtcblx0ICAgIH1cblx0fVxuXG5cdC8vIFNIUElYW10gU0hpZnQgcG9pbnQgYnkgYSBQSVhlbCBhbW91bnRcblx0Ly8gMHgzOFxuXHRmdW5jdGlvbiBTSFBJWChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG5cdCAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcblx0ICAgIHZhciBkID0gc3RhY2sucG9wKCkgLyAweDQwO1xuXHQgICAgdmFyIHoyID0gc3RhdGUuejI7XG5cblx0ICAgIHdoaWxlIChsb29wLS0pIHtcblx0ICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICB2YXIgcCA9IHoyW3BpXTtcblxuXHQgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuXHQgICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcblx0ICAgICAgICAgICAgICAgIChzdGF0ZS5sb29wID4gMSA/ICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6ICcnKSArXG5cdCAgICAgICAgICAgICAgICAnU0hQSVhbXScsIHBpLCBkXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCk7XG5cdCAgICAgICAgZnYudG91Y2gocCk7XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLmxvb3AgPSAxO1xuXHR9XG5cblx0Ly8gSVBbXSBJbnRlcnBvbGF0ZSBQb2ludFxuXHQvLyAweDM5XG5cdGZ1bmN0aW9uIElQKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBycDFpID0gc3RhdGUucnAxO1xuXHQgICAgdmFyIHJwMmkgPSBzdGF0ZS5ycDI7XG5cdCAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG5cdCAgICB2YXIgcnAxID0gc3RhdGUuejBbcnAxaV07XG5cdCAgICB2YXIgcnAyID0gc3RhdGUuejFbcnAyaV07XG5cdCAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcblx0ICAgIHZhciBwdiA9IHN0YXRlLmRwdjtcblx0ICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuXG5cdCAgICB3aGlsZSAobG9vcC0tKSB7XG5cdCAgICAgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgdmFyIHAgPSB6MltwaV07XG5cblx0ICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuXHQgICAgICAgICAgICBjb25zb2xlLmxvZyhcblx0ICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG5cdCAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgPyAnbG9vcCAnICsgKHN0YXRlLmxvb3AgLSBsb29wKSArICc6ICcgOiAnJykgK1xuXHQgICAgICAgICAgICAgICAgJ0lQW10nLCBwaSwgcnAxaSwgJzwtPicsIHJwMmlcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdi5pbnRlcnBvbGF0ZShwLCBycDEsIHJwMiwgcHYpO1xuXG5cdCAgICAgICAgZnYudG91Y2gocCk7XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLmxvb3AgPSAxO1xuXHR9XG5cblx0Ly8gTVNJUlBbYV0gTW92ZSBTdGFjayBJbmRpcmVjdCBSZWxhdGl2ZSBQb2ludFxuXHQvLyAweDNBLTB4M0Jcblx0ZnVuY3Rpb24gTVNJUlAoYSwgc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIGQgPSBzdGFjay5wb3AoKSAvIDY0O1xuXHQgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcCA9IHN0YXRlLnoxW3BpXTtcblx0ICAgIHZhciBycDAgPSBzdGF0ZS56MFtzdGF0ZS5ycDBdO1xuXHQgICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG5cdCAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblxuXHQgICAgZnYuc2V0UmVsYXRpdmUocCwgcnAwLCBkLCBwdik7XG5cdCAgICBmdi50b3VjaChwKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01TSVJQWycgKyBhICsgJ10nLCBkLCBwaSk7IH1cblxuXHQgICAgc3RhdGUucnAxID0gc3RhdGUucnAwO1xuXHQgICAgc3RhdGUucnAyID0gcGk7XG5cdCAgICBpZiAoYSkgeyBzdGF0ZS5ycDAgPSBwaTsgfVxuXHR9XG5cblx0Ly8gQUxJR05SUFtdIEFsaWduIHRvIHJlZmVyZW5jZSBwb2ludC5cblx0Ly8gMHgzQ1xuXHRmdW5jdGlvbiBBTElHTlJQKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBycDBpID0gc3RhdGUucnAwO1xuXHQgICAgdmFyIHJwMCA9IHN0YXRlLnowW3JwMGldO1xuXHQgICAgdmFyIGxvb3AgPSBzdGF0ZS5sb29wO1xuXHQgICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG5cdCAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblx0ICAgIHZhciB6MSA9IHN0YXRlLnoxO1xuXG5cdCAgICB3aGlsZSAobG9vcC0tKSB7XG5cdCAgICAgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgdmFyIHAgPSB6MVtwaV07XG5cblx0ICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuXHQgICAgICAgICAgICBjb25zb2xlLmxvZyhcblx0ICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG5cdCAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgPyAnbG9vcCAnICsgKHN0YXRlLmxvb3AgLSBsb29wKSArICc6ICcgOiAnJykgK1xuXHQgICAgICAgICAgICAgICAgJ0FMSUdOUlBbXScsIHBpXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcnAwLCAwLCBwdik7XG5cdCAgICAgICAgZnYudG91Y2gocCk7XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLmxvb3AgPSAxO1xuXHR9XG5cblx0Ly8gUlRHW10gUm91bmQgVG8gRG91YmxlIEdyaWRcblx0Ly8gMHgzRFxuXHRmdW5jdGlvbiBSVERHKHN0YXRlKSB7XG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlRER1tdJyk7IH1cblxuXHQgICAgc3RhdGUucm91bmQgPSByb3VuZFRvRG91YmxlR3JpZDtcblx0fVxuXG5cdC8vIE1JQVBbYV0gTW92ZSBJbmRpcmVjdCBBYnNvbHV0ZSBQb2ludFxuXHQvLyAweDNFLTB4M0Zcblx0ZnVuY3Rpb24gTUlBUChyb3VuZCwgc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHAgPSBzdGF0ZS56MFtwaV07XG5cdCAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcblx0ICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXHQgICAgdmFyIGN2ID0gc3RhdGUuY3Z0W25dO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuXHQgICAgICAgIGNvbnNvbGUubG9nKFxuXHQgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuXHQgICAgICAgICAgICAnTUlBUFsnICsgcm91bmQgKyAnXScsXG5cdCAgICAgICAgICAgIG4sICcoJywgY3YsICcpJywgcGlcblx0ICAgICAgICApO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHAsIEhQWmVybyk7XG5cblx0ICAgIGlmIChyb3VuZCkge1xuXHQgICAgICAgIGlmIChNYXRoLmFicyhkIC0gY3YpIDwgc3RhdGUuY3ZDdXRJbikgeyBkID0gY3Y7IH1cblxuXHQgICAgICAgIGQgPSBzdGF0ZS5yb3VuZChkKTtcblx0ICAgIH1cblxuXHQgICAgZnYuc2V0UmVsYXRpdmUocCwgSFBaZXJvLCBkLCBwdik7XG5cblx0ICAgIGlmIChzdGF0ZS56cDAgPT09IDApIHtcblx0ICAgICAgICBwLnhvID0gcC54O1xuXHQgICAgICAgIHAueW8gPSBwLnk7XG5cdCAgICB9XG5cblx0ICAgIGZ2LnRvdWNoKHApO1xuXG5cdCAgICBzdGF0ZS5ycDAgPSBzdGF0ZS5ycDEgPSBwaTtcblx0fVxuXG5cdC8vIE5QVVNCW10gUFVTSCBOIEJ5dGVzXG5cdC8vIDB4NDBcblx0ZnVuY3Rpb24gTlBVU0hCKHN0YXRlKSB7XG5cdCAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG5cdCAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG5cdCAgICB2YXIgbiA9IHByb2dbKytpcF07XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdOUFVTSEJbXScsIG4pOyB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7IHN0YWNrLnB1c2gocHJvZ1srK2lwXSk7IH1cblxuXHQgICAgc3RhdGUuaXAgPSBpcDtcblx0fVxuXG5cdC8vIE5QVVNIV1tdIFBVU0ggTiBXb3Jkc1xuXHQvLyAweDQxXG5cdGZ1bmN0aW9uIE5QVVNIVyhzdGF0ZSkge1xuXHQgICAgdmFyIGlwID0gc3RhdGUuaXA7XG5cdCAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBuID0gcHJvZ1srK2lwXTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05QVVNIV1tdJywgbik7IH1cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgICB2YXIgdyA9IChwcm9nWysraXBdIDw8IDgpIHwgcHJvZ1srK2lwXTtcblx0ICAgICAgICBpZiAodyAmIDB4ODAwMCkgeyB3ID0gLSgodyBeIDB4ZmZmZikgKyAxKTsgfVxuXHQgICAgICAgIHN0YWNrLnB1c2godyk7XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLmlwID0gaXA7XG5cdH1cblxuXHQvLyBXU1tdIFdyaXRlIFN0b3JlXG5cdC8vIDB4NDJcblx0ZnVuY3Rpb24gV1Moc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIHN0b3JlID0gc3RhdGUuc3RvcmU7XG5cblx0ICAgIGlmICghc3RvcmUpIHsgc3RvcmUgPSBzdGF0ZS5zdG9yZSA9IFtdOyB9XG5cblx0ICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnV1MnLCB2LCBsKTsgfVxuXG5cdCAgICBzdG9yZVtsXSA9IHY7XG5cdH1cblxuXHQvLyBSU1tdIFJlYWQgU3RvcmVcblx0Ly8gMHg0M1xuXHRmdW5jdGlvbiBSUyhzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgc3RvcmUgPSBzdGF0ZS5zdG9yZTtcblxuXHQgICAgdmFyIGwgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JTJywgbCk7IH1cblxuXHQgICAgdmFyIHYgPSAoc3RvcmUgJiYgc3RvcmVbbF0pIHx8IDA7XG5cblx0ICAgIHN0YWNrLnB1c2godik7XG5cdH1cblxuXHQvLyBXQ1ZUUFtdIFdyaXRlIENvbnRyb2wgVmFsdWUgVGFibGUgaW4gUGl4ZWwgdW5pdHNcblx0Ly8gMHg0NFxuXHRmdW5jdGlvbiBXQ1ZUUChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cblx0ICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnV0NWVFAnLCB2LCBsKTsgfVxuXG5cdCAgICBzdGF0ZS5jdnRbbF0gPSB2IC8gMHg0MDtcblx0fVxuXG5cdC8vIFJDVlRbXSBSZWFkIENvbnRyb2wgVmFsdWUgVGFibGUgZW50cnlcblx0Ly8gMHg0NVxuXHRmdW5jdGlvbiBSQ1ZUKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBjdnRlID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSQ1ZUJywgY3Z0ZSk7IH1cblxuXHQgICAgc3RhY2sucHVzaChzdGF0ZS5jdnRbY3Z0ZV0gKiAweDQwKTtcblx0fVxuXG5cdC8vIEdDW10gR2V0IENvb3JkaW5hdGUgcHJvamVjdGVkIG9udG8gdGhlIHByb2plY3Rpb24gdmVjdG9yXG5cdC8vIDB4NDYtMHg0N1xuXHRmdW5jdGlvbiBHQyhhLCBzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBwID0gc3RhdGUuejJbcGldO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR0NbJyArIGEgKyAnXScsIHBpKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKHN0YXRlLmRwdi5kaXN0YW5jZShwLCBIUFplcm8sIGEsIGZhbHNlKSAqIDB4NDApO1xuXHR9XG5cblx0Ly8gTURbYV0gTWVhc3VyZSBEaXN0YW5jZVxuXHQvLyAweDQ5LTB4NEFcblx0ZnVuY3Rpb24gTUQoYSwgc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIHBpMiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHBpMSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHAyID0gc3RhdGUuejFbcGkyXTtcblx0ICAgIHZhciBwMSA9IHN0YXRlLnowW3BpMV07XG5cdCAgICB2YXIgZCA9IHN0YXRlLmRwdi5kaXN0YW5jZShwMSwgcDIsIGEsIGEpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTURbJyArIGEgKyAnXScsIHBpMiwgcGkxLCAnLT4nLCBkKTsgfVxuXG5cdCAgICBzdGF0ZS5zdGFjay5wdXNoKE1hdGgucm91bmQoZCAqIDY0KSk7XG5cdH1cblxuXHQvLyBNUFBFTVtdIE1lYXN1cmUgUGl4ZWxzIFBlciBFTVxuXHQvLyAweDRCXG5cdGZ1bmN0aW9uIE1QUEVNKHN0YXRlKSB7XG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTVBQRU1bXScpOyB9XG5cdCAgICBzdGF0ZS5zdGFjay5wdXNoKHN0YXRlLnBwZW0pO1xuXHR9XG5cblx0Ly8gRkxJUE9OW10gc2V0IHRoZSBhdXRvIEZMSVAgQm9vbGVhbiB0byBPTlxuXHQvLyAweDREXG5cdGZ1bmN0aW9uIEZMSVBPTihzdGF0ZSkge1xuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0ZMSVBPTltdJyk7IH1cblx0ICAgIHN0YXRlLmF1dG9GbGlwID0gdHJ1ZTtcblx0fVxuXG5cdC8vIExUW10gTGVzcyBUaGFuXG5cdC8vIDB4NTBcblx0ZnVuY3Rpb24gTFQoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0xUW10nLCBlMiwgZTEpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goZTEgPCBlMiA/IDEgOiAwKTtcblx0fVxuXG5cdC8vIExURVFbXSBMZXNzIFRoYW4gb3IgRVF1YWxcblx0Ly8gMHg1M1xuXHRmdW5jdGlvbiBMVEVRKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdMVEVRW10nLCBlMiwgZTEpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goZTEgPD0gZTIgPyAxIDogMCk7XG5cdH1cblxuXHQvLyBHVEVRW10gR3JlYXRlciBUaGFuXG5cdC8vIDB4NTJcblx0ZnVuY3Rpb24gR1Qoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dUW10nLCBlMiwgZTEpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goZTEgPiBlMiA/IDEgOiAwKTtcblx0fVxuXG5cdC8vIEdURVFbXSBHcmVhdGVyIFRoYW4gb3IgRVF1YWxcblx0Ly8gMHg1M1xuXHRmdW5jdGlvbiBHVEVRKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHVEVRW10nLCBlMiwgZTEpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goZTEgPj0gZTIgPyAxIDogMCk7XG5cdH1cblxuXHQvLyBFUVtdIEVRdWFsXG5cdC8vIDB4NTRcblx0ZnVuY3Rpb24gRVEoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0VRW10nLCBlMiwgZTEpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goZTIgPT09IGUxID8gMSA6IDApO1xuXHR9XG5cblx0Ly8gTkVRW10gTm90IEVRdWFsXG5cdC8vIDB4NTVcblx0ZnVuY3Rpb24gTkVRKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdORVFbXScsIGUyLCBlMSk7IH1cblxuXHQgICAgc3RhY2sucHVzaChlMiAhPT0gZTEgPyAxIDogMCk7XG5cdH1cblxuXHQvLyBPRERbXSBPRERcblx0Ly8gMHg1NlxuXHRmdW5jdGlvbiBPREQoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ09ERFtdJywgbik7IH1cblxuXHQgICAgc3RhY2sucHVzaChNYXRoLnRydW5jKG4pICUgMiA/IDEgOiAwKTtcblx0fVxuXG5cdC8vIEVWRU5bXSBFVkVOXG5cdC8vIDB4NTdcblx0ZnVuY3Rpb24gRVZFTihzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRVZFTltdJywgbik7IH1cblxuXHQgICAgc3RhY2sucHVzaChNYXRoLnRydW5jKG4pICUgMiA/IDAgOiAxKTtcblx0fVxuXG5cdC8vIElGW10gSUYgdGVzdFxuXHQvLyAweDU4XG5cdGZ1bmN0aW9uIElGKHN0YXRlKSB7XG5cdCAgICB2YXIgdGVzdCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnSUZbXScsIHRlc3QpOyB9XG5cblx0ICAgIC8vIGlmIHRlc3QgaXMgdHJ1ZSBpdCBqdXN0IGNvbnRpbnVlc1xuXHQgICAgLy8gaWYgbm90IHRoZSBpcCBpcyBza2lwcGVkIHVudGlsIG1hdGNoaW5nIEVMU0Ugb3IgRUlGXG5cdCAgICBpZiAoIXRlc3QpIHtcblx0ICAgICAgICBza2lwKHN0YXRlLCB0cnVlKTtcblxuXHQgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICAnRUlGW10nKTsgfVxuXHQgICAgfVxuXHR9XG5cblx0Ly8gRUlGW10gRW5kIElGXG5cdC8vIDB4NTlcblx0ZnVuY3Rpb24gRUlGKHN0YXRlKSB7XG5cdCAgICAvLyB0aGlzIGNhbiBiZSByZWFjaGVkIG5vcm1hbGx5IHdoZW5cblx0ICAgIC8vIGV4ZWN1dGluZyBhbiBlbHNlIGJyYW5jaC5cblx0ICAgIC8vIC0+IGp1c3QgaWdub3JlIGl0XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFSUZbXScpOyB9XG5cdH1cblxuXHQvLyBBTkRbXSBsb2dpY2FsIEFORFxuXHQvLyAweDVBXG5cdGZ1bmN0aW9uIEFORChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQU5EW10nLCBlMiwgZTEpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goZTIgJiYgZTEgPyAxIDogMCk7XG5cdH1cblxuXHQvLyBPUltdIGxvZ2ljYWwgT1Jcblx0Ly8gMHg1QlxuXHRmdW5jdGlvbiBPUihzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnT1JbXScsIGUyLCBlMSk7IH1cblxuXHQgICAgc3RhY2sucHVzaChlMiB8fCBlMSA/IDEgOiAwKTtcblx0fVxuXG5cdC8vIE5PVFtdIGxvZ2ljYWwgTk9UXG5cdC8vIDB4NUNcblx0ZnVuY3Rpb24gTk9UKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBlID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdOT1RbXScsIGUpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goZSA/IDAgOiAxKTtcblx0fVxuXG5cdC8vIERFTFRBUDFbXSBERUxUQSBleGNlcHRpb24gUDFcblx0Ly8gREVMVEFQMltdIERFTFRBIGV4Y2VwdGlvbiBQMlxuXHQvLyBERUxUQVAzW10gREVMVEEgZXhjZXB0aW9uIFAzXG5cdC8vIDB4NUQsIDB4NzEsIDB4NzJcblx0ZnVuY3Rpb24gREVMVEFQMTIzKGIsIHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcblx0ICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXHQgICAgdmFyIHBwZW0gPSBzdGF0ZS5wcGVtO1xuXHQgICAgdmFyIGJhc2UgPSBzdGF0ZS5kZWx0YUJhc2UgKyAoYiAtIDEpICogMTY7XG5cdCAgICB2YXIgZHMgPSBzdGF0ZS5kZWx0YVNoaWZ0O1xuXHQgICAgdmFyIHowID0gc3RhdGUuejA7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERUxUQVBbJyArIGIgKyAnXScsIG4sIHN0YWNrKTsgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgIHZhciBhcmcgPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICB2YXIgYXBwZW0gPSBiYXNlICsgKChhcmcgJiAweEYwKSA+PiA0KTtcblx0ICAgICAgICBpZiAoYXBwZW0gIT09IHBwZW0pIHsgY29udGludWU7IH1cblxuXHQgICAgICAgIHZhciBtYWcgPSAoYXJnICYgMHgwRikgLSA4O1xuXHQgICAgICAgIGlmIChtYWcgPj0gMCkgeyBtYWcrKzsgfVxuXHQgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERUxUQVBGSVgnLCBwaSwgJ2J5JywgbWFnICogZHMpOyB9XG5cblx0ICAgICAgICB2YXIgcCA9IHowW3BpXTtcblx0ICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBtYWcgKiBkcywgcHYpO1xuXHQgICAgfVxuXHR9XG5cblx0Ly8gU0RCW10gU2V0IERlbHRhIEJhc2UgaW4gdGhlIGdyYXBoaWNzIHN0YXRlXG5cdC8vIDB4NUVcblx0ZnVuY3Rpb24gU0RCKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTREJbXScsIG4pOyB9XG5cblx0ICAgIHN0YXRlLmRlbHRhQmFzZSA9IG47XG5cdH1cblxuXHQvLyBTRFNbXSBTZXQgRGVsdGEgU2hpZnQgaW4gdGhlIGdyYXBoaWNzIHN0YXRlXG5cdC8vIDB4NUZcblx0ZnVuY3Rpb24gU0RTKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRFNbXScsIG4pOyB9XG5cblx0ICAgIHN0YXRlLmRlbHRhU2hpZnQgPSBNYXRoLnBvdygwLjUsIG4pO1xuXHR9XG5cblx0Ly8gQUREW10gQUREXG5cdC8vIDB4NjBcblx0ZnVuY3Rpb24gQUREKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBuMiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIG4xID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdBRERbXScsIG4yLCBuMSk7IH1cblxuXHQgICAgc3RhY2sucHVzaChuMSArIG4yKTtcblx0fVxuXG5cdC8vIFNVQltdIFNVQlxuXHQvLyAweDYxXG5cdGZ1bmN0aW9uIFNVQihzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBuMSA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1VCW10nLCBuMiwgbjEpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2gobjEgLSBuMik7XG5cdH1cblxuXHQvLyBESVZbXSBESVZcblx0Ly8gMHg2MlxuXHRmdW5jdGlvbiBESVYoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIG4yID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RJVltdJywgbjIsIG4xKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKG4xICogNjQgLyBuMik7XG5cdH1cblxuXHQvLyBNVUxbXSBNVUxcblx0Ly8gMHg2M1xuXHRmdW5jdGlvbiBNVUwoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIG4yID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01VTFtdJywgbjIsIG4xKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKG4xICogbjIgLyA2NCk7XG5cdH1cblxuXHQvLyBBQlNbXSBBQlNvbHV0ZSB2YWx1ZVxuXHQvLyAweDY0XG5cdGZ1bmN0aW9uIEFCUyhzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQUJTW10nLCBuKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKE1hdGguYWJzKG4pKTtcblx0fVxuXG5cdC8vIE5FR1tdIE5FR2F0ZVxuXHQvLyAweDY1XG5cdGZ1bmN0aW9uIE5FRyhzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTkVHW10nLCBuKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKC1uKTtcblx0fVxuXG5cdC8vIEZMT09SW10gRkxPT1Jcblx0Ly8gMHg2NlxuXHRmdW5jdGlvbiBGTE9PUihzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRkxPT1JbXScsIG4pOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goTWF0aC5mbG9vcihuIC8gMHg0MCkgKiAweDQwKTtcblx0fVxuXG5cdC8vIENFSUxJTkdbXSBDRUlMSU5HXG5cdC8vIDB4Njdcblx0ZnVuY3Rpb24gQ0VJTElORyhzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0VJTElOR1tdJywgbik7IH1cblxuXHQgICAgc3RhY2sucHVzaChNYXRoLmNlaWwobiAvIDB4NDApICogMHg0MCk7XG5cdH1cblxuXHQvLyBST1VORFthYl0gUk9VTkQgdmFsdWVcblx0Ly8gMHg2OC0weDZCXG5cdGZ1bmN0aW9uIFJPVU5EKGR0LCBzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUk9VTkRbXScpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goc3RhdGUucm91bmQobiAvIDB4NDApICogMHg0MCk7XG5cdH1cblxuXHQvLyBXQ1ZURltdIFdyaXRlIENvbnRyb2wgVmFsdWUgVGFibGUgaW4gRnVuaXRzXG5cdC8vIDB4NzBcblx0ZnVuY3Rpb24gV0NWVEYoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdXQ1ZURltdJywgdiwgbCk7IH1cblxuXHQgICAgc3RhdGUuY3Z0W2xdID0gdiAqIHN0YXRlLnBwZW0gLyBzdGF0ZS5mb250LnVuaXRzUGVyRW07XG5cdH1cblxuXHQvLyBERUxUQUMxW10gREVMVEEgZXhjZXB0aW9uIEMxXG5cdC8vIERFTFRBQzJbXSBERUxUQSBleGNlcHRpb24gQzJcblx0Ly8gREVMVEFDM1tdIERFTFRBIGV4Y2VwdGlvbiBDM1xuXHQvLyAweDczLCAweDc0LCAweDc1XG5cdGZ1bmN0aW9uIERFTFRBQzEyMyhiLCBzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHBwZW0gPSBzdGF0ZS5wcGVtO1xuXHQgICAgdmFyIGJhc2UgPSBzdGF0ZS5kZWx0YUJhc2UgKyAoYiAtIDEpICogMTY7XG5cdCAgICB2YXIgZHMgPSBzdGF0ZS5kZWx0YVNoaWZ0O1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFDWycgKyBiICsgJ10nLCBuLCBzdGFjayk7IH1cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgICB2YXIgYyA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgIHZhciBhcmcgPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICB2YXIgYXBwZW0gPSBiYXNlICsgKChhcmcgJiAweEYwKSA+PiA0KTtcblx0ICAgICAgICBpZiAoYXBwZW0gIT09IHBwZW0pIHsgY29udGludWU7IH1cblxuXHQgICAgICAgIHZhciBtYWcgPSAoYXJnICYgMHgwRikgLSA4O1xuXHQgICAgICAgIGlmIChtYWcgPj0gMCkgeyBtYWcrKzsgfVxuXG5cdCAgICAgICAgdmFyIGRlbHRhID0gbWFnICogZHM7XG5cblx0ICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFDRklYJywgYywgJ2J5JywgZGVsdGEpOyB9XG5cblx0ICAgICAgICBzdGF0ZS5jdnRbY10gKz0gZGVsdGE7XG5cdCAgICB9XG5cdH1cblxuXHQvLyBTUk9VTkRbXSBTdXBlciBST1VORFxuXHQvLyAweDc2XG5cdGZ1bmN0aW9uIFNST1VORChzdGF0ZSkge1xuXHQgICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NST1VORFtdJywgbik7IH1cblxuXHQgICAgc3RhdGUucm91bmQgPSByb3VuZFN1cGVyO1xuXG5cdCAgICB2YXIgcGVyaW9kO1xuXG5cdCAgICBzd2l0Y2ggKG4gJiAweEMwKSB7XG5cdCAgICAgICAgY2FzZSAweDAwOlxuXHQgICAgICAgICAgICBwZXJpb2QgPSAwLjU7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMHg0MDpcblx0ICAgICAgICAgICAgcGVyaW9kID0gMTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAweDgwOlxuXHQgICAgICAgICAgICBwZXJpb2QgPSAyO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgU1JPVU5EIHZhbHVlJyk7XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLnNyUGVyaW9kID0gcGVyaW9kO1xuXG5cdCAgICBzd2l0Y2ggKG4gJiAweDMwKSB7XG5cdCAgICAgICAgY2FzZSAweDAwOlxuXHQgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMDtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAweDEwOlxuXHQgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC4yNSAqIHBlcmlvZDtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAweDIwOlxuXHQgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC41ICAqIHBlcmlvZDtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAweDMwOlxuXHQgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC43NSAqIHBlcmlvZDtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFNST1VORCB2YWx1ZScpO1xuXHQgICAgfVxuXG5cdCAgICBuICY9IDB4MEY7XG5cblx0ICAgIGlmIChuID09PSAwKSB7IHN0YXRlLnNyVGhyZXNob2xkID0gMDsgfVxuXHQgICAgZWxzZSB7IHN0YXRlLnNyVGhyZXNob2xkID0gKG4gLyA4IC0gMC41KSAqIHBlcmlvZDsgfVxuXHR9XG5cblx0Ly8gUzQ1Uk9VTkRbXSBTdXBlciBST1VORCA0NSBkZWdyZWVzXG5cdC8vIDB4Nzdcblx0ZnVuY3Rpb24gUzQ1Uk9VTkQoc3RhdGUpIHtcblx0ICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTNDVST1VORFtdJywgbik7IH1cblxuXHQgICAgc3RhdGUucm91bmQgPSByb3VuZFN1cGVyO1xuXG5cdCAgICB2YXIgcGVyaW9kO1xuXG5cdCAgICBzd2l0Y2ggKG4gJiAweEMwKSB7XG5cdCAgICAgICAgY2FzZSAweDAwOlxuXHQgICAgICAgICAgICBwZXJpb2QgPSBNYXRoLnNxcnQoMikgLyAyO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIDB4NDA6XG5cdCAgICAgICAgICAgIHBlcmlvZCA9IE1hdGguc3FydCgyKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAweDgwOlxuXHQgICAgICAgICAgICBwZXJpb2QgPSAyICogTWF0aC5zcXJ0KDIpO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUzQ1Uk9VTkQgdmFsdWUnKTtcblx0ICAgIH1cblxuXHQgICAgc3RhdGUuc3JQZXJpb2QgPSBwZXJpb2Q7XG5cblx0ICAgIHN3aXRjaCAobiAmIDB4MzApIHtcblx0ICAgICAgICBjYXNlIDB4MDA6XG5cdCAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIDB4MTA6XG5cdCAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjI1ICogcGVyaW9kO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIDB4MjA6XG5cdCAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjUgICogcGVyaW9kO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIDB4MzA6XG5cdCAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjc1ICogcGVyaW9kO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUzQ1Uk9VTkQgdmFsdWUnKTtcblx0ICAgIH1cblxuXHQgICAgbiAmPSAweDBGO1xuXG5cdCAgICBpZiAobiA9PT0gMCkgeyBzdGF0ZS5zclRocmVzaG9sZCA9IDA7IH1cblx0ICAgIGVsc2UgeyBzdGF0ZS5zclRocmVzaG9sZCA9IChuIC8gOCAtIDAuNSkgKiBwZXJpb2Q7IH1cblx0fVxuXG5cdC8vIFJPRkZbXSBSb3VuZCBPZmZcblx0Ly8gMHg3QVxuXHRmdW5jdGlvbiBST0ZGKHN0YXRlKSB7XG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUk9GRltdJyk7IH1cblxuXHQgICAgc3RhdGUucm91bmQgPSByb3VuZE9mZjtcblx0fVxuXG5cdC8vIFJVVEdbXSBSb3VuZCBVcCBUbyBHcmlkXG5cdC8vIDB4N0Ncblx0ZnVuY3Rpb24gUlVURyhzdGF0ZSkge1xuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JVVEdbXScpOyB9XG5cblx0ICAgIHN0YXRlLnJvdW5kID0gcm91bmRVcFRvR3JpZDtcblx0fVxuXG5cdC8vIFJEVEdbXSBSb3VuZCBEb3duIFRvIEdyaWRcblx0Ly8gMHg3RFxuXHRmdW5jdGlvbiBSRFRHKHN0YXRlKSB7XG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUkRUR1tdJyk7IH1cblxuXHQgICAgc3RhdGUucm91bmQgPSByb3VuZERvd25Ub0dyaWQ7XG5cdH1cblxuXHQvLyBTQ0FOQ1RSTFtdIFNDQU4gY29udmVyc2lvbiBDb25UUm9MXG5cdC8vIDB4ODVcblx0ZnVuY3Rpb24gU0NBTkNUUkwoc3RhdGUpIHtcblx0ICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIC8vIGlnbm9yZWQgYnkgb3BlbnR5cGUuanNcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDQU5DVFJMW10nLCBuKTsgfVxuXHR9XG5cblx0Ly8gU0RQVlRMW2FdIFNldCBEdWFsIFByb2plY3Rpb24gVmVjdG9yIFRvIExpbmVcblx0Ly8gMHg4Ni0weDg3XG5cdGZ1bmN0aW9uIFNEUFZUTChhLCBzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgcDJpID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcDFpID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcDIgPSBzdGF0ZS56MltwMmldO1xuXHQgICAgdmFyIHAxID0gc3RhdGUuejFbcDFpXTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NEUFZUTFsnICsgYSArICddJywgcDJpLCBwMWkpOyB9XG5cblx0ICAgIHZhciBkeDtcblx0ICAgIHZhciBkeTtcblxuXHQgICAgaWYgKCFhKSB7XG5cdCAgICAgICAgZHggPSBwMS54IC0gcDIueDtcblx0ICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBkeCA9IHAyLnkgLSBwMS55O1xuXHQgICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLmRwdiA9IGdldFVuaXRWZWN0b3IoZHgsIGR5KTtcblx0fVxuXG5cdC8vIEdFVElORk9bXSBHRVQgSU5GT3JtYXRpb25cblx0Ly8gMHg4OFxuXHRmdW5jdGlvbiBHRVRJTkZPKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBzZWwgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciByID0gMDtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dFVElORk9bXScsIHNlbCk7IH1cblxuXHQgICAgLy8gdjM1IGFzIGluIG5vIHN1YnBpeGVsIGhpbnRpbmdcblx0ICAgIGlmIChzZWwgJiAweDAxKSB7IHIgPSAzNTsgfVxuXG5cdCAgICAvLyBUT0RPIHJvdGF0aW9uIGFuZCBzdHJldGNoIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXG5cdCAgICAvLyBhbmQgdGh1cyB0aG9zZSBHRVRJTkZPIGFyZSBhbHdheXMgMC5cblxuXHQgICAgLy8gb3BlbnR5cGUuanMgaXMgYWx3YXlzIGdyYXkgc2NhbGluZ1xuXHQgICAgaWYgKHNlbCAmIDB4MjApIHsgciB8PSAweDEwMDA7IH1cblxuXHQgICAgc3RhY2sucHVzaChyKTtcblx0fVxuXG5cdC8vIFJPTExbXSBST0xMIHRoZSB0b3AgdGhyZWUgc3RhY2sgZWxlbWVudHNcblx0Ly8gMHg4QVxuXHRmdW5jdGlvbiBST0xMKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBhID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgYiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIGMgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JPTExbXScpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goYik7XG5cdCAgICBzdGFjay5wdXNoKGEpO1xuXHQgICAgc3RhY2sucHVzaChjKTtcblx0fVxuXG5cdC8vIE1BWFtdIE1BWGltdW0gb2YgdG9wIHR3byBzdGFjayBlbGVtZW50c1xuXHQvLyAweDhCXG5cdGZ1bmN0aW9uIE1BWChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTUFYW10nLCBlMiwgZTEpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goTWF0aC5tYXgoZTEsIGUyKSk7XG5cdH1cblxuXHQvLyBNSU5bXSBNSU5pbXVtIG9mIHRvcCB0d28gc3RhY2sgZWxlbWVudHNcblx0Ly8gMHg4Q1xuXHRmdW5jdGlvbiBNSU4oc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01JTltdJywgZTIsIGUxKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKE1hdGgubWluKGUxLCBlMikpO1xuXHR9XG5cblx0Ly8gU0NBTlRZUEVbXSBTQ0FOVFlQRVxuXHQvLyAweDhEXG5cdGZ1bmN0aW9uIFNDQU5UWVBFKHN0YXRlKSB7XG5cdCAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXHQgICAgLy8gaWdub3JlZCBieSBvcGVudHlwZS5qc1xuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDQU5UWVBFW10nLCBuKTsgfVxuXHR9XG5cblx0Ly8gSU5TVENUUkxbXSBJTlNUQ1RSTFxuXHQvLyAweDhEXG5cdGZ1bmN0aW9uIElOU1RDVFJMKHN0YXRlKSB7XG5cdCAgICB2YXIgcyA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHYgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0lOU1RDVFJMW10nLCBzLCB2KTsgfVxuXG5cdCAgICBzd2l0Y2ggKHMpIHtcblx0ICAgICAgICBjYXNlIDEgOiBzdGF0ZS5pbmhpYml0R3JpZEZpdCA9ICEhdjsgcmV0dXJuO1xuXHQgICAgICAgIGNhc2UgMiA6IHN0YXRlLmlnbm9yZUN2dCA9ICEhdjsgcmV0dXJuO1xuXHQgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignaW52YWxpZCBJTlNUQ1RSTFtdIHNlbGVjdG9yJyk7XG5cdCAgICB9XG5cdH1cblxuXHQvLyBQVVNIQlthYmNdIFBVU0ggQnl0ZXNcblx0Ly8gMHhCMC0weEI3XG5cdGZ1bmN0aW9uIFBVU0hCKG4sIHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcblx0ICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUFVTSEJbJyArIG4gKyAnXScpOyB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7IHN0YWNrLnB1c2gocHJvZ1srK2lwXSk7IH1cblxuXHQgICAgc3RhdGUuaXAgPSBpcDtcblx0fVxuXG5cdC8vIFBVU0hXW2FiY10gUFVTSCBXb3Jkc1xuXHQvLyAweEI4LTB4QkZcblx0ZnVuY3Rpb24gUFVTSFcobiwgc3RhdGUpIHtcblx0ICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuXHQgICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLmlwLCAnUFVTSFdbJyArIG4gKyAnXScpOyB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHcgPSAocHJvZ1srK2lwXSA8PCA4KSB8IHByb2dbKytpcF07XG5cdCAgICAgICAgaWYgKHcgJiAweDgwMDApIHsgdyA9IC0oKHcgXiAweGZmZmYpICsgMSk7IH1cblx0ICAgICAgICBzdGFjay5wdXNoKHcpO1xuXHQgICAgfVxuXG5cdCAgICBzdGF0ZS5pcCA9IGlwO1xuXHR9XG5cblx0Ly8gTURSUFthYmNkZV0gTW92ZSBEaXJlY3QgUmVsYXRpdmUgUG9pbnRcblx0Ly8gMHhEMC0weEVGXG5cdC8vIChpZiBpbmRpcmVjdCBpcyAwKVxuXHQvL1xuXHQvLyBhbmRcblx0Ly9cblx0Ly8gTUlSUFthYmNkZV0gTW92ZSBJbmRpcmVjdCBSZWxhdGl2ZSBQb2ludFxuXHQvLyAweEUwLTB4RkZcblx0Ly8gKGlmIGluZGlyZWN0IGlzIDEpXG5cblx0ZnVuY3Rpb24gTURSUF9NSVJQKGluZGlyZWN0LCBzZXRScDAsIGtlZXBELCBybywgZHQsIHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBjdnRlID0gaW5kaXJlY3QgJiYgc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBycDBpID0gc3RhdGUucnAwO1xuXHQgICAgdmFyIHJwID0gc3RhdGUuejBbcnAwaV07XG5cdCAgICB2YXIgcCA9IHN0YXRlLnoxW3BpXTtcblxuXHQgICAgdmFyIG1kID0gc3RhdGUubWluRGlzO1xuXHQgICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG5cdCAgICB2YXIgcHYgPSBzdGF0ZS5kcHY7XG5cdCAgICB2YXIgb2Q7IC8vIG9yaWdpbmFsIGRpc3RhbmNlXG5cdCAgICB2YXIgZDsgLy8gbW92aW5nIGRpc3RhbmNlXG5cdCAgICB2YXIgc2lnbjsgLy8gc2lnbiBvZiBkaXN0YW5jZVxuXHQgICAgdmFyIGN2O1xuXG5cdCAgICBkID0gb2QgPSBwdi5kaXN0YW5jZShwLCBycCwgdHJ1ZSwgdHJ1ZSk7XG5cdCAgICBzaWduID0gZCA+PSAwID8gMSA6IC0xOyAvLyBNYXRoLnNpZ24gd291bGQgYmUgMCBpbiBjYXNlIG9mIDBcblxuXHQgICAgLy8gVE9ETyBjb25zaWRlciBhdXRvRmxpcFxuXHQgICAgZCA9IE1hdGguYWJzKGQpO1xuXG5cdCAgICBpZiAoaW5kaXJlY3QpIHtcblx0ICAgICAgICBjdiA9IHN0YXRlLmN2dFtjdnRlXTtcblxuXHQgICAgICAgIGlmIChybyAmJiBNYXRoLmFicyhkIC0gY3YpIDwgc3RhdGUuY3ZDdXRJbikgeyBkID0gY3Y7IH1cblx0ICAgIH1cblxuXHQgICAgaWYgKGtlZXBEICYmIGQgPCBtZCkgeyBkID0gbWQ7IH1cblxuXHQgICAgaWYgKHJvKSB7IGQgPSBzdGF0ZS5yb3VuZChkKTsgfVxuXG5cdCAgICBmdi5zZXRSZWxhdGl2ZShwLCBycCwgc2lnbiAqIGQsIHB2KTtcblx0ICAgIGZ2LnRvdWNoKHApO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuXHQgICAgICAgIGNvbnNvbGUubG9nKFxuXHQgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuXHQgICAgICAgICAgICAoaW5kaXJlY3QgPyAnTUlSUFsnIDogJ01EUlBbJykgK1xuXHQgICAgICAgICAgICAoc2V0UnAwID8gJ00nIDogJ20nKSArXG5cdCAgICAgICAgICAgIChrZWVwRCA/ICc+JyA6ICdfJykgK1xuXHQgICAgICAgICAgICAocm8gPyAnUicgOiAnXycpICtcblx0ICAgICAgICAgICAgKGR0ID09PSAwID8gJ0dyJyA6IChkdCA9PT0gMSA/ICdCbCcgOiAoZHQgPT09IDIgPyAnV2gnIDogJycpKSkgK1xuXHQgICAgICAgICAgICAnXScsXG5cdCAgICAgICAgICAgIGluZGlyZWN0ID9cblx0ICAgICAgICAgICAgICAgIGN2dGUgKyAnKCcgKyBzdGF0ZS5jdnRbY3Z0ZV0gKyAnLCcgKyAgY3YgKyAnKScgOlxuXHQgICAgICAgICAgICAgICAgJycsXG5cdCAgICAgICAgICAgIHBpLFxuXHQgICAgICAgICAgICAnKGQgPScsIG9kLCAnLT4nLCBzaWduICogZCwgJyknXG5cdCAgICAgICAgKTtcblx0ICAgIH1cblxuXHQgICAgc3RhdGUucnAxID0gc3RhdGUucnAwO1xuXHQgICAgc3RhdGUucnAyID0gcGk7XG5cdCAgICBpZiAoc2V0UnAwKSB7IHN0YXRlLnJwMCA9IHBpOyB9XG5cdH1cblxuXHQvKlxuXHQqIFRoZSBpbnN0cnVjdGlvbiB0YWJsZS5cblx0Ki9cblx0aW5zdHJ1Y3Rpb25UYWJsZSA9IFtcblx0ICAgIC8qIDB4MDAgKi8gU1ZUQ0EuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcblx0ICAgIC8qIDB4MDEgKi8gU1ZUQ0EuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcblx0ICAgIC8qIDB4MDIgKi8gU1BWVENBLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG5cdCAgICAvKiAweDAzICovIFNQVlRDQS5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuXHQgICAgLyogMHgwNCAqLyBTRlZUQ0EuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcblx0ICAgIC8qIDB4MDUgKi8gU0ZWVENBLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG5cdCAgICAvKiAweDA2ICovIFNQVlRMLmJpbmQodW5kZWZpbmVkLCAwKSxcblx0ICAgIC8qIDB4MDcgKi8gU1BWVEwuYmluZCh1bmRlZmluZWQsIDEpLFxuXHQgICAgLyogMHgwOCAqLyBTRlZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG5cdCAgICAvKiAweDA5ICovIFNGVlRMLmJpbmQodW5kZWZpbmVkLCAxKSxcblx0ICAgIC8qIDB4MEEgKi8gU1BWRlMsXG5cdCAgICAvKiAweDBCICovIFNGVkZTLFxuXHQgICAgLyogMHgwQyAqLyBHUFYsXG5cdCAgICAvKiAweDBEICovIEdGVixcblx0ICAgIC8qIDB4MEUgKi8gU0ZWVFBWLFxuXHQgICAgLyogMHgwRiAqLyBJU0VDVCxcblx0ICAgIC8qIDB4MTAgKi8gU1JQMCxcblx0ICAgIC8qIDB4MTEgKi8gU1JQMSxcblx0ICAgIC8qIDB4MTIgKi8gU1JQMixcblx0ICAgIC8qIDB4MTMgKi8gU1pQMCxcblx0ICAgIC8qIDB4MTQgKi8gU1pQMSxcblx0ICAgIC8qIDB4MTUgKi8gU1pQMixcblx0ICAgIC8qIDB4MTYgKi8gU1pQUyxcblx0ICAgIC8qIDB4MTcgKi8gU0xPT1AsXG5cdCAgICAvKiAweDE4ICovIFJURyxcblx0ICAgIC8qIDB4MTkgKi8gUlRIRyxcblx0ICAgIC8qIDB4MUEgKi8gU01ELFxuXHQgICAgLyogMHgxQiAqLyBFTFNFLFxuXHQgICAgLyogMHgxQyAqLyBKTVBSLFxuXHQgICAgLyogMHgxRCAqLyBTQ1ZUQ0ksXG5cdCAgICAvKiAweDFFICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIFNTV0NJXG5cdCAgICAvKiAweDFGICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIFNTV1xuXHQgICAgLyogMHgyMCAqLyBEVVAsXG5cdCAgICAvKiAweDIxICovIFBPUCxcblx0ICAgIC8qIDB4MjIgKi8gQ0xFQVIsXG5cdCAgICAvKiAweDIzICovIFNXQVAsXG5cdCAgICAvKiAweDI0ICovIERFUFRILFxuXHQgICAgLyogMHgyNSAqLyBDSU5ERVgsXG5cdCAgICAvKiAweDI2ICovIE1JTkRFWCxcblx0ICAgIC8qIDB4MjcgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gQUxJR05QVFNcblx0ICAgIC8qIDB4MjggKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHgyOSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBVVFBcblx0ICAgIC8qIDB4MkEgKi8gTE9PUENBTEwsXG5cdCAgICAvKiAweDJCICovIENBTEwsXG5cdCAgICAvKiAweDJDICovIEZERUYsXG5cdCAgICAvKiAweDJEICovIHVuZGVmaW5lZCwgICAvLyBFTkRGIChlYXRlbiBieSBGREVGKVxuXHQgICAgLyogMHgyRSAqLyBNREFQLmJpbmQodW5kZWZpbmVkLCAwKSxcblx0ICAgIC8qIDB4MkYgKi8gTURBUC5iaW5kKHVuZGVmaW5lZCwgMSksXG5cdCAgICAvKiAweDMwICovIElVUC5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuXHQgICAgLyogMHgzMSAqLyBJVVAuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcblx0ICAgIC8qIDB4MzIgKi8gU0hQLmJpbmQodW5kZWZpbmVkLCAwKSxcblx0ICAgIC8qIDB4MzMgKi8gU0hQLmJpbmQodW5kZWZpbmVkLCAxKSxcblx0ICAgIC8qIDB4MzQgKi8gU0hDLmJpbmQodW5kZWZpbmVkLCAwKSxcblx0ICAgIC8qIDB4MzUgKi8gU0hDLmJpbmQodW5kZWZpbmVkLCAxKSxcblx0ICAgIC8qIDB4MzYgKi8gU0haLmJpbmQodW5kZWZpbmVkLCAwKSxcblx0ICAgIC8qIDB4MzcgKi8gU0haLmJpbmQodW5kZWZpbmVkLCAxKSxcblx0ICAgIC8qIDB4MzggKi8gU0hQSVgsXG5cdCAgICAvKiAweDM5ICovIElQLFxuXHQgICAgLyogMHgzQSAqLyBNU0lSUC5iaW5kKHVuZGVmaW5lZCwgMCksXG5cdCAgICAvKiAweDNCICovIE1TSVJQLmJpbmQodW5kZWZpbmVkLCAxKSxcblx0ICAgIC8qIDB4M0MgKi8gQUxJR05SUCxcblx0ICAgIC8qIDB4M0QgKi8gUlRERyxcblx0ICAgIC8qIDB4M0UgKi8gTUlBUC5iaW5kKHVuZGVmaW5lZCwgMCksXG5cdCAgICAvKiAweDNGICovIE1JQVAuYmluZCh1bmRlZmluZWQsIDEpLFxuXHQgICAgLyogMHg0MCAqLyBOUFVTSEIsXG5cdCAgICAvKiAweDQxICovIE5QVVNIVyxcblx0ICAgIC8qIDB4NDIgKi8gV1MsXG5cdCAgICAvKiAweDQzICovIFJTLFxuXHQgICAgLyogMHg0NCAqLyBXQ1ZUUCxcblx0ICAgIC8qIDB4NDUgKi8gUkNWVCxcblx0ICAgIC8qIDB4NDYgKi8gR0MuYmluZCh1bmRlZmluZWQsIDApLFxuXHQgICAgLyogMHg0NyAqLyBHQy5iaW5kKHVuZGVmaW5lZCwgMSksXG5cdCAgICAvKiAweDQ4ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIFNDRlNcblx0ICAgIC8qIDB4NDkgKi8gTUQuYmluZCh1bmRlZmluZWQsIDApLFxuXHQgICAgLyogMHg0QSAqLyBNRC5iaW5kKHVuZGVmaW5lZCwgMSksXG5cdCAgICAvKiAweDRCICovIE1QUEVNLFxuXHQgICAgLyogMHg0QyAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBNUFNcblx0ICAgIC8qIDB4NEQgKi8gRkxJUE9OLFxuXHQgICAgLyogMHg0RSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBGTElQT0ZGXG5cdCAgICAvKiAweDRGICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIERFQlVHXG5cdCAgICAvKiAweDUwICovIExULFxuXHQgICAgLyogMHg1MSAqLyBMVEVRLFxuXHQgICAgLyogMHg1MiAqLyBHVCxcblx0ICAgIC8qIDB4NTMgKi8gR1RFUSxcblx0ICAgIC8qIDB4NTQgKi8gRVEsXG5cdCAgICAvKiAweDU1ICovIE5FUSxcblx0ICAgIC8qIDB4NTYgKi8gT0RELFxuXHQgICAgLyogMHg1NyAqLyBFVkVOLFxuXHQgICAgLyogMHg1OCAqLyBJRixcblx0ICAgIC8qIDB4NTkgKi8gRUlGLFxuXHQgICAgLyogMHg1QSAqLyBBTkQsXG5cdCAgICAvKiAweDVCICovIE9SLFxuXHQgICAgLyogMHg1QyAqLyBOT1QsXG5cdCAgICAvKiAweDVEICovIERFTFRBUDEyMy5iaW5kKHVuZGVmaW5lZCwgMSksXG5cdCAgICAvKiAweDVFICovIFNEQixcblx0ICAgIC8qIDB4NUYgKi8gU0RTLFxuXHQgICAgLyogMHg2MCAqLyBBREQsXG5cdCAgICAvKiAweDYxICovIFNVQixcblx0ICAgIC8qIDB4NjIgKi8gRElWLFxuXHQgICAgLyogMHg2MyAqLyBNVUwsXG5cdCAgICAvKiAweDY0ICovIEFCUyxcblx0ICAgIC8qIDB4NjUgKi8gTkVHLFxuXHQgICAgLyogMHg2NiAqLyBGTE9PUixcblx0ICAgIC8qIDB4NjcgKi8gQ0VJTElORyxcblx0ICAgIC8qIDB4NjggKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDApLFxuXHQgICAgLyogMHg2OSAqLyBST1VORC5iaW5kKHVuZGVmaW5lZCwgMSksXG5cdCAgICAvKiAweDZBICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAyKSxcblx0ICAgIC8qIDB4NkIgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDMpLFxuXHQgICAgLyogMHg2QyAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBOUk9VTkRbYWJdXG5cdCAgICAvKiAweDZEICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cblx0ICAgIC8qIDB4NkUgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuXHQgICAgLyogMHg2RiAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBOUk9VTkRbYWJdXG5cdCAgICAvKiAweDcwICovIFdDVlRGLFxuXHQgICAgLyogMHg3MSAqLyBERUxUQVAxMjMuYmluZCh1bmRlZmluZWQsIDIpLFxuXHQgICAgLyogMHg3MiAqLyBERUxUQVAxMjMuYmluZCh1bmRlZmluZWQsIDMpLFxuXHQgICAgLyogMHg3MyAqLyBERUxUQUMxMjMuYmluZCh1bmRlZmluZWQsIDEpLFxuXHQgICAgLyogMHg3NCAqLyBERUxUQUMxMjMuYmluZCh1bmRlZmluZWQsIDIpLFxuXHQgICAgLyogMHg3NSAqLyBERUxUQUMxMjMuYmluZCh1bmRlZmluZWQsIDMpLFxuXHQgICAgLyogMHg3NiAqLyBTUk9VTkQsXG5cdCAgICAvKiAweDc3ICovIFM0NVJPVU5ELFxuXHQgICAgLyogMHg3OCAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBKUk9UW11cblx0ICAgIC8qIDB4NzkgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gSlJPRltdXG5cdCAgICAvKiAweDdBICovIFJPRkYsXG5cdCAgICAvKiAweDdCICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4N0MgKi8gUlVURyxcblx0ICAgIC8qIDB4N0QgKi8gUkRURyxcblx0ICAgIC8qIDB4N0UgKi8gUE9QLCAvLyBhY3R1YWxseSBTQU5HVywgc3VwcG9zZWQgdG8gZG8gb25seSBhIHBvcCB0aG91Z2hcblx0ICAgIC8qIDB4N0YgKi8gUE9QLCAvLyBhY3R1YWxseSBBQSwgc3VwcG9zZWQgdG8gZG8gb25seSBhIHBvcCB0aG91Z2hcblx0ICAgIC8qIDB4ODAgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUFBUXG5cdCAgICAvKiAweDgxICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBSR09OXG5cdCAgICAvKiAweDgyICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBSR09GRlxuXHQgICAgLyogMHg4MyAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweDg0ICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4ODUgKi8gU0NBTkNUUkwsXG5cdCAgICAvKiAweDg2ICovIFNEUFZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG5cdCAgICAvKiAweDg3ICovIFNEUFZUTC5iaW5kKHVuZGVmaW5lZCwgMSksXG5cdCAgICAvKiAweDg4ICovIEdFVElORk8sXG5cdCAgICAvKiAweDg5ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIElERUZcblx0ICAgIC8qIDB4OEEgKi8gUk9MTCxcblx0ICAgIC8qIDB4OEIgKi8gTUFYLFxuXHQgICAgLyogMHg4QyAqLyBNSU4sXG5cdCAgICAvKiAweDhEICovIFNDQU5UWVBFLFxuXHQgICAgLyogMHg4RSAqLyBJTlNUQ1RSTCxcblx0ICAgIC8qIDB4OEYgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHg5MCAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweDkxICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4OTIgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHg5MyAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweDk0ICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4OTUgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHg5NiAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweDk3ICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4OTggKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHg5OSAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweDlBICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4OUIgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHg5QyAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweDlEICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4OUUgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHg5RiAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweEEwICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4QTEgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHhBMiAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweEEzICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4QTQgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHhBNSAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweEE2ICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4QTcgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHhBOCAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweEE5ICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4QUEgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHhBQiAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweEFDICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4QUQgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHhBRSAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweEFGICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4QjAgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDEpLFxuXHQgICAgLyogMHhCMSAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgMiksXG5cdCAgICAvKiAweEIyICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCAzKSxcblx0ICAgIC8qIDB4QjMgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDQpLFxuXHQgICAgLyogMHhCNCAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgNSksXG5cdCAgICAvKiAweEI1ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA2KSxcblx0ICAgIC8qIDB4QjYgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDcpLFxuXHQgICAgLyogMHhCNyAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgOCksXG5cdCAgICAvKiAweEI4ICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCAxKSxcblx0ICAgIC8qIDB4QjkgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDIpLFxuXHQgICAgLyogMHhCQSAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgMyksXG5cdCAgICAvKiAweEJCICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA0KSxcblx0ICAgIC8qIDB4QkMgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDUpLFxuXHQgICAgLyogMHhCRCAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgNiksXG5cdCAgICAvKiAweEJFICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA3KSxcblx0ICAgIC8qIDB4QkYgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDgpLFxuXHQgICAgLyogMHhDMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDApLFxuXHQgICAgLyogMHhDMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDEpLFxuXHQgICAgLyogMHhDMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDIpLFxuXHQgICAgLyogMHhDMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDMpLFxuXHQgICAgLyogMHhDNCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDApLFxuXHQgICAgLyogMHhDNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDEpLFxuXHQgICAgLyogMHhDNiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDIpLFxuXHQgICAgLyogMHhDNyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDMpLFxuXHQgICAgLyogMHhDOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDApLFxuXHQgICAgLyogMHhDOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDEpLFxuXHQgICAgLyogMHhDQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDIpLFxuXHQgICAgLyogMHhDQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDMpLFxuXHQgICAgLyogMHhDQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDApLFxuXHQgICAgLyogMHhDRCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDEpLFxuXHQgICAgLyogMHhDRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDIpLFxuXHQgICAgLyogMHhDRiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDMpLFxuXHQgICAgLyogMHhEMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDApLFxuXHQgICAgLyogMHhEMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDEpLFxuXHQgICAgLyogMHhEMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDIpLFxuXHQgICAgLyogMHhEMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDMpLFxuXHQgICAgLyogMHhENCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDApLFxuXHQgICAgLyogMHhENSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDEpLFxuXHQgICAgLyogMHhENiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDIpLFxuXHQgICAgLyogMHhENyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDMpLFxuXHQgICAgLyogMHhEOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDApLFxuXHQgICAgLyogMHhEOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDEpLFxuXHQgICAgLyogMHhEQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDIpLFxuXHQgICAgLyogMHhEQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDMpLFxuXHQgICAgLyogMHhEQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDApLFxuXHQgICAgLyogMHhERCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDEpLFxuXHQgICAgLyogMHhERSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDIpLFxuXHQgICAgLyogMHhERiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDMpLFxuXHQgICAgLyogMHhFMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDApLFxuXHQgICAgLyogMHhFMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDEpLFxuXHQgICAgLyogMHhFMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDIpLFxuXHQgICAgLyogMHhFMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDMpLFxuXHQgICAgLyogMHhFNCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDApLFxuXHQgICAgLyogMHhFNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDEpLFxuXHQgICAgLyogMHhFNiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDIpLFxuXHQgICAgLyogMHhFNyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDMpLFxuXHQgICAgLyogMHhFOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDApLFxuXHQgICAgLyogMHhFOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDEpLFxuXHQgICAgLyogMHhFQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDIpLFxuXHQgICAgLyogMHhFQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDMpLFxuXHQgICAgLyogMHhFQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDApLFxuXHQgICAgLyogMHhFRCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDEpLFxuXHQgICAgLyogMHhFRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDIpLFxuXHQgICAgLyogMHhFRiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDMpLFxuXHQgICAgLyogMHhGMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDApLFxuXHQgICAgLyogMHhGMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDEpLFxuXHQgICAgLyogMHhGMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDIpLFxuXHQgICAgLyogMHhGMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDMpLFxuXHQgICAgLyogMHhGNCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDApLFxuXHQgICAgLyogMHhGNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDEpLFxuXHQgICAgLyogMHhGNiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDIpLFxuXHQgICAgLyogMHhGNyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDMpLFxuXHQgICAgLyogMHhGOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDApLFxuXHQgICAgLyogMHhGOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDEpLFxuXHQgICAgLyogMHhGQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDIpLFxuXHQgICAgLyogMHhGQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDMpLFxuXHQgICAgLyogMHhGQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDApLFxuXHQgICAgLyogMHhGRCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDEpLFxuXHQgICAgLyogMHhGRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDIpLFxuXHQgICAgLyogMHhGRiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDMpXG5cdF07XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAgTWF0aGVtYXRpY2FsIENvbnNpZGVyYXRpb25zXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cdGZ2IC4uLiByZWZlcnMgdG8gZnJlZWRvbSB2ZWN0b3Jcblx0cHYgLi4uIHJlZmVycyB0byBwcm9qZWN0aW9uIHZlY3RvclxuXHRycCAuLi4gcmVmZXJzIHRvIHJlZmVyZW5jZSBwb2ludFxuXHRwICAuLi4gcmVmZXJzIHRvIHRvIHBvaW50IGJlaW5nIG9wZXJhdGVkIG9uXG5cdGQgIC4uLiByZWZlcnMgdG8gZGlzdGFuY2VcblxuXHRTRVRSRUxBVElWRTpcblx0PT09PT09PT09PT09XG5cblx0Y2FzZSBmcmVlZG9tIHZlY3RvciA9PSB4LWF4aXM6XG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIChwdilcblx0ICAgICAgICAgICAgICAgICAgICAgLi0nXG5cdCAgICAgICAgICAgICAgcnBkIC4tJ1xuXHQgICAgICAgICAgICAgICAuLSpcblx0ICAgICAgICAgIGQgLi0nOTDCsCdcblx0ICAgICAgICAgLi0nICAgICAgICdcblx0ICAgICAgLi0nICAgICAgICAgICAnXG5cdCAgICotJyAgICAgICAgICAgICAgICcgYlxuXHQgIHJwICAgICAgICAgICAgICAgICAgJ1xuXHQgICAgICAgICAgICAgICAgICAgICAgICdcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJ1xuXHQgICAgICAgICAgICBwICotLS0tLS0tLS0tKi0tLS0tLS0tLS0tLS0tIChmdilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICBwbVxuXG5cdCAgcnBkeCA9IHJweCArIGQgKiBwdi54XG5cdCAgcnBkeSA9IHJweSArIGQgKiBwdi55XG5cblx0ICBlcXVhdGlvbiBvZiBsaW5lIGJcblxuXHQgICB5IC0gcnBkeSA9IHB2bnMgKiAoeC0gcnBkeClcblxuXHQgICB5ID0gcC55XG5cblx0ICAgeCA9IHJwZHggKyAoIHAueSAtIHJwZHkgKSAvIHB2bnNcblxuXG5cdGNhc2UgZnJlZWRvbSB2ZWN0b3IgPT0geS1heGlzOlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHQgICAgKiBwbVxuXHQgICAgfFxcXG5cdCAgICB8IFxcXG5cdCAgICB8ICBcXFxuXHQgICAgfCAgIFxcXG5cdCAgICB8ICAgIFxcXG5cdCAgICB8ICAgICBcXFxuXHQgICAgfCAgICAgIFxcXG5cdCAgICB8ICAgICAgIFxcXG5cdCAgICB8ICAgICAgICBcXFxuXHQgICAgfCAgICAgICAgIFxcIGJcblx0ICAgIHwgICAgICAgICAgXFxcblx0ICAgIHwgICAgICAgICAgIFxcXG5cdCAgICB8ICAgICAgICAgICAgXFwgICAgLi0nIChwdilcblx0ICAgIHwgICAgICAgICA5MMKwIFxcLi0nXG5cdCAgICB8ICAgICAgICAgICAuLScqIHJwZFxuXHQgICAgfCAgICAgICAgLi0nXG5cdCAgICAqICAgICAqLScgIGRcblx0ICAgIHAgICAgIHJwXG5cblx0ICBycGR4ID0gcnB4ICsgZCAqIHB2Lnhcblx0ICBycGR5ID0gcnB5ICsgZCAqIHB2LnlcblxuXHQgIGVxdWF0aW9uIG9mIGxpbmUgYjpcblx0ICAgICAgICAgICBwdm5zIC4uLiBub3JtYWwgc2xvcGUgdG8gcHZcblxuXHQgICB5IC0gcnBkeSA9IHB2bnMgKiAoeCAtIHJwZHgpXG5cblx0ICAgeCA9IHAueFxuXG5cdCAgIHkgPSBycGR5ICsgIHB2bnMgKiAocC54IC0gcnBkeClcblxuXG5cblx0Z2VuZXJpYyBjYXNlOlxuXHQtLS0tLS0tLS0tLS0tXG5cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuJyhmdilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4nXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgLiogcG1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLicgIVxuXHQgICAgICAgICAgICAgICAgICAgICAgLicgICAgLlxuXHQgICAgICAgICAgICAgICAgICAgIC4nICAgICAgIVxuXHQgICAgICAgICAgICAgICAgICAuJyAgICAgICAgIC4gYlxuXHQgICAgICAgICAgICAgICAgLicgICAgICAgICAgICFcblx0ICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgLlxuXHQgICAgICAgICAgICAgIHAgICAgICAgICAgICAgICAhXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICA5MMKwICAgLiAgICAuLi4gKHB2KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4tKi0nJydcblx0ICAgICAgICAgICAgICAgICAgLi4uLS0tJycnICAgIHJwZFxuXHQgICAgICAgICAuLi4tLS0nJycgICBkXG5cdCAgICotLScnJ1xuXHQgIHJwXG5cblx0ICAgIHJwZHggPSBycHggKyBkICogcHYueFxuXHQgICAgcnBkeSA9IHJweSArIGQgKiBwdi55XG5cblx0IGVxdWF0aW9uIG9mIGxpbmUgYjpcblx0ICAgIHB2bnMuLi4gbm9ybWFsIHNsb3BlIHRvIHB2XG5cblx0ICAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuXHQgZXF1YXRpb24gb2YgZnJlZWRvbSB2ZWN0b3IgbGluZTpcblx0ICAgIGZ2cyAuLi4gc2xvcGUgb2YgZnJlZWRvbSB2ZWN0b3IgKD1meS9meClcblxuXHQgICAgeSAtIHB5ID0gZnZzICogKHggLSBweClcblxuXG5cdCAgb24gcG0gYm90aCBlcXVhdGlvbnMgYXJlIHRydWUgZm9yIHNhbWUgeC95XG5cblx0ICAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuXHQgICAgeSAtIHB5ID0gZnZzICogKHggLSBweClcblxuXHQgIGZvcm0gdG8geSBhbmQgc2V0IGVxdWFsOlxuXG5cdCAgICBwdm5zICogKHggLSBycGR4KSArIHJwZHkgPSBmdnMgKiAoeCAtIHB4KSArIHB5XG5cblx0ICBleHBhbmQ6XG5cblx0ICAgIHB2bnMgKiB4IC0gcHZucyAqIHJwZHggKyBycGR5ID0gZnZzICogeCAtIGZ2cyAqIHB4ICsgcHlcblxuXHQgIHN3aXRjaDpcblxuXHQgICAgZnZzICogeCAtIGZ2cyAqIHB4ICsgcHkgPSBwdm5zICogeCAtIHB2bnMgKiBycGR4ICsgcnBkeVxuXG5cdCAgc29sdmUgZm9yIHg6XG5cblx0ICAgIGZ2cyAqIHggLSBwdm5zICogeCA9IGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggLSBweSArIHJwZHlcblxuXG5cblx0ICAgICAgICAgIGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggKyBycGR5IC0gcHlcblx0ICAgIHggPSAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICAgICAgICAgICAgICAgICBmdnMgLSBwdm5zXG5cblx0ICBhbmQ6XG5cblx0ICAgIHkgPSBmdnMgKiAoeCAtIHB4KSArIHB5XG5cblxuXG5cdElOVEVSUE9MQVRFOlxuXHQ9PT09PT09PT09PT1cblxuXHRFeGFtcGxlcyBvZiBwb2ludCBpbnRlcnBvbGF0aW9uLlxuXG5cdFRoZSB3ZWlnaHQgb2YgdGhlIG1vdmVtZW50IG9mIHRoZSByZWZlcmVuY2UgcG9pbnQgZ2V0cyBiaWdnZXJcblx0dGhlIGZ1cnRoZXIgdGhlIG90aGVyIHJlZmVyZW5jZSBwb2ludCBpcyBhd2F5LCB0aHVzIHRoZSBzYWZlc3Rcblx0b3B0aW9uICh0aGF0IGlzIGF2b2lkaW5nIDAvMCBkaXZpc2lvbnMpIGlzIHRvIHdlaWdodCB0aGVcblx0b3JpZ2luYWwgZGlzdGFuY2Ugb2YgdGhlIG90aGVyIHBvaW50IGJ5IHRoZSBzdW0gb2YgYm90aCBkaXN0YW5jZXMuXG5cblx0SWYgdGhlIHN1bSBvZiBib3RoIGRpc3RhbmNlcyBpcyAwLCB0aGVuIG1vdmUgdGhlIHBvaW50IGJ5IHRoZVxuXHRhcml0aG1ldGljIGF2ZXJhZ2Ugb2YgdGhlIG1vdmVtZW50IG9mIGJvdGggcmVmZXJlbmNlIHBvaW50cy5cblxuXG5cblxuXHQgICAgICAgICAgICgrNilcblx0ICAgIHJwMW8gKi0tLS0+KnJwMVxuXHQgICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICAoKzEyKVxuXHQgICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgcnAybyAqLS0tLS0tLS0tLT4qIHJwMlxuXHQgICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuICAgICAgICAgICAuXG5cdCAgICAgICAgIC4gICAgIC4gICAgICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAgIC5cblx0ICAgICAgICAgLiAgICAxMCAgICAgICAgICAyMCAgICAgICAgICAgLiAgICAgICAgICAgLlxuXHQgICAgICAgICB8Li4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi58ICAgICAgICAgICAuXG5cdCAgICAgICAgICAgICAgIC4gICAuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5cblx0ICAgICAgICAgICAgICAgLiAgIC4gKCs4KSAgICAgICAgICAgICAgICAgICAgICAgICAgLlxuXHQgICAgICAgICAgICAgICAgcG8gKi0tLS0tLT4qcCAgICAgICAgICAgICAgICAgICAgICAuXG5cdCAgICAgICAgICAgICAgIC4gICAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgICAgIC5cblx0ICAgICAgICAgICAgICAgLiAgICAxMiAgICAgLiAgICAgICAgICAyNCAgICAgICAgICAgLlxuXHQgICAgICAgICAgICAgICB8Li4uLi4uLi4uLi58Li4uLi4uLi4uLi4uLi4uLi4uLi4uLi58XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzNlxuXG5cblx0LS0tLS0tLVxuXG5cblxuXHQgICAgICAgICAgICgrMTApXG5cdCAgICBycDFvICotLS0tLS0tLT4qcnAxXG5cdCAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICAgICAgICAgICgtMTApXG5cdCAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICBycDIgKjwtLS0tLS0tLS0qIHJwbzJcblx0ICAgICAgICAgLiAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgLiAgICAgICAgIC5cblx0ICAgICAgICAgLiAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgLiAgICAgICAgIC5cblx0ICAgICAgICAgLiAgICAxMCAgIC4gICAgICAgICAgMzAgICAgICAgLiAgICAgICAgIC5cblx0ICAgICAgICAgfC4uLi4uLi4uLnwuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLnxcblx0ICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgLlxuXHQgICAgICAgICAgICAgICAgICAgLiAoKzUpICAgICAgICAgICAgICAuXG5cdCAgICAgICAgICAgICAgICBwbyAqLS0tPiogcCAgICAgICAgICAgIC5cblx0ICAgICAgICAgICAgICAgICAgIC4gICAgLiAgICAgICAgICAgICAgLlxuXHQgICAgICAgICAgICAgICAgICAgLiAgICAuICAgMjAgICAgICAgICAuXG5cdCAgICAgICAgICAgICAgICAgICB8Li4uLnwuLi4uLi4uLi4uLi4uLnxcblx0ICAgICAgICAgICAgICAgICAgICAgNSAgICAgICAgMTVcblxuXG5cdC0tLS0tLS1cblxuXG5cdCAgICAgICAgICAgKCsxMClcblx0ICAgIHJwMW8gKi0tLS0tLS0tPipycDFcblx0ICAgICAgICAgLiAgICAgICAgIC5cblx0ICAgICAgICAgLiAgICAgICAgIC5cblx0ICAgIHJwMm8gKi0tLS0tLS0tPipycDJcblxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKzEwKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIHBvICotLS0tLS0tLT4qIHBcblxuXHQtLS0tLS0tXG5cblxuXHQgICAgICAgICAgICgrMTApXG5cdCAgICBycDFvICotLS0tLS0tLT4qcnAxXG5cdCAgICAgICAgIC4gICAgICAgICAuXG5cdCAgICAgICAgIC4gICAgICAgICAuKCszMClcblx0ICAgIHJwMm8gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+KnJwMlxuXG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgrMjUpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgcG8gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPiogcFxuXG5cblxuXHR2aW06IHNldCB0cz00IHN3PTQgZXhwYW5kdGFiOlxuXHQqKioqKi9cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGxpc3Qgb2YgdG9rZW5zLlxuXHQgKi9cblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IHRva2VuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIGEgc2luZ2xlIGNoYXJcblx0ICovXG5cdGZ1bmN0aW9uIFRva2VuKGNoYXIpIHtcblx0ICAgIHRoaXMuY2hhciA9IGNoYXI7XG5cdCAgICB0aGlzLnN0YXRlID0ge307XG5cdCAgICB0aGlzLmFjdGl2ZVN0YXRlID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgY29udGV4dCByYW5nZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCByYW5nZSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZW5kT2Zmc2V0IHJhbmdlIGVuZCBpbmRleCBvZmZzZXRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lIG93bmVyIGNvbnRleHQgbmFtZVxuXHQgKi9cblx0ZnVuY3Rpb24gQ29udGV4dFJhbmdlKHN0YXJ0SW5kZXgsIGVuZE9mZnNldCwgY29udGV4dE5hbWUpIHtcblx0ICAgIHRoaXMuY29udGV4dE5hbWUgPSBjb250ZXh0TmFtZTtcblx0ICAgIHRoaXMuc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XG5cdCAgICB0aGlzLmVuZE9mZnNldCA9IGVuZE9mZnNldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBjb250ZXh0IHN0YXJ0IGFuZCBlbmRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lIGEgdW5pcXVlIGNvbnRleHQgbmFtZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjaGVja1N0YXJ0IGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoZSBpbmRpY2F0ZXMgYSBjb250ZXh0J3Mgc3RhcnRcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY2hlY2tFbmQgYSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhlIGluZGljYXRlcyBhIGNvbnRleHQncyBlbmRcblx0ICovXG5cdGZ1bmN0aW9uIENvbnRleHRDaGVja2VyKGNvbnRleHROYW1lLCBjaGVja1N0YXJ0LCBjaGVja0VuZCkge1xuXHQgICAgdGhpcy5jb250ZXh0TmFtZSA9IGNvbnRleHROYW1lO1xuXHQgICAgdGhpcy5vcGVuUmFuZ2UgPSBudWxsO1xuXHQgICAgdGhpcy5yYW5nZXMgPSBbXTtcblx0ICAgIHRoaXMuY2hlY2tTdGFydCA9IGNoZWNrU3RhcnQ7XG5cdCAgICB0aGlzLmNoZWNrRW5kID0gY2hlY2tFbmQ7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGVkZWYgQ29udGV4dFBhcmFtc1xuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHByb3BlcnR5IHthcnJheX0gY29udGV4dCBjb250ZXh0IGl0ZW1zXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXJyZW50SW5kZXggY3VycmVudCBpdGVtIGluZGV4XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBjb250ZXh0IHBhcmFtc1xuXHQgKiBAcGFyYW0ge2FycmF5fSBjb250ZXh0IGEgbGlzdCBvZiBpdGVtc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEluZGV4IGN1cnJlbnQgaXRlbSBpbmRleFxuXHQgKi9cblx0ZnVuY3Rpb24gQ29udGV4dFBhcmFtcyhjb250ZXh0LCBjdXJyZW50SW5kZXgpIHtcblx0ICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cdCAgICB0aGlzLmluZGV4ID0gY3VycmVudEluZGV4O1xuXHQgICAgdGhpcy5sZW5ndGggPSBjb250ZXh0Lmxlbmd0aDtcblx0ICAgIHRoaXMuY3VycmVudCA9IGNvbnRleHRbY3VycmVudEluZGV4XTtcblx0ICAgIHRoaXMuYmFja3RyYWNrID0gY29udGV4dC5zbGljZSgwLCBjdXJyZW50SW5kZXgpO1xuXHQgICAgdGhpcy5sb29rYWhlYWQgPSBjb250ZXh0LnNsaWNlKGN1cnJlbnRJbmRleCArIDEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBldmVudCBpbnN0YW5jZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRJZCBldmVudCB1bmlxdWUgaWRcblx0ICovXG5cdGZ1bmN0aW9uIEV2ZW50KGV2ZW50SWQpIHtcblx0ICAgIHRoaXMuZXZlbnRJZCA9IGV2ZW50SWQ7XG5cdCAgICB0aGlzLnN1YnNjcmliZXJzID0gW107XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSBhIGNvcmUgZXZlbnRzIGFuZCBhdXRvIHN1YnNjcmliZSByZXF1aXJlZCBldmVudCBoYW5kbGVyc1xuXHQgKiBAcGFyYW0ge2FueX0gZXZlbnRzIGFuIG9iamVjdCB0aGF0IGVubGlzdHMgY29yZSBldmVudHMgaGFuZGxlcnNcblx0ICovXG5cdGZ1bmN0aW9uIGluaXRpYWxpemVDb3JlRXZlbnRzKGV2ZW50cykge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIHZhciBjb3JlRXZlbnRzID0gW1xuXHQgICAgICAgICdzdGFydCcsICdlbmQnLCAnbmV4dCcsICduZXdUb2tlbicsICdjb250ZXh0U3RhcnQnLFxuXHQgICAgICAgICdjb250ZXh0RW5kJywgJ2luc2VydFRva2VuJywgJ3JlbW92ZVRva2VuJywgJ3JlbW92ZVJhbmdlJyxcblx0ICAgICAgICAncmVwbGFjZVRva2VuJywgJ3JlcGxhY2VSYW5nZScsICdjb21wb3NlUlVEJywgJ3VwZGF0ZUNvbnRleHRzUmFuZ2VzJ1xuXHQgICAgXTtcblxuXHQgICAgY29yZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudElkKSB7XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMkMS5ldmVudHMsIGV2ZW50SWQsIHtcblx0ICAgICAgICAgICAgdmFsdWU6IG5ldyBFdmVudChldmVudElkKVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cblx0ICAgIGlmICghIWV2ZW50cykge1xuXHQgICAgICAgIGNvcmVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRJZCkge1xuXHQgICAgICAgICAgICB2YXIgZXZlbnQgPSBldmVudHNbZXZlbnRJZF07XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMkMS5ldmVudHNbZXZlbnRJZF0uc3Vic2NyaWJlKGV2ZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgdmFyIHJlcXVpcmVzQ29udGV4dFVwZGF0ZSA9IFtcblx0ICAgICAgICAnaW5zZXJ0VG9rZW4nLCAncmVtb3ZlVG9rZW4nLCAncmVtb3ZlUmFuZ2UnLFxuXHQgICAgICAgICdyZXBsYWNlVG9rZW4nLCAncmVwbGFjZVJhbmdlJywgJ2NvbXBvc2VSVUQnXG5cdCAgICBdO1xuXHQgICAgcmVxdWlyZXNDb250ZXh0VXBkYXRlLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SWQpIHtcblx0ICAgICAgICB0aGlzJDEuZXZlbnRzW2V2ZW50SWRdLnN1YnNjcmliZShcblx0ICAgICAgICAgICAgdGhpcyQxLnVwZGF0ZUNvbnRleHRzUmFuZ2VzXG5cdCAgICAgICAgKTtcblx0ICAgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBsaXN0IG9mIHRva2Vuc1xuXHQgKiBAcGFyYW0ge2FueX0gZXZlbnRzIHRva2VuaXplciBjb3JlIGV2ZW50c1xuXHQgKi9cblx0ZnVuY3Rpb24gVG9rZW5pemVyKGV2ZW50cykge1xuXHQgICAgdGhpcy50b2tlbnMgPSBbXTtcblx0ICAgIHRoaXMucmVnaXN0ZXJlZENvbnRleHRzID0ge307XG5cdCAgICB0aGlzLmNvbnRleHRDaGVja2VycyA9IFtdO1xuXHQgICAgdGhpcy5ldmVudHMgPSB7fTtcblx0ICAgIHRoaXMucmVnaXN0ZXJlZE1vZGlmaWVycyA9IFtdO1xuXG5cdCAgICBpbml0aWFsaXplQ29yZUV2ZW50cy5jYWxsKHRoaXMsIGV2ZW50cyk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgc3RhdGUgb2YgYSB0b2tlbiwgdXN1YWxseSBjYWxsZWQgYnkgYSBzdGF0ZSBtb2RpZmllci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdGF0ZSBpdGVtIGtleVxuXHQgKiBAcGFyYW0ge2FueX0gdmFsdWUgc3RhdGUgaXRlbSB2YWx1ZVxuXHQgKi9cblx0VG9rZW4ucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHQgICAgdGhpcy5zdGF0ZVtrZXldID0gdmFsdWU7XG5cdCAgICB0aGlzLmFjdGl2ZVN0YXRlID0geyBrZXk6IGtleSwgdmFsdWU6IHRoaXMuc3RhdGVba2V5XSB9O1xuXHQgICAgcmV0dXJuIHRoaXMuYWN0aXZlU3RhdGU7XG5cdH07XG5cblx0VG9rZW4ucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlSWQpIHtcblx0ICAgIHJldHVybiB0aGlzLnN0YXRlW3N0YXRlSWRdIHx8IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBhbiBpbmRleCBleGlzdHMgaW4gdGhlIHRva2VucyBsaXN0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcblx0ICovXG5cdFRva2VuaXplci5wcm90b3R5cGUuaW5ib3VuZEluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcblx0ICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb21wb3NlIGFuZCBhcHBseSBhIGxpc3Qgb2Ygb3BlcmF0aW9ucyAocmVwbGFjZSwgdXBkYXRlLCBkZWxldGUpXG5cdCAqIEBwYXJhbSB7YXJyYXl9IFJVRHMgcmVwbGFjZSwgdXBkYXRlIGFuZCBkZWxldGUgb3BlcmF0aW9uc1xuXHQgKiBUT0RPOiBQZXJmLiBPcHRpbWl6YXRpb24gKGxlbmd0aEJlZm9yZSA9PT0gbGVuZ3RoQWZ0ZXIgPyBkaXNwYXRjaCBvbmNlKVxuXHQgKi9cblx0VG9rZW5pemVyLnByb3RvdHlwZS5jb21wb3NlUlVEID0gZnVuY3Rpb24gKFJVRHMpIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICB2YXIgc2lsZW50ID0gdHJ1ZTtcblx0ICAgIHZhciBzdGF0ZSA9IFJVRHMubWFwKGZ1bmN0aW9uIChSVUQpIHsgcmV0dXJuIChcblx0ICAgICAgICB0aGlzJDFbUlVEWzBdXS5hcHBseSh0aGlzJDEsIFJVRC5zbGljZSgxKS5jb25jYXQoc2lsZW50KSlcblx0ICAgICk7IH0pO1xuXHQgICAgdmFyIGhhc0ZBSUxPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG5cdCAgICAgICAgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiZcblx0ICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoJ0ZBSUwnKVxuXHQgICAgKTsgfTtcblx0ICAgIGlmIChzdGF0ZS5ldmVyeShoYXNGQUlMT2JqZWN0KSkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIEZBSUw6IFwiY29tcG9zZVJVRDogb25lIG9yIG1vcmUgb3BlcmF0aW9ucyBoYXNuJ3QgY29tcGxldGVkIHN1Y2Nlc3NmdWxseVwiLFxuXHQgICAgICAgICAgICByZXBvcnQ6IHN0YXRlLmZpbHRlcihoYXNGQUlMT2JqZWN0KVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICB0aGlzLmRpc3BhdGNoKCdjb21wb3NlUlVEJywgW3N0YXRlLmZpbHRlcihmdW5jdGlvbiAob3ApIHsgcmV0dXJuICFoYXNGQUlMT2JqZWN0KG9wKTsgfSldKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVwbGFjZSBhIHJhbmdlIG9mIHRva2VucyB3aXRoIGEgbGlzdCBvZiB0b2tlbnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggcmFuZ2Ugc3RhcnQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCByYW5nZSBvZmZzZXRcblx0ICogQHBhcmFtIHt0b2tlbn0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnMgdG8gcmVwbGFjZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCBkaXNwYXRjaCBldmVudHMgYW5kIHVwZGF0ZSBjb250ZXh0IHJhbmdlc1xuXHQgKi9cblx0VG9rZW5pemVyLnByb3RvdHlwZS5yZXBsYWNlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgb2Zmc2V0LCB0b2tlbnMsIHNpbGVudCkge1xuXHQgICAgb2Zmc2V0ID0gb2Zmc2V0ICE9PSBudWxsID8gb2Zmc2V0IDogdGhpcy50b2tlbnMubGVuZ3RoO1xuXHQgICAgdmFyIGlzVG9rZW5UeXBlID0gdG9rZW5zLmV2ZXJ5KGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4gaW5zdGFuY2VvZiBUb2tlbjsgfSk7XG5cdCAgICBpZiAoIWlzTmFOKHN0YXJ0SW5kZXgpICYmIHRoaXMuaW5ib3VuZEluZGV4KHN0YXJ0SW5kZXgpICYmIGlzVG9rZW5UeXBlKSB7XG5cdCAgICAgICAgdmFyIHJlcGxhY2VkID0gdGhpcy50b2tlbnMuc3BsaWNlLmFwcGx5KFxuXHQgICAgICAgICAgICB0aGlzLnRva2VucywgW3N0YXJ0SW5kZXgsIG9mZnNldF0uY29uY2F0KHRva2Vucylcblx0ICAgICAgICApO1xuXHQgICAgICAgIGlmICghc2lsZW50KSB7IHRoaXMuZGlzcGF0Y2goJ3JlcGxhY2VUb2tlbicsIFtzdGFydEluZGV4LCBvZmZzZXQsIHRva2Vuc10pOyB9XG5cdCAgICAgICAgcmV0dXJuIFtyZXBsYWNlZCwgdG9rZW5zXTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHsgRkFJTDogJ3JlcGxhY2VSYW5nZTogaW52YWxpZCB0b2tlbnMgb3Igc3RhcnRJbmRleC4nIH07XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlcGxhY2UgYSB0b2tlbiB3aXRoIGFub3RoZXIgdG9rZW5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG5cdCAqIEBwYXJhbSB7dG9rZW59IHRva2VuIGEgdG9rZW4gdG8gcmVwbGFjZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCBkaXNwYXRjaCBldmVudHMgYW5kIHVwZGF0ZSBjb250ZXh0IHJhbmdlc1xuXHQgKi9cblx0VG9rZW5pemVyLnByb3RvdHlwZS5yZXBsYWNlVG9rZW4gPSBmdW5jdGlvbiAoaW5kZXgsIHRva2VuLCBzaWxlbnQpIHtcblx0ICAgIGlmICghaXNOYU4oaW5kZXgpICYmIHRoaXMuaW5ib3VuZEluZGV4KGluZGV4KSAmJiB0b2tlbiBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdCAgICAgICAgdmFyIHJlcGxhY2VkID0gdGhpcy50b2tlbnMuc3BsaWNlKGluZGV4LCAxLCB0b2tlbik7XG5cdCAgICAgICAgaWYgKCFzaWxlbnQpIHsgdGhpcy5kaXNwYXRjaCgncmVwbGFjZVRva2VuJywgW2luZGV4LCB0b2tlbl0pOyB9XG5cdCAgICAgICAgcmV0dXJuIFtyZXBsYWNlZFswXSwgdG9rZW5dO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4geyBGQUlMOiAncmVwbGFjZVRva2VuOiBpbnZhbGlkIHRva2VuIG9yIGluZGV4LicgfTtcblx0ICAgIH1cblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhIHJhbmdlIG9mIHRva2Vuc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCByYW5nZSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHJhbmdlIG9mZnNldFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudCBkaXNwYXRjaCBldmVudHMgYW5kIHVwZGF0ZSBjb250ZXh0IHJhbmdlc1xuXHQgKi9cblx0VG9rZW5pemVyLnByb3RvdHlwZS5yZW1vdmVSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0SW5kZXgsIG9mZnNldCwgc2lsZW50KSB7XG5cdCAgICBvZmZzZXQgPSAhaXNOYU4ob2Zmc2V0KSA/IG9mZnNldCA6IHRoaXMudG9rZW5zLmxlbmd0aDtcblx0ICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2Vucy5zcGxpY2Uoc3RhcnRJbmRleCwgb2Zmc2V0KTtcblx0ICAgIGlmICghc2lsZW50KSB7IHRoaXMuZGlzcGF0Y2goJ3JlbW92ZVJhbmdlJywgW3Rva2Vucywgc3RhcnRJbmRleCwgb2Zmc2V0XSk7IH1cblx0ICAgIHJldHVybiB0b2tlbnM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIHRva2VuIGF0IGEgY2VydGFpbiBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcblx0ICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgZGlzcGF0Y2ggZXZlbnRzIGFuZCB1cGRhdGUgY29udGV4dCByYW5nZXNcblx0ICovXG5cdFRva2VuaXplci5wcm90b3R5cGUucmVtb3ZlVG9rZW4gPSBmdW5jdGlvbihpbmRleCwgc2lsZW50KSB7XG5cdCAgICBpZiAoIWlzTmFOKGluZGV4KSAmJiB0aGlzLmluYm91bmRJbmRleChpbmRleCkpIHtcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2Vucy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgIGlmICghc2lsZW50KSB7IHRoaXMuZGlzcGF0Y2goJ3JlbW92ZVRva2VuJywgW3Rva2VuLCBpbmRleF0pOyB9XG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4geyBGQUlMOiAncmVtb3ZlVG9rZW46IGludmFsaWQgdG9rZW4gaW5kZXguJyB9O1xuXHQgICAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnNlcnQgYSBsaXN0IG9mIHRva2VucyBhdCBhIGNlcnRhaW4gaW5kZXhcblx0ICogQHBhcmFtIHthcnJheX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnMgdG8gaW5zZXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbnNlcnQgdGhlIGxpc3Qgb2YgdG9rZW5zIGF0IGluZGV4XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IGRpc3BhdGNoIGV2ZW50cyBhbmQgdXBkYXRlIGNvbnRleHQgcmFuZ2VzXG5cdCAqL1xuXHRUb2tlbml6ZXIucHJvdG90eXBlLmluc2VydFRva2VuID0gZnVuY3Rpb24gKHRva2VucywgaW5kZXgsIHNpbGVudCkge1xuXHQgICAgdmFyIHRva2VuVHlwZSA9IHRva2Vucy5ldmVyeShcblx0ICAgICAgICBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuIGluc3RhbmNlb2YgVG9rZW47IH1cblx0ICAgICk7XG5cdCAgICBpZiAodG9rZW5UeXBlKSB7XG5cdCAgICAgICAgdGhpcy50b2tlbnMuc3BsaWNlLmFwcGx5KFxuXHQgICAgICAgICAgICB0aGlzLnRva2VucywgW2luZGV4LCAwXS5jb25jYXQodG9rZW5zKVxuXHQgICAgICAgICk7XG5cdCAgICAgICAgaWYgKCFzaWxlbnQpIHsgdGhpcy5kaXNwYXRjaCgnaW5zZXJ0VG9rZW4nLCBbdG9rZW5zLCBpbmRleF0pOyB9XG5cdCAgICAgICAgcmV0dXJuIHRva2Vucztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHsgRkFJTDogJ2luc2VydFRva2VuOiBpbnZhbGlkIHRva2VuKHMpLicgfTtcblx0ICAgIH1cblx0fTtcblxuXHQvKipcblx0ICogQSBzdGF0ZSBtb2RpZmllciB0aGF0IGlzIGNhbGxlZCBvbiAnbmV3VG9rZW4nIGV2ZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RpZmllcklkIHN0YXRlIG1vZGlmaWVyIGlkXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBvciBmYWxzZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb2RpZmllciBhIGZ1bmN0aW9uIHRvIHVwZGF0ZSB0b2tlbiBzdGF0ZVxuXHQgKi9cblx0VG9rZW5pemVyLnByb3RvdHlwZS5yZWdpc3Rlck1vZGlmaWVyID0gZnVuY3Rpb24obW9kaWZpZXJJZCwgY29uZGl0aW9uLCBtb2RpZmllcikge1xuXHQgICAgdGhpcy5ldmVudHMubmV3VG9rZW4uc3Vic2NyaWJlKGZ1bmN0aW9uKHRva2VuLCBjb250ZXh0UGFyYW1zKSB7XG5cdCAgICAgICAgdmFyIGNvbmRpdGlvblBhcmFtcyA9IFt0b2tlbiwgY29udGV4dFBhcmFtc107XG5cdCAgICAgICAgdmFyIGNhbkFwcGx5TW9kaWZpZXIgPSAoXG5cdCAgICAgICAgICAgIGNvbmRpdGlvbiA9PT0gbnVsbCB8fFxuXHQgICAgICAgICAgICBjb25kaXRpb24uYXBwbHkodGhpcywgY29uZGl0aW9uUGFyYW1zKSA9PT0gdHJ1ZVxuXHQgICAgICAgICk7XG5cdCAgICAgICAgdmFyIG1vZGlmaWVyUGFyYW1zID0gW3Rva2VuLCBjb250ZXh0UGFyYW1zXTtcblx0ICAgICAgICBpZiAoY2FuQXBwbHlNb2RpZmllcikge1xuXHQgICAgICAgICAgICB2YXIgbmV3U3RhdGVWYWx1ZSA9IG1vZGlmaWVyLmFwcGx5KHRoaXMsIG1vZGlmaWVyUGFyYW1zKTtcblx0ICAgICAgICAgICAgdG9rZW4uc2V0U3RhdGUobW9kaWZpZXJJZCwgbmV3U3RhdGVWYWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICB0aGlzLnJlZ2lzdGVyZWRNb2RpZmllcnMucHVzaChtb2RpZmllcklkKTtcblx0fTtcblxuXHQvKipcblx0ICogU3Vic2NyaWJlIGEgaGFuZGxlciB0byBhbiBldmVudFxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBldmVudEhhbmRsZXIgYW4gZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuXHQgKi9cblx0RXZlbnQucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChldmVudEhhbmRsZXIpIHtcblx0ICAgIGlmICh0eXBlb2YgZXZlbnRIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuICgodGhpcy5zdWJzY3JpYmVycy5wdXNoKGV2ZW50SGFuZGxlcikpIC0gMSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiB7IEZBSUw6IChcImludmFsaWQgJ1wiICsgKHRoaXMuZXZlbnRJZCkgKyBcIicgZXZlbnQgaGFuZGxlclwiKX07XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFVuc3Vic2NyaWJlIGFuIGV2ZW50IGhhbmRsZXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN1YnNJZCBzdWJzY3JpcHRpb24gaWRcblx0ICovXG5cdEV2ZW50LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzSWQpIHtcblx0ICAgIHRoaXMuc3Vic2NyaWJlcnMuc3BsaWNlKHN1YnNJZCwgMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgY29udGV4dCBwYXJhbXMgY3VycmVudCB2YWx1ZSBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggY29udGV4dCBwYXJhbXMgY3VycmVudCB2YWx1ZSBpbmRleFxuXHQgKi9cblx0Q29udGV4dFBhcmFtcy5wcm90b3R5cGUuc2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcblx0ICAgIHRoaXMuaW5kZXggPSBpbmRleDtcblx0ICAgIHRoaXMuY3VycmVudCA9IHRoaXMuY29udGV4dFtpbmRleF07XG5cdCAgICB0aGlzLmJhY2t0cmFjayA9IHRoaXMuY29udGV4dC5zbGljZSgwLCBpbmRleCk7XG5cdCAgICB0aGlzLmxvb2thaGVhZCA9IHRoaXMuY29udGV4dC5zbGljZShpbmRleCArIDEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYW4gaXRlbSBhdCBhbiBvZmZzZXQgZnJvbSB0aGUgY3VycmVudCB2YWx1ZVxuXHQgKiBleGFtcGxlIChjdXJyZW50IHZhbHVlIGlzIDMpOlxuXHQgKiAgMSAgICAyICAgWzNdICAgNCAgICA1ICAgfCAgIGl0ZW1zIHZhbHVlc1xuXHQgKiAtMiAgIC0xICAgIDAgICAgMSAgICAyICAgfCAgIG9mZnNldCB2YWx1ZXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBhbiBvZmZzZXQgZnJvbSBjdXJyZW50IHZhbHVlIGluZGV4XG5cdCAqL1xuXHRDb250ZXh0UGFyYW1zLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG5cdCAgICBzd2l0Y2ggKHRydWUpIHtcblx0ICAgICAgICBjYXNlIChvZmZzZXQgPT09IDApOlxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuXHQgICAgICAgIGNhc2UgKG9mZnNldCA8IDAgJiYgTWF0aC5hYnMob2Zmc2V0KSA8PSB0aGlzLmJhY2t0cmFjay5sZW5ndGgpOlxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5iYWNrdHJhY2suc2xpY2Uob2Zmc2V0KVswXTtcblx0ICAgICAgICBjYXNlIChvZmZzZXQgPiAwICYmIG9mZnNldCA8PSB0aGlzLmxvb2thaGVhZC5sZW5ndGgpOlxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rYWhlYWRbb2Zmc2V0IC0gMV07XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgY29udGV4dCByYW5nZSBpbnRvIGEgc3RyaW5nIHZhbHVlXG5cdCAqIEBwYXJhbSB7Y29udGV4dFJhbmdlfSByYW5nZSBhIGNvbnRleHQgcmFuZ2Vcblx0ICovXG5cdFRva2VuaXplci5wcm90b3R5cGUucmFuZ2VUb1RleHQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcblx0ICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbnRleHRSYW5nZSkge1xuXHQgICAgICAgIHJldHVybiAoXG5cdCAgICAgICAgICAgIHRoaXMuZ2V0UmFuZ2VUb2tlbnMocmFuZ2UpXG5cdCAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uY2hhcjsgfSkuam9pbignJylcblx0ICAgICAgICApO1xuXHQgICAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhbGwgdG9rZW5zIGludG8gYSBzdHJpbmdcblx0ICovXG5cdFRva2VuaXplci5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLnRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5jaGFyOyB9KS5qb2luKCcnKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGEgY29udGV4dCBieSBuYW1lXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZSBjb250ZXh0IG5hbWUgdG8gZ2V0XG5cdCAqL1xuXHRUb2tlbml6ZXIucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dE5hbWUpIHtcblx0ICAgIHZhciBjb250ZXh0ID0gdGhpcy5yZWdpc3RlcmVkQ29udGV4dHNbY29udGV4dE5hbWVdO1xuXHQgICAgcmV0dXJuICEhY29udGV4dCA/IGNvbnRleHQgOiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdWJzY3JpYmVzIGEgbmV3IGV2ZW50IGhhbmRsZXIgdG8gYW4gZXZlbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBldmVudCBuYW1lIHRvIHN1YnNjcmliZSB0b1xuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBldmVudEhhbmRsZXIgYSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIG9uIGV2ZW50XG5cdCAqL1xuXHRUb2tlbml6ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcblx0ICAgIHZhciBldmVudCA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV07XG5cdCAgICBpZiAoISFldmVudCkge1xuXHQgICAgICAgIHJldHVybiBldmVudC5zdWJzY3JpYmUoZXZlbnRIYW5kbGVyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZXMgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBldmVudCBuYW1lXG5cdCAqIEBwYXJhbSB7YW55fSBhcmdzIGV2ZW50IGhhbmRsZXIgYXJndW1lbnRzXG5cdCAqL1xuXHRUb2tlbml6ZXIucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24oZXZlbnROYW1lLCBhcmdzKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgdmFyIGV2ZW50ID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXTtcblx0ICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEV2ZW50KSB7XG5cdCAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuXHQgICAgICAgICAgICBzdWJzY3JpYmVyLmFwcGx5KHRoaXMkMSwgYXJncyB8fCBbXSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGEgbmV3IGNvbnRleHQgY2hlY2tlclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgYSB1bmlxdWUgY29udGV4dCBuYW1lXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnRleHRTdGFydENoZWNrIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIG9uIGNvbnRleHQgc3RhcnRcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY29udGV4dEVuZENoZWNrICBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBvbiBjb250ZXh0IGVuZFxuXHQgKiBUT0RPOiBjYWxsIHRva2VuaXplIG9uIHJlZ2lzdHJhdGlvbiB0byB1cGRhdGUgY29udGV4dCByYW5nZXMgd2l0aCB0aGUgbmV3IGNvbnRleHQuXG5cdCAqL1xuXHRUb2tlbml6ZXIucHJvdG90eXBlLnJlZ2lzdGVyQ29udGV4dENoZWNrZXIgPSBmdW5jdGlvbihjb250ZXh0TmFtZSwgY29udGV4dFN0YXJ0Q2hlY2ssIGNvbnRleHRFbmRDaGVjaykge1xuXHQgICAgaWYgKCEhdGhpcy5nZXRDb250ZXh0KGNvbnRleHROYW1lKSkgeyByZXR1cm4ge1xuXHQgICAgICAgIEZBSUw6XG5cdCAgICAgICAgKFwiY29udGV4dCBuYW1lICdcIiArIGNvbnRleHROYW1lICsgXCInIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC5cIilcblx0ICAgIH07IH1cblx0ICAgIGlmICh0eXBlb2YgY29udGV4dFN0YXJ0Q2hlY2sgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIHtcblx0ICAgICAgICBGQUlMOlxuXHQgICAgICAgIFwibWlzc2luZyBjb250ZXh0IHN0YXJ0IGNoZWNrLlwiXG5cdCAgICB9OyB9XG5cdCAgICBpZiAodHlwZW9mIGNvbnRleHRFbmRDaGVjayAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4ge1xuXHQgICAgICAgIEZBSUw6XG5cdCAgICAgICAgXCJtaXNzaW5nIGNvbnRleHQgZW5kIGNoZWNrLlwiXG5cdCAgICB9OyB9XG5cdCAgICB2YXIgY29udGV4dENoZWNrZXJzID0gbmV3IENvbnRleHRDaGVja2VyKFxuXHQgICAgICAgIGNvbnRleHROYW1lLCBjb250ZXh0U3RhcnRDaGVjaywgY29udGV4dEVuZENoZWNrXG5cdCAgICApO1xuXHQgICAgdGhpcy5yZWdpc3RlcmVkQ29udGV4dHNbY29udGV4dE5hbWVdID0gY29udGV4dENoZWNrZXJzO1xuXHQgICAgdGhpcy5jb250ZXh0Q2hlY2tlcnMucHVzaChjb250ZXh0Q2hlY2tlcnMpO1xuXHQgICAgcmV0dXJuIGNvbnRleHRDaGVja2Vycztcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyBhIGNvbnRleHQgcmFuZ2UgdG9rZW5zXG5cdCAqIEBwYXJhbSB7Y29udGV4dFJhbmdlfSByYW5nZSBhIGNvbnRleHQgcmFuZ2Vcblx0ICovXG5cdFRva2VuaXplci5wcm90b3R5cGUuZ2V0UmFuZ2VUb2tlbnMgPSBmdW5jdGlvbihyYW5nZSkge1xuXHQgICAgdmFyIGVuZEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleCArIHJhbmdlLmVuZE9mZnNldDtcblx0ICAgIHJldHVybiBbXS5jb25jYXQoXG5cdCAgICAgICAgdGhpcy50b2tlbnNcblx0ICAgICAgICAgICAgLnNsaWNlKHJhbmdlLnN0YXJ0SW5kZXgsIGVuZEluZGV4KVxuXHQgICAgKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgcmFuZ2VzIG9mIGEgY29udGV4dFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWUgY29udGV4dCBuYW1lXG5cdCAqL1xuXHRUb2tlbml6ZXIucHJvdG90eXBlLmdldENvbnRleHRSYW5nZXMgPSBmdW5jdGlvbihjb250ZXh0TmFtZSkge1xuXHQgICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoY29udGV4dE5hbWUpO1xuXHQgICAgaWYgKCEhY29udGV4dCkge1xuXHQgICAgICAgIHJldHVybiBjb250ZXh0LnJhbmdlcztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHsgRkFJTDogKFwiY29udGV4dCBjaGVja2VyICdcIiArIGNvbnRleHROYW1lICsgXCInIGlzIG5vdCByZWdpc3RlcmVkLlwiKSB9O1xuXHQgICAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXNldHMgY29udGV4dCByYW5nZXMgdG8gcnVuIGNvbnRleHQgdXBkYXRlXG5cdCAqL1xuXHRUb2tlbml6ZXIucHJvdG90eXBlLnJlc2V0Q29udGV4dHNSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgcmVnaXN0ZXJlZENvbnRleHRzID0gdGhpcy5yZWdpc3RlcmVkQ29udGV4dHM7XG5cdCAgICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiByZWdpc3RlcmVkQ29udGV4dHMpIHtcblx0ICAgICAgICBpZiAocmVnaXN0ZXJlZENvbnRleHRzLmhhc093blByb3BlcnR5KGNvbnRleHROYW1lKSkge1xuXHQgICAgICAgICAgICB2YXIgY29udGV4dCA9IHJlZ2lzdGVyZWRDb250ZXh0c1tjb250ZXh0TmFtZV07XG5cdCAgICAgICAgICAgIGNvbnRleHQucmFuZ2VzID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIGNvbnRleHQgcmFuZ2VzXG5cdCAqL1xuXHRUb2tlbml6ZXIucHJvdG90eXBlLnVwZGF0ZUNvbnRleHRzUmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5yZXNldENvbnRleHRzUmFuZ2VzKCk7XG5cdCAgICB2YXIgY2hhcnMgPSB0aGlzLnRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5jaGFyOyB9KTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgY29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKGNoYXJzLCBpKTtcblx0ICAgICAgICB0aGlzLnJ1bkNvbnRleHRDaGVjayhjb250ZXh0UGFyYW1zKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuZGlzcGF0Y2goJ3VwZGF0ZUNvbnRleHRzUmFuZ2VzJywgW3RoaXMucmVnaXN0ZXJlZENvbnRleHRzXSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGVuZCBvZmZzZXQgb2YgYW4gb3BlbiByYW5nZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHJhbmdlIGVuZCBvZmZzZXRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lIGNvbnRleHQgbmFtZVxuXHQgKi9cblx0VG9rZW5pemVyLnByb3RvdHlwZS5zZXRFbmRPZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0LCBjb250ZXh0TmFtZSkge1xuXHQgICAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLmdldENvbnRleHQoY29udGV4dE5hbWUpLm9wZW5SYW5nZS5zdGFydEluZGV4O1xuXHQgICAgdmFyIHJhbmdlID0gbmV3IENvbnRleHRSYW5nZShzdGFydEluZGV4LCBvZmZzZXQsIGNvbnRleHROYW1lKTtcblx0ICAgIHZhciByYW5nZXMgPSB0aGlzLmdldENvbnRleHQoY29udGV4dE5hbWUpLnJhbmdlcztcblx0ICAgIHJhbmdlLnJhbmdlSWQgPSBjb250ZXh0TmFtZSArIFwiLlwiICsgKHJhbmdlcy5sZW5ndGgpO1xuXHQgICAgcmFuZ2VzLnB1c2gocmFuZ2UpO1xuXHQgICAgdGhpcy5nZXRDb250ZXh0KGNvbnRleHROYW1lKS5vcGVuUmFuZ2UgPSBudWxsO1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSdW5zIGEgY29udGV4dCBjaGVjayBvbiB0aGUgY3VycmVudCBjb250ZXh0XG5cdCAqIEBwYXJhbSB7Y29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjdXJyZW50IGNvbnRleHQgcGFyYW1zXG5cdCAqL1xuXHRUb2tlbml6ZXIucHJvdG90eXBlLnJ1bkNvbnRleHRDaGVjayA9IGZ1bmN0aW9uKGNvbnRleHRQYXJhbXMpIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICB2YXIgaW5kZXggPSBjb250ZXh0UGFyYW1zLmluZGV4O1xuXHQgICAgdGhpcy5jb250ZXh0Q2hlY2tlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29udGV4dENoZWNrZXIpIHtcblx0ICAgICAgICB2YXIgY29udGV4dE5hbWUgPSBjb250ZXh0Q2hlY2tlci5jb250ZXh0TmFtZTtcblx0ICAgICAgICB2YXIgb3BlblJhbmdlID0gdGhpcyQxLmdldENvbnRleHQoY29udGV4dE5hbWUpLm9wZW5SYW5nZTtcblx0ICAgICAgICBpZiAoIW9wZW5SYW5nZSAmJiBjb250ZXh0Q2hlY2tlci5jaGVja1N0YXJ0KGNvbnRleHRQYXJhbXMpKSB7XG5cdCAgICAgICAgICAgIG9wZW5SYW5nZSA9IG5ldyBDb250ZXh0UmFuZ2UoaW5kZXgsIG51bGwsIGNvbnRleHROYW1lKTtcblx0ICAgICAgICAgICAgdGhpcyQxLmdldENvbnRleHQoY29udGV4dE5hbWUpLm9wZW5SYW5nZSA9IG9wZW5SYW5nZTtcblx0ICAgICAgICAgICAgdGhpcyQxLmRpc3BhdGNoKCdjb250ZXh0U3RhcnQnLCBbY29udGV4dE5hbWUsIGluZGV4XSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghIW9wZW5SYW5nZSAmJiBjb250ZXh0Q2hlY2tlci5jaGVja0VuZChjb250ZXh0UGFyYW1zKSkge1xuXHQgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gKGluZGV4IC0gb3BlblJhbmdlLnN0YXJ0SW5kZXgpICsgMTtcblx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcyQxLnNldEVuZE9mZnNldChvZmZzZXQsIGNvbnRleHROYW1lKTtcblx0ICAgICAgICAgICAgdGhpcyQxLmRpc3BhdGNoKCdjb250ZXh0RW5kJywgW2NvbnRleHROYW1lLCByYW5nZV0pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHRleHQgaW50byBhIGxpc3Qgb2YgdG9rZW5zXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IGEgdGV4dCB0byB0b2tlbml6ZVxuXHQgKi9cblx0VG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG5cdCAgICB0aGlzLnRva2VucyA9IFtdO1xuXHQgICAgdGhpcy5yZXNldENvbnRleHRzUmFuZ2VzKCk7XG5cdCAgICB2YXIgY2hhcnMgPSBBcnJheS5mcm9tKHRleHQpO1xuXHQgICAgdGhpcy5kaXNwYXRjaCgnc3RhcnQnKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgY2hhciA9IGNoYXJzW2ldO1xuXHQgICAgICAgIHZhciBjb250ZXh0UGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMoY2hhcnMsIGkpO1xuXHQgICAgICAgIHRoaXMuZGlzcGF0Y2goJ25leHQnLCBbY29udGV4dFBhcmFtc10pO1xuXHQgICAgICAgIHRoaXMucnVuQ29udGV4dENoZWNrKGNvbnRleHRQYXJhbXMpO1xuXHQgICAgICAgIHZhciB0b2tlbiA9IG5ldyBUb2tlbihjaGFyKTtcblx0ICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcblx0ICAgICAgICB0aGlzLmRpc3BhdGNoKCduZXdUb2tlbicsIFt0b2tlbiwgY29udGV4dFBhcmFtc10pO1xuXHQgICAgfVxuXHQgICAgdGhpcy5kaXNwYXRjaCgnZW5kJywgW3RoaXMudG9rZW5zXSk7XG5cdCAgICByZXR1cm4gdGhpcy50b2tlbnM7XG5cdH07XG5cblx0Ly8g4pWt4pSA4pSE4pSE4pSE4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSE4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pWuXG5cdC8vIOKUiiBDaGFyYWN0ZXIgQ2xhc3MgQXNzZXJ0aW9ucyDilIogQ2hlY2tzIGlmIGEgY2hhciBiZWxvbmdzIHRvIGEgY2VydGFpbiBjbGFzcyDilIpcblx0Ly8g4pWw4pSA4pW+4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSE4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pWvXG5cdC8vIGpzY3M6ZGlzYWJsZSBtYXhpbXVtTGluZUxlbmd0aFxuXHQvKipcblx0ICogQ2hlY2sgaWYgYSBjaGFyIGlzIEFyYWJpY1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gYyBhIHNpbmdsZSBjaGFyXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0FyYWJpY0NoYXIoYykge1xuXHQgICAgcmV0dXJuIC9bXFx1MDYwMC1cXHUwNjVGXFx1MDY2QS1cXHUwNkQyXFx1MDZGQS1cXHUwNkZGXS8udGVzdChjKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhIGNoYXIgaXMgYW4gaXNvbGF0ZWQgYXJhYmljIGNoYXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGMgYSBzaW5nbGUgY2hhclxuXHQgKi9cblx0ZnVuY3Rpb24gaXNJc29sYXRlZEFyYWJpY0NoYXIoY2hhcikge1xuXHQgICAgcmV0dXJuIC9bXFx1MDYzMFxcdTA2OTBcXHUwNjIxXFx1MDYzMVxcdTA2NjFcXHUwNjcxXFx1MDYyMlxcdTA2MzJcXHUwNjcyXFx1MDY5MlxcdTA2QzJcXHUwNjIzXFx1MDY3M1xcdTA2OTNcXHUwNkMzXFx1MDYyNFxcdTA2OTRcXHUwNkM0XFx1MDYyNVxcdTA2NzVcXHUwNjk1XFx1MDZDNVxcdTA2RTVcXHUwNjc2XFx1MDY5NlxcdTA2QzZcXHUwNjI3XFx1MDY3N1xcdTA2OTdcXHUwNkM3XFx1MDY0OFxcdTA2ODhcXHUwNjk4XFx1MDZDOFxcdTA2ODlcXHUwNjk5XFx1MDZDOVxcdTA2OEFcXHUwNkNBXFx1MDY2QlxcdTA2OEJcXHUwNkNCXFx1MDY4Q1xcdTA2OERcXHUwNkNEXFx1MDZGRFxcdTA2OEVcXHUwNkVFXFx1MDZGRVxcdTA2MkZcXHUwNjhGXFx1MDZDRlxcdTA2RUZdLy50ZXN0KGNoYXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGEgY2hhciBpcyBhbiBBcmFiaWMgVGFzaGtlZWwgY2hhclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYyBhIHNpbmdsZSBjaGFyXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1Rhc2hrZWVsQXJhYmljQ2hhcihjaGFyKSB7XG5cdCAgICByZXR1cm4gL1tcXHUwNjAwLVxcdTA2MDVcXHUwNjBDLVxcdTA2MEVcXHUwNjEwLVxcdTA2MUJcXHUwNjFFXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXS8udGVzdChjaGFyKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhIGNoYXIgaXMgTGF0aW5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGMgYSBzaW5nbGUgY2hhclxuXHQgKi9cblx0ZnVuY3Rpb24gaXNMYXRpbkNoYXIoYykge1xuXHQgICAgcmV0dXJuIC9bQS16XS8udGVzdChjKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhIGNoYXIgaXMgd2hpdGVzcGFjZSBjaGFyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjIGEgc2luZ2xlIGNoYXJcblx0ICovXG5cdGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjKSB7XG5cdCAgICByZXR1cm4gL1xccy8udGVzdChjKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBRdWVyeSBhIGZlYXR1cmUgYnkgc29tZSBvZiBpdCdzIHByb3BlcnRpZXMgdG8gbG9va3VwIGEgZ2x5cGggc3Vic3RpdHV0aW9uLlxuXHQgKi9cblxuXHQvKipcblx0ICogQ3JlYXRlIGZlYXR1cmUgcXVlcnkgaW5zdGFuY2Vcblx0ICogQHBhcmFtIHtGb250fSBmb250IG9wZW50eXBlIGZvbnQgaW5zdGFuY2Vcblx0ICovXG5cdGZ1bmN0aW9uIEZlYXR1cmVRdWVyeShmb250KSB7XG5cdCAgICB0aGlzLmZvbnQgPSBmb250O1xuXHQgICAgdGhpcy5mZWF0dXJlcyA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlZGVmIFN1YnN0aXR1dGlvbkFjdGlvblxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IGlkIHN1YnN0aXR1dGlvbiB0eXBlXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YWcgZmVhdHVyZSB0YWdcblx0ICogQHByb3BlcnR5IHthbnl9IHN1YnN0aXR1dGlvbiBzdWJzdGl0dXRpb24gdmFsdWUocylcblx0ICovXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIHN1YnN0aXR1dGlvbiBhY3Rpb24gaW5zdGFuY2Vcblx0ICogQHBhcmFtIHtTdWJzdGl0dXRpb25BY3Rpb259IGFjdGlvblxuXHQgKi9cblx0ZnVuY3Rpb24gU3Vic3RpdHV0aW9uQWN0aW9uKGFjdGlvbikge1xuXHQgICAgdGhpcy5pZCA9IGFjdGlvbi5pZDtcblx0ICAgIHRoaXMudGFnID0gYWN0aW9uLnRhZztcblx0ICAgIHRoaXMuc3Vic3RpdHV0aW9uID0gYWN0aW9uLnN1YnN0aXR1dGlvbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBMb29rdXAgYSBjb3ZlcmFnZSB0YWJsZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhJbmRleCBnbHlwaCBpbmRleFxuXHQgKiBAcGFyYW0ge0NvdmVyYWdlVGFibGV9IGNvdmVyYWdlIGNvdmVyYWdlIHRhYmxlXG5cdCAqL1xuXHRmdW5jdGlvbiBsb29rdXBDb3ZlcmFnZShnbHlwaEluZGV4LCBjb3ZlcmFnZSkge1xuXHQgICAgaWYgKCFnbHlwaEluZGV4KSB7IHJldHVybiAtMTsgfVxuXHQgICAgc3dpdGNoIChjb3ZlcmFnZS5mb3JtYXQpIHtcblx0ICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgIHJldHVybiBjb3ZlcmFnZS5nbHlwaHMuaW5kZXhPZihnbHlwaEluZGV4KTtcblxuXHQgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgdmFyIHJhbmdlcyA9IGNvdmVyYWdlLnJhbmdlcztcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChnbHlwaEluZGV4ID49IHJhbmdlLnN0YXJ0ICYmIGdseXBoSW5kZXggPD0gcmFuZ2UuZW5kKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGdseXBoSW5kZXggLSByYW5nZS5zdGFydDtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UuaW5kZXggKyBvZmZzZXQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgcmV0dXJuIC0xOyAvLyBub3QgZm91bmRcblx0ICAgIH1cblx0ICAgIHJldHVybiAtMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYSBzaW5nbGUgc3Vic3RpdHV0aW9uIC0gZm9ybWF0IDFcblx0ICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIHRvIGxvb2t1cFxuXHQgKi9cblx0ZnVuY3Rpb24gc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MShnbHlwaEluZGV4LCBzdWJ0YWJsZSkge1xuXHQgICAgdmFyIHN1YnN0aXR1dGVJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIHN1YnRhYmxlLmNvdmVyYWdlKTtcblx0ICAgIGlmIChzdWJzdGl0dXRlSW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG5cdCAgICByZXR1cm4gZ2x5cGhJbmRleCArIHN1YnRhYmxlLmRlbHRhR2x5cGhJZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYSBzaW5nbGUgc3Vic3RpdHV0aW9uIC0gZm9ybWF0IDJcblx0ICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIHRvIGxvb2t1cFxuXHQgKi9cblx0ZnVuY3Rpb24gc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MihnbHlwaEluZGV4LCBzdWJ0YWJsZSkge1xuXHQgICAgdmFyIHN1YnN0aXR1dGVJbmRleCA9IGxvb2t1cENvdmVyYWdlKGdseXBoSW5kZXgsIHN1YnRhYmxlLmNvdmVyYWdlKTtcblx0ICAgIGlmIChzdWJzdGl0dXRlSW5kZXggPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG5cdCAgICByZXR1cm4gc3VidGFibGUuc3Vic3RpdHV0ZVtzdWJzdGl0dXRlSW5kZXhdO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvb2t1cCBhIGxpc3Qgb2YgY292ZXJhZ2UgdGFibGVzXG5cdCAqIEBwYXJhbSB7YW55fSBjb3ZlcmFnZUxpc3QgYSBsaXN0IG9mIGNvdmVyYWdlIHRhYmxlc1xuXHQgKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNvbnRleHRQYXJhbXMgY29udGV4dCBwYXJhbXMgdG8gbG9va3VwXG5cdCAqL1xuXHRmdW5jdGlvbiBsb29rdXBDb3ZlcmFnZUxpc3QoY292ZXJhZ2VMaXN0LCBjb250ZXh0UGFyYW1zKSB7XG5cdCAgICB2YXIgbG9va3VwTGlzdCA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3ZlcmFnZUxpc3QubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgY292ZXJhZ2UgPSBjb3ZlcmFnZUxpc3RbaV07XG5cdCAgICAgICAgdmFyIGdseXBoSW5kZXggPSBjb250ZXh0UGFyYW1zLmN1cnJlbnQ7XG5cdCAgICAgICAgZ2x5cGhJbmRleCA9IEFycmF5LmlzQXJyYXkoZ2x5cGhJbmRleCkgPyBnbHlwaEluZGV4WzBdIDogZ2x5cGhJbmRleDtcblx0ICAgICAgICB2YXIgbG9va3VwSW5kZXggPSBsb29rdXBDb3ZlcmFnZShnbHlwaEluZGV4LCBjb3ZlcmFnZSk7XG5cdCAgICAgICAgaWYgKGxvb2t1cEluZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICBsb29rdXBMaXN0LnB1c2gobG9va3VwSW5kZXgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChsb29rdXBMaXN0Lmxlbmd0aCAhPT0gY292ZXJhZ2VMaXN0Lmxlbmd0aCkgeyByZXR1cm4gLTE7IH1cblx0ICAgIHJldHVybiBsb29rdXBMaXN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBjaGFpbmluZyBjb250ZXh0IHN1YnN0aXR1dGlvbiAtIGZvcm1hdCAzXG5cdCAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtcyB0byBsb29rdXBcblx0ICovXG5cdGZ1bmN0aW9uIGNoYWluaW5nU3Vic3RpdHV0aW9uRm9ybWF0Myhjb250ZXh0UGFyYW1zLCBzdWJ0YWJsZSkge1xuXHQgICAgdmFyIGxvb2t1cHNDb3VudCA9IChcblx0ICAgICAgICBzdWJ0YWJsZS5pbnB1dENvdmVyYWdlLmxlbmd0aCArXG5cdCAgICAgICAgc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UubGVuZ3RoICtcblx0ICAgICAgICBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZS5sZW5ndGhcblx0ICAgICk7XG5cdCAgICBpZiAoY29udGV4dFBhcmFtcy5jb250ZXh0Lmxlbmd0aCA8IGxvb2t1cHNDb3VudCkgeyByZXR1cm4gW107IH1cblx0ICAgIC8vIElOUFVUIExPT0tVUCAvL1xuXHQgICAgdmFyIGlucHV0TG9va3VwcyA9IGxvb2t1cENvdmVyYWdlTGlzdChcblx0ICAgICAgICBzdWJ0YWJsZS5pbnB1dENvdmVyYWdlLCBjb250ZXh0UGFyYW1zXG5cdCAgICApO1xuXHQgICAgaWYgKGlucHV0TG9va3VwcyA9PT0gLTEpIHsgcmV0dXJuIFtdOyB9XG5cdCAgICAvLyBMT09LQUhFQUQgTE9PS1VQIC8vXG5cdCAgICB2YXIgbG9va2FoZWFkT2Zmc2V0ID0gc3VidGFibGUuaW5wdXRDb3ZlcmFnZS5sZW5ndGggLSAxO1xuXHQgICAgaWYgKGNvbnRleHRQYXJhbXMubG9va2FoZWFkLmxlbmd0aCA8IHN1YnRhYmxlLmxvb2thaGVhZENvdmVyYWdlLmxlbmd0aCkgeyByZXR1cm4gW107IH1cblx0ICAgIHZhciBsb29rYWhlYWRDb250ZXh0ID0gY29udGV4dFBhcmFtcy5sb29rYWhlYWQuc2xpY2UobG9va2FoZWFkT2Zmc2V0KTtcblx0ICAgIHdoaWxlIChsb29rYWhlYWRDb250ZXh0Lmxlbmd0aCAmJiBpc1Rhc2hrZWVsQXJhYmljQ2hhcihsb29rYWhlYWRDb250ZXh0WzBdLmNoYXIpKSB7XG5cdCAgICAgICAgbG9va2FoZWFkQ29udGV4dC5zaGlmdCgpO1xuXHQgICAgfVxuXHQgICAgdmFyIGxvb2thaGVhZFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKGxvb2thaGVhZENvbnRleHQsIDApO1xuXHQgICAgdmFyIGxvb2thaGVhZExvb2t1cHMgPSBsb29rdXBDb3ZlcmFnZUxpc3QoXG5cdCAgICAgICAgc3VidGFibGUubG9va2FoZWFkQ292ZXJhZ2UsIGxvb2thaGVhZFBhcmFtc1xuXHQgICAgKTtcblx0ICAgIC8vIEJBQ0tUUkFDSyBMT09LVVAgLy9cblx0ICAgIHZhciBiYWNrdHJhY2tDb250ZXh0ID0gW10uY29uY2F0KGNvbnRleHRQYXJhbXMuYmFja3RyYWNrKTtcblx0ICAgIGJhY2t0cmFja0NvbnRleHQucmV2ZXJzZSgpO1xuXHQgICAgd2hpbGUgKGJhY2t0cmFja0NvbnRleHQubGVuZ3RoICYmIGlzVGFzaGtlZWxBcmFiaWNDaGFyKGJhY2t0cmFja0NvbnRleHRbMF0uY2hhcikpIHtcblx0ICAgICAgICBiYWNrdHJhY2tDb250ZXh0LnNoaWZ0KCk7XG5cdCAgICB9XG5cdCAgICBpZiAoYmFja3RyYWNrQ29udGV4dC5sZW5ndGggPCBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZS5sZW5ndGgpIHsgcmV0dXJuIFtdOyB9XG5cdCAgICB2YXIgYmFja3RyYWNrUGFyYW1zID0gbmV3IENvbnRleHRQYXJhbXMoYmFja3RyYWNrQ29udGV4dCwgMCk7XG5cdCAgICB2YXIgYmFja3RyYWNrTG9va3VwcyA9IGxvb2t1cENvdmVyYWdlTGlzdChcblx0ICAgICAgICBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZSwgYmFja3RyYWNrUGFyYW1zXG5cdCAgICApO1xuXHQgICAgdmFyIGNvbnRleHRSdWxlc01hdGNoID0gKFxuXHQgICAgICAgIGlucHV0TG9va3Vwcy5sZW5ndGggPT09IHN1YnRhYmxlLmlucHV0Q292ZXJhZ2UubGVuZ3RoICYmXG5cdCAgICAgICAgbG9va2FoZWFkTG9va3Vwcy5sZW5ndGggPT09IHN1YnRhYmxlLmxvb2thaGVhZENvdmVyYWdlLmxlbmd0aCAmJlxuXHQgICAgICAgIGJhY2t0cmFja0xvb2t1cHMubGVuZ3RoID09PSBzdWJ0YWJsZS5iYWNrdHJhY2tDb3ZlcmFnZS5sZW5ndGhcblx0ICAgICk7XG5cdCAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IFtdO1xuXHQgICAgaWYgKGNvbnRleHRSdWxlc01hdGNoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZS5sb29rdXBSZWNvcmRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBsb29rdXBSZWNvcmQgPSBzdWJ0YWJsZS5sb29rdXBSZWNvcmRzW2ldO1xuXHQgICAgICAgICAgICB2YXIgbG9va3VwTGlzdEluZGV4ID0gbG9va3VwUmVjb3JkLmxvb2t1cExpc3RJbmRleDtcblx0ICAgICAgICAgICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBCeUluZGV4KGxvb2t1cExpc3RJbmRleCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgbG9va3VwVGFibGUuc3VidGFibGVzLmxlbmd0aDsgcysrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3VidGFibGUkMSA9IGxvb2t1cFRhYmxlLnN1YnRhYmxlc1tzXTtcblx0ICAgICAgICAgICAgICAgIHZhciBsb29rdXAgPSB0aGlzLmdldExvb2t1cE1ldGhvZChsb29rdXBUYWJsZSwgc3VidGFibGUkMSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3Vic3RpdHV0aW9uVHlwZSA9IHRoaXMuZ2V0U3Vic3RpdHV0aW9uVHlwZShsb29rdXBUYWJsZSwgc3VidGFibGUkMSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uVHlwZSA9PT0gJzEyJykge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgaW5wdXRMb29rdXBzLmxlbmd0aDsgbisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnbHlwaEluZGV4ID0gY29udGV4dFBhcmFtcy5nZXQobik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRpb24gPSBsb29rdXAoZ2x5cGhJbmRleCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb24pIHsgc3Vic3RpdHV0aW9ucy5wdXNoKHN1YnN0aXR1dGlvbik7IH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc3Vic3RpdHV0aW9ucztcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgbGlnYXR1cmUgc3Vic3RpdHV0aW9uIC0gZm9ybWF0IDFcblx0ICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIHRvIGxvb2t1cFxuXHQgKi9cblx0ZnVuY3Rpb24gbGlnYXR1cmVTdWJzdGl0dXRpb25Gb3JtYXQxKGNvbnRleHRQYXJhbXMsIHN1YnRhYmxlKSB7XG5cdCAgICAvLyBDT1ZFUkFHRSBMT09LVVAgLy9cblx0ICAgIHZhciBnbHlwaEluZGV4ID0gY29udGV4dFBhcmFtcy5jdXJyZW50O1xuXHQgICAgdmFyIGxpZ1NldEluZGV4ID0gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgc3VidGFibGUuY292ZXJhZ2UpO1xuXHQgICAgaWYgKGxpZ1NldEluZGV4ID09PSAtMSkgeyByZXR1cm4gbnVsbDsgfVxuXHQgICAgLy8gQ09NUE9ORU5UUyBMT09LVVBcblx0ICAgIC8vICghKSBub3RlLCBjb21wb25lbnRzIGFyZSBvcmRlcmVkIGluIHRoZSB3cml0dGVuIGRpcmVjdGlvbi5cblx0ICAgIHZhciBsaWdhdHVyZTtcblx0ICAgIHZhciBsaWdhdHVyZVNldCA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0c1tsaWdTZXRJbmRleF07XG5cdCAgICBmb3IgKHZhciBzID0gMDsgcyA8IGxpZ2F0dXJlU2V0Lmxlbmd0aDsgcysrKSB7XG5cdCAgICAgICAgbGlnYXR1cmUgPSBsaWdhdHVyZVNldFtzXTtcblx0ICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpZ2F0dXJlLmNvbXBvbmVudHMubGVuZ3RoOyBsKyspIHtcblx0ICAgICAgICAgICAgdmFyIGxvb2thaGVhZEl0ZW0gPSBjb250ZXh0UGFyYW1zLmxvb2thaGVhZFtsXTtcblx0ICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGxpZ2F0dXJlLmNvbXBvbmVudHNbbF07XG5cdCAgICAgICAgICAgIGlmIChsb29rYWhlYWRJdGVtICE9PSBjb21wb25lbnQpIHsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgaWYgKGwgPT09IGxpZ2F0dXJlLmNvbXBvbmVudHMubGVuZ3RoIC0gMSkgeyByZXR1cm4gbGlnYXR1cmU7IH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgZGVjb21wb3NpdGlvbiBzdWJzdGl0dXRpb24gLSBmb3JtYXQgMVxuXHQgKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhJbmRleCBnbHlwaCBpbmRleFxuXHQgKiBAcGFyYW0ge2FueX0gc3VidGFibGUgc3VidGFibGVcblx0ICovXG5cdGZ1bmN0aW9uIGRlY29tcG9zaXRpb25TdWJzdGl0dXRpb25Gb3JtYXQxKGdseXBoSW5kZXgsIHN1YnRhYmxlKSB7XG5cdCAgICB2YXIgc3Vic3RpdHV0ZUluZGV4ID0gbG9va3VwQ292ZXJhZ2UoZ2x5cGhJbmRleCwgc3VidGFibGUuY292ZXJhZ2UpO1xuXHQgICAgaWYgKHN1YnN0aXR1dGVJbmRleCA9PT0gLTEpIHsgcmV0dXJuIG51bGw7IH1cblx0ICAgIHJldHVybiBzdWJ0YWJsZS5zZXF1ZW5jZXNbc3Vic3RpdHV0ZUluZGV4XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgZGVmYXVsdCBzY3JpcHQgZmVhdHVyZXMgaW5kZXhlc1xuXHQgKi9cblx0RmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXREZWZhdWx0U2NyaXB0RmVhdHVyZXNJbmRleGVzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHNjcmlwdHMgPSB0aGlzLmZvbnQudGFibGVzLmdzdWIuc2NyaXB0cztcblx0ICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc2NyaXB0cy5sZW5ndGg7IHMrKykge1xuXHQgICAgICAgIHZhciBzY3JpcHQgPSBzY3JpcHRzW3NdO1xuXHQgICAgICAgIGlmIChzY3JpcHQudGFnID09PSAnREZMVCcpIHsgcmV0dXJuIChcblx0ICAgICAgICAgICAgc2NyaXB0LnNjcmlwdC5kZWZhdWx0TGFuZ1N5cy5mZWF0dXJlSW5kZXhlc1xuXHQgICAgICAgICk7IH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBbXTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGZlYXR1cmUgaW5kZXhlcyBvZiBhIHNwZWNpZmljIHNjcmlwdFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0VGFnIHNjcmlwdCB0YWdcblx0ICovXG5cdEZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0U2NyaXB0RmVhdHVyZXNJbmRleGVzID0gZnVuY3Rpb24oc2NyaXB0VGFnKSB7XG5cdCAgICB2YXIgdGFibGVzID0gdGhpcy5mb250LnRhYmxlcztcblx0ICAgIGlmICghdGFibGVzLmdzdWIpIHsgcmV0dXJuIFtdOyB9XG5cdCAgICBpZiAoIXNjcmlwdFRhZykgeyByZXR1cm4gdGhpcy5nZXREZWZhdWx0U2NyaXB0RmVhdHVyZXNJbmRleGVzKCk7IH1cblx0ICAgIHZhciBzY3JpcHRzID0gdGhpcy5mb250LnRhYmxlcy5nc3ViLnNjcmlwdHM7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgc2NyaXB0ID0gc2NyaXB0c1tpXTtcblx0ICAgICAgICBpZiAoc2NyaXB0LnRhZyA9PT0gc2NyaXB0VGFnICYmIHNjcmlwdC5zY3JpcHQuZGVmYXVsdExhbmdTeXMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNjcmlwdC5zY3JpcHQuZGVmYXVsdExhbmdTeXMuZmVhdHVyZUluZGV4ZXM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGxhbmdTeXNSZWNvcmRzID0gc2NyaXB0LmxhbmdTeXNSZWNvcmRzO1xuXHQgICAgICAgICAgICBpZiAoISFsYW5nU3lzUmVjb3Jkcykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsYW5nU3lzUmVjb3Jkcy5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsYW5nU3lzUmVjb3JkID0gbGFuZ1N5c1JlY29yZHNbal07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdTeXNSZWNvcmQudGFnID09PSBzY3JpcHRUYWcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmdTeXMgPSBsYW5nU3lzUmVjb3JkLmxhbmdTeXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsYW5nU3lzLmZlYXR1cmVJbmRleGVzO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRTY3JpcHRGZWF0dXJlc0luZGV4ZXMoKTtcblx0fTtcblxuXHQvKipcblx0ICogTWFwIGEgZmVhdHVyZSB0YWcgdG8gYSBnc3ViIGZlYXR1cmVcblx0ICogQHBhcmFtIHthbnl9IGZlYXR1cmVzIGdzdWIgZmVhdHVyZXNcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdFRhZyBzY3JpcHQgdGFnXG5cdCAqL1xuXHRGZWF0dXJlUXVlcnkucHJvdG90eXBlLm1hcFRhZ3NUb0ZlYXR1cmVzID0gZnVuY3Rpb24gKGZlYXR1cmVzLCBzY3JpcHRUYWcpIHtcblx0ICAgIHZhciB0YWdzID0ge307XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHRhZyA9IGZlYXR1cmVzW2ldLnRhZztcblx0ICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldLmZlYXR1cmU7XG5cdCAgICAgICAgdGFnc1t0YWddID0gZmVhdHVyZTtcblx0ICAgIH1cblx0ICAgIHRoaXMuZmVhdHVyZXNbc2NyaXB0VGFnXS50YWdzID0gdGFncztcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGZlYXR1cmVzIG9mIGEgc3BlY2lmaWMgc2NyaXB0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHRUYWcgc2NyaXB0IHRhZ1xuXHQgKi9cblx0RmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5nZXRTY3JpcHRGZWF0dXJlcyA9IGZ1bmN0aW9uIChzY3JpcHRUYWcpIHtcblx0ICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXNbc2NyaXB0VGFnXTtcblx0ICAgIGlmICh0aGlzLmZlYXR1cmVzLmhhc093blByb3BlcnR5KHNjcmlwdFRhZykpIHsgcmV0dXJuIGZlYXR1cmVzOyB9XG5cdCAgICB2YXIgZmVhdHVyZXNJbmRleGVzID0gdGhpcy5nZXRTY3JpcHRGZWF0dXJlc0luZGV4ZXMoc2NyaXB0VGFnKTtcblx0ICAgIGlmICghZmVhdHVyZXNJbmRleGVzKSB7IHJldHVybiBudWxsOyB9XG5cdCAgICB2YXIgZ3N1YiA9IHRoaXMuZm9udC50YWJsZXMuZ3N1Yjtcblx0ICAgIGZlYXR1cmVzID0gZmVhdHVyZXNJbmRleGVzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGdzdWIuZmVhdHVyZXNbaW5kZXhdOyB9KTtcblx0ICAgIHRoaXMuZmVhdHVyZXNbc2NyaXB0VGFnXSA9IGZlYXR1cmVzO1xuXHQgICAgdGhpcy5tYXBUYWdzVG9GZWF0dXJlcyhmZWF0dXJlcywgc2NyaXB0VGFnKTtcblx0ICAgIHJldHVybiBmZWF0dXJlcztcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHN1YnN0aXR1dGlvbiB0eXBlXG5cdCAqIEBwYXJhbSB7YW55fSBsb29rdXBUYWJsZSBsb29rdXAgdGFibGVcblx0ICogQHBhcmFtIHthbnl9IHN1YnRhYmxlIHN1YnRhYmxlXG5cdCAqL1xuXHRGZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldFN1YnN0aXR1dGlvblR5cGUgPSBmdW5jdGlvbihsb29rdXBUYWJsZSwgc3VidGFibGUpIHtcblx0ICAgIHZhciBsb29rdXBUeXBlID0gbG9va3VwVGFibGUubG9va3VwVHlwZS50b1N0cmluZygpO1xuXHQgICAgdmFyIHN1YnN0Rm9ybWF0ID0gc3VidGFibGUuc3Vic3RGb3JtYXQudG9TdHJpbmcoKTtcblx0ICAgIHJldHVybiBsb29rdXBUeXBlICsgc3Vic3RGb3JtYXQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBsb29rdXAgbWV0aG9kXG5cdCAqIEBwYXJhbSB7YW55fSBsb29rdXBUYWJsZSBsb29rdXAgdGFibGVcblx0ICogQHBhcmFtIHthbnl9IHN1YnRhYmxlIHN1YnRhYmxlXG5cdCAqL1xuXHRGZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldExvb2t1cE1ldGhvZCA9IGZ1bmN0aW9uKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIHZhciBzdWJzdGl0dXRpb25UeXBlID0gdGhpcy5nZXRTdWJzdGl0dXRpb25UeXBlKGxvb2t1cFRhYmxlLCBzdWJ0YWJsZSk7XG5cdCAgICBzd2l0Y2ggKHN1YnN0aXR1dGlvblR5cGUpIHtcblx0ICAgICAgICBjYXNlICcxMSc6XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ2x5cGhJbmRleCkgeyByZXR1cm4gc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MS5hcHBseShcblx0ICAgICAgICAgICAgICAgIHRoaXMkMSwgW2dseXBoSW5kZXgsIHN1YnRhYmxlXVxuXHQgICAgICAgICAgICApOyB9O1xuXHQgICAgICAgIGNhc2UgJzEyJzpcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbHlwaEluZGV4KSB7IHJldHVybiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQyLmFwcGx5KFxuXHQgICAgICAgICAgICAgICAgdGhpcyQxLCBbZ2x5cGhJbmRleCwgc3VidGFibGVdXG5cdCAgICAgICAgICAgICk7IH07XG5cdCAgICAgICAgY2FzZSAnNjMnOlxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHRQYXJhbXMpIHsgcmV0dXJuIGNoYWluaW5nU3Vic3RpdHV0aW9uRm9ybWF0My5hcHBseShcblx0ICAgICAgICAgICAgICAgIHRoaXMkMSwgW2NvbnRleHRQYXJhbXMsIHN1YnRhYmxlXVxuXHQgICAgICAgICAgICApOyB9O1xuXHQgICAgICAgIGNhc2UgJzQxJzpcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0UGFyYW1zKSB7IHJldHVybiBsaWdhdHVyZVN1YnN0aXR1dGlvbkZvcm1hdDEuYXBwbHkoXG5cdCAgICAgICAgICAgICAgICB0aGlzJDEsIFtjb250ZXh0UGFyYW1zLCBzdWJ0YWJsZV1cblx0ICAgICAgICAgICAgKTsgfTtcblx0ICAgICAgICBjYXNlICcyMSc6XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ2x5cGhJbmRleCkgeyByZXR1cm4gZGVjb21wb3NpdGlvblN1YnN0aXR1dGlvbkZvcm1hdDEuYXBwbHkoXG5cdCAgICAgICAgICAgICAgICB0aGlzJDEsIFtnbHlwaEluZGV4LCBzdWJ0YWJsZV1cblx0ICAgICAgICAgICAgKTsgfTtcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG5cdCAgICAgICAgICAgICAgICBcImxvb2t1cFR5cGU6IFwiICsgKGxvb2t1cFRhYmxlLmxvb2t1cFR5cGUpICsgXCIgLSBcIiArXG5cdCAgICAgICAgICAgICAgICBcInN1YnN0Rm9ybWF0OiBcIiArIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCkgKyBcIiBcIiArXG5cdCAgICAgICAgICAgICAgICBcImlzIG5vdCB5ZXQgc3VwcG9ydGVkXCJcblx0ICAgICAgICAgICAgKTtcblx0ICAgIH1cblx0fTtcblxuXHQvKipcblx0ICogWyBMT09LVVAgVFlQRVMgXVxuXHQgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAqIFNpbmdsZSAgICAgICAgICAgICAgICAgICAgICAgIDE7XG5cdCAqIE11bHRpcGxlICAgICAgICAgICAgICAgICAgICAgIDI7XG5cdCAqIEFsdGVybmF0ZSAgICAgICAgICAgICAgICAgICAgIDM7XG5cdCAqIExpZ2F0dXJlICAgICAgICAgICAgICAgICAgICAgIDQ7XG5cdCAqIENvbnRleHQgICAgICAgICAgICAgICAgICAgICAgIDU7XG5cdCAqIENoYWluaW5nQ29udGV4dCAgICAgICAgICAgICAgIDY7XG5cdCAqIEV4dGVuc2lvblN1YnN0aXR1dGlvbiAgICAgICAgIDc7XG5cdCAqIFJldmVyc2VDaGFpbmluZ0NvbnRleHQgICAgICAgIDg7XG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICpcblx0ICovXG5cblx0LyoqXG5cdCAqIEB0eXBlZGVmIEZRdWVyeVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhZyBmZWF0dXJlIHRhZ1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0IGZlYXR1cmUgc2NyaXB0XG5cdCAqIEBwYXJhbSB7Q29udGV4dFBhcmFtc30gY29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtc1xuXHQgKi9cblxuXHQvKipcblx0ICogTG9va3VwIGEgZmVhdHVyZSB1c2luZyBhIHF1ZXJ5IHBhcmFtZXRlcnNcblx0ICogQHBhcmFtIHtGUXVlcnl9IHF1ZXJ5IGZlYXR1cmUgcXVlcnlcblx0ICovXG5cdEZlYXR1cmVRdWVyeS5wcm90b3R5cGUubG9va3VwRmVhdHVyZSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuXHQgICAgdmFyIGNvbnRleHRQYXJhbXMgPSBxdWVyeS5jb250ZXh0UGFyYW1zO1xuXHQgICAgdmFyIGN1cnJlbnRJbmRleCA9IGNvbnRleHRQYXJhbXMuaW5kZXg7XG5cdCAgICB2YXIgZmVhdHVyZSA9IHRoaXMuZ2V0RmVhdHVyZSh7XG5cdCAgICAgICAgdGFnOiBxdWVyeS50YWcsIHNjcmlwdDogcXVlcnkuc2NyaXB0XG5cdCAgICB9KTtcblx0ICAgIGlmICghZmVhdHVyZSkgeyByZXR1cm4gbmV3IEVycm9yKFxuXHQgICAgICAgIFwiZm9udCAnXCIgKyAodGhpcy5mb250Lm5hbWVzLmZ1bGxOYW1lLmVuKSArIFwiJyBcIiArXG5cdCAgICAgICAgXCJkb2Vzbid0IHN1cHBvcnQgZmVhdHVyZSAnXCIgKyAocXVlcnkudGFnKSArIFwiJyBcIiArXG5cdCAgICAgICAgXCJmb3Igc2NyaXB0ICdcIiArIChxdWVyeS5zY3JpcHQpICsgXCInLlwiXG5cdCAgICApOyB9XG5cdCAgICB2YXIgbG9va3VwcyA9IHRoaXMuZ2V0RmVhdHVyZUxvb2t1cHMoZmVhdHVyZSk7XG5cdCAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IFtdLmNvbmNhdChjb250ZXh0UGFyYW1zLmNvbnRleHQpO1xuXHQgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsb29rdXBzLmxlbmd0aDsgbCsrKSB7XG5cdCAgICAgICAgdmFyIGxvb2t1cFRhYmxlID0gbG9va3Vwc1tsXTtcblx0ICAgICAgICB2YXIgc3VidGFibGVzID0gdGhpcy5nZXRMb29rdXBTdWJ0YWJsZXMobG9va3VwVGFibGUpO1xuXHQgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc3VidGFibGVzLmxlbmd0aDsgcysrKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tzXTtcblx0ICAgICAgICAgICAgdmFyIHN1YnN0VHlwZSA9IHRoaXMuZ2V0U3Vic3RpdHV0aW9uVHlwZShsb29rdXBUYWJsZSwgc3VidGFibGUpO1xuXHQgICAgICAgICAgICB2YXIgbG9va3VwID0gdGhpcy5nZXRMb29rdXBNZXRob2QobG9va3VwVGFibGUsIHN1YnRhYmxlKTtcblx0ICAgICAgICAgICAgdmFyIHN1YnN0aXR1dGlvbiA9ICh2b2lkIDApO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKHN1YnN0VHlwZSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnMTEnOlxuXHQgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChjb250ZXh0UGFyYW1zLmN1cnJlbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5zcGxpY2UoY3VycmVudEluZGV4LCAxLCBuZXcgU3Vic3RpdHV0aW9uQWN0aW9uKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAxMSwgdGFnOiBxdWVyeS50YWcsIHN1YnN0aXR1dGlvbjogc3Vic3RpdHV0aW9uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlICcxMic6XG5cdCAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uID0gbG9va3VwKGNvbnRleHRQYXJhbXMuY3VycmVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0aXR1dGlvbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnNwbGljZShjdXJyZW50SW5kZXgsIDEsIG5ldyBTdWJzdGl0dXRpb25BY3Rpb24oe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDEyLCB0YWc6IHF1ZXJ5LnRhZywgc3Vic3RpdHV0aW9uOiBzdWJzdGl0dXRpb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJzYzJzpcblx0ICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb24gPSBsb29rdXAoY29udGV4dFBhcmFtcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic3RpdHV0aW9uKSAmJiBzdWJzdGl0dXRpb24ubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSwgbmV3IFN1YnN0aXR1dGlvbkFjdGlvbih7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogNjMsIHRhZzogcXVlcnkudGFnLCBzdWJzdGl0dXRpb246IHN1YnN0aXR1dGlvblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnNDEnOlxuXHQgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChjb250ZXh0UGFyYW1zKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RpdHV0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuc3BsaWNlKGN1cnJlbnRJbmRleCwgMSwgbmV3IFN1YnN0aXR1dGlvbkFjdGlvbih7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogNDEsIHRhZzogcXVlcnkudGFnLCBzdWJzdGl0dXRpb246IHN1YnN0aXR1dGlvblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnMjEnOlxuXHQgICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbiA9IGxvb2t1cChjb250ZXh0UGFyYW1zLmN1cnJlbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzdGl0dXRpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5zcGxpY2UoY3VycmVudEluZGV4LCAxLCBuZXcgU3Vic3RpdHV0aW9uQWN0aW9uKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAyMSwgdGFnOiBxdWVyeS50YWcsIHN1YnN0aXR1dGlvbjogc3Vic3RpdHV0aW9uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKHN1YnN0aXR1dGlvbnMsIGN1cnJlbnRJbmRleCk7XG5cdCAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1YnN0aXR1dGlvbikgJiYgIXN1YnN0aXR1dGlvbi5sZW5ndGgpIHsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgc3Vic3RpdHV0aW9uID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc3Vic3RpdHV0aW9ucy5sZW5ndGggPyBzdWJzdGl0dXRpb25zIDogbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgZm9udCBzdXBwb3J0cyBhIHNwZWNpZmljIGZlYXR1cmVzXG5cdCAqIEBwYXJhbSB7RlF1ZXJ5fSBxdWVyeSBmZWF0dXJlIHF1ZXJ5IG9iamVjdFxuXHQgKi9cblx0RmVhdHVyZVF1ZXJ5LnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChxdWVyeSkge1xuXHQgICAgaWYgKCFxdWVyeS5zY3JpcHQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdCAgICB0aGlzLmdldFNjcmlwdEZlYXR1cmVzKHF1ZXJ5LnNjcmlwdCk7XG5cdCAgICB2YXIgc3VwcG9ydGVkU2NyaXB0ID0gdGhpcy5mZWF0dXJlcy5oYXNPd25Qcm9wZXJ0eShxdWVyeS5zY3JpcHQpO1xuXHQgICAgaWYgKCFxdWVyeS50YWcpIHsgcmV0dXJuIHN1cHBvcnRlZFNjcmlwdDsgfVxuXHQgICAgdmFyIHN1cHBvcnRlZEZlYXR1cmUgPSAoXG5cdCAgICAgICAgdGhpcy5mZWF0dXJlc1txdWVyeS5zY3JpcHRdLnNvbWUoZnVuY3Rpb24gKGZlYXR1cmUpIHsgcmV0dXJuIGZlYXR1cmUudGFnID09PSBxdWVyeS50YWc7IH0pXG5cdCAgICApO1xuXHQgICAgcmV0dXJuIHN1cHBvcnRlZFNjcmlwdCAmJiBzdXBwb3J0ZWRGZWF0dXJlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgbG9va3VwIHRhYmxlIHN1YnRhYmxlc1xuXHQgKiBAcGFyYW0ge2FueX0gbG9va3VwVGFibGUgbG9va3VwIHRhYmxlXG5cdCAqL1xuXHRGZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldExvb2t1cFN1YnRhYmxlcyA9IGZ1bmN0aW9uIChsb29rdXBUYWJsZSkge1xuXHQgICAgcmV0dXJuIGxvb2t1cFRhYmxlLnN1YnRhYmxlcyB8fCBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgbG9va3VwIHRhYmxlIGJ5IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBsb29rdXAgdGFibGUgaW5kZXhcblx0ICovXG5cdEZlYXR1cmVRdWVyeS5wcm90b3R5cGUuZ2V0TG9va3VwQnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHQgICAgdmFyIGxvb2t1cHMgPSB0aGlzLmZvbnQudGFibGVzLmdzdWIubG9va3Vwcztcblx0ICAgIHJldHVybiBsb29rdXBzW2luZGV4XSB8fCBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgbG9va3VwIHRhYmxlcyBmb3IgYSBmZWF0dXJlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlXG5cdCAqL1xuXHRGZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldEZlYXR1cmVMb29rdXBzID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcblx0ICAgIC8vIFRPRE86IG1lbW9pemVcblx0ICAgIHJldHVybiBmZWF0dXJlLmxvb2t1cExpc3RJbmRleGVzLm1hcCh0aGlzLmdldExvb2t1cEJ5SW5kZXguYmluZCh0aGlzKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFF1ZXJ5IGEgZmVhdHVyZSBieSBpdCdzIHByb3BlcnRpZXNcblx0ICogQHBhcmFtIHthbnl9IHF1ZXJ5IGFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgcHJvcGVydGllcyBvZiBhIHF1ZXJ5XG5cdCAqL1xuXHRGZWF0dXJlUXVlcnkucHJvdG90eXBlLmdldEZlYXR1cmUgPSBmdW5jdGlvbiBnZXRGZWF0dXJlKHF1ZXJ5KSB7XG5cdCAgICBpZiAoIXRoaXMuZm9udCkgeyByZXR1cm4geyBGQUlMOiBcIk5vIGZvbnQgd2FzIGZvdW5kXCJ9OyB9XG5cdCAgICBpZiAoIXRoaXMuZmVhdHVyZXMuaGFzT3duUHJvcGVydHkocXVlcnkuc2NyaXB0KSkge1xuXHQgICAgICAgIHRoaXMuZ2V0U2NyaXB0RmVhdHVyZXMocXVlcnkuc2NyaXB0KTtcblx0ICAgIH1cblx0ICAgIHZhciBzY3JpcHRGZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXNbcXVlcnkuc2NyaXB0XTtcblx0ICAgIGlmICghc2NyaXB0RmVhdHVyZXMpIHsgcmV0dXJuIChcblx0ICAgICAgICB7IEZBSUw6IChcIk5vIGZlYXR1cmUgZm9yIHNjcmlwdCBcIiArIChxdWVyeS5zY3JpcHQpKX1cblx0ICAgICk7IH1cblx0ICAgIGlmICghc2NyaXB0RmVhdHVyZXMudGFnc1txdWVyeS50YWddKSB7IHJldHVybiBudWxsOyB9XG5cdCAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1txdWVyeS5zY3JpcHRdLnRhZ3NbcXVlcnkudGFnXTtcblx0fTtcblxuXHQvKipcblx0ICogQXJhYmljIHdvcmQgY29udGV4dCBjaGVja2Vyc1xuXHQgKi9cblxuXHRmdW5jdGlvbiBhcmFiaWNXb3JkU3RhcnRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG5cdCAgICB2YXIgY2hhciA9IGNvbnRleHRQYXJhbXMuY3VycmVudDtcblx0ICAgIHZhciBwcmV2Q2hhciA9IGNvbnRleHRQYXJhbXMuZ2V0KC0xKTtcblx0ICAgIHJldHVybiAoXG5cdCAgICAgICAgLy8gPyBhcmFiaWMgZmlyc3QgY2hhclxuXHQgICAgICAgIChwcmV2Q2hhciA9PT0gbnVsbCAmJiBpc0FyYWJpY0NoYXIoY2hhcikpIHx8XG5cdCAgICAgICAgLy8gPyBhcmFiaWMgY2hhciBwcmVjZWRlZCB3aXRoIGEgbm9uIGFyYWJpYyBjaGFyXG5cdCAgICAgICAgKCFpc0FyYWJpY0NoYXIocHJldkNoYXIpICYmIGlzQXJhYmljQ2hhcihjaGFyKSlcblx0ICAgICk7XG5cdH1cblxuXHRmdW5jdGlvbiBhcmFiaWNXb3JkRW5kQ2hlY2soY29udGV4dFBhcmFtcykge1xuXHQgICAgdmFyIG5leHRDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoMSk7XG5cdCAgICByZXR1cm4gKFxuXHQgICAgICAgIC8vID8gbGFzdCBhcmFiaWMgY2hhclxuXHQgICAgICAgIChuZXh0Q2hhciA9PT0gbnVsbCkgfHxcblx0ICAgICAgICAvLyA/IG5leHQgY2hhciBpcyBub3QgYXJhYmljXG5cdCAgICAgICAgKCFpc0FyYWJpY0NoYXIobmV4dENoYXIpKVxuXHQgICAgKTtcblx0fVxuXG5cdHZhciBhcmFiaWNXb3JkQ2hlY2sgPSB7XG5cdCAgICBzdGFydENoZWNrOiBhcmFiaWNXb3JkU3RhcnRDaGVjayxcblx0ICAgIGVuZENoZWNrOiBhcmFiaWNXb3JkRW5kQ2hlY2tcblx0fTtcblxuXHQvKipcblx0ICogQXJhYmljIHNlbnRlbmNlIGNvbnRleHQgY2hlY2tlcnNcblx0ICovXG5cblx0ZnVuY3Rpb24gYXJhYmljU2VudGVuY2VTdGFydENoZWNrKGNvbnRleHRQYXJhbXMpIHtcblx0ICAgIHZhciBjaGFyID0gY29udGV4dFBhcmFtcy5jdXJyZW50O1xuXHQgICAgdmFyIHByZXZDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoLTEpO1xuXHQgICAgcmV0dXJuIChcblx0ICAgICAgICAvLyA/IGFuIGFyYWJpYyBjaGFyIHByZWNlZGVkIHdpdGggYSBub24gYXJhYmljIGNoYXJcblx0ICAgICAgICAoaXNBcmFiaWNDaGFyKGNoYXIpIHx8IGlzVGFzaGtlZWxBcmFiaWNDaGFyKGNoYXIpKSAmJlxuXHQgICAgICAgICFpc0FyYWJpY0NoYXIocHJldkNoYXIpXG5cdCAgICApO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXJhYmljU2VudGVuY2VFbmRDaGVjayhjb250ZXh0UGFyYW1zKSB7XG5cdCAgICB2YXIgbmV4dENoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgxKTtcblx0ICAgIHN3aXRjaCAodHJ1ZSkge1xuXHQgICAgICAgIGNhc2UgbmV4dENoYXIgPT09IG51bGw6XG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIGNhc2UgKCFpc0FyYWJpY0NoYXIobmV4dENoYXIpICYmICFpc1Rhc2hrZWVsQXJhYmljQ2hhcihuZXh0Q2hhcikpOlxuXHQgICAgICAgICAgICB2YXIgbmV4dElzV2hpdGVzcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cdCAgICAgICAgICAgIGlmICghbmV4dElzV2hpdGVzcGFjZSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHQgICAgICAgICAgICBpZiAobmV4dElzV2hpdGVzcGFjZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGFyYWJpY0NoYXJBaGVhZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgYXJhYmljQ2hhckFoZWFkID0gKFxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRleHRQYXJhbXMubG9va2FoZWFkLnNvbWUoXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjKSB7IHJldHVybiBpc0FyYWJpY0NoYXIoYykgfHwgaXNUYXNoa2VlbEFyYWJpY0NoYXIoYyk7IH1cblx0ICAgICAgICAgICAgICAgICAgICApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFhcmFiaWNDaGFyQWhlYWQpIHsgcmV0dXJuIHRydWU7IH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdH1cblxuXHR2YXIgYXJhYmljU2VudGVuY2VDaGVjayA9IHtcblx0ICAgIHN0YXJ0Q2hlY2s6IGFyYWJpY1NlbnRlbmNlU3RhcnRDaGVjayxcblx0ICAgIGVuZENoZWNrOiBhcmFiaWNTZW50ZW5jZUVuZENoZWNrXG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGx5IHNpbmdsZSBzdWJzdGl0dXRpb24gZm9ybWF0IDFcblx0ICogQHBhcmFtIHtBcnJheX0gc3Vic3RpdHV0aW9ucyBzdWJzdGl0dXRpb25zXG5cdCAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggdG9rZW4gaW5kZXhcblx0ICovXG5cdGZ1bmN0aW9uIHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDEkMShhY3Rpb24sIHRva2VucywgaW5kZXgpIHtcblx0ICAgIHRva2Vuc1tpbmRleF0uc2V0U3RhdGUoYWN0aW9uLnRhZywgYWN0aW9uLnN1YnN0aXR1dGlvbik7XG5cdH1cblxuXHQvKipcblx0ICogQXBwbHkgc2luZ2xlIHN1YnN0aXR1dGlvbiBmb3JtYXQgMlxuXHQgKiBAcGFyYW0ge0FycmF5fSBzdWJzdGl0dXRpb25zIHN1YnN0aXR1dGlvbnNcblx0ICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuXHQgKi9cblx0ZnVuY3Rpb24gc2luZ2xlU3Vic3RpdHV0aW9uRm9ybWF0MiQxKGFjdGlvbiwgdG9rZW5zLCBpbmRleCkge1xuXHQgICAgdG9rZW5zW2luZGV4XS5zZXRTdGF0ZShhY3Rpb24udGFnLCBhY3Rpb24uc3Vic3RpdHV0aW9uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBseSBjaGFpbmluZyBjb250ZXh0IHN1YnN0aXR1dGlvbiBmb3JtYXQgM1xuXHQgKiBAcGFyYW0ge0FycmF5fSBzdWJzdGl0dXRpb25zIHN1YnN0aXR1dGlvbnNcblx0ICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuXHQgKi9cblx0ZnVuY3Rpb24gY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzJDEoYWN0aW9uLCB0b2tlbnMsIGluZGV4KSB7XG5cdCAgICBhY3Rpb24uc3Vic3RpdHV0aW9uLmZvckVhY2goZnVuY3Rpb24gKHN1YnN0LCBvZmZzZXQpIHtcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaW5kZXggKyBvZmZzZXRdO1xuXHQgICAgICAgIHRva2VuLnNldFN0YXRlKGFjdGlvbi50YWcsIHN1YnN0KTtcblx0ICAgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGx5IGxpZ2F0dXJlIHN1YnN0aXR1dGlvbiBmb3JtYXQgMVxuXHQgKiBAcGFyYW0ge0FycmF5fSBzdWJzdGl0dXRpb25zIHN1YnN0aXR1dGlvbnNcblx0ICogQHBhcmFtIHthbnl9IHRva2VucyBhIGxpc3Qgb2YgdG9rZW5zXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCB0b2tlbiBpbmRleFxuXHQgKi9cblx0ZnVuY3Rpb24gbGlnYXR1cmVTdWJzdGl0dXRpb25Gb3JtYXQxJDEoYWN0aW9uLCB0b2tlbnMsIGluZGV4KSB7XG5cdCAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaW5kZXhdO1xuXHQgICAgdG9rZW4uc2V0U3RhdGUoYWN0aW9uLnRhZywgYWN0aW9uLnN1YnN0aXR1dGlvbi5saWdHbHlwaCk7XG5cdCAgICB2YXIgY29tcHNDb3VudCA9IGFjdGlvbi5zdWJzdGl0dXRpb24uY29tcG9uZW50cy5sZW5ndGg7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBzQ291bnQ7IGkrKykge1xuXHQgICAgICAgIHRva2VuID0gdG9rZW5zW2luZGV4ICsgaSArIDFdO1xuXHQgICAgICAgIHRva2VuLnNldFN0YXRlKCdkZWxldGVkJywgdHJ1ZSk7XG5cdCAgICB9XG5cdH1cblxuXHQvKipcblx0ICogU3VwcG9ydGVkIHN1YnN0aXR1dGlvbnNcblx0ICovXG5cdHZhciBTVUJTVElUVVRJT05TID0ge1xuXHQgICAgMTE6IHNpbmdsZVN1YnN0aXR1dGlvbkZvcm1hdDEkMSxcblx0ICAgIDEyOiBzaW5nbGVTdWJzdGl0dXRpb25Gb3JtYXQyJDEsXG5cdCAgICA2MzogY2hhaW5pbmdTdWJzdGl0dXRpb25Gb3JtYXQzJDEsXG5cdCAgICA0MTogbGlnYXR1cmVTdWJzdGl0dXRpb25Gb3JtYXQxJDFcblx0fTtcblxuXHQvKipcblx0ICogQXBwbHkgc3Vic3RpdHV0aW9ucyB0byBhIGxpc3Qgb2YgdG9rZW5zXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgc3Vic3RpdHV0aW9uc1xuXHQgKiBAcGFyYW0ge2FueX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHRva2VuIGluZGV4XG5cdCAqL1xuXHRmdW5jdGlvbiBhcHBseVN1YnN0aXR1dGlvbihhY3Rpb24sIHRva2VucywgaW5kZXgpIHtcblx0ICAgIGlmIChhY3Rpb24gaW5zdGFuY2VvZiBTdWJzdGl0dXRpb25BY3Rpb24gJiYgU1VCU1RJVFVUSU9OU1thY3Rpb24uaWRdKSB7XG5cdCAgICAgICAgU1VCU1RJVFVUSU9OU1thY3Rpb24uaWRdKGFjdGlvbiwgdG9rZW5zLCBpbmRleCk7XG5cdCAgICB9XG5cdH1cblxuXHQvKipcblx0ICogQXBwbHkgQXJhYmljIHByZXNlbnRhdGlvbiBmb3JtcyB0byBhIHJhbmdlIG9mIHRva2Vuc1xuXHQgKi9cblxuXHQvKipcblx0ICogQ2hlY2sgaWYgYSBjaGFyIGNhbiBiZSBjb25uZWN0ZWQgdG8gaXQncyBwcmVjZWRpbmcgY2hhclxuXHQgKiBAcGFyYW0ge0NvbnRleHRQYXJhbXN9IGNoYXJDb250ZXh0UGFyYW1zIGNvbnRleHQgcGFyYW1zIG9mIGEgY2hhclxuXHQgKi9cblx0ZnVuY3Rpb24gd2lsbENvbm5lY3RQcmV2KGNoYXJDb250ZXh0UGFyYW1zKSB7XG5cdCAgICB2YXIgYmFja3RyYWNrID0gW10uY29uY2F0KGNoYXJDb250ZXh0UGFyYW1zLmJhY2t0cmFjayk7XG5cdCAgICBmb3IgKHZhciBpID0gYmFja3RyYWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgdmFyIHByZXZDaGFyID0gYmFja3RyYWNrW2ldO1xuXHQgICAgICAgIHZhciBpc29sYXRlZCA9IGlzSXNvbGF0ZWRBcmFiaWNDaGFyKHByZXZDaGFyKTtcblx0ICAgICAgICB2YXIgdGFzaGtlZWwgPSBpc1Rhc2hrZWVsQXJhYmljQ2hhcihwcmV2Q2hhcik7XG5cdCAgICAgICAgaWYgKCFpc29sYXRlZCAmJiAhdGFzaGtlZWwpIHsgcmV0dXJuIHRydWU7IH1cblx0ICAgICAgICBpZiAoaXNvbGF0ZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgaWYgYSBjaGFyIGNhbiBiZSBjb25uZWN0ZWQgdG8gaXQncyBwcm9jZWVkaW5nIGNoYXJcblx0ICogQHBhcmFtIHtDb250ZXh0UGFyYW1zfSBjaGFyQ29udGV4dFBhcmFtcyBjb250ZXh0IHBhcmFtcyBvZiBhIGNoYXJcblx0ICovXG5cdGZ1bmN0aW9uIHdpbGxDb25uZWN0TmV4dChjaGFyQ29udGV4dFBhcmFtcykge1xuXHQgICAgaWYgKGlzSXNvbGF0ZWRBcmFiaWNDaGFyKGNoYXJDb250ZXh0UGFyYW1zLmN1cnJlbnQpKSB7IHJldHVybiBmYWxzZTsgfVxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyQ29udGV4dFBhcmFtcy5sb29rYWhlYWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgbmV4dENoYXIgPSBjaGFyQ29udGV4dFBhcmFtcy5sb29rYWhlYWRbaV07XG5cdCAgICAgICAgdmFyIHRhc2hrZWVsID0gaXNUYXNoa2VlbEFyYWJpY0NoYXIobmV4dENoYXIpO1xuXHQgICAgICAgIGlmICghdGFzaGtlZWwpIHsgcmV0dXJuIHRydWU7IH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBseSBhcmFiaWMgcHJlc2VudGF0aW9uIGZvcm1zIHRvIGEgbGlzdCBvZiB0b2tlbnNcblx0ICogQHBhcmFtIHtDb250ZXh0UmFuZ2V9IHJhbmdlIGEgcmFuZ2Ugb2YgdG9rZW5zXG5cdCAqL1xuXHRmdW5jdGlvbiBhcmFiaWNQcmVzZW50YXRpb25Gb3JtcyhyYW5nZSkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIHZhciBzY3JpcHQgPSAnYXJhYic7XG5cdCAgICB2YXIgdGFncyA9IHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF07XG5cdCAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbml6ZXIuZ2V0UmFuZ2VUb2tlbnMocmFuZ2UpO1xuXHQgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHsgcmV0dXJuOyB9XG5cdCAgICB2YXIgY29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKFxuXHQgICAgICAgIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5nZXRTdGF0ZSgnZ2x5cGhJbmRleCcpOyB9XG5cdCAgICApLCAwKTtcblx0ICAgIHZhciBjaGFyQ29udGV4dFBhcmFtcyA9IG5ldyBDb250ZXh0UGFyYW1zKFxuXHQgICAgICAgIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5jaGFyOyB9XG5cdCAgICApLCAwKTtcblx0ICAgIHRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbiwgaW5kZXgpIHtcblx0ICAgICAgICBpZiAoaXNUYXNoa2VlbEFyYWJpY0NoYXIodG9rZW4uY2hhcikpIHsgcmV0dXJuOyB9XG5cdCAgICAgICAgY29udGV4dFBhcmFtcy5zZXRDdXJyZW50SW5kZXgoaW5kZXgpO1xuXHQgICAgICAgIGNoYXJDb250ZXh0UGFyYW1zLnNldEN1cnJlbnRJbmRleChpbmRleCk7XG5cdCAgICAgICAgdmFyIENPTk5FQ1QgPSAwOyAvLyAyIGJpdHMgMDAgKDEwOiBjYW4gY29ubmVjdCBuZXh0KSAoMDE6IGNhbiBjb25uZWN0IHByZXYpXG5cdCAgICAgICAgaWYgKHdpbGxDb25uZWN0UHJldihjaGFyQ29udGV4dFBhcmFtcykpIHsgQ09OTkVDVCB8PSAxOyB9XG5cdCAgICAgICAgaWYgKHdpbGxDb25uZWN0TmV4dChjaGFyQ29udGV4dFBhcmFtcykpIHsgQ09OTkVDVCB8PSAyOyB9XG5cdCAgICAgICAgdmFyIHRhZztcblx0ICAgICAgICBzd2l0Y2ggKENPTk5FQ1QpIHtcblx0ICAgICAgICAgICAgY2FzZSAxOiAodGFnID0gJ2ZpbmEnKTsgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgMjogKHRhZyA9ICdpbml0Jyk7IGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIDM6ICh0YWcgPSAnbWVkaScpOyBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRhZ3MuaW5kZXhPZih0YWcpID09PSAtMSkgeyByZXR1cm47IH1cblx0ICAgICAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IHRoaXMkMS5xdWVyeS5sb29rdXBGZWF0dXJlKHtcblx0ICAgICAgICAgICAgdGFnOiB0YWcsIHNjcmlwdDogc2NyaXB0LCBjb250ZXh0UGFyYW1zOiBjb250ZXh0UGFyYW1zXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgaWYgKHN1YnN0aXR1dGlvbnMgaW5zdGFuY2VvZiBFcnJvcikgeyByZXR1cm4gY29uc29sZS5pbmZvKHN1YnN0aXR1dGlvbnMubWVzc2FnZSk7IH1cblx0ICAgICAgICBzdWJzdGl0dXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbiwgaW5kZXgpIHtcblx0ICAgICAgICAgICAgaWYgKGFjdGlvbiBpbnN0YW5jZW9mIFN1YnN0aXR1dGlvbkFjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgYXBwbHlTdWJzdGl0dXRpb24oYWN0aW9uLCB0b2tlbnMsIGluZGV4KTtcblx0ICAgICAgICAgICAgICAgIGNvbnRleHRQYXJhbXMuY29udGV4dFtpbmRleF0gPSBhY3Rpb24uc3Vic3RpdHV0aW9uO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBseSBBcmFiaWMgcmVxdWlyZWQgbGlnYXR1cmVzIGZlYXR1cmUgdG8gYSByYW5nZSBvZiB0b2tlbnNcblx0ICovXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBjb250ZXh0IHBhcmFtc1xuXHQgKiBAcGFyYW0ge2FueX0gdG9rZW5zIGEgbGlzdCBvZiB0b2tlbnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGN1cnJlbnQgaXRlbSBpbmRleFxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0Q29udGV4dFBhcmFtcyh0b2tlbnMsIGluZGV4KSB7XG5cdCAgICB2YXIgY29udGV4dCA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbi5hY3RpdmVTdGF0ZS52YWx1ZTsgfSk7XG5cdCAgICByZXR1cm4gbmV3IENvbnRleHRQYXJhbXMoY29udGV4dCwgaW5kZXggfHwgMCk7XG5cdH1cblxuXHQvKipcblx0ICogQXBwbHkgQXJhYmljIHJlcXVpcmVkIGxpZ2F0dXJlcyB0byBhIGNvbnRleHQgcmFuZ2Vcblx0ICogQHBhcmFtIHtDb250ZXh0UmFuZ2V9IHJhbmdlIGEgcmFuZ2Ugb2YgdG9rZW5zXG5cdCAqL1xuXHRmdW5jdGlvbiBhcmFiaWNSZXF1aXJlZExpZ2F0dXJlcyhyYW5nZSkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIHZhciBzY3JpcHQgPSAnYXJhYic7XG5cdCAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbml6ZXIuZ2V0UmFuZ2VUb2tlbnMocmFuZ2UpO1xuXHQgICAgdmFyIGNvbnRleHRQYXJhbXMgPSBnZXRDb250ZXh0UGFyYW1zKHRva2Vucyk7XG5cdCAgICBjb250ZXh0UGFyYW1zLmNvbnRleHQuZm9yRWFjaChmdW5jdGlvbiAoZ2x5cGhJbmRleCwgaW5kZXgpIHtcblx0ICAgICAgICBjb250ZXh0UGFyYW1zLnNldEN1cnJlbnRJbmRleChpbmRleCk7XG5cdCAgICAgICAgdmFyIHN1YnN0aXR1dGlvbnMgPSB0aGlzJDEucXVlcnkubG9va3VwRmVhdHVyZSh7XG5cdCAgICAgICAgICAgIHRhZzogJ3JsaWcnLCBzY3JpcHQ6IHNjcmlwdCwgY29udGV4dFBhcmFtczogY29udGV4dFBhcmFtc1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGlmIChzdWJzdGl0dXRpb25zLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBzdWJzdGl0dXRpb25zLmZvckVhY2goXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBhcHBseVN1YnN0aXR1dGlvbihhY3Rpb24sIHRva2VucywgaW5kZXgpOyB9XG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIGNvbnRleHRQYXJhbXMgPSBnZXRDb250ZXh0UGFyYW1zKHRva2Vucyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogTGF0aW4gd29yZCBjb250ZXh0IGNoZWNrZXJzXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGxhdGluV29yZFN0YXJ0Q2hlY2soY29udGV4dFBhcmFtcykge1xuXHQgICAgdmFyIGNoYXIgPSBjb250ZXh0UGFyYW1zLmN1cnJlbnQ7XG5cdCAgICB2YXIgcHJldkNoYXIgPSBjb250ZXh0UGFyYW1zLmdldCgtMSk7XG5cdCAgICByZXR1cm4gKFxuXHQgICAgICAgIC8vID8gbGF0aW4gZmlyc3QgY2hhclxuXHQgICAgICAgIChwcmV2Q2hhciA9PT0gbnVsbCAmJiBpc0xhdGluQ2hhcihjaGFyKSkgfHxcblx0ICAgICAgICAvLyA/IGxhdGluIGNoYXIgcHJlY2VkZWQgd2l0aCBhIG5vbiBsYXRpbiBjaGFyXG5cdCAgICAgICAgKCFpc0xhdGluQ2hhcihwcmV2Q2hhcikgJiYgaXNMYXRpbkNoYXIoY2hhcikpXG5cdCAgICApO1xuXHR9XG5cblx0ZnVuY3Rpb24gbGF0aW5Xb3JkRW5kQ2hlY2soY29udGV4dFBhcmFtcykge1xuXHQgICAgdmFyIG5leHRDaGFyID0gY29udGV4dFBhcmFtcy5nZXQoMSk7XG5cdCAgICByZXR1cm4gKFxuXHQgICAgICAgIC8vID8gbGFzdCBsYXRpbiBjaGFyXG5cdCAgICAgICAgKG5leHRDaGFyID09PSBudWxsKSB8fFxuXHQgICAgICAgIC8vID8gbmV4dCBjaGFyIGlzIG5vdCBsYXRpblxuXHQgICAgICAgICghaXNMYXRpbkNoYXIobmV4dENoYXIpKVxuXHQgICAgKTtcblx0fVxuXG5cdHZhciBsYXRpbldvcmRDaGVjayA9IHtcblx0ICAgIHN0YXJ0Q2hlY2s6IGxhdGluV29yZFN0YXJ0Q2hlY2ssXG5cdCAgICBlbmRDaGVjazogbGF0aW5Xb3JkRW5kQ2hlY2tcblx0fTtcblxuXHQvKipcblx0ICogQXBwbHkgTGF0aW4gbGlnYXR1cmUgZmVhdHVyZSB0byBhIHJhbmdlIG9mIHRva2Vuc1xuXHQgKi9cblxuXHQvKipcblx0ICogVXBkYXRlIGNvbnRleHQgcGFyYW1zXG5cdCAqIEBwYXJhbSB7YW55fSB0b2tlbnMgYSBsaXN0IG9mIHRva2Vuc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggY3VycmVudCBpdGVtIGluZGV4XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRDb250ZXh0UGFyYW1zJDEodG9rZW5zLCBpbmRleCkge1xuXHQgICAgdmFyIGNvbnRleHQgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW4uYWN0aXZlU3RhdGUudmFsdWU7IH0pO1xuXHQgICAgcmV0dXJuIG5ldyBDb250ZXh0UGFyYW1zKGNvbnRleHQsIGluZGV4IHx8IDApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGx5IEFyYWJpYyByZXF1aXJlZCBsaWdhdHVyZXMgdG8gYSBjb250ZXh0IHJhbmdlXG5cdCAqIEBwYXJhbSB7Q29udGV4dFJhbmdlfSByYW5nZSBhIHJhbmdlIG9mIHRva2Vuc1xuXHQgKi9cblx0ZnVuY3Rpb24gbGF0aW5MaWdhdHVyZShyYW5nZSkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIHZhciBzY3JpcHQgPSAnbGF0bic7XG5cdCAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbml6ZXIuZ2V0UmFuZ2VUb2tlbnMocmFuZ2UpO1xuXHQgICAgdmFyIGNvbnRleHRQYXJhbXMgPSBnZXRDb250ZXh0UGFyYW1zJDEodG9rZW5zKTtcblx0ICAgIGNvbnRleHRQYXJhbXMuY29udGV4dC5mb3JFYWNoKGZ1bmN0aW9uIChnbHlwaEluZGV4LCBpbmRleCkge1xuXHQgICAgICAgIGNvbnRleHRQYXJhbXMuc2V0Q3VycmVudEluZGV4KGluZGV4KTtcblx0ICAgICAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IHRoaXMkMS5xdWVyeS5sb29rdXBGZWF0dXJlKHtcblx0ICAgICAgICAgICAgdGFnOiAnbGlnYScsIHNjcmlwdDogc2NyaXB0LCBjb250ZXh0UGFyYW1zOiBjb250ZXh0UGFyYW1zXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgaWYgKHN1YnN0aXR1dGlvbnMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMuZm9yRWFjaChcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGFwcGx5U3Vic3RpdHV0aW9uKGFjdGlvbiwgdG9rZW5zLCBpbmRleCk7IH1cblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgY29udGV4dFBhcmFtcyA9IGdldENvbnRleHRQYXJhbXMkMSh0b2tlbnMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluZmVyIGJpZGlyZWN0aW9uYWwgcHJvcGVydGllcyBmb3IgYSBnaXZlbiB0ZXh0IGFuZCBhcHBseVxuXHQgKiB0aGUgY29ycmVzcG9uZGluZyBsYXlvdXQgcnVsZXMuXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgQmlkaS4gZmVhdHVyZXNcblx0ICogQHBhcmFtIHtzdHJpbmd9IGJhc2VEaXIgdGV4dCBiYXNlIGRpcmVjdGlvbi4gdmFsdWUgZWl0aGVyICdsdHInIG9yICdydGwnXG5cdCAqL1xuXHRmdW5jdGlvbiBCaWRpKGJhc2VEaXIpIHtcblx0ICAgIHRoaXMuYmFzZURpciA9IGJhc2VEaXIgfHwgJ2x0cic7XG5cdCAgICB0aGlzLnRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoKTtcblx0ICAgIHRoaXMuZmVhdHVyZXNUYWdzID0ge307XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBCaWRpIHRleHRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHQgYSB0ZXh0IGlucHV0XG5cdCAqL1xuXHRCaWRpLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcblx0ICAgIHRoaXMudGV4dCA9IHRleHQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3JlIGVzc2VudGlhbCBjb250ZXh0IGNoZWNrczpcblx0ICogYXJhYmljIHdvcmQgY2hlY2sgZm9yIGFwcGx5aW5nIGdzdWIgZmVhdHVyZXNcblx0ICogYXJhYmljIHNlbnRlbmNlIGNoZWNrIGZvciBhZGp1c3RpbmcgYXJhYmljIGxheW91dFxuXHQgKi9cblx0QmlkaS5wcm90b3R5cGUuY29udGV4dENoZWNrcyA9ICh7XG5cdCAgICBsYXRpbldvcmRDaGVjazogbGF0aW5Xb3JkQ2hlY2ssXG5cdCAgICBhcmFiaWNXb3JkQ2hlY2s6IGFyYWJpY1dvcmRDaGVjayxcblx0ICAgIGFyYWJpY1NlbnRlbmNlQ2hlY2s6IGFyYWJpY1NlbnRlbmNlQ2hlY2tcblx0fSk7XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGFyYWJpYyB3b3JkIGNoZWNrXG5cdCAqL1xuXHRmdW5jdGlvbiByZWdpc3RlckNvbnRleHRDaGVja2VyKGNoZWNrSWQpIHtcblx0ICAgIHZhciBjaGVjayA9IHRoaXMuY29udGV4dENoZWNrc1soY2hlY2tJZCArIFwiQ2hlY2tcIildO1xuXHQgICAgcmV0dXJuIHRoaXMudG9rZW5pemVyLnJlZ2lzdGVyQ29udGV4dENoZWNrZXIoXG5cdCAgICAgICAgY2hlY2tJZCwgY2hlY2suc3RhcnRDaGVjaywgY2hlY2suZW5kQ2hlY2tcblx0ICAgICk7XG5cdH1cblxuXHQvKipcblx0ICogUGVyZm9ybSBwcmUgdG9rZW5pemF0aW9uIHByb2NlZHVyZSB0aGVuXG5cdCAqIHRva2VuaXplIHRleHQgaW5wdXRcblx0ICovXG5cdGZ1bmN0aW9uIHRva2VuaXplVGV4dCgpIHtcblx0ICAgIHJlZ2lzdGVyQ29udGV4dENoZWNrZXIuY2FsbCh0aGlzLCAnbGF0aW5Xb3JkJyk7XG5cdCAgICByZWdpc3RlckNvbnRleHRDaGVja2VyLmNhbGwodGhpcywgJ2FyYWJpY1dvcmQnKTtcblx0ICAgIHJlZ2lzdGVyQ29udGV4dENoZWNrZXIuY2FsbCh0aGlzLCAnYXJhYmljU2VudGVuY2UnKTtcblx0ICAgIHJldHVybiB0aGlzLnRva2VuaXplci50b2tlbml6ZSh0aGlzLnRleHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldmVyc2UgYXJhYmljIHNlbnRlbmNlIGxheW91dFxuXHQgKiBUT0RPOiBjaGVjayBiYXNlIGRpciBiZWZvcmUgYXBwbHlpbmcgYWRqdXN0bWVudHMgLSBwcmlvcml0eSBsb3dcblx0ICovXG5cdGZ1bmN0aW9uIHJldmVyc2VBcmFiaWNTZW50ZW5jZXMoKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgdmFyIHJhbmdlcyA9IHRoaXMudG9rZW5pemVyLmdldENvbnRleHRSYW5nZXMoJ2FyYWJpY1NlbnRlbmNlJyk7XG5cdCAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcblx0ICAgICAgICB2YXIgcmFuZ2VUb2tlbnMgPSB0aGlzJDEudG9rZW5pemVyLmdldFJhbmdlVG9rZW5zKHJhbmdlKTtcblx0ICAgICAgICB0aGlzJDEudG9rZW5pemVyLnJlcGxhY2VSYW5nZShcblx0ICAgICAgICAgICAgcmFuZ2Uuc3RhcnRJbmRleCxcblx0ICAgICAgICAgICAgcmFuZ2UuZW5kT2Zmc2V0LFxuXHQgICAgICAgICAgICByYW5nZVRva2Vucy5yZXZlcnNlKClcblx0ICAgICAgICApO1xuXHQgICAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXIgc3VwcG9ydGVkIGZlYXR1cmVzIHRhZ3Ncblx0ICogQHBhcmFtIHtzY3JpcHR9IHNjcmlwdCBzY3JpcHQgdGFnXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhZ3MgZmVhdHVyZXMgdGFncyBsaXN0XG5cdCAqL1xuXHRCaWRpLnByb3RvdHlwZS5yZWdpc3RlckZlYXR1cmVzID0gZnVuY3Rpb24gKHNjcmlwdCwgdGFncykge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIHZhciBzdXBwb3J0ZWRUYWdzID0gdGFncy5maWx0ZXIoXG5cdCAgICAgICAgZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGhpcyQxLnF1ZXJ5LnN1cHBvcnRzKHtzY3JpcHQ6IHNjcmlwdCwgdGFnOiB0YWd9KTsgfVxuXHQgICAgKTtcblx0ICAgIGlmICghdGhpcy5mZWF0dXJlc1RhZ3MuaGFzT3duUHJvcGVydHkoc2NyaXB0KSkge1xuXHQgICAgICAgIHRoaXMuZmVhdHVyZXNUYWdzW3NjcmlwdF0gPSBzdXBwb3J0ZWRUYWdzO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdID1cblx0ICAgICAgICB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdLmNvbmNhdChzdXBwb3J0ZWRUYWdzKTtcblx0ICAgIH1cblx0fTtcblxuXHQvKipcblx0ICogQXBwbHkgR1NVQiBmZWF0dXJlc1xuXHQgKiBAcGFyYW0ge0FycmF5fSB0YWdzTGlzdCBhIGxpc3Qgb2YgZmVhdHVyZXMgdGFnc1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0IGEgc2NyaXB0IHRhZ1xuXHQgKiBAcGFyYW0ge0ZvbnR9IGZvbnQgb3BlbnR5cGUgZm9udCBpbnN0YW5jZVxuXHQgKi9cblx0QmlkaS5wcm90b3R5cGUuYXBwbHlGZWF0dXJlcyA9IGZ1bmN0aW9uIChmb250LCBmZWF0dXJlcykge1xuXHQgICAgaWYgKCFmb250KSB7IHRocm93IG5ldyBFcnJvcihcblx0ICAgICAgICAnTm8gdmFsaWQgZm9udCB3YXMgcHJvdmlkZWQgdG8gYXBwbHkgZmVhdHVyZXMnXG5cdCAgICApOyB9XG5cdCAgICBpZiAoIXRoaXMucXVlcnkpIHsgdGhpcy5xdWVyeSA9IG5ldyBGZWF0dXJlUXVlcnkoZm9udCk7IH1cblx0ICAgIGZvciAodmFyIGYgPSAwOyBmIDwgZmVhdHVyZXMubGVuZ3RoOyBmKyspIHtcblx0ICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ZdO1xuXHQgICAgICAgIGlmICghdGhpcy5xdWVyeS5zdXBwb3J0cyh7c2NyaXB0OiBmZWF0dXJlLnNjcmlwdH0pKSB7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgdGhpcy5yZWdpc3RlckZlYXR1cmVzKGZlYXR1cmUuc2NyaXB0LCBmZWF0dXJlLnRhZ3MpO1xuXHQgICAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhIHN0YXRlIG1vZGlmaWVyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RpZmllcklkIHN0YXRlIG1vZGlmaWVyIGlkXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbmRpdGlvbiBhIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBvciBmYWxzZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb2RpZmllciBhIG1vZGlmaWVyIGZ1bmN0aW9uIHRvIHNldCB0b2tlbiBzdGF0ZVxuXHQgKi9cblx0QmlkaS5wcm90b3R5cGUucmVnaXN0ZXJNb2RpZmllciA9IGZ1bmN0aW9uIChtb2RpZmllcklkLCBjb25kaXRpb24sIG1vZGlmaWVyKSB7XG5cdCAgICB0aGlzLnRva2VuaXplci5yZWdpc3Rlck1vZGlmaWVyKG1vZGlmaWVySWQsIGNvbmRpdGlvbiwgbW9kaWZpZXIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiAnZ2x5cGhJbmRleCcgaXMgcmVnaXN0ZXJlZFxuXHQgKi9cblx0ZnVuY3Rpb24gY2hlY2tHbHlwaEluZGV4U3RhdHVzKCkge1xuXHQgICAgaWYgKHRoaXMudG9rZW5pemVyLnJlZ2lzdGVyZWRNb2RpZmllcnMuaW5kZXhPZignZ2x5cGhJbmRleCcpID09PSAtMSkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcblx0ICAgICAgICAgICAgJ2dseXBoSW5kZXggbW9kaWZpZXIgaXMgcmVxdWlyZWQgdG8gYXBwbHkgJyArXG5cdCAgICAgICAgICAgICdhcmFiaWMgcHJlc2VudGF0aW9uIGZlYXR1cmVzLidcblx0ICAgICAgICApO1xuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGx5IGFyYWJpYyBwcmVzZW50YXRpb24gZm9ybXMgZmVhdHVyZXNcblx0ICovXG5cdGZ1bmN0aW9uIGFwcGx5QXJhYmljUHJlc2VudGF0aW9uRm9ybXMoKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgdmFyIHNjcmlwdCA9ICdhcmFiJztcblx0ICAgIGlmICghdGhpcy5mZWF0dXJlc1RhZ3MuaGFzT3duUHJvcGVydHkoc2NyaXB0KSkgeyByZXR1cm47IH1cblx0ICAgIGNoZWNrR2x5cGhJbmRleFN0YXR1cy5jYWxsKHRoaXMpO1xuXHQgICAgdmFyIHJhbmdlcyA9IHRoaXMudG9rZW5pemVyLmdldENvbnRleHRSYW5nZXMoJ2FyYWJpY1dvcmQnKTtcblx0ICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuXHQgICAgICAgIGFyYWJpY1ByZXNlbnRhdGlvbkZvcm1zLmNhbGwodGhpcyQxLCByYW5nZSk7XG5cdCAgICB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBseSByZXF1aXJlZCBhcmFiaWMgbGlnYXR1cmVzXG5cdCAqL1xuXHRmdW5jdGlvbiBhcHBseUFyYWJpY1JlcXVpcmVMaWdhdHVyZXMoKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgdmFyIHNjcmlwdCA9ICdhcmFiJztcblx0ICAgIGlmICghdGhpcy5mZWF0dXJlc1RhZ3MuaGFzT3duUHJvcGVydHkoc2NyaXB0KSkgeyByZXR1cm47IH1cblx0ICAgIHZhciB0YWdzID0gdGhpcy5mZWF0dXJlc1RhZ3Nbc2NyaXB0XTtcblx0ICAgIGlmICh0YWdzLmluZGV4T2YoJ3JsaWcnKSA9PT0gLTEpIHsgcmV0dXJuOyB9XG5cdCAgICBjaGVja0dseXBoSW5kZXhTdGF0dXMuY2FsbCh0aGlzKTtcblx0ICAgIHZhciByYW5nZXMgPSB0aGlzLnRva2VuaXplci5nZXRDb250ZXh0UmFuZ2VzKCdhcmFiaWNXb3JkJyk7XG5cdCAgICByYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAocmFuZ2UpIHtcblx0ICAgICAgICBhcmFiaWNSZXF1aXJlZExpZ2F0dXJlcy5jYWxsKHRoaXMkMSwgcmFuZ2UpO1xuXHQgICAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogQXBwbHkgcmVxdWlyZWQgYXJhYmljIGxpZ2F0dXJlc1xuXHQgKi9cblx0ZnVuY3Rpb24gYXBwbHlMYXRpbkxpZ2F0dXJlcygpIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICB2YXIgc2NyaXB0ID0gJ2xhdG4nO1xuXHQgICAgaWYgKCF0aGlzLmZlYXR1cmVzVGFncy5oYXNPd25Qcm9wZXJ0eShzY3JpcHQpKSB7IHJldHVybjsgfVxuXHQgICAgdmFyIHRhZ3MgPSB0aGlzLmZlYXR1cmVzVGFnc1tzY3JpcHRdO1xuXHQgICAgaWYgKHRhZ3MuaW5kZXhPZignbGlnYScpID09PSAtMSkgeyByZXR1cm47IH1cblx0ICAgIGNoZWNrR2x5cGhJbmRleFN0YXR1cy5jYWxsKHRoaXMpO1xuXHQgICAgdmFyIHJhbmdlcyA9IHRoaXMudG9rZW5pemVyLmdldENvbnRleHRSYW5nZXMoJ2xhdGluV29yZCcpO1xuXHQgICAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG5cdCAgICAgICAgbGF0aW5MaWdhdHVyZS5jYWxsKHRoaXMkMSwgcmFuZ2UpO1xuXHQgICAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgaWYgYSBjb250ZXh0IGlzIHJlZ2lzdGVyZWRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRJZCBjb250ZXh0IGlkXG5cdCAqL1xuXHRCaWRpLnByb3RvdHlwZS5jaGVja0NvbnRleHRSZWFkeSA9IGZ1bmN0aW9uIChjb250ZXh0SWQpIHtcblx0ICAgIHJldHVybiAhIXRoaXMudG9rZW5pemVyLmdldENvbnRleHQoY29udGV4dElkKTtcblx0fTtcblxuXHQvKipcblx0ICogQXBwbHkgZmVhdHVyZXMgdG8gcmVnaXN0ZXJlZCBjb250ZXh0c1xuXHQgKi9cblx0QmlkaS5wcm90b3R5cGUuYXBwbHlGZWF0dXJlc1RvQ29udGV4dHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5jaGVja0NvbnRleHRSZWFkeSgnYXJhYmljV29yZCcpKSB7XG5cdCAgICAgICAgYXBwbHlBcmFiaWNQcmVzZW50YXRpb25Gb3Jtcy5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGFwcGx5QXJhYmljUmVxdWlyZUxpZ2F0dXJlcy5jYWxsKHRoaXMpO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuY2hlY2tDb250ZXh0UmVhZHkoJ2xhdGluV29yZCcpKSB7XG5cdCAgICAgICAgYXBwbHlMYXRpbkxpZ2F0dXJlcy5jYWxsKHRoaXMpO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuY2hlY2tDb250ZXh0UmVhZHkoJ2FyYWJpY1NlbnRlbmNlJykpIHtcblx0ICAgICAgICByZXZlcnNlQXJhYmljU2VudGVuY2VzLmNhbGwodGhpcyk7XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIHByb2Nlc3MgdGV4dCBpbnB1dFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBhbiBpbnB1dCB0ZXh0XG5cdCAqL1xuXHRCaWRpLnByb3RvdHlwZS5wcm9jZXNzVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICAgIGlmICghdGhpcy50ZXh0IHx8IHRoaXMudGV4dCAhPT0gdGV4dCkge1xuXHQgICAgICAgIHRoaXMuc2V0VGV4dCh0ZXh0KTtcblx0ICAgICAgICB0b2tlbml6ZVRleHQuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmFwcGx5RmVhdHVyZXNUb0NvbnRleHRzKCk7XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb2Nlc3MgYSBzdHJpbmcgb2YgdGV4dCB0byBpZGVudGlmeSBhbmQgYWRqdXN0XG5cdCAqIGJpZGlyZWN0aW9uYWwgdGV4dCBlbnRpdGllcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHQgaW5wdXQgdGV4dFxuXHQgKi9cblx0QmlkaS5wcm90b3R5cGUuZ2V0QmlkaVRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuXHQgICAgdGhpcy5wcm9jZXNzVGV4dCh0ZXh0KTtcblx0ICAgIHJldHVybiB0aGlzLnRva2VuaXplci5nZXRUZXh0KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCBzdGF0ZSBpbmRleCBvZiBlYWNoIHRva2VuXG5cdCAqIEBwYXJhbSB7dGV4dH0gdGV4dCBhbiBpbnB1dCB0ZXh0XG5cdCAqL1xuXHRCaWRpLnByb3RvdHlwZS5nZXRUZXh0R2x5cGhzID0gZnVuY3Rpb24gKHRleHQpIHtcblx0ICAgIHRoaXMucHJvY2Vzc1RleHQodGV4dCk7XG5cdCAgICB2YXIgaW5kZXhlcyA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRva2VuaXplci50b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2VuaXplci50b2tlbnNbaV07XG5cdCAgICAgICAgaWYgKHRva2VuLnN0YXRlLmRlbGV0ZWQpIHsgY29udGludWU7IH1cblx0ICAgICAgICB2YXIgaW5kZXggPSB0b2tlbi5hY3RpdmVTdGF0ZS52YWx1ZTtcblx0ICAgICAgICBpbmRleGVzLnB1c2goQXJyYXkuaXNBcnJheShpbmRleCkgPyBpbmRleFswXSA6IGluZGV4KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBpbmRleGVzO1xuXHR9O1xuXG5cdC8vIFRoZSBGb250IG9iamVjdFxuXG5cdC8qKlxuXHQgKiBAdHlwZWRlZiBGb250T3B0aW9uc1xuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHByb3BlcnR5IHtCb29sZWFufSBlbXB0eSAtIHdoZXRoZXIgdG8gY3JlYXRlIGEgbmV3IGVtcHR5IGZvbnRcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGZhbWlseU5hbWVcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IHN0eWxlTmFtZVxuXHQgKiBAcHJvcGVydHkge3N0cmluZz19IGZ1bGxOYW1lXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gcG9zdFNjcmlwdE5hbWVcblx0ICogQHByb3BlcnR5IHtzdHJpbmc9fSBkZXNpZ25lclxuXHQgKiBAcHJvcGVydHkge3N0cmluZz19IGRlc2lnbmVyVVJMXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbWFudWZhY3R1cmVyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbWFudWZhY3R1cmVyVVJMXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbGljZW5zZVxuXHQgKiBAcHJvcGVydHkge3N0cmluZz19IGxpY2Vuc2VVUkxcblx0ICogQHByb3BlcnR5IHtzdHJpbmc9fSB2ZXJzaW9uXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzY3JpcHRpb25cblx0ICogQHByb3BlcnR5IHtzdHJpbmc9fSBjb3B5cmlnaHRcblx0ICogQHByb3BlcnR5IHtzdHJpbmc9fSB0cmFkZW1hcmtcblx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IHVuaXRzUGVyRW1cblx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IGFzY2VuZGVyXG5cdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkZXNjZW5kZXJcblx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IGNyZWF0ZWRUaW1lc3RhbXBcblx0ICogQHByb3BlcnR5IHtzdHJpbmc9fSB3ZWlnaHRDbGFzc1xuXHQgKiBAcHJvcGVydHkge3N0cmluZz19IHdpZHRoQ2xhc3Ncblx0ICogQHByb3BlcnR5IHtzdHJpbmc9fSBmc1NlbGVjdGlvblxuXHQgKi9cblxuXHQvKipcblx0ICogQSBGb250IHJlcHJlc2VudHMgYSBsb2FkZWQgT3BlblR5cGUgZm9udCBmaWxlLlxuXHQgKiBJdCBjb250YWlucyBhIHNldCBvZiBnbHlwaHMgYW5kIG1ldGhvZHMgdG8gZHJhdyB0ZXh0IG9uIGEgZHJhd2luZyBjb250ZXh0LFxuXHQgKiBvciB0byBnZXQgYSBwYXRoIHJlcHJlc2VudGluZyB0aGUgdGV4dC5cblx0ICogQGV4cG9ydHMgb3BlbnR5cGUuRm9udFxuXHQgKiBAY2xhc3Ncblx0ICogQHBhcmFtIHtGb250T3B0aW9uc31cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBGb250KG9wdGlvbnMpIHtcblx0ICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgICAgb3B0aW9ucy50YWJsZXMgPSBvcHRpb25zLnRhYmxlcyB8fCB7fTtcblxuXHQgICAgaWYgKCFvcHRpb25zLmVtcHR5KSB7XG5cdCAgICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSd2ZSBwcm92aWRlZCB0aGUgbWluaW11bSBzZXQgb2YgbmFtZXMuXG5cdCAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLmZhbWlseU5hbWUsICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBmYW1pbHlOYW1lIGlzIHJlcXVpcmVkLicpO1xuXHQgICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy5zdHlsZU5hbWUsICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBzdHlsZU5hbWUgaXMgcmVxdWlyZWQuJyk7XG5cdCAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLnVuaXRzUGVyRW0sICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCB1bml0c1BlckVtIGlzIHJlcXVpcmVkLicpO1xuXHQgICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy5hc2NlbmRlciwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIGFzY2VuZGVyIGlzIHJlcXVpcmVkLicpO1xuXHQgICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy5kZXNjZW5kZXIgPD0gMCwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIG5lZ2F0aXZlIGRlc2NlbmRlciB2YWx1ZSBpcyByZXF1aXJlZC4nKTtcblxuXHQgICAgICAgIC8vIE9TIFggd2lsbCBjb21wbGFpbiBpZiB0aGUgbmFtZXMgYXJlIGVtcHR5LCBzbyB3ZSBwdXQgYSBzaW5nbGUgc3BhY2UgZXZlcnl3aGVyZSBieSBkZWZhdWx0LlxuXHQgICAgICAgIHRoaXMubmFtZXMgPSB7XG5cdCAgICAgICAgICAgIGZvbnRGYW1pbHk6IHtlbjogb3B0aW9ucy5mYW1pbHlOYW1lIHx8ICcgJ30sXG5cdCAgICAgICAgICAgIGZvbnRTdWJmYW1pbHk6IHtlbjogb3B0aW9ucy5zdHlsZU5hbWUgfHwgJyAnfSxcblx0ICAgICAgICAgICAgZnVsbE5hbWU6IHtlbjogb3B0aW9ucy5mdWxsTmFtZSB8fCBvcHRpb25zLmZhbWlseU5hbWUgKyAnICcgKyBvcHRpb25zLnN0eWxlTmFtZX0sXG5cdCAgICAgICAgICAgIC8vIHBvc3RTY3JpcHROYW1lIG1heSBub3QgY29udGFpbiBhbnkgd2hpdGVzcGFjZVxuXHQgICAgICAgICAgICBwb3N0U2NyaXB0TmFtZToge2VuOiBvcHRpb25zLnBvc3RTY3JpcHROYW1lIHx8IChvcHRpb25zLmZhbWlseU5hbWUgKyBvcHRpb25zLnN0eWxlTmFtZSkucmVwbGFjZSgvXFxzL2csICcnKX0sXG5cdCAgICAgICAgICAgIGRlc2lnbmVyOiB7ZW46IG9wdGlvbnMuZGVzaWduZXIgfHwgJyAnfSxcblx0ICAgICAgICAgICAgZGVzaWduZXJVUkw6IHtlbjogb3B0aW9ucy5kZXNpZ25lclVSTCB8fCAnICd9LFxuXHQgICAgICAgICAgICBtYW51ZmFjdHVyZXI6IHtlbjogb3B0aW9ucy5tYW51ZmFjdHVyZXIgfHwgJyAnfSxcblx0ICAgICAgICAgICAgbWFudWZhY3R1cmVyVVJMOiB7ZW46IG9wdGlvbnMubWFudWZhY3R1cmVyVVJMIHx8ICcgJ30sXG5cdCAgICAgICAgICAgIGxpY2Vuc2U6IHtlbjogb3B0aW9ucy5saWNlbnNlIHx8ICcgJ30sXG5cdCAgICAgICAgICAgIGxpY2Vuc2VVUkw6IHtlbjogb3B0aW9ucy5saWNlbnNlVVJMIHx8ICcgJ30sXG5cdCAgICAgICAgICAgIHZlcnNpb246IHtlbjogb3B0aW9ucy52ZXJzaW9uIHx8ICdWZXJzaW9uIDAuMSd9LFxuXHQgICAgICAgICAgICBkZXNjcmlwdGlvbjoge2VuOiBvcHRpb25zLmRlc2NyaXB0aW9uIHx8ICcgJ30sXG5cdCAgICAgICAgICAgIGNvcHlyaWdodDoge2VuOiBvcHRpb25zLmNvcHlyaWdodCB8fCAnICd9LFxuXHQgICAgICAgICAgICB0cmFkZW1hcms6IHtlbjogb3B0aW9ucy50cmFkZW1hcmsgfHwgJyAnfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy51bml0c1BlckVtID0gb3B0aW9ucy51bml0c1BlckVtIHx8IDEwMDA7XG5cdCAgICAgICAgdGhpcy5hc2NlbmRlciA9IG9wdGlvbnMuYXNjZW5kZXI7XG5cdCAgICAgICAgdGhpcy5kZXNjZW5kZXIgPSBvcHRpb25zLmRlc2NlbmRlcjtcblx0ICAgICAgICB0aGlzLmNyZWF0ZWRUaW1lc3RhbXAgPSBvcHRpb25zLmNyZWF0ZWRUaW1lc3RhbXA7XG5cdCAgICAgICAgdGhpcy50YWJsZXMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMudGFibGVzLCB7XG5cdCAgICAgICAgICAgIG9zMjogT2JqZWN0LmFzc2lnbih7XG5cdCAgICAgICAgICAgICAgICB1c1dlaWdodENsYXNzOiBvcHRpb25zLndlaWdodENsYXNzIHx8IHRoaXMudXNXZWlnaHRDbGFzc2VzLk1FRElVTSxcblx0ICAgICAgICAgICAgICAgIHVzV2lkdGhDbGFzczogb3B0aW9ucy53aWR0aENsYXNzIHx8IHRoaXMudXNXaWR0aENsYXNzZXMuTUVESVVNLFxuXHQgICAgICAgICAgICAgICAgZnNTZWxlY3Rpb246IG9wdGlvbnMuZnNTZWxlY3Rpb24gfHwgdGhpcy5mc1NlbGVjdGlvblZhbHVlcy5SRUdVTEFSLFxuXHQgICAgICAgICAgICB9LCBvcHRpb25zLnRhYmxlcy5vczIpXG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuc3VwcG9ydGVkID0gdHJ1ZTsgLy8gRGVwcmVjYXRlZDogcGFyc2VCdWZmZXIgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBmb250IGlzIG5vdCBzdXBwb3J0ZWQuXG5cdCAgICB0aGlzLmdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldCh0aGlzLCBvcHRpb25zLmdseXBocyB8fCBbXSk7XG5cdCAgICB0aGlzLmVuY29kaW5nID0gbmV3IERlZmF1bHRFbmNvZGluZyh0aGlzKTtcblx0ICAgIHRoaXMucG9zaXRpb24gPSBuZXcgUG9zaXRpb24odGhpcyk7XG5cdCAgICB0aGlzLnN1YnN0aXR1dGlvbiA9IG5ldyBTdWJzdGl0dXRpb24odGhpcyk7XG5cdCAgICB0aGlzLnRhYmxlcyA9IHRoaXMudGFibGVzIHx8IHt9O1xuXG5cdCAgICAvLyBuZWVkZWQgZm9yIGxvdyBtZW1vcnkgbW9kZSBvbmx5LlxuXHQgICAgdGhpcy5fcHVzaCA9IG51bGw7XG5cdCAgICB0aGlzLl9obXR4VGFibGVEYXRhID0ge307XG5cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaGludGluZycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5faGludGluZykgeyByZXR1cm4gdGhpcy5faGludGluZzsgfVxuXHQgICAgICAgICAgICBpZiAodGhpcy5vdXRsaW5lc0Zvcm1hdCA9PT0gJ3RydWV0eXBlJykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9oaW50aW5nID0gbmV3IEhpbnRpbmcodGhpcykpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhlIGZvbnQgaGFzIGEgZ2x5cGggZm9yIHRoZSBnaXZlbiBjaGFyYWN0ZXIuXG5cdCAqIEBwYXJhbSAge3N0cmluZ31cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdEZvbnQucHJvdG90eXBlLmhhc0NoYXIgPSBmdW5jdGlvbihjKSB7XG5cdCAgICByZXR1cm4gdGhpcy5lbmNvZGluZy5jaGFyVG9HbHlwaEluZGV4KGMpICE9PSBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgdG8gYSBzaW5nbGUgZ2x5cGggaW5kZXguXG5cdCAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGVyZSBpcyBhIG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuXG5cdCAqIHRoZSBnaXZlbiBjaGFyYWN0ZXIgYW5kIGEgZ2x5cGg7IGZvciBjb21wbGV4IHNjcmlwdHMgdGhpcyBtaWdodCBub3QgYmUgdGhlIGNhc2UuXG5cdCAqIEBwYXJhbSAge3N0cmluZ31cblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKHMpIHtcblx0ICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgocyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhlIGdpdmVuIGNoYXJhY3RlciB0byBhIHNpbmdsZSBHbHlwaCBvYmplY3QuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGVyZSBpcyBhIG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuXG5cdCAqIHRoZSBnaXZlbiBjaGFyYWN0ZXIgYW5kIGEgZ2x5cGg7IGZvciBjb21wbGV4IHNjcmlwdHMgdGhpcyBtaWdodCBub3QgYmUgdGhlIGNhc2UuXG5cdCAqIEBwYXJhbSAge3N0cmluZ31cblx0ICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaCA9IGZ1bmN0aW9uKGMpIHtcblx0ICAgIHZhciBnbHlwaEluZGV4ID0gdGhpcy5jaGFyVG9HbHlwaEluZGV4KGMpO1xuXHQgICAgdmFyIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KGdseXBoSW5kZXgpO1xuXHQgICAgaWYgKCFnbHlwaCkge1xuXHQgICAgICAgIC8vIC5ub3RkZWZcblx0ICAgICAgICBnbHlwaCA9IHRoaXMuZ2x5cGhzLmdldCgwKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGdseXBoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGUgZmVhdHVyZXNcblx0ICogQHBhcmFtIHthbnl9IG9wdGlvbnMgZmVhdHVyZXMgb3B0aW9uc1xuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUudXBkYXRlRmVhdHVyZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgLy8gVE9ETzogdXBkYXRlIGFsbCBmZWF0dXJlcyBvcHRpb25zIG5vdCBvbmx5ICdsYXRuJy5cblx0ICAgIHJldHVybiB0aGlzLmRlZmF1bHRSZW5kZXJPcHRpb25zLmZlYXR1cmVzLm1hcChmdW5jdGlvbiAoZmVhdHVyZSkge1xuXHQgICAgICAgIGlmIChmZWF0dXJlLnNjcmlwdCA9PT0gJ2xhdG4nKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBzY3JpcHQ6ICdsYXRuJyxcblx0ICAgICAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmUudGFncy5maWx0ZXIoZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gb3B0aW9uc1t0YWddOyB9KVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmZWF0dXJlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoZSBnaXZlbiB0ZXh0IHRvIGEgbGlzdCBvZiBHbHlwaCBvYmplY3RzLlxuXHQgKiBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gc3RyaWN0IG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuIGNoYXJhY3RlcnMgYW5kXG5cdCAqIGdseXBocywgc28gdGhlIGxpc3Qgb2YgcmV0dXJuZWQgZ2x5cGhzIGNhbiBiZSBsYXJnZXIgb3Igc21hbGxlciB0aGFuIHRoZVxuXHQgKiBsZW5ndGggb2YgdGhlIGdpdmVuIHN0cmluZy5cblx0ICogQHBhcmFtICB7c3RyaW5nfVxuXHQgKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnN9IFtvcHRpb25zXVxuXHQgKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaFtdfVxuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUuc3RyaW5nVG9HbHlwaHMgPSBmdW5jdGlvbihzLCBvcHRpb25zKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXG5cdCAgICB2YXIgYmlkaSA9IG5ldyBCaWRpKCk7XG5cblx0ICAgIC8vIENyZWF0ZSBhbmQgcmVnaXN0ZXIgJ2dseXBoSW5kZXgnIHN0YXRlIG1vZGlmaWVyXG5cdCAgICB2YXIgY2hhclRvR2x5cGhJbmRleE1vZCA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdGhpcyQxLmNoYXJUb0dseXBoSW5kZXgodG9rZW4uY2hhcik7IH07XG5cdCAgICBiaWRpLnJlZ2lzdGVyTW9kaWZpZXIoJ2dseXBoSW5kZXgnLCBudWxsLCBjaGFyVG9HbHlwaEluZGV4TW9kKTtcblxuXHQgICAgLy8gcm9sbC1iYWNrIHRvIGRlZmF1bHQgZmVhdHVyZXNcblx0ICAgIHZhciBmZWF0dXJlcyA9IG9wdGlvbnMgP1xuXHQgICAgdGhpcy51cGRhdGVGZWF0dXJlcyhvcHRpb25zLmZlYXR1cmVzKSA6XG5cdCAgICB0aGlzLmRlZmF1bHRSZW5kZXJPcHRpb25zLmZlYXR1cmVzO1xuXG5cdCAgICBiaWRpLmFwcGx5RmVhdHVyZXModGhpcywgZmVhdHVyZXMpO1xuXG5cdCAgICB2YXIgaW5kZXhlcyA9IGJpZGkuZ2V0VGV4dEdseXBocyhzKTtcblxuXHQgICAgdmFyIGxlbmd0aCA9IGluZGV4ZXMubGVuZ3RoO1xuXG5cdCAgICAvLyBjb252ZXJ0IGdseXBoIGluZGV4ZXMgdG8gZ2x5cGggb2JqZWN0c1xuXHQgICAgdmFyIGdseXBocyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHQgICAgdmFyIG5vdGRlZiA9IHRoaXMuZ2x5cGhzLmdldCgwKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICBnbHlwaHNbaV0gPSB0aGlzLmdseXBocy5nZXQoaW5kZXhlc1tpXSkgfHwgbm90ZGVmO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGdseXBocztcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtICB7c3RyaW5nfVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5uYW1lVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24obmFtZSkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2x5cGhOYW1lcy5uYW1lVG9HbHlwaEluZGV4KG5hbWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9XG5cdCAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUubmFtZVRvR2x5cGggPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICB2YXIgZ2x5cGhJbmRleCA9IHRoaXMubmFtZVRvR2x5cGhJbmRleChuYW1lKTtcblx0ICAgIHZhciBnbHlwaCA9IHRoaXMuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcblx0ICAgIGlmICghZ2x5cGgpIHtcblx0ICAgICAgICAvLyAubm90ZGVmXG5cdCAgICAgICAgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoMCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBnbHlwaDtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtICB7TnVtYmVyfVxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5nbHlwaEluZGV4VG9OYW1lID0gZnVuY3Rpb24oZ2lkKSB7XG5cdCAgICBpZiAoIXRoaXMuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuICcnO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5nbHlwaE5hbWVzLmdseXBoSW5kZXhUb05hbWUoZ2lkKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0cmlldmUgdGhlIHZhbHVlIG9mIHRoZSBrZXJuaW5nIHBhaXIgYmV0d2VlbiB0aGUgbGVmdCBnbHlwaCAob3IgaXRzIGluZGV4KVxuXHQgKiBhbmQgdGhlIHJpZ2h0IGdseXBoIChvciBpdHMgaW5kZXgpLiBJZiBubyBrZXJuaW5nIHBhaXIgaXMgZm91bmQsIHJldHVybiAwLlxuXHQgKiBUaGUga2VybmluZyB2YWx1ZSBnZXRzIGFkZGVkIHRvIHRoZSBhZHZhbmNlIHdpZHRoIHdoZW4gY2FsY3VsYXRpbmcgdGhlIHNwYWNpbmdcblx0ICogYmV0d2VlbiBnbHlwaHMuXG5cdCAqIEZvciBHUE9TIGtlcm5pbmcsIHRoaXMgbWV0aG9kIHVzZXMgdGhlIGRlZmF1bHQgc2NyaXB0IGFuZCBsYW5ndWFnZSwgd2hpY2ggY292ZXJzXG5cdCAqIG1vc3QgdXNlIGNhc2VzLiBUbyBoYXZlIGdyZWF0ZXIgY29udHJvbCwgdXNlIGZvbnQucG9zaXRpb24uZ2V0S2VybmluZ1ZhbHVlIC5cblx0ICogQHBhcmFtICB7b3BlbnR5cGUuR2x5cGh9IGxlZnRHbHlwaFxuXHQgKiBAcGFyYW0gIHtvcGVudHlwZS5HbHlwaH0gcmlnaHRHbHlwaFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5nZXRLZXJuaW5nVmFsdWUgPSBmdW5jdGlvbihsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIHtcblx0ICAgIGxlZnRHbHlwaCA9IGxlZnRHbHlwaC5pbmRleCB8fCBsZWZ0R2x5cGg7XG5cdCAgICByaWdodEdseXBoID0gcmlnaHRHbHlwaC5pbmRleCB8fCByaWdodEdseXBoO1xuXHQgICAgdmFyIGdwb3NLZXJuaW5nID0gdGhpcy5wb3NpdGlvbi5kZWZhdWx0S2VybmluZ1RhYmxlcztcblx0ICAgIGlmIChncG9zS2VybmluZykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLmdldEtlcm5pbmdWYWx1ZShncG9zS2VybmluZywgbGVmdEdseXBoLCByaWdodEdseXBoKTtcblx0ICAgIH1cblx0ICAgIC8vIFwia2VyblwiIHRhYmxlXG5cdCAgICByZXR1cm4gdGhpcy5rZXJuaW5nUGFpcnNbbGVmdEdseXBoICsgJywnICsgcmlnaHRHbHlwaF0gfHwgMDtcblx0fTtcblxuXHQvKipcblx0ICogQHR5cGVkZWYgR2x5cGhSZW5kZXJPcHRpb25zXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW3NjcmlwdF0gLSBzY3JpcHQgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZmVhdHVyZXMgdG8gYXBwbHkuIEJ5IGRlZmF1bHQsICdERkxUJyBvciAnbGF0bicgaXMgdXNlZC5cblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMvc2NyaXB0dGFncy5odG1cblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddIC0gbGFuZ3VhZ2Ugc3lzdGVtIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGZlYXR1cmVzIHRvIGFwcGx5LlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L2RldmVsb3BlcnMvb3BlbnR5cGUvbGFuZ3VhZ2V0YWdzLmFzcHhcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBba2VybmluZz10cnVlXSAtIHdoZXRoZXIgdG8gaW5jbHVkZSBrZXJuaW5nIHZhbHVlc1xuXHQgKiBAcHJvcGVydHkge29iamVjdH0gW2ZlYXR1cmVzXSAtIE9wZW5UeXBlIExheW91dCBmZWF0dXJlIHRhZ3MuIFVzZWQgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGZlYXR1cmVzIG9mIHRoZSBnaXZlbiBzY3JpcHQvbGFuZ3VhZ2Ugc3lzdGVtLlxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL2ZlYXR1cmV0YWdzLmh0bVxuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUuZGVmYXVsdFJlbmRlck9wdGlvbnMgPSB7XG5cdCAgICBrZXJuaW5nOiB0cnVlLFxuXHQgICAgZmVhdHVyZXM6IFtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiB0aGVzZSA0IGZlYXR1cmVzIGFyZSByZXF1aXJlZCB0byByZW5kZXIgQXJhYmljIHRleHQgcHJvcGVybHlcblx0ICAgICAgICAgKiBhbmQgc2hvdWxkbid0IGJlIHR1cm5lZCBvZmYgd2hlbiByZW5kZXJpbmcgYXJhYmljIHRleHQuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgeyBzY3JpcHQ6ICdhcmFiJywgdGFnczogWydpbml0JywgJ21lZGknLCAnZmluYScsICdybGlnJ10gfSxcblx0ICAgICAgICB7IHNjcmlwdDogJ2xhdG4nLCB0YWdzOiBbJ2xpZ2EnLCAncmxpZyddIH1cblx0ICAgIF1cblx0fTtcblxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGVhY2ggZ2x5cGggaW4gdGhlIGdpdmVuIHRleHQuXG5cdCAqIFRoZSBjYWxsYmFjayBnZXRzIGAoZ2x5cGgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKWAuKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBhcHBseS5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuXHQgKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG5cdCAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUuZm9yRWFjaEdseXBoID0gZnVuY3Rpb24odGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdCAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG5cdCAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG5cdCAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDcyO1xuXHQgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFJlbmRlck9wdGlvbnMsIG9wdGlvbnMpO1xuXHQgICAgdmFyIGZvbnRTY2FsZSA9IDEgLyB0aGlzLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcblx0ICAgIHZhciBnbHlwaHMgPSB0aGlzLnN0cmluZ1RvR2x5cGhzKHRleHQsIG9wdGlvbnMpO1xuXHQgICAgdmFyIGtlcm5pbmdMb29rdXBzO1xuXHQgICAgaWYgKG9wdGlvbnMua2VybmluZykge1xuXHQgICAgICAgIHZhciBzY3JpcHQgPSBvcHRpb25zLnNjcmlwdCB8fCB0aGlzLnBvc2l0aW9uLmdldERlZmF1bHRTY3JpcHROYW1lKCk7XG5cdCAgICAgICAga2VybmluZ0xvb2t1cHMgPSB0aGlzLnBvc2l0aW9uLmdldEtlcm5pbmdUYWJsZXMoc2NyaXB0LCBvcHRpb25zLmxhbmd1YWdlKTtcblx0ICAgIH1cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuXHQgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZ2x5cGgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKTtcblx0ICAgICAgICBpZiAoZ2x5cGguYWR2YW5jZVdpZHRoKSB7XG5cdCAgICAgICAgICAgIHggKz0gZ2x5cGguYWR2YW5jZVdpZHRoICogZm9udFNjYWxlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChvcHRpb25zLmtlcm5pbmcgJiYgaSA8IGdseXBocy5sZW5ndGggLSAxKSB7XG5cdCAgICAgICAgICAgIC8vIFdlIHNob3VsZCBhcHBseSBwb3NpdGlvbiBhZGp1c3RtZW50IGxvb2t1cHMgaW4gYSBtb3JlIGdlbmVyaWMgd2F5LlxuXHQgICAgICAgICAgICAvLyBIZXJlIHdlIG9ubHkgdXNlIHRoZSB4QWR2YW5jZSB2YWx1ZS5cblx0ICAgICAgICAgICAgdmFyIGtlcm5pbmdWYWx1ZSA9IGtlcm5pbmdMb29rdXBzID9cblx0ICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5nZXRLZXJuaW5nVmFsdWUoa2VybmluZ0xvb2t1cHMsIGdseXBoLmluZGV4LCBnbHlwaHNbaSArIDFdLmluZGV4KSA6XG5cdCAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0S2VybmluZ1ZhbHVlKGdseXBoLCBnbHlwaHNbaSArIDFdKTtcblx0ICAgICAgICAgICAgeCArPSBrZXJuaW5nVmFsdWUgKiBmb250U2NhbGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMubGV0dGVyU3BhY2luZykge1xuXHQgICAgICAgICAgICB4ICs9IG9wdGlvbnMubGV0dGVyU3BhY2luZyAqIGZvbnRTaXplO1xuXHQgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy50cmFja2luZykge1xuXHQgICAgICAgICAgICB4ICs9IChvcHRpb25zLnRyYWNraW5nIC8gMTAwMCkgKiBmb250U2l6ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4geDtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cblx0ICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuXHQgKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRofVxuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG5cdCAgICB2YXIgZnVsbFBhdGggPSBuZXcgUGF0aCgpO1xuXHQgICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuXHQgICAgICAgIHZhciBnbHlwaFBhdGggPSBnbHlwaC5nZXRQYXRoKGdYLCBnWSwgZ0ZvbnRTaXplLCBvcHRpb25zLCB0aGlzKTtcblx0ICAgICAgICBmdWxsUGF0aC5leHRlbmQoZ2x5cGhQYXRoKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIGZ1bGxQYXRoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gYXJyYXkgb2YgUGF0aCBvYmplY3RzIHRoYXQgcmVwcmVzZW50IHRoZSBnbHlwaHMgb2YgYSBnaXZlbiB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cblx0ICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuXHQgKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRoW119XG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5nZXRQYXRocyA9IGZ1bmN0aW9uKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG5cdCAgICB2YXIgZ2x5cGhQYXRocyA9IFtdO1xuXHQgICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuXHQgICAgICAgIHZhciBnbHlwaFBhdGggPSBnbHlwaC5nZXRQYXRoKGdYLCBnWSwgZ0ZvbnRTaXplLCBvcHRpb25zLCB0aGlzKTtcblx0ICAgICAgICBnbHlwaFBhdGhzLnB1c2goZ2x5cGhQYXRoKTtcblx0ICAgIH0pO1xuXG5cdCAgICByZXR1cm4gZ2x5cGhQYXRocztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYWR2YW5jZSB3aWR0aCBvZiBhIHRleHQuXG5cdCAqXG5cdCAqIFRoaXMgaXMgc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIFBhdGguZ2V0Qm91bmRpbmdCb3goKSBhcyBmb3IgZXhhbXBsZSBhXG5cdCAqIHN1ZmZpeGVkIHdoaXRlc3BhY2UgaW5jcmVhc2VzIHRoZSBhZHZhbmNlV2lkdGggYnV0IG5vdCB0aGUgYm91bmRpbmcgYm94XG5cdCAqIG9yIGFuIG92ZXJoYW5naW5nIGxldHRlciBsaWtlIGEgY2FsbGlncmFwaGljICdmJyBtaWdodCBoYXZlIGEgcXVpdGUgbGFyZ2VyXG5cdCAqIGJvdW5kaW5nIGJveCB0aGFuIGl0cyBhZHZhbmNlIHdpZHRoLlxuXHQgKlxuXHQgKiBUaGlzIGNvcnJlc3BvbmRzIHRvIGNhbnZhczJkQ29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aFxuXHQgKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG5cdCAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcblx0ICogQHJldHVybiBhZHZhbmNlIHdpZHRoXG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5nZXRBZHZhbmNlV2lkdGggPSBmdW5jdGlvbih0ZXh0LCBmb250U2l6ZSwgb3B0aW9ucykge1xuXHQgICAgcmV0dXJuIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIDAsIDAsIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbigpIHt9KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhdyB0aGUgdGV4dCBvbiB0aGUgZ2l2ZW4gZHJhd2luZyBjb250ZXh0LlxuXHQgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cblx0ICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG5cdCAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcblx0ICovXG5cdEZvbnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG5cdCAgICB0aGlzLmdldFBhdGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpLmRyYXcoY3R4KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhdyB0aGUgcG9pbnRzIG9mIGFsbCBnbHlwaHMgaW4gdGhlIHRleHQuXG5cdCAqIE9uLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIGJsdWUsIG9mZi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiByZWQuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG5cdCAqIEBwYXJhbSB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUuZHJhd1BvaW50cyA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcblx0ICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbihnbHlwaCwgZ1gsIGdZLCBnRm9udFNpemUpIHtcblx0ICAgICAgICBnbHlwaC5kcmF3UG9pbnRzKGN0eCwgZ1gsIGdZLCBnRm9udFNpemUpO1xuXHQgICAgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXcgbGluZXMgaW5kaWNhdGluZyBpbXBvcnRhbnQgZm9udCBtZWFzdXJlbWVudHMgZm9yIGFsbCBnbHlwaHMgaW4gdGhlIHRleHQuXG5cdCAqIEJsYWNrIGxpbmVzIGluZGljYXRlIHRoZSBvcmlnaW4gb2YgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIChwb2ludCAwLDApLlxuXHQgKiBCbHVlIGxpbmVzIGluZGljYXRlIHRoZSBnbHlwaCBib3VuZGluZyBib3guXG5cdCAqIEdyZWVuIGxpbmUgaW5kaWNhdGVzIHRoZSBhZHZhbmNlIHdpZHRoIG9mIHRoZSBnbHlwaC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cblx0ICogQHBhcmFtIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5kcmF3TWV0cmljcyA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcblx0ICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbihnbHlwaCwgZ1gsIGdZLCBnRm9udFNpemUpIHtcblx0ICAgICAgICBnbHlwaC5kcmF3TWV0cmljcyhjdHgsIGdYLCBnWSwgZ0ZvbnRTaXplKTtcblx0ICAgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9XG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdEZvbnQucHJvdG90eXBlLmdldEVuZ2xpc2hOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuXHQgICAgdmFyIHRyYW5zbGF0aW9ucyA9IHRoaXMubmFtZXNbbmFtZV07XG5cdCAgICBpZiAodHJhbnNsYXRpb25zKSB7XG5cdCAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9ucy5lbjtcblx0ICAgIH1cblx0fTtcblxuXHQvKipcblx0ICogVmFsaWRhdGVcblx0ICovXG5cdEZvbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdCAgICBmdW5jdGlvbiBhc3NlcnQocHJlZGljYXRlLCBtZXNzYWdlKSB7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGFzc2VydE5hbWVQcmVzZW50KG5hbWUpIHtcblx0ICAgICAgICB2YXIgZW5nbGlzaE5hbWUgPSBfdGhpcy5nZXRFbmdsaXNoTmFtZShuYW1lKTtcblx0ICAgICAgICBhc3NlcnQoZW5nbGlzaE5hbWUgJiYgZW5nbGlzaE5hbWUudHJpbSgpLmxlbmd0aCA+IDApO1xuXHQgICAgfVxuXG5cdCAgICAvLyBJZGVudGlmaWNhdGlvbiBpbmZvcm1hdGlvblxuXHQgICAgYXNzZXJ0TmFtZVByZXNlbnQoJ2ZvbnRGYW1pbHknKTtcblx0ICAgIGFzc2VydE5hbWVQcmVzZW50KCd3ZWlnaHROYW1lJyk7XG5cdCAgICBhc3NlcnROYW1lUHJlc2VudCgnbWFudWZhY3R1cmVyJyk7XG5cdCAgICBhc3NlcnROYW1lUHJlc2VudCgnY29weXJpZ2h0Jyk7XG5cdCAgICBhc3NlcnROYW1lUHJlc2VudCgndmVyc2lvbicpO1xuXG5cdCAgICAvLyBEaW1lbnNpb24gaW5mb3JtYXRpb25cblx0ICAgIGFzc2VydCh0aGlzLnVuaXRzUGVyRW0gPiAwKTtcblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydCB0aGUgZm9udCBvYmplY3QgdG8gYSBTRk5UIGRhdGEgc3RydWN0dXJlLlxuXHQgKiBUaGlzIHN0cnVjdHVyZSBjb250YWlucyBhbGwgdGhlIG5lY2Vzc2FyeSB0YWJsZXMgYW5kIG1ldGFkYXRhIHRvIGNyZWF0ZSBhIGJpbmFyeSBPVEYgZmlsZS5cblx0ICogQHJldHVybiB7b3BlbnR5cGUuVGFibGV9XG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS50b1RhYmxlcyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHNmbnQuZm9udFRvVGFibGUodGhpcyk7XG5cdH07XG5cdC8qKlxuXHQgKiBAZGVwcmVjYXRlZCBGb250LnRvQnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBGb250LnRvQXJyYXlCdWZmZXIgaW5zdGVhZC5cblx0ICovXG5cdEZvbnQucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oKSB7XG5cdCAgICBjb25zb2xlLndhcm4oJ0ZvbnQudG9CdWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIEZvbnQudG9BcnJheUJ1ZmZlciBpbnN0ZWFkLicpO1xuXHQgICAgcmV0dXJuIHRoaXMudG9BcnJheUJ1ZmZlcigpO1xuXHR9O1xuXHQvKipcblx0ICogQ29udmVydHMgYSBgb3BlbnR5cGUuRm9udGAgaW50byBhbiBgQXJyYXlCdWZmZXJgXG5cdCAqIEByZXR1cm4ge0FycmF5QnVmZmVyfVxuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHNmbnRUYWJsZSA9IHRoaXMudG9UYWJsZXMoKTtcblx0ICAgIHZhciBieXRlcyA9IHNmbnRUYWJsZS5lbmNvZGUoKTtcblx0ICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMubGVuZ3RoKTtcblx0ICAgIHZhciBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaW50QXJyYXlbaV0gPSBieXRlc1tpXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGJ1ZmZlcjtcblx0fTtcblxuXHQvKipcblx0ICogSW5pdGlhdGUgYSBkb3dubG9hZCBvZiB0aGUgT3BlblR5cGUgZm9udC5cblx0ICovXG5cdEZvbnQucHJvdG90eXBlLmRvd25sb2FkID0gZnVuY3Rpb24oZmlsZU5hbWUpIHtcblx0ICAgIHZhciBmYW1pbHlOYW1lID0gdGhpcy5nZXRFbmdsaXNoTmFtZSgnZm9udEZhbWlseScpO1xuXHQgICAgdmFyIHN0eWxlTmFtZSA9IHRoaXMuZ2V0RW5nbGlzaE5hbWUoJ2ZvbnRTdWJmYW1pbHknKTtcblx0ICAgIGZpbGVOYW1lID0gZmlsZU5hbWUgfHwgZmFtaWx5TmFtZS5yZXBsYWNlKC9cXHMvZywgJycpICsgJy0nICsgc3R5bGVOYW1lICsgJy5vdGYnO1xuXHQgICAgdmFyIGFycmF5QnVmZmVyID0gdGhpcy50b0FycmF5QnVmZmVyKCk7XG5cblx0ICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuXHQgICAgICAgIHdpbmRvdy5VUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG5cblx0ICAgICAgICBpZiAod2luZG93LlVSTCkge1xuXHQgICAgICAgICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuXHQgICAgICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtkYXRhVmlld10sIHt0eXBlOiAnZm9udC9vcGVudHlwZSd9KTtcblxuXHQgICAgICAgICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0ICAgICAgICAgICAgbGluay5ocmVmID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cdCAgICAgICAgICAgIGxpbmsuZG93bmxvYWQgPSBmaWxlTmFtZTtcblxuXHQgICAgICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblx0ICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KCdjbGljaycsIHRydWUsIGZhbHNlKTtcblx0ICAgICAgICAgICAgbGluay5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZvbnQgZmlsZSBjb3VsZCBub3QgYmUgZG93bmxvYWRlZC4gVHJ5IHVzaW5nIGEgZGlmZmVyZW50IGJyb3dzZXIuJyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXHQgICAgICAgIHZhciBidWZmZXIgPSBhcnJheUJ1ZmZlclRvTm9kZUJ1ZmZlcihhcnJheUJ1ZmZlcik7XG5cdCAgICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlTmFtZSwgYnVmZmVyKTtcblx0ICAgIH1cblx0fTtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5mc1NlbGVjdGlvblZhbHVlcyA9IHtcblx0ICAgIElUQUxJQzogICAgICAgICAgICAgIDB4MDAxLCAvLzFcblx0ICAgIFVOREVSU0NPUkU6ICAgICAgICAgIDB4MDAyLCAvLzJcblx0ICAgIE5FR0FUSVZFOiAgICAgICAgICAgIDB4MDA0LCAvLzRcblx0ICAgIE9VVExJTkVEOiAgICAgICAgICAgIDB4MDA4LCAvLzhcblx0ICAgIFNUUklLRU9VVDogICAgICAgICAgIDB4MDEwLCAvLzE2XG5cdCAgICBCT0xEOiAgICAgICAgICAgICAgICAweDAyMCwgLy8zMlxuXHQgICAgUkVHVUxBUjogICAgICAgICAgICAgMHgwNDAsIC8vNjRcblx0ICAgIFVTRVJfVFlQT19NRVRSSUNTOiAgIDB4MDgwLCAvLzEyOFxuXHQgICAgV1dTOiAgICAgICAgICAgICAgICAgMHgxMDAsIC8vMjU2XG5cdCAgICBPQkxJUVVFOiAgICAgICAgICAgICAweDIwMCAgLy81MTJcblx0fTtcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdEZvbnQucHJvdG90eXBlLnVzV2lkdGhDbGFzc2VzID0ge1xuXHQgICAgVUxUUkFfQ09OREVOU0VEOiAxLFxuXHQgICAgRVhUUkFfQ09OREVOU0VEOiAyLFxuXHQgICAgQ09OREVOU0VEOiAzLFxuXHQgICAgU0VNSV9DT05ERU5TRUQ6IDQsXG5cdCAgICBNRURJVU06IDUsXG5cdCAgICBTRU1JX0VYUEFOREVEOiA2LFxuXHQgICAgRVhQQU5ERUQ6IDcsXG5cdCAgICBFWFRSQV9FWFBBTkRFRDogOCxcblx0ICAgIFVMVFJBX0VYUEFOREVEOiA5XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS51c1dlaWdodENsYXNzZXMgPSB7XG5cdCAgICBUSElOOiAxMDAsXG5cdCAgICBFWFRSQV9MSUdIVDogMjAwLFxuXHQgICAgTElHSFQ6IDMwMCxcblx0ICAgIE5PUk1BTDogNDAwLFxuXHQgICAgTUVESVVNOiA1MDAsXG5cdCAgICBTRU1JX0JPTEQ6IDYwMCxcblx0ICAgIEJPTEQ6IDcwMCxcblx0ICAgIEVYVFJBX0JPTEQ6IDgwMCxcblx0ICAgIEJMQUNLOiAgICA5MDBcblx0fTtcblxuXHQvLyBUaGUgYGZ2YXJgIHRhYmxlIHN0b3JlcyBmb250IHZhcmlhdGlvbiBheGVzIGFuZCBpbnN0YW5jZXMuXG5cblx0ZnVuY3Rpb24gYWRkTmFtZShuYW1lLCBuYW1lcykge1xuXHQgICAgdmFyIG5hbWVTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShuYW1lKTtcblx0ICAgIHZhciBuYW1lSUQgPSAyNTY7XG5cdCAgICBmb3IgKHZhciBuYW1lS2V5IGluIG5hbWVzKSB7XG5cdCAgICAgICAgdmFyIG4gPSBwYXJzZUludChuYW1lS2V5KTtcblx0ICAgICAgICBpZiAoIW4gfHwgbiA8IDI1Nikge1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkobmFtZXNbbmFtZUtleV0pID09PSBuYW1lU3RyaW5nKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChuYW1lSUQgPD0gbikge1xuXHQgICAgICAgICAgICBuYW1lSUQgPSBuICsgMTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIG5hbWVzW25hbWVJRF0gPSBuYW1lO1xuXHQgICAgcmV0dXJuIG5hbWVJRDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VGdmFyQXhpcyhuLCBheGlzLCBuYW1lcykge1xuXHQgICAgdmFyIG5hbWVJRCA9IGFkZE5hbWUoYXhpcy5uYW1lLCBuYW1lcyk7XG5cdCAgICByZXR1cm4gW1xuXHQgICAgICAgIHtuYW1lOiAndGFnXycgKyBuLCB0eXBlOiAnVEFHJywgdmFsdWU6IGF4aXMudGFnfSxcblx0ICAgICAgICB7bmFtZTogJ21pblZhbHVlXycgKyBuLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogYXhpcy5taW5WYWx1ZSA8PCAxNn0sXG5cdCAgICAgICAge25hbWU6ICdkZWZhdWx0VmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLmRlZmF1bHRWYWx1ZSA8PCAxNn0sXG5cdCAgICAgICAge25hbWU6ICdtYXhWYWx1ZV8nICsgbiwgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IGF4aXMubWF4VmFsdWUgPDwgMTZ9LFxuXHQgICAgICAgIHtuYW1lOiAnZmxhZ3NfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICduYW1lSURfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfVxuXHQgICAgXTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlRnZhckF4aXMoZGF0YSwgc3RhcnQsIG5hbWVzKSB7XG5cdCAgICB2YXIgYXhpcyA9IHt9O1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIGF4aXMudGFnID0gcC5wYXJzZVRhZygpO1xuXHQgICAgYXhpcy5taW5WYWx1ZSA9IHAucGFyc2VGaXhlZCgpO1xuXHQgICAgYXhpcy5kZWZhdWx0VmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcblx0ICAgIGF4aXMubWF4VmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcblx0ICAgIHAuc2tpcCgndVNob3J0JywgMSk7ICAvLyByZXNlcnZlZCBmb3IgZmxhZ3M7IG5vIHZhbHVlcyBkZWZpbmVkXG5cdCAgICBheGlzLm5hbWUgPSBuYW1lc1twLnBhcnNlVVNob3J0KCldIHx8IHt9O1xuXHQgICAgcmV0dXJuIGF4aXM7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlRnZhckluc3RhbmNlKG4sIGluc3QsIGF4ZXMsIG5hbWVzKSB7XG5cdCAgICB2YXIgbmFtZUlEID0gYWRkTmFtZShpbnN0Lm5hbWUsIG5hbWVzKTtcblx0ICAgIHZhciBmaWVsZHMgPSBbXG5cdCAgICAgICAge25hbWU6ICduYW1lSURfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfSxcblx0ICAgICAgICB7bmFtZTogJ2ZsYWdzXycgKyBuLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG5cdCAgICBdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICB2YXIgYXhpc1RhZyA9IGF4ZXNbaV0udGFnO1xuXHQgICAgICAgIGZpZWxkcy5wdXNoKHtcblx0ICAgICAgICAgICAgbmFtZTogJ2F4aXNfJyArIG4gKyAnICcgKyBheGlzVGFnLFxuXHQgICAgICAgICAgICB0eXBlOiAnRklYRUQnLFxuXHQgICAgICAgICAgICB2YWx1ZTogaW5zdC5jb29yZGluYXRlc1theGlzVGFnXSA8PCAxNlxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmllbGRzO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VGdmFySW5zdGFuY2UoZGF0YSwgc3RhcnQsIGF4ZXMsIG5hbWVzKSB7XG5cdCAgICB2YXIgaW5zdCA9IHt9O1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIGluc3QubmFtZSA9IG5hbWVzW3AucGFyc2VVU2hvcnQoKV0gfHwge307XG5cdCAgICBwLnNraXAoJ3VTaG9ydCcsIDEpOyAgLy8gcmVzZXJ2ZWQgZm9yIGZsYWdzOyBubyB2YWx1ZXMgZGVmaW5lZFxuXG5cdCAgICBpbnN0LmNvb3JkaW5hdGVzID0ge307XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICBpbnN0LmNvb3JkaW5hdGVzW2F4ZXNbaV0udGFnXSA9IHAucGFyc2VGaXhlZCgpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gaW5zdDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VGdmFyVGFibGUoZnZhciwgbmFtZXMpIHtcblx0ICAgIHZhciByZXN1bHQgPSBuZXcgdGFibGUuVGFibGUoJ2Z2YXInLCBbXG5cdCAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB4MTAwMDB9LFxuXHQgICAgICAgIHtuYW1lOiAnb2Zmc2V0VG9EYXRhJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2NvdW50U2l6ZVBhaXJzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAyfSxcblx0ICAgICAgICB7bmFtZTogJ2F4aXNDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZnZhci5heGVzLmxlbmd0aH0sXG5cdCAgICAgICAge25hbWU6ICdheGlzU2l6ZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMjB9LFxuXHQgICAgICAgIHtuYW1lOiAnaW5zdGFuY2VDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZnZhci5pbnN0YW5jZXMubGVuZ3RofSxcblx0ICAgICAgICB7bmFtZTogJ2luc3RhbmNlU2l6ZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogNCArIGZ2YXIuYXhlcy5sZW5ndGggKiA0fVxuXHQgICAgXSk7XG5cdCAgICByZXN1bHQub2Zmc2V0VG9EYXRhID0gcmVzdWx0LnNpemVPZigpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ2YXIuYXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHJlc3VsdC5maWVsZHMgPSByZXN1bHQuZmllbGRzLmNvbmNhdChtYWtlRnZhckF4aXMoaSwgZnZhci5heGVzW2ldLCBuYW1lcykpO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZ2YXIuaW5zdGFuY2VzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgcmVzdWx0LmZpZWxkcyA9IHJlc3VsdC5maWVsZHMuY29uY2F0KG1ha2VGdmFySW5zdGFuY2UoaiwgZnZhci5pbnN0YW5jZXNbal0sIGZ2YXIuYXhlcywgbmFtZXMpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlRnZhclRhYmxlKGRhdGEsIHN0YXJ0LCBuYW1lcykge1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMHgwMDAxMDAwMCwgJ1Vuc3VwcG9ydGVkIGZ2YXIgdGFibGUgdmVyc2lvbi4nKTtcblx0ICAgIHZhciBvZmZzZXRUb0RhdGEgPSBwLnBhcnNlT2Zmc2V0MTYoKTtcblx0ICAgIC8vIFNraXAgY291bnRTaXplUGFpcnMuXG5cdCAgICBwLnNraXAoJ3VTaG9ydCcsIDEpO1xuXHQgICAgdmFyIGF4aXNDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIHZhciBheGlzU2l6ZSA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIHZhciBpbnN0YW5jZUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgdmFyIGluc3RhbmNlU2l6ZSA9IHAucGFyc2VVU2hvcnQoKTtcblxuXHQgICAgdmFyIGF4ZXMgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhpc0NvdW50OyBpKyspIHtcblx0ICAgICAgICBheGVzLnB1c2gocGFyc2VGdmFyQXhpcyhkYXRhLCBzdGFydCArIG9mZnNldFRvRGF0YSArIGkgKiBheGlzU2l6ZSwgbmFtZXMpKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGluc3RhbmNlcyA9IFtdO1xuXHQgICAgdmFyIGluc3RhbmNlU3RhcnQgPSBzdGFydCArIG9mZnNldFRvRGF0YSArIGF4aXNDb3VudCAqIGF4aXNTaXplO1xuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnN0YW5jZUNvdW50OyBqKyspIHtcblx0ICAgICAgICBpbnN0YW5jZXMucHVzaChwYXJzZUZ2YXJJbnN0YW5jZShkYXRhLCBpbnN0YW5jZVN0YXJ0ICsgaiAqIGluc3RhbmNlU2l6ZSwgYXhlcywgbmFtZXMpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHtheGVzOiBheGVzLCBpbnN0YW5jZXM6IGluc3RhbmNlc307XG5cdH1cblxuXHR2YXIgZnZhciA9IHsgbWFrZTogbWFrZUZ2YXJUYWJsZSwgcGFyc2U6IHBhcnNlRnZhclRhYmxlIH07XG5cblx0Ly8gVGhlIGBHREVGYCB0YWJsZSBjb250YWlucyB2YXJpb3VzIGdseXBoIHByb3BlcnRpZXNcblxuXHR2YXIgYXR0YWNoTGlzdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcblx0ICAgICAgICBhdHRhY2hQb2ludHM6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci51U2hvcnRMaXN0KSlcblx0ICAgIH07XG5cdH07XG5cblx0dmFyIGNhcmV0VmFsdWUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBmb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICBjaGVjay5hcmd1bWVudChmb3JtYXQgPT09IDEgfHwgZm9ybWF0ID09PSAyIHx8IGZvcm1hdCA9PT0gMyxcblx0ICAgICAgICAnVW5zdXBwb3J0ZWQgQ2FyZXRWYWx1ZSB0YWJsZSB2ZXJzaW9uLicpO1xuXHQgICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiB7IGNvb3JkaW5hdGU6IHRoaXMucGFyc2VTaG9ydCgpIH07XG5cdCAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuXHQgICAgICAgIHJldHVybiB7IHBvaW50aW5kZXg6IHRoaXMucGFyc2VTaG9ydCgpIH07XG5cdCAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMykge1xuXHQgICAgICAgIC8vIERldmljZSAvIFZhcmlhdGlvbiBJbmRleCB0YWJsZXMgdW5zdXBwb3J0ZWRcblx0ICAgICAgICByZXR1cm4geyBjb29yZGluYXRlOiB0aGlzLnBhcnNlU2hvcnQoKSB9O1xuXHQgICAgfVxuXHR9O1xuXG5cdHZhciBsaWdHbHlwaCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKGNhcmV0VmFsdWUpKTtcblx0fTtcblxuXHR2YXIgbGlnQ2FyZXRMaXN0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuXHQgICAgICAgIGxpZ0dseXBoczogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIobGlnR2x5cGgpKVxuXHQgICAgfTtcblx0fTtcblxuXHR2YXIgbWFya0dseXBoU2V0cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5wYXJzZVVTaG9ydCgpOyAvLyBWZXJzaW9uXG5cdCAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gcGFyc2VHREVGVGFibGUoZGF0YSwgc3RhcnQpIHtcblx0ICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcblx0ICAgIHZhciBwID0gbmV3IFBhcnNlcihkYXRhLCBzdGFydCk7XG5cdCAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oMSk7XG5cdCAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEgfHwgdGFibGVWZXJzaW9uID09PSAxLjIgfHwgdGFibGVWZXJzaW9uID09PSAxLjMsXG5cdCAgICAgICAgJ1Vuc3VwcG9ydGVkIEdERUYgdGFibGUgdmVyc2lvbi4nKTtcblx0ICAgIHZhciBnZGVmID0ge1xuXHQgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcblx0ICAgICAgICBjbGFzc0RlZjogcC5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcblx0ICAgICAgICBhdHRhY2hMaXN0OiBwLnBhcnNlUG9pbnRlcihhdHRhY2hMaXN0KSxcblx0ICAgICAgICBsaWdDYXJldExpc3Q6IHAucGFyc2VQb2ludGVyKGxpZ0NhcmV0TGlzdCksXG5cdCAgICAgICAgbWFya0F0dGFjaENsYXNzRGVmOiBwLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpXG5cdCAgICB9O1xuXHQgICAgaWYgKHRhYmxlVmVyc2lvbiA+PSAxLjIpIHtcblx0ICAgICAgICBnZGVmLm1hcmtHbHlwaFNldHMgPSBwLnBhcnNlUG9pbnRlcihtYXJrR2x5cGhTZXRzKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBnZGVmO1xuXHR9XG5cdHZhciBnZGVmID0geyBwYXJzZTogcGFyc2VHREVGVGFibGUgfTtcblxuXHQvLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cblxuXHR2YXIgc3VidGFibGVQYXJzZXJzJDEgPSBuZXcgQXJyYXkoMTApOyAgICAgICAgIC8vIHN1YnRhYmxlUGFyc2Vyc1swXSBpcyB1bnVzZWRcblxuXHQvLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3BvcyNsb29rdXAtdHlwZS0xLXNpbmdsZS1hZGp1c3RtZW50LXBvc2l0aW9uaW5nLXN1YnRhYmxlXG5cdC8vIHRoaXMgPSBQYXJzZXIgaW5zdGFuY2Vcblx0c3VidGFibGVQYXJzZXJzJDFbMV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDEoKSB7XG5cdCAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG5cdCAgICB2YXIgcG9zZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgaWYgKHBvc2Zvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHBvc0Zvcm1hdDogMSxcblx0ICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG5cdCAgICAgICAgICAgIHZhbHVlOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQoKVxuXHQgICAgICAgIH07XG5cdCAgICB9IGVsc2UgaWYgKHBvc2Zvcm1hdCA9PT0gMikge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHBvc0Zvcm1hdDogMixcblx0ICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG5cdCAgICAgICAgICAgIHZhbHVlczogdGhpcy5wYXJzZVZhbHVlUmVjb3JkTGlzdCgpXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IEdQT1MgbG9va3VwIHR5cGUgMSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG5cdH07XG5cblx0Ly8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3MjbG9va3VwLXR5cGUtMi1wYWlyLWFkanVzdG1lbnQtcG9zaXRpb25pbmctc3VidGFibGVcblx0c3VidGFibGVQYXJzZXJzJDFbMl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDIoKSB7XG5cdCAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG5cdCAgICB2YXIgcG9zRm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgY2hlY2suYXNzZXJ0KHBvc0Zvcm1hdCA9PT0gMSB8fCBwb3NGb3JtYXQgPT09IDIsICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBHUE9TIGxvb2t1cCB0eXBlIDIgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xuXHQgICAgdmFyIGNvdmVyYWdlID0gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKTtcblx0ICAgIHZhciB2YWx1ZUZvcm1hdDEgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICB2YXIgdmFsdWVGb3JtYXQyID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgaWYgKHBvc0Zvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgIC8vIEFkanVzdG1lbnRzIGZvciBHbHlwaCBQYWlyc1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHBvc0Zvcm1hdDogcG9zRm9ybWF0LFxuXHQgICAgICAgICAgICBjb3ZlcmFnZTogY292ZXJhZ2UsXG5cdCAgICAgICAgICAgIHZhbHVlRm9ybWF0MTogdmFsdWVGb3JtYXQxLFxuXHQgICAgICAgICAgICB2YWx1ZUZvcm1hdDI6IHZhbHVlRm9ybWF0Mixcblx0ICAgICAgICAgICAgcGFpclNldHM6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5saXN0KGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHsgICAgICAgIC8vIHBhaXJWYWx1ZVJlY29yZFxuXHQgICAgICAgICAgICAgICAgICAgIHNlY29uZEdseXBoOiB0aGlzLnBhcnNlVVNob3J0KCksXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUxOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQxKSxcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTI6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh2YWx1ZUZvcm1hdDIpXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KSkpXG5cdCAgICAgICAgfTtcblx0ICAgIH0gZWxzZSBpZiAocG9zRm9ybWF0ID09PSAyKSB7XG5cdCAgICAgICAgdmFyIGNsYXNzRGVmMSA9IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZik7XG5cdCAgICAgICAgdmFyIGNsYXNzRGVmMiA9IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZik7XG5cdCAgICAgICAgdmFyIGNsYXNzMUNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIHZhciBjbGFzczJDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAvLyBDbGFzcyBQYWlyIEFkanVzdG1lbnRcblx0ICAgICAgICAgICAgcG9zRm9ybWF0OiBwb3NGb3JtYXQsXG5cdCAgICAgICAgICAgIGNvdmVyYWdlOiBjb3ZlcmFnZSxcblx0ICAgICAgICAgICAgdmFsdWVGb3JtYXQxOiB2YWx1ZUZvcm1hdDEsXG5cdCAgICAgICAgICAgIHZhbHVlRm9ybWF0MjogdmFsdWVGb3JtYXQyLFxuXHQgICAgICAgICAgICBjbGFzc0RlZjE6IGNsYXNzRGVmMSxcblx0ICAgICAgICAgICAgY2xhc3NEZWYyOiBjbGFzc0RlZjIsXG5cdCAgICAgICAgICAgIGNsYXNzMUNvdW50OiBjbGFzczFDb3VudCxcblx0ICAgICAgICAgICAgY2xhc3MyQ291bnQ6IGNsYXNzMkNvdW50LFxuXHQgICAgICAgICAgICBjbGFzc1JlY29yZHM6IHRoaXMucGFyc2VMaXN0KGNsYXNzMUNvdW50LCBQYXJzZXIubGlzdChjbGFzczJDb3VudCwgZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlMTogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MSksXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUyOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQyKVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSkpXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0fTtcblxuXHRzdWJ0YWJsZVBhcnNlcnMkMVszXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMygpIHsgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCAzIG5vdCBzdXBwb3J0ZWQnIH07IH07XG5cdHN1YnRhYmxlUGFyc2VycyQxWzRdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA0KCkgeyByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDQgbm90IHN1cHBvcnRlZCcgfTsgfTtcblx0c3VidGFibGVQYXJzZXJzJDFbNV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDUoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNSBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuXHRzdWJ0YWJsZVBhcnNlcnMkMVs2XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNigpIHsgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA2IG5vdCBzdXBwb3J0ZWQnIH07IH07XG5cdHN1YnRhYmxlUGFyc2VycyQxWzddID0gZnVuY3Rpb24gcGFyc2VMb29rdXA3KCkgeyByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDcgbm90IHN1cHBvcnRlZCcgfTsgfTtcblx0c3VidGFibGVQYXJzZXJzJDFbOF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDgoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgOCBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuXHRzdWJ0YWJsZVBhcnNlcnMkMVs5XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwOSgpIHsgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA5IG5vdCBzdXBwb3J0ZWQnIH07IH07XG5cblx0Ly8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3Ncblx0ZnVuY3Rpb24gcGFyc2VHcG9zVGFibGUoZGF0YSwgc3RhcnQpIHtcblx0ICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcblx0ICAgIHZhciBwID0gbmV3IFBhcnNlcihkYXRhLCBzdGFydCk7XG5cdCAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oMSk7XG5cdCAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEgfHwgdGFibGVWZXJzaW9uID09PSAxLjEsICdVbnN1cHBvcnRlZCBHUE9TIHRhYmxlIHZlcnNpb24gJyArIHRhYmxlVmVyc2lvbik7XG5cblx0ICAgIGlmICh0YWJsZVZlcnNpb24gPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG5cdCAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG5cdCAgICAgICAgICAgIGZlYXR1cmVzOiBwLnBhcnNlRmVhdHVyZUxpc3QoKSxcblx0ICAgICAgICAgICAgbG9va3VwczogcC5wYXJzZUxvb2t1cExpc3Qoc3VidGFibGVQYXJzZXJzJDEpXG5cdCAgICAgICAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuXHQgICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuXHQgICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG5cdCAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycyQxKSxcblx0ICAgICAgICAgICAgdmFyaWF0aW9uczogcC5wYXJzZUZlYXR1cmVWYXJpYXRpb25zTGlzdCgpXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblxuXHR9XG5cblx0Ly8gR1BPUyBXcml0aW5nIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gTk9UIFNVUFBPUlRFRFxuXHR2YXIgc3VidGFibGVNYWtlcnMkMSA9IG5ldyBBcnJheSgxMCk7XG5cblx0ZnVuY3Rpb24gbWFrZUdwb3NUYWJsZShncG9zKSB7XG5cdCAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdHUE9TJywgW1xuXHQgICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAweDEwMDAwfSxcblx0ICAgICAgICB7bmFtZTogJ3NjcmlwdHMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLlNjcmlwdExpc3QoZ3Bvcy5zY3JpcHRzKX0sXG5cdCAgICAgICAge25hbWU6ICdmZWF0dXJlcycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuRmVhdHVyZUxpc3QoZ3Bvcy5mZWF0dXJlcyl9LFxuXHQgICAgICAgIHtuYW1lOiAnbG9va3VwcycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuTG9va3VwTGlzdChncG9zLmxvb2t1cHMsIHN1YnRhYmxlTWFrZXJzJDEpfVxuXHQgICAgXSk7XG5cdH1cblxuXHR2YXIgZ3BvcyA9IHsgcGFyc2U6IHBhcnNlR3Bvc1RhYmxlLCBtYWtlOiBtYWtlR3Bvc1RhYmxlIH07XG5cblx0Ly8gVGhlIGBrZXJuYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLlxuXG5cdGZ1bmN0aW9uIHBhcnNlV2luZG93c0tlcm5UYWJsZShwKSB7XG5cdCAgICB2YXIgcGFpcnMgPSB7fTtcblx0ICAgIC8vIFNraXAgblRhYmxlcy5cblx0ICAgIHAuc2tpcCgndVNob3J0Jyk7XG5cdCAgICB2YXIgc3VidGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgY2hlY2suYXJndW1lbnQoc3VidGFibGVWZXJzaW9uID09PSAwLCAnVW5zdXBwb3J0ZWQga2VybiBzdWItdGFibGUgdmVyc2lvbi4nKTtcblx0ICAgIC8vIFNraXAgc3VidGFibGVMZW5ndGgsIHN1YnRhYmxlQ292ZXJhZ2Vcblx0ICAgIHAuc2tpcCgndVNob3J0JywgMik7XG5cdCAgICB2YXIgblBhaXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgLy8gU2tpcCBzZWFyY2hSYW5nZSwgZW50cnlTZWxlY3RvciwgcmFuZ2VTaGlmdC5cblx0ICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWlyczsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGxlZnRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICB2YXIgcmlnaHRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgICAgICBwYWlyc1tsZWZ0SW5kZXggKyAnLCcgKyByaWdodEluZGV4XSA9IHZhbHVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHBhaXJzO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VNYWNLZXJuVGFibGUocCkge1xuXHQgICAgdmFyIHBhaXJzID0ge307XG5cdCAgICAvLyBUaGUgTWFjIGtlcm4gdGFibGUgc3RvcmVzIHRoZSB2ZXJzaW9uIGFzIGEgZml4ZWQgKDMyIGJpdHMpIGJ1dCB3ZSBvbmx5IGxvYWRlZCB0aGUgZmlyc3QgMTYgYml0cy5cblx0ICAgIC8vIFNraXAgdGhlIHJlc3QuXG5cdCAgICBwLnNraXAoJ3VTaG9ydCcpO1xuXHQgICAgdmFyIG5UYWJsZXMgPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgIC8vY2hlY2suYXJndW1lbnQoblRhYmxlcyA9PT0gMSwgJ09ubHkgMSBzdWJ0YWJsZSBpcyBzdXBwb3J0ZWQgKGdvdCAnICsgblRhYmxlcyArICcpLicpO1xuXHQgICAgaWYgKG5UYWJsZXMgPiAxKSB7XG5cdCAgICAgICAgY29uc29sZS53YXJuKCdPbmx5IHRoZSBmaXJzdCBrZXJuIHN1YnRhYmxlIGlzIHN1cHBvcnRlZC4nKTtcblx0ICAgIH1cblx0ICAgIHAuc2tpcCgndUxvbmcnKTtcblx0ICAgIHZhciBjb3ZlcmFnZSA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIHZhciBzdWJ0YWJsZVZlcnNpb24gPSBjb3ZlcmFnZSAmIDB4RkY7XG5cdCAgICBwLnNraXAoJ3VTaG9ydCcpO1xuXHQgICAgaWYgKHN1YnRhYmxlVmVyc2lvbiA9PT0gMCkge1xuXHQgICAgICAgIHZhciBuUGFpcnMgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgLy8gU2tpcCBzZWFyY2hSYW5nZSwgZW50cnlTZWxlY3RvciwgcmFuZ2VTaGlmdC5cblx0ICAgICAgICBwLnNraXAoJ3VTaG9ydCcsIDMpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhaXJzOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgdmFyIGxlZnRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgICAgICAgICBwYWlyc1tsZWZ0SW5kZXggKyAnLCcgKyByaWdodEluZGV4XSA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBwYWlycztcblx0fVxuXG5cdC8vIFBhcnNlIHRoZSBga2VybmAgdGFibGUgd2hpY2ggY29udGFpbnMga2VybmluZyBwYWlycy5cblx0ZnVuY3Rpb24gcGFyc2VLZXJuVGFibGUoZGF0YSwgc3RhcnQpIHtcblx0ICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cdCAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiBwYXJzZVdpbmRvd3NLZXJuVGFibGUocCk7XG5cdCAgICB9IGVsc2UgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiBwYXJzZU1hY0tlcm5UYWJsZShwKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXJuIHRhYmxlIHZlcnNpb24gKCcgKyB0YWJsZVZlcnNpb24gKyAnKS4nKTtcblx0ICAgIH1cblx0fVxuXG5cdHZhciBrZXJuID0geyBwYXJzZTogcGFyc2VLZXJuVGFibGUgfTtcblxuXHQvLyBUaGUgYGxvY2FgIHRhYmxlIHN0b3JlcyB0aGUgb2Zmc2V0cyB0byB0aGUgbG9jYXRpb25zIG9mIHRoZSBnbHlwaHMgaW4gdGhlIGZvbnQuXG5cblx0Ly8gUGFyc2UgdGhlIGBsb2NhYCB0YWJsZS4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIG9mZnNldHMgdG8gdGhlIGxvY2F0aW9ucyBvZiB0aGUgZ2x5cGhzIGluIHRoZSBmb250LFxuXHQvLyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBnbHlwaERhdGEgdGFibGUuXG5cdC8vIFRoZSBudW1iZXIgb2YgZ2x5cGhzIHN0b3JlZCBpbiB0aGUgYGxvY2FgIHRhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgYG1heHBgIHRhYmxlICh1bmRlciBudW1HbHlwaHMpXG5cdC8vIFRoZSBsb2NhIHRhYmxlIGhhcyB0d28gdmVyc2lvbnM6IGEgc2hvcnQgdmVyc2lvbiB3aGVyZSBvZmZzZXRzIGFyZSBzdG9yZWQgYXMgdVNob3J0cywgYW5kIGEgbG9uZ1xuXHQvLyB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1TG9uZ3MuIFRoZSBgaGVhZGAgdGFibGUgc3BlY2lmaWVzIHdoaWNoIHZlcnNpb24gdG8gdXNlXG5cdC8vICh1bmRlciBpbmRleFRvTG9jRm9ybWF0KS5cblx0ZnVuY3Rpb24gcGFyc2VMb2NhVGFibGUoZGF0YSwgc3RhcnQsIG51bUdseXBocywgc2hvcnRWZXJzaW9uKSB7XG5cdCAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgdmFyIHBhcnNlRm4gPSBzaG9ydFZlcnNpb24gPyBwLnBhcnNlVVNob3J0IDogcC5wYXJzZVVMb25nO1xuXHQgICAgLy8gVGhlcmUgaXMgYW4gZXh0cmEgZW50cnkgYWZ0ZXIgdGhlIGxhc3QgaW5kZXggZWxlbWVudCB0byBjb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIGxhc3QgZ2x5cGguXG5cdCAgICAvLyBUaGF0J3Mgd2h5IHdlIHVzZSBudW1HbHlwaHMgKyAxLlxuXHQgICAgdmFyIGdseXBoT2Zmc2V0cyA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1HbHlwaHMgKyAxOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgZ2x5cGhPZmZzZXQgPSBwYXJzZUZuLmNhbGwocCk7XG5cdCAgICAgICAgaWYgKHNob3J0VmVyc2lvbikge1xuXHQgICAgICAgICAgICAvLyBUaGUgc2hvcnQgdGFibGUgdmVyc2lvbiBzdG9yZXMgdGhlIGFjdHVhbCBvZmZzZXQgZGl2aWRlZCBieSAyLlxuXHQgICAgICAgICAgICBnbHlwaE9mZnNldCAqPSAyO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGdseXBoT2Zmc2V0cy5wdXNoKGdseXBoT2Zmc2V0KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGdseXBoT2Zmc2V0cztcblx0fVxuXG5cdHZhciBsb2NhID0geyBwYXJzZTogcGFyc2VMb2NhVGFibGUgfTtcblxuXHQvLyBvcGVudHlwZS5qc1xuXG5cdC8qKlxuXHQgKiBUaGUgb3BlbnR5cGUgbGlicmFyeS5cblx0ICogQG5hbWVzcGFjZSBvcGVudHlwZVxuXHQgKi9cblxuXHQvLyBGaWxlIGxvYWRlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8qKlxuXHQgKiBMb2FkcyBhIGZvbnQgZnJvbSBhIGZpbGUuIFRoZSBjYWxsYmFjayB0aHJvd3MgYW4gZXJyb3IgbWVzc2FnZSBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIGlmIGl0IGZhaWxzXG5cdCAqIGFuZCB0aGUgZm9udCBhcyBhbiBBcnJheUJ1ZmZlciBpbiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpZiBpdCBzdWNjZWVkcy5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggb2YgdGhlIGZpbGVcblx0ICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZm9udCBsb2FkIGNvbXBsZXRlc1xuXHQgKi9cblx0ZnVuY3Rpb24gbG9hZEZyb21GaWxlKHBhdGgsIGNhbGxiYWNrKSB7XG5cdCAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXHQgICAgZnMucmVhZEZpbGUocGF0aCwgZnVuY3Rpb24oZXJyLCBidWZmZXIpIHtcblx0ICAgICAgICBpZiAoZXJyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIubWVzc2FnZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY2FsbGJhY2sobnVsbCwgbm9kZUJ1ZmZlclRvQXJyYXlCdWZmZXIoYnVmZmVyKSk7XG5cdCAgICB9KTtcblx0fVxuXHQvKipcblx0ICogTG9hZHMgYSBmb250IGZyb20gYSBVUkwuIFRoZSBjYWxsYmFjayB0aHJvd3MgYW4gZXJyb3IgbWVzc2FnZSBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIGlmIGl0IGZhaWxzXG5cdCAqIGFuZCB0aGUgZm9udCBhcyBhbiBBcnJheUJ1ZmZlciBpbiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpZiBpdCBzdWNjZWVkcy5cblx0ICogQHBhcmFtICB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBmb250IGZpbGUuXG5cdCAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGZvbnQgbG9hZCBjb21wbGV0ZXNcblx0ICovXG5cdGZ1bmN0aW9uIGxvYWRGcm9tVXJsKHVybCwgY2FsbGJhY2spIHtcblx0ICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdCAgICByZXF1ZXN0Lm9wZW4oJ2dldCcsIHVybCwgdHJ1ZSk7XG5cdCAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdCAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3BvbnNlKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soJ0ZvbnQgY291bGQgbm90IGJlIGxvYWRlZDogJyArIHJlcXVlc3Quc3RhdHVzVGV4dCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGNhbGxiYWNrKCdGb250IGNvdWxkIG5vdCBiZSBsb2FkZWQnKTtcblx0ICAgIH07XG5cblx0ICAgIHJlcXVlc3Quc2VuZCgpO1xuXHR9XG5cblx0Ly8gVGFibGUgRGlyZWN0b3J5IEVudHJpZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvKipcblx0ICogUGFyc2VzIE9wZW5UeXBlIHRhYmxlIGVudHJpZXMuXG5cdCAqIEBwYXJhbSAge0RhdGFWaWV3fVxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9XG5cdCAqIEByZXR1cm4ge09iamVjdFtdfVxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpIHtcblx0ICAgIHZhciB0YWJsZUVudHJpZXMgPSBbXTtcblx0ICAgIHZhciBwID0gMTI7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIHRhZyA9IHBhcnNlLmdldFRhZyhkYXRhLCBwKTtcblx0ICAgICAgICB2YXIgY2hlY2tzdW0gPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgNCk7XG5cdCAgICAgICAgdmFyIG9mZnNldCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA4KTtcblx0ICAgICAgICB2YXIgbGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDEyKTtcblx0ICAgICAgICB0YWJsZUVudHJpZXMucHVzaCh7dGFnOiB0YWcsIGNoZWNrc3VtOiBjaGVja3N1bSwgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogbGVuZ3RoLCBjb21wcmVzc2lvbjogZmFsc2V9KTtcblx0ICAgICAgICBwICs9IDE2O1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGFibGVFbnRyaWVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyBXT0ZGIHRhYmxlIGVudHJpZXMuXG5cdCAqIEBwYXJhbSAge0RhdGFWaWV3fVxuXHQgKiBAcGFyYW0gIHtOdW1iZXJ9XG5cdCAqIEByZXR1cm4ge09iamVjdFtdfVxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VXT0ZGVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcykge1xuXHQgICAgdmFyIHRhYmxlRW50cmllcyA9IFtdO1xuXHQgICAgdmFyIHAgPSA0NDsgLy8gb2Zmc2V0IHRvIHRoZSBmaXJzdCB0YWJsZSBkaXJlY3RvcnkgZW50cnkuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIHRhZyA9IHBhcnNlLmdldFRhZyhkYXRhLCBwKTtcblx0ICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDQpO1xuXHQgICAgICAgIHZhciBjb21wTGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDgpO1xuXHQgICAgICAgIHZhciBvcmlnTGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDEyKTtcblx0ICAgICAgICB2YXIgY29tcHJlc3Npb24gPSAodm9pZCAwKTtcblx0ICAgICAgICBpZiAoY29tcExlbmd0aCA8IG9yaWdMZW5ndGgpIHtcblx0ICAgICAgICAgICAgY29tcHJlc3Npb24gPSAnV09GRic7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgY29tcHJlc3Npb24gPSBmYWxzZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0YWJsZUVudHJpZXMucHVzaCh7dGFnOiB0YWcsIG9mZnNldDogb2Zmc2V0LCBjb21wcmVzc2lvbjogY29tcHJlc3Npb24sXG5cdCAgICAgICAgICAgIGNvbXByZXNzZWRMZW5ndGg6IGNvbXBMZW5ndGgsIGxlbmd0aDogb3JpZ0xlbmd0aH0pO1xuXHQgICAgICAgIHAgKz0gMjA7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0YWJsZUVudHJpZXM7XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGVkZWYgVGFibGVEYXRhXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKiBAcHJvcGVydHkge0RhdGFWaWV3fSBkYXRhIC0gVGhlIERhdGFWaWV3XG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgZGF0YSBvZmZzZXQuXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtEYXRhVmlld31cblx0ICogQHBhcmFtICB7T2JqZWN0fVxuXHQgKiBAcmV0dXJuIHtUYWJsZURhdGF9XG5cdCAqL1xuXHRmdW5jdGlvbiB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSkge1xuXHQgICAgaWYgKHRhYmxlRW50cnkuY29tcHJlc3Npb24gPT09ICdXT0ZGJykge1xuXHQgICAgICAgIHZhciBpbkJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCB0YWJsZUVudHJ5Lm9mZnNldCArIDIsIHRhYmxlRW50cnkuY29tcHJlc3NlZExlbmd0aCAtIDIpO1xuXHQgICAgICAgIHZhciBvdXRCdWZmZXIgPSBuZXcgVWludDhBcnJheSh0YWJsZUVudHJ5Lmxlbmd0aCk7XG5cdCAgICAgICAgdGlueUluZmxhdGUoaW5CdWZmZXIsIG91dEJ1ZmZlcik7XG5cdCAgICAgICAgaWYgKG91dEJ1ZmZlci5ieXRlTGVuZ3RoICE9PSB0YWJsZUVudHJ5Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29tcHJlc3Npb24gZXJyb3I6ICcgKyB0YWJsZUVudHJ5LnRhZyArICcgZGVjb21wcmVzc2VkIGxlbmd0aCBkb2VzblxcJ3QgbWF0Y2ggcmVjb3JkZWQgbGVuZ3RoJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlciwgMCk7XG5cdCAgICAgICAgcmV0dXJuIHtkYXRhOiB2aWV3LCBvZmZzZXQ6IDB9O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4ge2RhdGE6IGRhdGEsIG9mZnNldDogdGFibGVFbnRyeS5vZmZzZXR9O1xuXHQgICAgfVxuXHR9XG5cblx0Ly8gUHVibGljIEFQSSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdC8qKlxuXHQgKiBQYXJzZSB0aGUgT3BlblR5cGUgZmlsZSBkYXRhIChhcyBhbiBBcnJheUJ1ZmZlcikgYW5kIHJldHVybiBhIEZvbnQgb2JqZWN0LlxuXHQgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGZvbnQgY291bGQgbm90IGJlIHBhcnNlZC5cblx0ICogQHBhcmFtICB7QXJyYXlCdWZmZXJ9XG5cdCAqIEBwYXJhbSAge09iamVjdH0gb3B0IC0gb3B0aW9ucyBmb3IgcGFyc2luZ1xuXHQgKiBAcmV0dXJuIHtvcGVudHlwZS5Gb250fVxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VCdWZmZXIoYnVmZmVyLCBvcHQpIHtcblx0ICAgIG9wdCA9IChvcHQgPT09IHVuZGVmaW5lZCB8fCBvcHQgPT09IG51bGwpID8gIHt9IDogb3B0O1xuXG5cdCAgICB2YXIgaW5kZXhUb0xvY0Zvcm1hdDtcblx0ICAgIHZhciBsdGFnVGFibGU7XG5cblx0ICAgIC8vIFNpbmNlIHRoZSBjb25zdHJ1Y3RvciBjYW4gYWxzbyBiZSBjYWxsZWQgdG8gY3JlYXRlIG5ldyBmb250cyBmcm9tIHNjcmF0Y2gsIHdlIGluZGljYXRlIHRoaXNcblx0ICAgIC8vIHNob3VsZCBiZSBhbiBlbXB0eSBmb250IHRoYXQgd2UnbGwgZmlsbCB3aXRoIG91ciBvd24gZGF0YS5cblx0ICAgIHZhciBmb250ID0gbmV3IEZvbnQoe2VtcHR5OiB0cnVlfSk7XG5cblx0ICAgIC8vIE9wZW5UeXBlIGZvbnRzIHVzZSBiaWcgZW5kaWFuIGJ5dGUgb3JkZXJpbmcuXG5cdCAgICAvLyBXZSBjYW4ndCByZWx5IG9uIHR5cGVkIGFycmF5IHZpZXcgdHlwZXMsIGJlY2F1c2UgdGhleSBvcGVyYXRlIHdpdGggdGhlIGVuZGlhbm5lc3Mgb2YgdGhlIGhvc3QgY29tcHV0ZXIuXG5cdCAgICAvLyBJbnN0ZWFkIHdlIHVzZSBEYXRhVmlld3Mgd2hlcmUgd2UgY2FuIHNwZWNpZnkgZW5kaWFubmVzcy5cblx0ICAgIHZhciBkYXRhID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgMCk7XG5cdCAgICB2YXIgbnVtVGFibGVzO1xuXHQgICAgdmFyIHRhYmxlRW50cmllcyA9IFtdO1xuXHQgICAgdmFyIHNpZ25hdHVyZSA9IHBhcnNlLmdldFRhZyhkYXRhLCAwKTtcblx0ICAgIGlmIChzaWduYXR1cmUgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMSwgMCwgMCkgfHwgc2lnbmF0dXJlID09PSAndHJ1ZScgfHwgc2lnbmF0dXJlID09PSAndHlwMScpIHtcblx0ICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ3RydWV0eXBlJztcblx0ICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG5cdCAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuXHQgICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09ICdPVFRPJykge1xuXHQgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAnY2ZmJztcblx0ICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG5cdCAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuXHQgICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09ICd3T0ZGJykge1xuXHQgICAgICAgIHZhciBmbGF2b3IgPSBwYXJzZS5nZXRUYWcoZGF0YSwgNCk7XG5cdCAgICAgICAgaWYgKGZsYXZvciA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAxLCAwLCAwKSkge1xuXHQgICAgICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ3RydWV0eXBlJztcblx0ICAgICAgICB9IGVsc2UgaWYgKGZsYXZvciA9PT0gJ09UVE8nKSB7XG5cdCAgICAgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAnY2ZmJztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE9wZW5UeXBlIGZsYXZvciAnICsgc2lnbmF0dXJlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgMTIpO1xuXHQgICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlV09GRlRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE9wZW5UeXBlIHNpZ25hdHVyZSAnICsgc2lnbmF0dXJlKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNmZlRhYmxlRW50cnk7XG5cdCAgICB2YXIgZnZhclRhYmxlRW50cnk7XG5cdCAgICB2YXIgZ2x5ZlRhYmxlRW50cnk7XG5cdCAgICB2YXIgZ2RlZlRhYmxlRW50cnk7XG5cdCAgICB2YXIgZ3Bvc1RhYmxlRW50cnk7XG5cdCAgICB2YXIgZ3N1YlRhYmxlRW50cnk7XG5cdCAgICB2YXIgaG10eFRhYmxlRW50cnk7XG5cdCAgICB2YXIga2VyblRhYmxlRW50cnk7XG5cdCAgICB2YXIgbG9jYVRhYmxlRW50cnk7XG5cdCAgICB2YXIgbmFtZVRhYmxlRW50cnk7XG5cdCAgICB2YXIgbWV0YVRhYmxlRW50cnk7XG5cdCAgICB2YXIgcDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciB0YWJsZUVudHJ5ID0gdGFibGVFbnRyaWVzW2ldO1xuXHQgICAgICAgIHZhciB0YWJsZSA9ICh2b2lkIDApO1xuXHQgICAgICAgIHN3aXRjaCAodGFibGVFbnRyeS50YWcpIHtcblx0ICAgICAgICAgICAgY2FzZSAnY21hcCc6XG5cdCAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcblx0ICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmNtYXAgPSBjbWFwLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICBmb250LmVuY29kaW5nID0gbmV3IENtYXBFbmNvZGluZyhmb250LnRhYmxlcy5jbWFwKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlICdjdnQgJyA6XG5cdCAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcblx0ICAgICAgICAgICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5jdnQgPSBwLnBhcnNlU2hvcnRMaXN0KHRhYmxlRW50cnkubGVuZ3RoIC8gMik7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnZnZhcic6XG5cdCAgICAgICAgICAgICAgICBmdmFyVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnZnBnbScgOlxuXHQgICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG5cdCAgICAgICAgICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcih0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgZm9udC50YWJsZXMuZnBnbSA9IHAucGFyc2VCeXRlTGlzdCh0YWJsZUVudHJ5Lmxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnaGVhZCc6XG5cdCAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcblx0ICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmhlYWQgPSBoZWFkLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICBmb250LnVuaXRzUGVyRW0gPSBmb250LnRhYmxlcy5oZWFkLnVuaXRzUGVyRW07XG5cdCAgICAgICAgICAgICAgICBpbmRleFRvTG9jRm9ybWF0ID0gZm9udC50YWJsZXMuaGVhZC5pbmRleFRvTG9jRm9ybWF0O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ2hoZWEnOlxuXHQgICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG5cdCAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5oaGVhID0gaGhlYS5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgZm9udC5hc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuYXNjZW5kZXI7XG5cdCAgICAgICAgICAgICAgICBmb250LmRlc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuZGVzY2VuZGVyO1xuXHQgICAgICAgICAgICAgICAgZm9udC5udW1iZXJPZkhNZXRyaWNzID0gZm9udC50YWJsZXMuaGhlYS5udW1iZXJPZkhNZXRyaWNzO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ2htdHgnOlxuXHQgICAgICAgICAgICAgICAgaG10eFRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ2x0YWcnOlxuXHQgICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG5cdCAgICAgICAgICAgICAgICBsdGFnVGFibGUgPSBsdGFnLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnbWF4cCc6XG5cdCAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcblx0ICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLm1heHAgPSBtYXhwLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICBmb250Lm51bUdseXBocyA9IGZvbnQudGFibGVzLm1heHAubnVtR2x5cGhzO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ25hbWUnOlxuXHQgICAgICAgICAgICAgICAgbmFtZVRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ09TLzInOlxuXHQgICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG5cdCAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5vczIgPSBvczIucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlICdwb3N0Jzpcblx0ICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuXHQgICAgICAgICAgICAgICAgZm9udC50YWJsZXMucG9zdCA9IHBvc3QucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIGZvbnQuZ2x5cGhOYW1lcyA9IG5ldyBHbHlwaE5hbWVzKGZvbnQudGFibGVzLnBvc3QpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ3ByZXAnIDpcblx0ICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuXHQgICAgICAgICAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLnByZXAgPSBwLnBhcnNlQnl0ZUxpc3QodGFibGVFbnRyeS5sZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ2dseWYnOlxuXHQgICAgICAgICAgICAgICAgZ2x5ZlRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ2xvY2EnOlxuXHQgICAgICAgICAgICAgICAgbG9jYVRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ0NGRiAnOlxuXHQgICAgICAgICAgICAgICAgY2ZmVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAna2Vybic6XG5cdCAgICAgICAgICAgICAgICBrZXJuVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnR0RFRic6XG5cdCAgICAgICAgICAgICAgICBnZGVmVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnR1BPUyc6XG5cdCAgICAgICAgICAgICAgICBncG9zVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnR1NVQic6XG5cdCAgICAgICAgICAgICAgICBnc3ViVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnbWV0YSc6XG5cdCAgICAgICAgICAgICAgICBtZXRhVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBuYW1lVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgbmFtZVRhYmxlRW50cnkpO1xuXHQgICAgZm9udC50YWJsZXMubmFtZSA9IF9uYW1lLnBhcnNlKG5hbWVUYWJsZS5kYXRhLCBuYW1lVGFibGUub2Zmc2V0LCBsdGFnVGFibGUpO1xuXHQgICAgZm9udC5uYW1lcyA9IGZvbnQudGFibGVzLm5hbWU7XG5cblx0ICAgIGlmIChnbHlmVGFibGVFbnRyeSAmJiBsb2NhVGFibGVFbnRyeSkge1xuXHQgICAgICAgIHZhciBzaG9ydFZlcnNpb24gPSBpbmRleFRvTG9jRm9ybWF0ID09PSAwO1xuXHQgICAgICAgIHZhciBsb2NhVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgbG9jYVRhYmxlRW50cnkpO1xuXHQgICAgICAgIHZhciBsb2NhT2Zmc2V0cyA9IGxvY2EucGFyc2UobG9jYVRhYmxlLmRhdGEsIGxvY2FUYWJsZS5vZmZzZXQsIGZvbnQubnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pO1xuXHQgICAgICAgIHZhciBnbHlmVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ2x5ZlRhYmxlRW50cnkpO1xuXHQgICAgICAgIGZvbnQuZ2x5cGhzID0gZ2x5Zi5wYXJzZShnbHlmVGFibGUuZGF0YSwgZ2x5ZlRhYmxlLm9mZnNldCwgbG9jYU9mZnNldHMsIGZvbnQsIG9wdCk7XG5cdCAgICB9IGVsc2UgaWYgKGNmZlRhYmxlRW50cnkpIHtcblx0ICAgICAgICB2YXIgY2ZmVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgY2ZmVGFibGVFbnRyeSk7XG5cdCAgICAgICAgY2ZmLnBhcnNlKGNmZlRhYmxlLmRhdGEsIGNmZlRhYmxlLm9mZnNldCwgZm9udCwgb3B0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb250IGRvZXNuXFwndCBjb250YWluIFRydWVUeXBlIG9yIENGRiBvdXRsaW5lcy4nKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGhtdHhUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBobXR4VGFibGVFbnRyeSk7XG5cdCAgICBobXR4LnBhcnNlKGZvbnQsIGhtdHhUYWJsZS5kYXRhLCBobXR4VGFibGUub2Zmc2V0LCBmb250Lm51bWJlck9mSE1ldHJpY3MsIGZvbnQubnVtR2x5cGhzLCBmb250LmdseXBocywgb3B0KTtcblx0ICAgIGFkZEdseXBoTmFtZXMoZm9udCwgb3B0KTtcblxuXHQgICAgaWYgKGtlcm5UYWJsZUVudHJ5KSB7XG5cdCAgICAgICAgdmFyIGtlcm5UYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBrZXJuVGFibGVFbnRyeSk7XG5cdCAgICAgICAgZm9udC5rZXJuaW5nUGFpcnMgPSBrZXJuLnBhcnNlKGtlcm5UYWJsZS5kYXRhLCBrZXJuVGFibGUub2Zmc2V0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZm9udC5rZXJuaW5nUGFpcnMgPSB7fTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGdkZWZUYWJsZUVudHJ5KSB7XG5cdCAgICAgICAgdmFyIGdkZWZUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBnZGVmVGFibGVFbnRyeSk7XG5cdCAgICAgICAgZm9udC50YWJsZXMuZ2RlZiA9IGdkZWYucGFyc2UoZ2RlZlRhYmxlLmRhdGEsIGdkZWZUYWJsZS5vZmZzZXQpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZ3Bvc1RhYmxlRW50cnkpIHtcblx0ICAgICAgICB2YXIgZ3Bvc1RhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdwb3NUYWJsZUVudHJ5KTtcblx0ICAgICAgICBmb250LnRhYmxlcy5ncG9zID0gZ3Bvcy5wYXJzZShncG9zVGFibGUuZGF0YSwgZ3Bvc1RhYmxlLm9mZnNldCk7XG5cdCAgICAgICAgZm9udC5wb3NpdGlvbi5pbml0KCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChnc3ViVGFibGVFbnRyeSkge1xuXHQgICAgICAgIHZhciBnc3ViVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ3N1YlRhYmxlRW50cnkpO1xuXHQgICAgICAgIGZvbnQudGFibGVzLmdzdWIgPSBnc3ViLnBhcnNlKGdzdWJUYWJsZS5kYXRhLCBnc3ViVGFibGUub2Zmc2V0KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGZ2YXJUYWJsZUVudHJ5KSB7XG5cdCAgICAgICAgdmFyIGZ2YXJUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBmdmFyVGFibGVFbnRyeSk7XG5cdCAgICAgICAgZm9udC50YWJsZXMuZnZhciA9IGZ2YXIucGFyc2UoZnZhclRhYmxlLmRhdGEsIGZ2YXJUYWJsZS5vZmZzZXQsIGZvbnQubmFtZXMpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobWV0YVRhYmxlRW50cnkpIHtcblx0ICAgICAgICB2YXIgbWV0YVRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIG1ldGFUYWJsZUVudHJ5KTtcblx0ICAgICAgICBmb250LnRhYmxlcy5tZXRhID0gbWV0YS5wYXJzZShtZXRhVGFibGUuZGF0YSwgbWV0YVRhYmxlLm9mZnNldCk7XG5cdCAgICAgICAgZm9udC5tZXRhcyA9IGZvbnQudGFibGVzLm1ldGE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmb250O1xuXHR9XG5cblx0LyoqXG5cdCAqIEFzeW5jaHJvbm91c2x5IGxvYWQgdGhlIGZvbnQgZnJvbSBhIFVSTCBvciBhIGZpbGVzeXN0ZW0uIFdoZW4gZG9uZSwgY2FsbCB0aGUgY2FsbGJhY2tcblx0ICogd2l0aCB0d28gYXJndW1lbnRzIGAoZXJyLCBmb250KWAuIFRoZSBgZXJyYCB3aWxsIGJlIG51bGwgb24gc3VjY2Vzcyxcblx0ICogdGhlIGBmb250YCBpcyBhIEZvbnQgb2JqZWN0LlxuXHQgKiBXZSB1c2UgdGhlIG5vZGUuanMgY2FsbGJhY2sgY29udmVudGlvbiBzbyB0aGF0XG5cdCAqIG9wZW50eXBlLmpzIGNhbiBpbnRlZ3JhdGUgd2l0aCBmcmFtZXdvcmtzIGxpa2UgYXN5bmMuanMuXG5cdCAqIEBhbGlhcyBvcGVudHlwZS5sb2FkXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gdXJsIC0gVGhlIFVSTCBvZiB0aGUgZm9udCB0byBsb2FkLlxuXHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2suXG5cdCAqL1xuXHRmdW5jdGlvbiBsb2FkKHVybCwgY2FsbGJhY2ssIG9wdCkge1xuXHQgICAgb3B0ID0gKG9wdCA9PT0gdW5kZWZpbmVkIHx8IG9wdCA9PT0gbnVsbCkgPyAge30gOiBvcHQ7XG5cdCAgICB2YXIgaXNOb2RlID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5cdCAgICB2YXIgbG9hZEZuID0gaXNOb2RlICYmICFvcHQuaXNVcmwgPyBsb2FkRnJvbUZpbGUgOiBsb2FkRnJvbVVybDtcblxuXHQgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBsb2FkRm4odXJsLCBmdW5jdGlvbihlcnIsIGFycmF5QnVmZmVyKSB7XG5cdCAgICAgICAgICAgIGlmIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgZm9udDtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGZvbnQgPSBwYXJzZUJ1ZmZlcihhcnJheUJ1ZmZlciwgb3B0KTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIG51bGwpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZm9udCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXNvbHZlKGZvbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTeW5jaHJvbm91c2x5IGxvYWQgdGhlIGZvbnQgZnJvbSBhIFVSTCBvciBmaWxlLlxuXHQgKiBXaGVuIGRvbmUsIHJldHVybnMgdGhlIGZvbnQgb2JqZWN0IG9yIHRocm93cyBhbiBlcnJvci5cblx0ICogQGFsaWFzIG9wZW50eXBlLmxvYWRTeW5jXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gdXJsIC0gVGhlIFVSTCBvZiB0aGUgZm9udCB0byBsb2FkLlxuXHQgKiBAcGFyYW0gIHtPYmplY3R9IG9wdCAtIG9wdC5sb3dNZW1vcnlcblx0ICogQHJldHVybiB7b3BlbnR5cGUuRm9udH1cblx0ICovXG5cdGZ1bmN0aW9uIGxvYWRTeW5jKHVybCwgb3B0KSB7XG5cdCAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXHQgICAgdmFyIGJ1ZmZlciA9IGZzLnJlYWRGaWxlU3luYyh1cmwpO1xuXHQgICAgcmV0dXJuIHBhcnNlQnVmZmVyKG5vZGVCdWZmZXJUb0FycmF5QnVmZmVyKGJ1ZmZlciksIG9wdCk7XG5cdH1cblxuXHR2YXIgb3BlbnR5cGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0X19wcm90b19fOiBudWxsLFxuXHRcdEZvbnQ6IEZvbnQsXG5cdFx0R2x5cGg6IEdseXBoLFxuXHRcdFBhdGg6IFBhdGgsXG5cdFx0Qm91bmRpbmdCb3g6IEJvdW5kaW5nQm94LFxuXHRcdF9wYXJzZTogcGFyc2UsXG5cdFx0cGFyc2U6IHBhcnNlQnVmZmVyLFxuXHRcdGxvYWQ6IGxvYWQsXG5cdFx0bG9hZFN5bmM6IGxvYWRTeW5jXG5cdH0pO1xuXG5cdGV4cG9ydHMuQm91bmRpbmdCb3ggPSBCb3VuZGluZ0JveDtcblx0ZXhwb3J0cy5Gb250ID0gRm9udDtcblx0ZXhwb3J0cy5HbHlwaCA9IEdseXBoO1xuXHRleHBvcnRzLlBhdGggPSBQYXRoO1xuXHRleHBvcnRzLl9wYXJzZSA9IHBhcnNlO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBvcGVudHlwZTtcblx0ZXhwb3J0cy5sb2FkID0gbG9hZDtcblx0ZXhwb3J0cy5sb2FkU3luYyA9IGxvYWRTeW5jO1xuXHRleHBvcnRzLnBhcnNlID0gcGFyc2VCdWZmZXI7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZW50eXBlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/opentype.js/dist/opentype.js\n");

/***/ })

};
;