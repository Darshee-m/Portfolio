/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-utils";
exports.ids = ["vendor-chunks/troika-three-utils"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.umd.js":
/*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.umd.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\")) :\n  0;\n}(this, (function (exports, three) { 'use strict';\n\n  /**\n   * Regular expression for matching the `void main() {` opener line in GLSL.\n   * @type {RegExp}\n   */\n  const voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n  /**\n   * Recursively expands all `#include <xyz>` statements within string of shader code.\n   * Copied from three's WebGLProgram#parseIncludes for external use.\n   *\n   * @param {string} source - The GLSL source code to evaluate\n   * @return {string} The GLSL code with all includes expanded\n   */\n  function expandShaderIncludes( source ) {\n    const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n    function replace(match, include) {\n      let chunk = three.ShaderChunk[include];\n      return chunk ? expandShaderIncludes(chunk) : match\n    }\n    return source.replace( pattern, replace )\n  }\n\n  /*\n   * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n   * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n   * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n   */\n\n  const _lut = [];\n\n  for (let i = 0; i < 256; i++) {\n    _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n  }\n\n  function generateUUID() {\n\n    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n    const d0 = Math.random() * 0xffffffff | 0;\n    const d1 = Math.random() * 0xffffffff | 0;\n    const d2 = Math.random() * 0xffffffff | 0;\n    const d3 = Math.random() * 0xffffffff | 0;\n    const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +\n      _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +\n      _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +\n      _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n    // .toUpperCase() here flattens concatenated strings to save heap memory space.\n    return uuid.toUpperCase()\n\n  }\n\n  // Local assign polyfill to avoid importing troika-core\n  const assign = Object.assign || function(/*target, ...sources*/) {\n    let target = arguments[0];\n    for (let i = 1, len = arguments.length; i < len; i++) {\n      let source = arguments[i];\n      if (source) {\n        for (let prop in source) {\n          if (Object.prototype.hasOwnProperty.call(source, prop)) {\n            target[prop] = source[prop];\n          }\n        }\n      }\n    }\n    return target\n  };\n\n\n  const epoch = Date.now();\n  const CONSTRUCTOR_CACHE = new WeakMap();\n  const SHADER_UPGRADE_CACHE = new Map();\n\n  // Material ids must be integers, but we can't access the increment from Three's `Material` module,\n  // so let's choose a sufficiently large starting value that should theoretically never collide.\n  let materialInstanceId = 1e10;\n\n  /**\n   * A utility for creating a custom shader material derived from another material's\n   * shaders. This allows you to inject custom shader logic and transforms into the\n   * builtin ThreeJS materials without having to recreate them from scratch.\n   *\n   * @param {THREE.Material} baseMaterial - the original material to derive from\n   *\n   * @param {Object} options - How the base material should be modified.\n   * @param {Object} options.defines - Custom `defines` for the material\n   * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n   * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n   *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n   *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n   * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n   *        both shaders, and it will automatically be updated on each render frame with a number of\n   *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n   *        true calendar time.\n   * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n   *        shader's `void main` function.\n   * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n   *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n   *        those attributes exposed by their normal names as read/write values.\n   * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n   *        definitions, above the `void main()` function.\n   * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n   *        shader's `void main` function.\n   * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n   *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n   *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n   *        want those to apply to your changes use `fragmentColorTransform` instead.\n   * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n   *        output value. Will be injected near the end of the `void main` function, but before any\n   *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n   *        `fragmentMainOutro`.\n   * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n   *        for performing custom rewrites of the full shader code. Useful if you need to do something\n   *        special that's not covered by the other builtin options. This function will be executed before\n   *        any other transforms are applied.\n   * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\n   *        material, rather than the default behavior of copying it. This allows the derived material to\n   *        automatically pick up changes made to the base material and its properties. This can be useful\n   *        where the derived material is hidden from the user as an implementation detail, allowing them\n   *        to work with the original material like normal. But it can result in unexpected behavior if not\n   *        handled carefully.\n   *\n   * @return {THREE.Material}\n   *\n   * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n   * which can be called to get a variant of the derived material for use in shadow casting. If the\n   * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n   * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n   * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n   * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n   * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n   * scenarios, e.g. skipping antialiasing or expensive shader logic.\n   */\n  function createDerivedMaterial(baseMaterial, options) {\n    // Generate a key that is unique to the content of these `options`. We'll use this\n    // throughout for caching and for generating the upgraded shader code. This increases\n    // the likelihood that the resulting shaders will line up across multiple calls so\n    // their GL programs can be shared and cached.\n    const optionsKey = getKeyForOptions(options);\n\n    // First check to see if we've already derived from this baseMaterial using this\n    // unique set of options, and if so reuse the constructor to avoid some allocations.\n    let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n    if (!ctorsByDerivation) {\n      CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\n    }\n    if (ctorsByDerivation[optionsKey]) {\n      return new ctorsByDerivation[optionsKey]()\n    }\n\n    const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n\n    // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n    // the renderer switches to this material's program\n    const onBeforeCompile = function (shaderInfo, renderer) {\n      baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);\n\n      // Upgrade the shaders, caching the result by incoming source code\n      const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\n      let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n      if (!upgradedShaders) {\n        const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);\n        upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n      }\n\n      // Inject upgraded shaders and uniforms into the program\n      shaderInfo.vertexShader = upgradedShaders.vertexShader;\n      shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n      assign(shaderInfo.uniforms, this.uniforms);\n\n      // Inject auto-updating time uniform if requested\n      if (options.timeUniform) {\n        shaderInfo.uniforms[options.timeUniform] = {\n          get value() {return Date.now() - epoch}\n        };\n      }\n\n      // Users can still add their own handlers on top of ours\n      if (this[privateBeforeCompileProp]) {\n        this[privateBeforeCompileProp](shaderInfo);\n      }\n    };\n\n    const DerivedMaterial = function DerivedMaterial() {\n      return derive(options.chained ? baseMaterial : baseMaterial.clone())\n    };\n\n    const derive = function(base) {\n      // Prototype chain to the base material\n      const derived = Object.create(base, descriptor);\n\n      // Store the baseMaterial for reference; this is always the original even when cloning\n      Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\n\n      // Needs its own ids\n      Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\n      derived.uuid = generateUUID();\n\n      // Merge uniforms, defines, and extensions\n      derived.uniforms = assign({}, base.uniforms, options.uniforms);\n      derived.defines = assign({}, base.defines, options.defines);\n      derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n      derived.extensions = assign({}, base.extensions, options.extensions);\n\n      // Don't inherit EventDispatcher listeners\n      derived._listeners = undefined;\n\n      return derived\n    };\n\n    const descriptor = {\n      constructor: {value: DerivedMaterial},\n      isDerivedMaterial: {value: true},\n\n      customProgramCacheKey: {\n        writable: true,\n        configurable: true,\n        value: function () {\n          return baseMaterial.customProgramCacheKey() + '|' + optionsKey\n        }\n      },\n\n      onBeforeCompile: {\n        get() {\n          return onBeforeCompile\n        },\n        set(fn) {\n          this[privateBeforeCompileProp] = fn;\n        }\n      },\n\n      copy: {\n        writable: true,\n        configurable: true,\n        value: function (source) {\n          baseMaterial.copy.call(this, source);\n          if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n            assign(this.extensions, source.extensions);\n            assign(this.defines, source.defines);\n            assign(this.uniforms, three.UniformsUtils.clone(source.uniforms));\n          }\n          return this\n        }\n      },\n\n      clone: {\n        writable: true,\n        configurable: true,\n        value: function () {\n          const newBase = new baseMaterial.constructor();\n          return derive(newBase).copy(this)\n        }\n      },\n\n      /**\n       * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDepthMaterial: {\n        writable: true,\n        configurable: true,\n        value: function() {\n          let depthMaterial = this._depthMaterial;\n          if (!depthMaterial) {\n            depthMaterial = this._depthMaterial = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDepthMaterial()\n                : new three.MeshDepthMaterial({ depthPacking: three.RGBADepthPacking }),\n              options\n            );\n            depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n            depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n          }\n          return depthMaterial\n        }\n      },\n\n      /**\n       * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n       * transformations and discarded fragments.\n       */\n      getDistanceMaterial: {\n        writable: true,\n        configurable: true,\n        value: function() {\n          let distanceMaterial = this._distanceMaterial;\n          if (!distanceMaterial) {\n            distanceMaterial = this._distanceMaterial = createDerivedMaterial(\n              baseMaterial.isDerivedMaterial\n                ? baseMaterial.getDistanceMaterial()\n                : new three.MeshDistanceMaterial(),\n              options\n            );\n            distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n            distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n          }\n          return distanceMaterial\n        }\n      },\n\n      dispose: {\n        writable: true,\n        configurable: true,\n        value() {\n          const {_depthMaterial, _distanceMaterial} = this;\n          if (_depthMaterial) _depthMaterial.dispose();\n          if (_distanceMaterial) _distanceMaterial.dispose();\n          baseMaterial.dispose.call(this);\n        }\n      }\n    };\n\n    ctorsByDerivation[optionsKey] = DerivedMaterial;\n    return new DerivedMaterial()\n  }\n\n\n  function upgradeShaders(material, {vertexShader, fragmentShader}, options, key) {\n    let {\n      vertexDefs,\n      vertexMainIntro,\n      vertexMainOutro,\n      vertexTransform,\n      fragmentDefs,\n      fragmentMainIntro,\n      fragmentMainOutro,\n      fragmentColorTransform,\n      customRewriter,\n      timeUniform\n    } = options;\n\n    vertexDefs = vertexDefs || '';\n    vertexMainIntro = vertexMainIntro || '';\n    vertexMainOutro = vertexMainOutro || '';\n    fragmentDefs = fragmentDefs || '';\n    fragmentMainIntro = fragmentMainIntro || '';\n    fragmentMainOutro = fragmentMainOutro || '';\n\n    // Expand includes if needed\n    if (vertexTransform || customRewriter) {\n      vertexShader = expandShaderIncludes(vertexShader);\n    }\n    if (fragmentColorTransform || customRewriter) {\n      // We need to be able to find postprocessing chunks after include expansion in order to\n      // put them after the fragmentColorTransform, so mark them with comments first. Even if\n      // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n      // so we still mark them.\n      fragmentShader = fragmentShader.replace(\n        /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n        '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\n      );\n      fragmentShader = expandShaderIncludes(fragmentShader);\n    }\n\n    // Apply custom rewriter function\n    if (customRewriter) {\n      let res = customRewriter({vertexShader, fragmentShader});\n      vertexShader = res.vertexShader;\n      fragmentShader = res.fragmentShader;\n    }\n\n    // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n    // those and re-insert them into the outro in the correct place:\n    if (fragmentColorTransform) {\n      let postChunks = [];\n      fragmentShader = fragmentShader.replace(\n        /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n        match => {\n          postChunks.push(match);\n          return ''\n        }\n      );\n      fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n    }\n\n    // Inject auto-updating time uniform if requested\n    if (timeUniform) {\n      const code = `\\nuniform float ${timeUniform};\\n`;\n      vertexDefs = code + vertexDefs;\n      fragmentDefs = code + fragmentDefs;\n    }\n\n    // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n    if (vertexTransform) {\n      // Hoist these defs to the very top so they work in other function defs\n      vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n      vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n      vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n      vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n        return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\n      });\n\n      // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'\n      // Perhaps the other textures too going forward?\n      if (!(material.map && material.map.channel > 0)) {\n        vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);\n      }\n    }\n\n    // Inject defs and intro/outro snippets\n    vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n    fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n    return {\n      vertexShader,\n      fragmentShader\n    }\n  }\n\n  function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n    if (intro || outro || defs) {\n      shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`\n      );\n      shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n    }\n    return shaderCode\n  }\n\n\n  function optionsJsonReplacer(key, value) {\n    return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\n  }\n\n  let _idCtr = 0;\n  const optionsHashesToIds = new Map();\n  function getKeyForOptions(options) {\n    const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n    let id = optionsHashesToIds.get(optionsHash);\n    if (id == null) {\n      optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\n    }\n    return id\n  }\n\n  // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n  // TODO how can we keep this from getting stale?\n  const MATERIAL_TYPES_TO_SHADERS = {\n    MeshDepthMaterial: 'depth',\n    MeshDistanceMaterial: 'distanceRGBA',\n    MeshNormalMaterial: 'normal',\n    MeshBasicMaterial: 'basic',\n    MeshLambertMaterial: 'lambert',\n    MeshPhongMaterial: 'phong',\n    MeshToonMaterial: 'toon',\n    MeshStandardMaterial: 'physical',\n    MeshPhysicalMaterial: 'physical',\n    MeshMatcapMaterial: 'matcap',\n    LineBasicMaterial: 'basic',\n    LineDashedMaterial: 'dashed',\n    PointsMaterial: 'points',\n    ShadowMaterial: 'shadow',\n    SpriteMaterial: 'sprite'\n  };\n\n  /**\n   * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n   * used to render that material.\n   *\n   * @param material - the Material instance\n   * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n   */\n  function getShadersForMaterial(material) {\n    let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n    return builtinType ? three.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n  }\n\n  /**\n   * Find all uniforms and their types within a shader code string.\n   *\n   * @param {string} shader - The shader code to parse\n   * @return {object} mapping of uniform names to their glsl type\n   */\n  function getShaderUniformTypes(shader) {\n    let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n    let uniforms = Object.create(null);\n    let match;\n    while ((match = uniformRE.exec(shader)) !== null) {\n      uniforms[match[2]] = match[1];\n    }\n    return uniforms\n  }\n\n  /**\n   * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n   * that happened in ThreeJS r123.\n   * @param {Matrix4} srcMatrix\n   * @param {Matrix4} [tgtMatrix]\n   */\n  function invertMatrix4(srcMatrix, tgtMatrix = new three.Matrix4()) {\n    if (typeof tgtMatrix.invert === 'function') {\n      tgtMatrix.copy(srcMatrix).invert();\n    } else {\n      tgtMatrix.getInverse(srcMatrix);\n    }\n    return tgtMatrix\n  }\n\n  /*\n  Input geometry is a cylinder with r=1, height in y dimension from 0 to 1,\n  divided into a reasonable number of height segments.\n  */\n\n  const vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\n\n  const vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\n\n  const fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\n\n  const fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n\n  // Debugging: separate color for each of the 6 sides:\n  // const fragmentColorTransform = `\n  // float sideNum = floor(vUV.x * 6.0);\n  // vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n  //   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n  //   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n  //   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n  //   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n  //   vec3(1.0, 0.0, 1.0);\n  // gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n  // `\n\n\n\n  function createBezierMeshMaterial(baseMaterial) {\n    return createDerivedMaterial(\n      baseMaterial,\n      {\n        chained: true,\n        uniforms: {\n          pointA: {value: new three.Vector3()},\n          controlA: {value: new three.Vector3()},\n          controlB: {value: new three.Vector3()},\n          pointB: {value: new three.Vector3()},\n          radius: {value: 0.01},\n          dashing: {value: new three.Vector3()} //on, off, offset\n        },\n        vertexDefs,\n        vertexTransform,\n        fragmentDefs,\n        fragmentMainIntro\n      }\n    )\n  }\n\n  let geometry = null;\n\n  const defaultBaseMaterial = /*#__PURE__*/new three.MeshStandardMaterial({color: 0xffffff, side: three.DoubleSide});\n\n\n  /**\n   * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n   * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n   * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n   * automatically.\n   *\n   * The cubiz bezier path is determined by its four `Vector3` properties:\n   * - `pointA`\n   * - `controlA`\n   * - `controlB`\n   * - `pointB`\n   *\n   * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n   *\n   * You can also give the tube a dashed appearance with two properties:\n   *\n   * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n   *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n   *   used as input to the cubic bezier function, not its visible length.)\n   * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n   *\n   * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n   * thicker tubes.\n   *\n   * TODO: proper geometry bounding sphere and raycasting\n   * TODO: allow control of the geometry's segment counts\n   */\n  class BezierMesh extends three.Mesh {\n    static getGeometry() {\n      return geometry || (geometry =\n        new three.CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n      )\n    }\n\n    constructor() {\n      super(\n        BezierMesh.getGeometry(),\n        defaultBaseMaterial\n      );\n\n      this.pointA = new three.Vector3();\n      this.controlA = new three.Vector3();\n      this.controlB = new three.Vector3();\n      this.pointB = new three.Vector3();\n      this.radius = 0.01;\n      this.dashArray = new three.Vector2();\n      this.dashOffset = 0;\n\n      // TODO - disabling frustum culling until I figure out how to customize the\n      //  geometry's bounding sphere that gets used\n      this.frustumCulled = false;\n    }\n\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    get material() {\n      let derivedMaterial = this._derivedMaterial;\n      const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      return derivedMaterial\n    }\n    set material(baseMaterial) {\n      this._baseMaterial = baseMaterial;\n    }\n\n    // Create and update material for shadows upon request:\n    get customDepthMaterial() {\n      return this.material.getDepthMaterial()\n    }\n    get customDistanceMaterial() {\n      return this.material.getDistanceMaterial()\n    }\n\n    onBeforeRender() {\n      const {uniforms} = this.material;\n      const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\n      uniforms.pointA.value.copy(pointA);\n      uniforms.controlA.value.copy(controlA);\n      uniforms.controlB.value.copy(controlB);\n      uniforms.pointB.value.copy(pointB);\n      uniforms.radius.value = radius;\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    }\n\n    raycast(/*raycaster, intersects*/) {\n      // TODO - just fail for now\n    }\n  }\n\n  exports.BezierMesh = BezierMesh;\n  exports.createDerivedMaterial = createDerivedMaterial;\n  exports.expandShaderIncludes = expandShaderIncludes;\n  exports.getShaderUniformTypes = getShaderUniformTypes;\n  exports.getShadersForMaterial = getShadersForMaterial;\n  exports.invertMatrix4 = invertMatrix4;\n  exports.voidMainRegExp = voidMainRegExp;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLnVtZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEVBQUUsS0FBNEQsb0JBQW9CLG1CQUFPLENBQUMseURBQU87QUFDakcsRUFBRSxDQUNpSTtBQUNuSSxDQUFDLG9DQUFvQzs7QUFFckM7QUFDQSx1REFBdUQ7QUFDdkQsWUFBWTtBQUNaO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUSxrRUFBa0Usa0JBQWtCO0FBQ3pHLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FB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Q2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVyc29uYWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy90cm9pa2EtdGhyZWUtdXRpbHMvZGlzdC90cm9pa2EtdGhyZWUtdXRpbHMudW1kLmpzPzFlNjEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCd0aHJlZScpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAndGhyZWUnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC50cm9pa2FfdGhyZWVfdXRpbHMgPSB7fSwgZ2xvYmFsLlRIUkVFKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cywgdGhyZWUpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIHRoZSBgdm9pZCBtYWluKCkge2Agb3BlbmVyIGxpbmUgaW4gR0xTTC5cbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gIGNvbnN0IHZvaWRNYWluUmVnRXhwID0gL1xcYnZvaWRcXHMrbWFpblxccypcXChcXHMqXFwpXFxzKnsvZztcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgZXhwYW5kcyBhbGwgYCNpbmNsdWRlIDx4eXo+YCBzdGF0ZW1lbnRzIHdpdGhpbiBzdHJpbmcgb2Ygc2hhZGVyIGNvZGUuXG4gICAqIENvcGllZCBmcm9tIHRocmVlJ3MgV2ViR0xQcm9ncmFtI3BhcnNlSW5jbHVkZXMgZm9yIGV4dGVybmFsIHVzZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIFRoZSBHTFNMIHNvdXJjZSBjb2RlIHRvIGV2YWx1YXRlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEdMU0wgY29kZSB3aXRoIGFsbCBpbmNsdWRlcyBleHBhbmRlZFxuICAgKi9cbiAgZnVuY3Rpb24gZXhwYW5kU2hhZGVySW5jbHVkZXMoIHNvdXJjZSApIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gL15bIFxcdF0qI2luY2x1ZGUgKzwoW1xcd1xcZC4vXSspPi9nbTtcbiAgICBmdW5jdGlvbiByZXBsYWNlKG1hdGNoLCBpbmNsdWRlKSB7XG4gICAgICBsZXQgY2h1bmsgPSB0aHJlZS5TaGFkZXJDaHVua1tpbmNsdWRlXTtcbiAgICAgIHJldHVybiBjaHVuayA/IGV4cGFuZFNoYWRlckluY2x1ZGVzKGNodW5rKSA6IG1hdGNoXG4gICAgfVxuICAgIHJldHVybiBzb3VyY2UucmVwbGFjZSggcGF0dGVybiwgcmVwbGFjZSApXG4gIH1cblxuICAvKlxuICAgKiBUaGlzIGlzIGEgZGlyZWN0IGNvcHkgb2YgTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCBmcm9tIFRocmVlLmpzLCB0byBwcmVzZXJ2ZSBjb21wYXRpYmlsaXR5IHdpdGggdGhyZWVcbiAgICogdmVyc2lvbnMgYmVmb3JlIDAuMTEzLjAgYXMgaXQgd2FzIGNoYW5nZWQgZnJvbSBNYXRoIHRvIE1hdGhVdGlscyBpbiB0aGF0IHZlcnNpb24uXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9kZDhiNWFhM2IyNzBjMTcwOTZiOTA5NDVjZDJkNmQxYjEzYWFlYzUzL3NyYy9tYXRoL01hdGhVdGlscy5qcyNMMTZcbiAgICovXG5cbiAgY29uc3QgX2x1dCA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBfbHV0W2ldID0gKGkgPCAxNiA/ICcwJyA6ICcnKSArIChpKS50b1N0cmluZygxNik7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG5cbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjE5NjMxMzYjMjE5NjMxMzZcblxuICAgIGNvbnN0IGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICAgIGNvbnN0IGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICAgIGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICAgIGNvbnN0IGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICAgIGNvbnN0IHV1aWQgPSBfbHV0W2QwICYgMHhmZl0gKyBfbHV0W2QwID4+IDggJiAweGZmXSArIF9sdXRbZDAgPj4gMTYgJiAweGZmXSArIF9sdXRbZDAgPj4gMjQgJiAweGZmXSArICctJyArXG4gICAgICBfbHV0W2QxICYgMHhmZl0gKyBfbHV0W2QxID4+IDggJiAweGZmXSArICctJyArIF9sdXRbZDEgPj4gMTYgJiAweDBmIHwgMHg0MF0gKyBfbHV0W2QxID4+IDI0ICYgMHhmZl0gKyAnLScgK1xuICAgICAgX2x1dFtkMiAmIDB4M2YgfCAweDgwXSArIF9sdXRbZDIgPj4gOCAmIDB4ZmZdICsgJy0nICsgX2x1dFtkMiA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMiA+PiAyNCAmIDB4ZmZdICtcbiAgICAgIF9sdXRbZDMgJiAweGZmXSArIF9sdXRbZDMgPj4gOCAmIDB4ZmZdICsgX2x1dFtkMyA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMyA+PiAyNCAmIDB4ZmZdO1xuXG4gICAgLy8gLnRvVXBwZXJDYXNlKCkgaGVyZSBmbGF0dGVucyBjb25jYXRlbmF0ZWQgc3RyaW5ncyB0byBzYXZlIGhlYXAgbWVtb3J5IHNwYWNlLlxuICAgIHJldHVybiB1dWlkLnRvVXBwZXJDYXNlKClcblxuICB9XG5cbiAgLy8gTG9jYWwgYXNzaWduIHBvbHlmaWxsIHRvIGF2b2lkIGltcG9ydGluZyB0cm9pa2EtY29yZVxuICBjb25zdCBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKC8qdGFyZ2V0LCAuLi5zb3VyY2VzKi8pIHtcbiAgICBsZXQgdGFyZ2V0ID0gYXJndW1lbnRzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxldCBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRcbiAgfTtcblxuXG4gIGNvbnN0IGVwb2NoID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgQ09OU1RSVUNUT1JfQ0FDSEUgPSBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBTSEFERVJfVVBHUkFERV9DQUNIRSA9IG5ldyBNYXAoKTtcblxuICAvLyBNYXRlcmlhbCBpZHMgbXVzdCBiZSBpbnRlZ2VycywgYnV0IHdlIGNhbid0IGFjY2VzcyB0aGUgaW5jcmVtZW50IGZyb20gVGhyZWUncyBgTWF0ZXJpYWxgIG1vZHVsZSxcbiAgLy8gc28gbGV0J3MgY2hvb3NlIGEgc3VmZmljaWVudGx5IGxhcmdlIHN0YXJ0aW5nIHZhbHVlIHRoYXQgc2hvdWxkIHRoZW9yZXRpY2FsbHkgbmV2ZXIgY29sbGlkZS5cbiAgbGV0IG1hdGVyaWFsSW5zdGFuY2VJZCA9IDFlMTA7XG5cbiAgLyoqXG4gICAqIEEgdXRpbGl0eSBmb3IgY3JlYXRpbmcgYSBjdXN0b20gc2hhZGVyIG1hdGVyaWFsIGRlcml2ZWQgZnJvbSBhbm90aGVyIG1hdGVyaWFsJ3NcbiAgICogc2hhZGVycy4gVGhpcyBhbGxvd3MgeW91IHRvIGluamVjdCBjdXN0b20gc2hhZGVyIGxvZ2ljIGFuZCB0cmFuc2Zvcm1zIGludG8gdGhlXG4gICAqIGJ1aWx0aW4gVGhyZWVKUyBtYXRlcmlhbHMgd2l0aG91dCBoYXZpbmcgdG8gcmVjcmVhdGUgdGhlbSBmcm9tIHNjcmF0Y2guXG4gICAqXG4gICAqIEBwYXJhbSB7VEhSRUUuTWF0ZXJpYWx9IGJhc2VNYXRlcmlhbCAtIHRoZSBvcmlnaW5hbCBtYXRlcmlhbCB0byBkZXJpdmUgZnJvbVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEhvdyB0aGUgYmFzZSBtYXRlcmlhbCBzaG91bGQgYmUgbW9kaWZpZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmRlZmluZXMgLSBDdXN0b20gYGRlZmluZXNgIGZvciB0aGUgbWF0ZXJpYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZXh0ZW5zaW9ucyAtIEN1c3RvbSBgZXh0ZW5zaW9uc2AgZm9yIHRoZSBtYXRlcmlhbCwgZS5nLiBge2Rlcml2YXRpdmVzOiB0cnVlfWBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMudW5pZm9ybXMgLSBDdXN0b20gYHVuaWZvcm1zYCBmb3IgdXNlIGluIHRoZSBtb2RpZmllZCBzaGFkZXIuIFRoZXNlIGNhblxuICAgKiAgICAgICAgYmUgYWNjZXNzZWQgYW5kIG1hbmlwdWxhdGVkIHZpYSB0aGUgcmVzdWx0aW5nIG1hdGVyaWFsJ3MgYHVuaWZvcm1zYCBwcm9wZXJ0eSwganVzdCBsaWtlXG4gICAqICAgICAgICBpbiBhIFNoYWRlck1hdGVyaWFsLiBZb3UgZG8gbm90IG5lZWQgdG8gcmVwZWF0IHRoZSBiYXNlIG1hdGVyaWFsJ3Mgb3duIHVuaWZvcm1zIGhlcmUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWVVbmlmb3JtIC0gSWYgc3BlY2lmaWVkLCBhIHVuaWZvcm0gb2YgdGhpcyBuYW1lIHdpbGwgYmUgaW5qZWN0ZWQgaW50b1xuICAgKiAgICAgICAgYm90aCBzaGFkZXJzLCBhbmQgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHVwZGF0ZWQgb24gZWFjaCByZW5kZXIgZnJhbWUgd2l0aCBhIG51bWJlciBvZlxuICAgKiAgICAgICAgZWxhcHNlZCBtaWxsaXNlY29uZHMuIFRoZSBcInplcm9cIiBlcG9jaCB0aW1lIGlzIG5vdCBzaWduaWZpY2FudCBzbyBkb24ndCByZWx5IG9uIHRoaXMgYXMgYVxuICAgKiAgICAgICAgdHJ1ZSBjYWxlbmRhciB0aW1lLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhEZWZzIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgaW50byB0aGUgdmVydGV4IHNoYWRlcidzIHRvcC1sZXZlbFxuICAgKiAgICAgICAgZGVmaW5pdGlvbnMsIGFib3ZlIHRoZSBgdm9pZCBtYWluKClgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhNYWluSW50cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgdG9wIG9mIHRoZSB2ZXJ0ZXhcbiAgICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhNYWluT3V0cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgZW5kIG9mIHRoZSB2ZXJ0ZXhcbiAgICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhUcmFuc2Zvcm0gLSBDdXN0b20gR0xTTCBjb2RlIHRvIG1hbmlwdWxhdGUgdGhlIGBwb3NpdGlvbmAsIGBub3JtYWxgLFxuICAgKiAgICAgICAgYW5kL29yIGB1dmAgdmVydGV4IGF0dHJpYnV0ZXMuIFRoaXMgY29kZSB3aWxsIGJlIHdyYXBwZWQgd2l0aGluIGEgc3RhbmRhbG9uZSBmdW5jdGlvbiB3aXRoXG4gICAqICAgICAgICB0aG9zZSBhdHRyaWJ1dGVzIGV4cG9zZWQgYnkgdGhlaXIgbm9ybWFsIG5hbWVzIGFzIHJlYWQvd3JpdGUgdmFsdWVzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudERlZnMgLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBpbnRvIHRoZSBmcmFnbWVudCBzaGFkZXIncyB0b3AtbGV2ZWxcbiAgICogICAgICAgIGRlZmluaXRpb25zLCBhYm92ZSB0aGUgYHZvaWQgbWFpbigpYCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZnJhZ21lbnRNYWluSW50cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgdG9wIG9mIHRoZSBmcmFnbWVudFxuICAgKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50TWFpbk91dHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnRcbiAgICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLiBZb3UgY2FuIG1hbmlwdWxhdGUgYGdsX0ZyYWdDb2xvcmAgaGVyZSBidXQga2VlcCBpbiBtaW5kIGl0IGdvZXNcbiAgICogICAgICAgIGFmdGVyIGFueSBvZiBUaHJlZUpTJ3MgY29sb3IgcG9zdHByb2Nlc3Npbmcgc2hhZGVyIGNodW5rcyAodG9uZW1hcHBpbmcsIGZvZywgZXRjLiksIHNvIGlmIHlvdVxuICAgKiAgICAgICAgd2FudCB0aG9zZSB0byBhcHBseSB0byB5b3VyIGNoYW5nZXMgdXNlIGBmcmFnbWVudENvbG9yVHJhbnNmb3JtYCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudENvbG9yVHJhbnNmb3JtIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBtYW5pcHVsYXRlIHRoZSBgZ2xfRnJhZ0NvbG9yYFxuICAgKiAgICAgICAgb3V0cHV0IHZhbHVlLiBXaWxsIGJlIGluamVjdGVkIG5lYXIgdGhlIGVuZCBvZiB0aGUgYHZvaWQgbWFpbmAgZnVuY3Rpb24sIGJ1dCBiZWZvcmUgYW55XG4gICAqICAgICAgICBvZiBUaHJlZUpTJ3MgY29sb3IgcG9zdHByb2Nlc3Npbmcgc2hhZGVyIGNodW5rcyAodG9uZW1hcHBpbmcsIGZvZywgZXRjLiksIGFuZCBiZWZvcmUgdGhlXG4gICAqICAgICAgICBgZnJhZ21lbnRNYWluT3V0cm9gLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uPHt2ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXJ9Pjp7dmVydGV4U2hhZGVyLGZyYWdtZW50U2hhZGVyfX0gb3B0aW9ucy5jdXN0b21SZXdyaXRlciAtIEEgZnVuY3Rpb25cbiAgICogICAgICAgIGZvciBwZXJmb3JtaW5nIGN1c3RvbSByZXdyaXRlcyBvZiB0aGUgZnVsbCBzaGFkZXIgY29kZS4gVXNlZnVsIGlmIHlvdSBuZWVkIHRvIGRvIHNvbWV0aGluZ1xuICAgKiAgICAgICAgc3BlY2lhbCB0aGF0J3Mgbm90IGNvdmVyZWQgYnkgdGhlIG90aGVyIGJ1aWx0aW4gb3B0aW9ucy4gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGV4ZWN1dGVkIGJlZm9yZVxuICAgKiAgICAgICAgYW55IG90aGVyIHRyYW5zZm9ybXMgYXJlIGFwcGxpZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jaGFpbmVkIC0gU2V0IHRvIGB0cnVlYCB0byBwcm90b3R5cGUtY2hhaW4gdGhlIGRlcml2ZWQgbWF0ZXJpYWwgdG8gdGhlIGJhc2VcbiAgICogICAgICAgIG1hdGVyaWFsLCByYXRoZXIgdGhhbiB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBjb3B5aW5nIGl0LiBUaGlzIGFsbG93cyB0aGUgZGVyaXZlZCBtYXRlcmlhbCB0b1xuICAgKiAgICAgICAgYXV0b21hdGljYWxseSBwaWNrIHVwIGNoYW5nZXMgbWFkZSB0byB0aGUgYmFzZSBtYXRlcmlhbCBhbmQgaXRzIHByb3BlcnRpZXMuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICAgKiAgICAgICAgd2hlcmUgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgaXMgaGlkZGVuIGZyb20gdGhlIHVzZXIgYXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLCBhbGxvd2luZyB0aGVtXG4gICAqICAgICAgICB0byB3b3JrIHdpdGggdGhlIG9yaWdpbmFsIG1hdGVyaWFsIGxpa2Ugbm9ybWFsLiBCdXQgaXQgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW9yIGlmIG5vdFxuICAgKiAgICAgICAgaGFuZGxlZCBjYXJlZnVsbHkuXG4gICAqXG4gICAqIEByZXR1cm4ge1RIUkVFLk1hdGVyaWFsfVxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQgbWF0ZXJpYWwgd2lsbCBhbHNvIGhhdmUgdHdvIG5ldyBtZXRob2RzLCBgZ2V0RGVwdGhNYXRlcmlhbCgpYCBhbmQgYGdldERpc3RhbmNlTWF0ZXJpYWwoKWAsXG4gICAqIHdoaWNoIGNhbiBiZSBjYWxsZWQgdG8gZ2V0IGEgdmFyaWFudCBvZiB0aGUgZGVyaXZlZCBtYXRlcmlhbCBmb3IgdXNlIGluIHNoYWRvdyBjYXN0aW5nLiBJZiB0aGVcbiAgICogdGFyZ2V0IG1lc2ggaXMgZXhwZWN0ZWQgdG8gY2FzdCBzaGFkb3dzLCB0aGVuIHlvdSBjYW4gYXNzaWduIHRoZXNlIHRvIHRoZSBtZXNoJ3MgYGN1c3RvbURlcHRoTWF0ZXJpYWxgXG4gICAqIChmb3IgZGlyZWN0aW9uYWwgYW5kIHNwb3QgbGlnaHRzKSBhbmQvb3IgYGN1c3RvbURpc3RhbmNlTWF0ZXJpYWxgIChmb3IgcG9pbnQgbGlnaHRzKSBwcm9wZXJ0aWVzIHRvXG4gICAqIGFsbG93IHRoZSBjYXN0IHNoYWRvdyB0byBob25vciB5b3VyIGRlcml2ZWQgc2hhZGVyJ3MgdmVydGV4IHRyYW5zZm9ybXMgYW5kIGRpc2NhcmRlZCBmcmFnbWVudHMuIFRoZXNlXG4gICAqIHdpbGwgYWxzbyBzZXQgYSBjdXN0b20gYCNkZWZpbmUgSVNfREVQVEhfTUFURVJJQUxgIG9yIGAjZGVmaW5lIElTX0RJU1RBTkNFX01BVEVSSUFMYCB0aGF0IHlvdSBjYW4gbG9va1xuICAgKiBmb3IgaW4geW91ciBkZXJpdmVkIHNoYWRlcnMgd2l0aCBgI2lmZGVmYCB0byBjdXN0b21pemUgdGhlaXIgYmVoYXZpb3IgZm9yIHRoZSBkZXB0aCBvciBkaXN0YW5jZVxuICAgKiBzY2VuYXJpb3MsIGUuZy4gc2tpcHBpbmcgYW50aWFsaWFzaW5nIG9yIGV4cGVuc2l2ZSBzaGFkZXIgbG9naWMuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsLCBvcHRpb25zKSB7XG4gICAgLy8gR2VuZXJhdGUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIGNvbnRlbnQgb2YgdGhlc2UgYG9wdGlvbnNgLiBXZSdsbCB1c2UgdGhpc1xuICAgIC8vIHRocm91Z2hvdXQgZm9yIGNhY2hpbmcgYW5kIGZvciBnZW5lcmF0aW5nIHRoZSB1cGdyYWRlZCBzaGFkZXIgY29kZS4gVGhpcyBpbmNyZWFzZXNcbiAgICAvLyB0aGUgbGlrZWxpaG9vZCB0aGF0IHRoZSByZXN1bHRpbmcgc2hhZGVycyB3aWxsIGxpbmUgdXAgYWNyb3NzIG11bHRpcGxlIGNhbGxzIHNvXG4gICAgLy8gdGhlaXIgR0wgcHJvZ3JhbXMgY2FuIGJlIHNoYXJlZCBhbmQgY2FjaGVkLlxuICAgIGNvbnN0IG9wdGlvbnNLZXkgPSBnZXRLZXlGb3JPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgdG8gc2VlIGlmIHdlJ3ZlIGFscmVhZHkgZGVyaXZlZCBmcm9tIHRoaXMgYmFzZU1hdGVyaWFsIHVzaW5nIHRoaXNcbiAgICAvLyB1bmlxdWUgc2V0IG9mIG9wdGlvbnMsIGFuZCBpZiBzbyByZXVzZSB0aGUgY29uc3RydWN0b3IgdG8gYXZvaWQgc29tZSBhbGxvY2F0aW9ucy5cbiAgICBsZXQgY3RvcnNCeURlcml2YXRpb24gPSBDT05TVFJVQ1RPUl9DQUNIRS5nZXQoYmFzZU1hdGVyaWFsKTtcbiAgICBpZiAoIWN0b3JzQnlEZXJpdmF0aW9uKSB7XG4gICAgICBDT05TVFJVQ1RPUl9DQUNIRS5zZXQoYmFzZU1hdGVyaWFsLCAoY3RvcnNCeURlcml2YXRpb24gPSBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gICAgfVxuICAgIGlmIChjdG9yc0J5RGVyaXZhdGlvbltvcHRpb25zS2V5XSkge1xuICAgICAgcmV0dXJuIG5ldyBjdG9yc0J5RGVyaXZhdGlvbltvcHRpb25zS2V5XSgpXG4gICAgfVxuXG4gICAgY29uc3QgcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wID0gYF9vbkJlZm9yZUNvbXBpbGUke29wdGlvbnNLZXl9YDtcblxuICAgIC8vIFByaXZhdGUgb25CZWZvcmVDb21waWxlIGhhbmRsZXIgdGhhdCBpbmplY3RzIHRoZSBtb2RpZmllZCBzaGFkZXJzIGFuZCB1bmlmb3JtcyB3aGVuXG4gICAgLy8gdGhlIHJlbmRlcmVyIHN3aXRjaGVzIHRvIHRoaXMgbWF0ZXJpYWwncyBwcm9ncmFtXG4gICAgY29uc3Qgb25CZWZvcmVDb21waWxlID0gZnVuY3Rpb24gKHNoYWRlckluZm8sIHJlbmRlcmVyKSB7XG4gICAgICBiYXNlTWF0ZXJpYWwub25CZWZvcmVDb21waWxlLmNhbGwodGhpcywgc2hhZGVySW5mbywgcmVuZGVyZXIpO1xuXG4gICAgICAvLyBVcGdyYWRlIHRoZSBzaGFkZXJzLCBjYWNoaW5nIHRoZSByZXN1bHQgYnkgaW5jb21pbmcgc291cmNlIGNvZGVcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKSArICd8JyArIHNoYWRlckluZm8udmVydGV4U2hhZGVyICsgJ3wnICsgc2hhZGVySW5mby5mcmFnbWVudFNoYWRlcjtcbiAgICAgIGxldCB1cGdyYWRlZFNoYWRlcnMgPSBTSEFERVJfVVBHUkFERV9DQUNIRVtjYWNoZUtleV07XG4gICAgICBpZiAoIXVwZ3JhZGVkU2hhZGVycykge1xuICAgICAgICBjb25zdCB1cGdyYWRlZCA9IHVwZ3JhZGVTaGFkZXJzKHRoaXMsIHNoYWRlckluZm8sIG9wdGlvbnMsIG9wdGlvbnNLZXkpO1xuICAgICAgICB1cGdyYWRlZFNoYWRlcnMgPSBTSEFERVJfVVBHUkFERV9DQUNIRVtjYWNoZUtleV0gPSB1cGdyYWRlZDtcbiAgICAgIH1cblxuICAgICAgLy8gSW5qZWN0IHVwZ3JhZGVkIHNoYWRlcnMgYW5kIHVuaWZvcm1zIGludG8gdGhlIHByb2dyYW1cbiAgICAgIHNoYWRlckluZm8udmVydGV4U2hhZGVyID0gdXBncmFkZWRTaGFkZXJzLnZlcnRleFNoYWRlcjtcbiAgICAgIHNoYWRlckluZm8uZnJhZ21lbnRTaGFkZXIgPSB1cGdyYWRlZFNoYWRlcnMuZnJhZ21lbnRTaGFkZXI7XG4gICAgICBhc3NpZ24oc2hhZGVySW5mby51bmlmb3JtcywgdGhpcy51bmlmb3Jtcyk7XG5cbiAgICAgIC8vIEluamVjdCBhdXRvLXVwZGF0aW5nIHRpbWUgdW5pZm9ybSBpZiByZXF1ZXN0ZWRcbiAgICAgIGlmIChvcHRpb25zLnRpbWVVbmlmb3JtKSB7XG4gICAgICAgIHNoYWRlckluZm8udW5pZm9ybXNbb3B0aW9ucy50aW1lVW5pZm9ybV0gPSB7XG4gICAgICAgICAgZ2V0IHZhbHVlKCkge3JldHVybiBEYXRlLm5vdygpIC0gZXBvY2h9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXJzIGNhbiBzdGlsbCBhZGQgdGhlaXIgb3duIGhhbmRsZXJzIG9uIHRvcCBvZiBvdXJzXG4gICAgICBpZiAodGhpc1twcml2YXRlQmVmb3JlQ29tcGlsZVByb3BdKSB7XG4gICAgICAgIHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXShzaGFkZXJJbmZvKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgRGVyaXZlZE1hdGVyaWFsID0gZnVuY3Rpb24gRGVyaXZlZE1hdGVyaWFsKCkge1xuICAgICAgcmV0dXJuIGRlcml2ZShvcHRpb25zLmNoYWluZWQgPyBiYXNlTWF0ZXJpYWwgOiBiYXNlTWF0ZXJpYWwuY2xvbmUoKSlcbiAgICB9O1xuXG4gICAgY29uc3QgZGVyaXZlID0gZnVuY3Rpb24oYmFzZSkge1xuICAgICAgLy8gUHJvdG90eXBlIGNoYWluIHRvIHRoZSBiYXNlIG1hdGVyaWFsXG4gICAgICBjb25zdCBkZXJpdmVkID0gT2JqZWN0LmNyZWF0ZShiYXNlLCBkZXNjcmlwdG9yKTtcblxuICAgICAgLy8gU3RvcmUgdGhlIGJhc2VNYXRlcmlhbCBmb3IgcmVmZXJlbmNlOyB0aGlzIGlzIGFsd2F5cyB0aGUgb3JpZ2luYWwgZXZlbiB3aGVuIGNsb25pbmdcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXJpdmVkLCAnYmFzZU1hdGVyaWFsJywgeyB2YWx1ZTogYmFzZU1hdGVyaWFsIH0pO1xuXG4gICAgICAvLyBOZWVkcyBpdHMgb3duIGlkc1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWQsICdpZCcsIHsgdmFsdWU6IG1hdGVyaWFsSW5zdGFuY2VJZCsrIH0pO1xuICAgICAgZGVyaXZlZC51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICAgIC8vIE1lcmdlIHVuaWZvcm1zLCBkZWZpbmVzLCBhbmQgZXh0ZW5zaW9uc1xuICAgICAgZGVyaXZlZC51bmlmb3JtcyA9IGFzc2lnbih7fSwgYmFzZS51bmlmb3Jtcywgb3B0aW9ucy51bmlmb3Jtcyk7XG4gICAgICBkZXJpdmVkLmRlZmluZXMgPSBhc3NpZ24oe30sIGJhc2UuZGVmaW5lcywgb3B0aW9ucy5kZWZpbmVzKTtcbiAgICAgIGRlcml2ZWQuZGVmaW5lc1tgVFJPSUtBX0RFUklWRURfTUFURVJJQUxfJHtvcHRpb25zS2V5fWBdID0gJyc7IC8vZm9yY2UgYSBwcm9ncmFtIGNoYW5nZSBmcm9tIHRoZSBiYXNlIG1hdGVyaWFsXG4gICAgICBkZXJpdmVkLmV4dGVuc2lvbnMgPSBhc3NpZ24oe30sIGJhc2UuZXh0ZW5zaW9ucywgb3B0aW9ucy5leHRlbnNpb25zKTtcblxuICAgICAgLy8gRG9uJ3QgaW5oZXJpdCBFdmVudERpc3BhdGNoZXIgbGlzdGVuZXJzXG4gICAgICBkZXJpdmVkLl9saXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBkZXJpdmVkXG4gICAgfTtcblxuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge3ZhbHVlOiBEZXJpdmVkTWF0ZXJpYWx9LFxuICAgICAgaXNEZXJpdmVkTWF0ZXJpYWw6IHt2YWx1ZTogdHJ1ZX0sXG5cbiAgICAgIGN1c3RvbVByb2dyYW1DYWNoZUtleToge1xuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBiYXNlTWF0ZXJpYWwuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KCkgKyAnfCcgKyBvcHRpb25zS2V5XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG9uQmVmb3JlQ29tcGlsZToge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG9uQmVmb3JlQ29tcGlsZVxuICAgICAgICB9LFxuICAgICAgICBzZXQoZm4pIHtcbiAgICAgICAgICB0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0gPSBmbjtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgY29weToge1xuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgIGJhc2VNYXRlcmlhbC5jb3B5LmNhbGwodGhpcywgc291cmNlKTtcbiAgICAgICAgICBpZiAoIWJhc2VNYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmICFiYXNlTWF0ZXJpYWwuaXNEZXJpdmVkTWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIGFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIHNvdXJjZS5leHRlbnNpb25zKTtcbiAgICAgICAgICAgIGFzc2lnbih0aGlzLmRlZmluZXMsIHNvdXJjZS5kZWZpbmVzKTtcbiAgICAgICAgICAgIGFzc2lnbih0aGlzLnVuaWZvcm1zLCB0aHJlZS5Vbmlmb3Jtc1V0aWxzLmNsb25lKHNvdXJjZS51bmlmb3JtcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjbG9uZToge1xuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IG5ld0Jhc2UgPSBuZXcgYmFzZU1hdGVyaWFsLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgcmV0dXJuIGRlcml2ZShuZXdCYXNlKS5jb3B5KHRoaXMpXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVXRpbGl0eSB0byBnZXQgYSBNZXNoRGVwdGhNYXRlcmlhbCB0aGF0IHdpbGwgaG9ub3IgdGhpcyBkZXJpdmVkIG1hdGVyaWFsJ3MgdmVydGV4XG4gICAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgYW5kIGRpc2NhcmRlZCBmcmFnbWVudHMuXG4gICAgICAgKi9cbiAgICAgIGdldERlcHRoTWF0ZXJpYWw6IHtcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxldCBkZXB0aE1hdGVyaWFsID0gdGhpcy5fZGVwdGhNYXRlcmlhbDtcbiAgICAgICAgICBpZiAoIWRlcHRoTWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIGRlcHRoTWF0ZXJpYWwgPSB0aGlzLl9kZXB0aE1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKFxuICAgICAgICAgICAgICBiYXNlTWF0ZXJpYWwuaXNEZXJpdmVkTWF0ZXJpYWxcbiAgICAgICAgICAgICAgICA/IGJhc2VNYXRlcmlhbC5nZXREZXB0aE1hdGVyaWFsKClcbiAgICAgICAgICAgICAgICA6IG5ldyB0aHJlZS5NZXNoRGVwdGhNYXRlcmlhbCh7IGRlcHRoUGFja2luZzogdGhyZWUuUkdCQURlcHRoUGFja2luZyB9KSxcbiAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRlcHRoTWF0ZXJpYWwuZGVmaW5lcy5JU19ERVBUSF9NQVRFUklBTCA9ICcnO1xuICAgICAgICAgICAgZGVwdGhNYXRlcmlhbC51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7IC8vYXV0b21hdGljYWxseSByZWNpZXZlIHNhbWUgdW5pZm9ybSB2YWx1ZXNcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlcHRoTWF0ZXJpYWxcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVdGlsaXR5IHRvIGdldCBhIE1lc2hEaXN0YW5jZU1hdGVyaWFsIHRoYXQgd2lsbCBob25vciB0aGlzIGRlcml2ZWQgbWF0ZXJpYWwncyB2ZXJ0ZXhcbiAgICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgICAqL1xuICAgICAgZ2V0RGlzdGFuY2VNYXRlcmlhbDoge1xuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGV0IGRpc3RhbmNlTWF0ZXJpYWwgPSB0aGlzLl9kaXN0YW5jZU1hdGVyaWFsO1xuICAgICAgICAgIGlmICghZGlzdGFuY2VNYXRlcmlhbCkge1xuICAgICAgICAgICAgZGlzdGFuY2VNYXRlcmlhbCA9IHRoaXMuX2Rpc3RhbmNlTWF0ZXJpYWwgPSBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoXG4gICAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICAgID8gYmFzZU1hdGVyaWFsLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICAgICAgICAgICAgICAgIDogbmV3IHRocmVlLk1lc2hEaXN0YW5jZU1hdGVyaWFsKCksXG4gICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkaXN0YW5jZU1hdGVyaWFsLmRlZmluZXMuSVNfRElTVEFOQ0VfTUFURVJJQUwgPSAnJztcbiAgICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zOyAvL2F1dG9tYXRpY2FsbHkgcmVjaWV2ZSBzYW1lIHVuaWZvcm0gdmFsdWVzXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaXN0YW5jZU1hdGVyaWFsXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRpc3Bvc2U6IHtcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUoKSB7XG4gICAgICAgICAgY29uc3Qge19kZXB0aE1hdGVyaWFsLCBfZGlzdGFuY2VNYXRlcmlhbH0gPSB0aGlzO1xuICAgICAgICAgIGlmIChfZGVwdGhNYXRlcmlhbCkgX2RlcHRoTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICAgIGlmIChfZGlzdGFuY2VNYXRlcmlhbCkgX2Rpc3RhbmNlTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICAgIGJhc2VNYXRlcmlhbC5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY3RvcnNCeURlcml2YXRpb25bb3B0aW9uc0tleV0gPSBEZXJpdmVkTWF0ZXJpYWw7XG4gICAgcmV0dXJuIG5ldyBEZXJpdmVkTWF0ZXJpYWwoKVxuICB9XG5cblxuICBmdW5jdGlvbiB1cGdyYWRlU2hhZGVycyhtYXRlcmlhbCwge3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJ9LCBvcHRpb25zLCBrZXkpIHtcbiAgICBsZXQge1xuICAgICAgdmVydGV4RGVmcyxcbiAgICAgIHZlcnRleE1haW5JbnRybyxcbiAgICAgIHZlcnRleE1haW5PdXRybyxcbiAgICAgIHZlcnRleFRyYW5zZm9ybSxcbiAgICAgIGZyYWdtZW50RGVmcyxcbiAgICAgIGZyYWdtZW50TWFpbkludHJvLFxuICAgICAgZnJhZ21lbnRNYWluT3V0cm8sXG4gICAgICBmcmFnbWVudENvbG9yVHJhbnNmb3JtLFxuICAgICAgY3VzdG9tUmV3cml0ZXIsXG4gICAgICB0aW1lVW5pZm9ybVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgdmVydGV4RGVmcyA9IHZlcnRleERlZnMgfHwgJyc7XG4gICAgdmVydGV4TWFpbkludHJvID0gdmVydGV4TWFpbkludHJvIHx8ICcnO1xuICAgIHZlcnRleE1haW5PdXRybyA9IHZlcnRleE1haW5PdXRybyB8fCAnJztcbiAgICBmcmFnbWVudERlZnMgPSBmcmFnbWVudERlZnMgfHwgJyc7XG4gICAgZnJhZ21lbnRNYWluSW50cm8gPSBmcmFnbWVudE1haW5JbnRybyB8fCAnJztcbiAgICBmcmFnbWVudE1haW5PdXRybyA9IGZyYWdtZW50TWFpbk91dHJvIHx8ICcnO1xuXG4gICAgLy8gRXhwYW5kIGluY2x1ZGVzIGlmIG5lZWRlZFxuICAgIGlmICh2ZXJ0ZXhUcmFuc2Zvcm0gfHwgY3VzdG9tUmV3cml0ZXIpIHtcbiAgICAgIHZlcnRleFNoYWRlciA9IGV4cGFuZFNoYWRlckluY2x1ZGVzKHZlcnRleFNoYWRlcik7XG4gICAgfVxuICAgIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtIHx8IGN1c3RvbVJld3JpdGVyKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGJlIGFibGUgdG8gZmluZCBwb3N0cHJvY2Vzc2luZyBjaHVua3MgYWZ0ZXIgaW5jbHVkZSBleHBhbnNpb24gaW4gb3JkZXIgdG9cbiAgICAgIC8vIHB1dCB0aGVtIGFmdGVyIHRoZSBmcmFnbWVudENvbG9yVHJhbnNmb3JtLCBzbyBtYXJrIHRoZW0gd2l0aCBjb21tZW50cyBmaXJzdC4gRXZlbiBpZlxuICAgICAgLy8gdGhpcyBwYXJ0aWN1bGFyIGRlcml2YXRpb24gZG9lc24ndCBoYXZlIGEgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSwgb3RoZXIgZGVyaXZhdGlvbnMgbWF5LFxuICAgICAgLy8gc28gd2Ugc3RpbGwgbWFyayB0aGVtLlxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlci5yZXBsYWNlKFxuICAgICAgICAvXlsgXFx0XSojaW5jbHVkZSA8KCg/OnRvbmVtYXBwaW5nfGVuY29kaW5nc3xmb2d8cHJlbXVsdGlwbGllZF9hbHBoYXxkaXRoZXJpbmcpX2ZyYWdtZW50KT4vZ20sXG4gICAgICAgICdcXG4vLyFCRUdJTl9QT1NUX0NIVU5LICQxXFxuJCZcXG4vLyFFTkRfUE9TVF9DSFVOS1xcbidcbiAgICAgICk7XG4gICAgICBmcmFnbWVudFNoYWRlciA9IGV4cGFuZFNoYWRlckluY2x1ZGVzKGZyYWdtZW50U2hhZGVyKTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBjdXN0b20gcmV3cml0ZXIgZnVuY3Rpb25cbiAgICBpZiAoY3VzdG9tUmV3cml0ZXIpIHtcbiAgICAgIGxldCByZXMgPSBjdXN0b21SZXdyaXRlcih7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn0pO1xuICAgICAgdmVydGV4U2hhZGVyID0gcmVzLnZlcnRleFNoYWRlcjtcbiAgICAgIGZyYWdtZW50U2hhZGVyID0gcmVzLmZyYWdtZW50U2hhZGVyO1xuICAgIH1cblxuICAgIC8vIFRoZSBmcmFnbWVudENvbG9yVHJhbnNmb3JtIG5lZWRzIHRvIGdvIGJlZm9yZSBhbnkgcG9zdHByb2Nlc3NpbmcgY2h1bmtzLCBzbyBleHRyYWN0XG4gICAgLy8gdGhvc2UgYW5kIHJlLWluc2VydCB0aGVtIGludG8gdGhlIG91dHJvIGluIHRoZSBjb3JyZWN0IHBsYWNlOlxuICAgIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtKSB7XG4gICAgICBsZXQgcG9zdENodW5rcyA9IFtdO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlci5yZXBsYWNlKFxuICAgICAgICAvXlxcL1xcLyFCRUdJTl9QT1NUX0NIVU5LW15dKz9eXFwvXFwvIUVORF9QT1NUX0NIVU5LL2dtLCAvLyBbXl0rPyA9IG5vbi1ncmVlZHkgbWF0Y2ggb2YgYW55IGNoYXJzIGluY2x1ZGluZyBuZXdsaW5lc1xuICAgICAgICBtYXRjaCA9PiB7XG4gICAgICAgICAgcG9zdENodW5rcy5wdXNoKG1hdGNoKTtcbiAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGZyYWdtZW50TWFpbk91dHJvID0gYCR7ZnJhZ21lbnRDb2xvclRyYW5zZm9ybX1cXG4ke3Bvc3RDaHVua3Muam9pbignXFxuJyl9XFxuJHtmcmFnbWVudE1haW5PdXRyb31gO1xuICAgIH1cblxuICAgIC8vIEluamVjdCBhdXRvLXVwZGF0aW5nIHRpbWUgdW5pZm9ybSBpZiByZXF1ZXN0ZWRcbiAgICBpZiAodGltZVVuaWZvcm0pIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBgXFxudW5pZm9ybSBmbG9hdCAke3RpbWVVbmlmb3JtfTtcXG5gO1xuICAgICAgdmVydGV4RGVmcyA9IGNvZGUgKyB2ZXJ0ZXhEZWZzO1xuICAgICAgZnJhZ21lbnREZWZzID0gY29kZSArIGZyYWdtZW50RGVmcztcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgYSBmdW5jdGlvbiBmb3IgdGhlIHZlcnRleFRyYW5zZm9ybSBhbmQgcmVuYW1lIGFsbCB1c2FnZXMgb2YgcG9zaXRpb24vbm9ybWFsL3V2XG4gICAgaWYgKHZlcnRleFRyYW5zZm9ybSkge1xuICAgICAgLy8gSG9pc3QgdGhlc2UgZGVmcyB0byB0aGUgdmVyeSB0b3Agc28gdGhleSB3b3JrIGluIG90aGVyIGZ1bmN0aW9uIGRlZnNcbiAgICAgIHZlcnRleFNoYWRlciA9IGB2ZWMzIHRyb2lrYV9wb3NpdGlvbl8ke2tleX07XG52ZWMzIHRyb2lrYV9ub3JtYWxfJHtrZXl9O1xudmVjMiB0cm9pa2FfdXZfJHtrZXl9O1xuJHt2ZXJ0ZXhTaGFkZXJ9XG5gO1xuICAgICAgdmVydGV4RGVmcyA9IGAke3ZlcnRleERlZnN9XG52b2lkIHRyb2lrYVZlcnRleFRyYW5zZm9ybSR7a2V5fShpbm91dCB2ZWMzIHBvc2l0aW9uLCBpbm91dCB2ZWMzIG5vcm1hbCwgaW5vdXQgdmVjMiB1dikge1xuICAke3ZlcnRleFRyYW5zZm9ybX1cbn1cbmA7XG4gICAgICB2ZXJ0ZXhNYWluSW50cm8gPSBgXG50cm9pa2FfcG9zaXRpb25fJHtrZXl9ID0gdmVjMyhwb3NpdGlvbik7XG50cm9pa2Ffbm9ybWFsXyR7a2V5fSA9IHZlYzMobm9ybWFsKTtcbnRyb2lrYV91dl8ke2tleX0gPSB2ZWMyKHV2KTtcbnRyb2lrYVZlcnRleFRyYW5zZm9ybSR7a2V5fSh0cm9pa2FfcG9zaXRpb25fJHtrZXl9LCB0cm9pa2Ffbm9ybWFsXyR7a2V5fSwgdHJvaWthX3V2XyR7a2V5fSk7XG4ke3ZlcnRleE1haW5JbnRyb31cbmA7XG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZSgvXFxiKHBvc2l0aW9ufG5vcm1hbHx1dilcXGIvZywgKG1hdGNoLCBtYXRjaDEsIGluZGV4LCBmdWxsU3RyKSA9PiB7XG4gICAgICAgIHJldHVybiAvXFxiYXR0cmlidXRlXFxzK3ZlY1syM11cXHMrJC8udGVzdChmdWxsU3RyLnN1YnN0cigwLCBpbmRleCkpID8gbWF0Y2gxIDogYHRyb2lrYV8ke21hdGNoMX1fJHtrZXl9YFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRocmVlIHIxNTIgaW50cm9kdWNlZCB0aGUgTUFQX1VWIHRva2VuLCByZXBsYWNlIGl0IHRvbyBpZiBpdCdzIHBvaW50aW5nIHRvIHRoZSBtYWluICd1didcbiAgICAgIC8vIFBlcmhhcHMgdGhlIG90aGVyIHRleHR1cmVzIHRvbyBnb2luZyBmb3J3YXJkP1xuICAgICAgaWYgKCEobWF0ZXJpYWwubWFwICYmIG1hdGVyaWFsLm1hcC5jaGFubmVsID4gMCkpIHtcbiAgICAgICAgdmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyLnJlcGxhY2UoL1xcYk1BUF9VVlxcYi9nLCBgdHJvaWthX3V2XyR7a2V5fWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluamVjdCBkZWZzIGFuZCBpbnRyby9vdXRybyBzbmlwcGV0c1xuICAgIHZlcnRleFNoYWRlciA9IGluamVjdEludG9TaGFkZXJDb2RlKHZlcnRleFNoYWRlciwga2V5LCB2ZXJ0ZXhEZWZzLCB2ZXJ0ZXhNYWluSW50cm8sIHZlcnRleE1haW5PdXRybyk7XG4gICAgZnJhZ21lbnRTaGFkZXIgPSBpbmplY3RJbnRvU2hhZGVyQ29kZShmcmFnbWVudFNoYWRlciwga2V5LCBmcmFnbWVudERlZnMsIGZyYWdtZW50TWFpbkludHJvLCBmcmFnbWVudE1haW5PdXRybyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmVydGV4U2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmplY3RJbnRvU2hhZGVyQ29kZShzaGFkZXJDb2RlLCBpZCwgZGVmcywgaW50cm8sIG91dHJvKSB7XG4gICAgaWYgKGludHJvIHx8IG91dHJvIHx8IGRlZnMpIHtcbiAgICAgIHNoYWRlckNvZGUgPSBzaGFkZXJDb2RlLnJlcGxhY2Uodm9pZE1haW5SZWdFeHAsIGBcbiR7ZGVmc31cbnZvaWQgdHJvaWthT3JpZ01haW4ke2lkfSgpIHtgXG4gICAgICApO1xuICAgICAgc2hhZGVyQ29kZSArPSBgXG52b2lkIG1haW4oKSB7XG4gICR7aW50cm99XG4gIHRyb2lrYU9yaWdNYWluJHtpZH0oKTtcbiAgJHtvdXRyb31cbn1gO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZGVyQ29kZVxuICB9XG5cblxuICBmdW5jdGlvbiBvcHRpb25zSnNvblJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ga2V5ID09PSAndW5pZm9ybXMnID8gdW5kZWZpbmVkIDogdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlXG4gIH1cblxuICBsZXQgX2lkQ3RyID0gMDtcbiAgY29uc3Qgb3B0aW9uc0hhc2hlc1RvSWRzID0gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiBnZXRLZXlGb3JPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zSGFzaCA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIG9wdGlvbnNKc29uUmVwbGFjZXIpO1xuICAgIGxldCBpZCA9IG9wdGlvbnNIYXNoZXNUb0lkcy5nZXQob3B0aW9uc0hhc2gpO1xuICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zSGFzaGVzVG9JZHMuc2V0KG9wdGlvbnNIYXNoLCAoaWQgPSArK19pZEN0cikpO1xuICAgIH1cbiAgICByZXR1cm4gaWRcbiAgfVxuXG4gIC8vIENvcGllZCBmcm9tIHRocmVlanMgV2ViR0xQcm9ncmFtcy5qcyBzbyB3ZSBjYW4gcmVzb2x2ZSBidWlsdGluIG1hdGVyaWFscyB0byB0aGVpciBzaGFkZXJzXG4gIC8vIFRPRE8gaG93IGNhbiB3ZSBrZWVwIHRoaXMgZnJvbSBnZXR0aW5nIHN0YWxlP1xuICBjb25zdCBNQVRFUklBTF9UWVBFU19UT19TSEFERVJTID0ge1xuICAgIE1lc2hEZXB0aE1hdGVyaWFsOiAnZGVwdGgnLFxuICAgIE1lc2hEaXN0YW5jZU1hdGVyaWFsOiAnZGlzdGFuY2VSR0JBJyxcbiAgICBNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxuICAgIE1lc2hCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICAgIE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ICdsYW1iZXJ0JyxcbiAgICBNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcbiAgICBNZXNoVG9vbk1hdGVyaWFsOiAndG9vbicsXG4gICAgTWVzaFN0YW5kYXJkTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXG4gICAgTWVzaFBoeXNpY2FsTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXG4gICAgTWVzaE1hdGNhcE1hdGVyaWFsOiAnbWF0Y2FwJyxcbiAgICBMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgICBMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxuICAgIFBvaW50c01hdGVyaWFsOiAncG9pbnRzJyxcbiAgICBTaGFkb3dNYXRlcmlhbDogJ3NoYWRvdycsXG4gICAgU3ByaXRlTWF0ZXJpYWw6ICdzcHJpdGUnXG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgVGhyZWUuanMgYE1hdGVyaWFsYCBpbnN0YW5jZSwgZmluZCB0aGUgc2hhZGVycy91bmlmb3JtcyB0aGF0IHdpbGwgYmVcbiAgICogdXNlZCB0byByZW5kZXIgdGhhdCBtYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIG1hdGVyaWFsIC0gdGhlIE1hdGVyaWFsIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSB0aGUgbWF0ZXJpYWwncyBzaGFkZXIgaW5mbzogYHt1bmlmb3Jtczp7fSwgZnJhZ21lbnRTaGFkZXI6JycsIHZlcnRleFNoYWRlcjonJ31gXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTaGFkZXJzRm9yTWF0ZXJpYWwobWF0ZXJpYWwpIHtcbiAgICBsZXQgYnVpbHRpblR5cGUgPSBNQVRFUklBTF9UWVBFU19UT19TSEFERVJTW21hdGVyaWFsLnR5cGVdO1xuICAgIHJldHVybiBidWlsdGluVHlwZSA/IHRocmVlLlNoYWRlckxpYltidWlsdGluVHlwZV0gOiBtYXRlcmlhbCAvL1RPRE8gZmFsbGJhY2sgZm9yIHVua25vd24gdHlwZT9cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGFsbCB1bmlmb3JtcyBhbmQgdGhlaXIgdHlwZXMgd2l0aGluIGEgc2hhZGVyIGNvZGUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hhZGVyIC0gVGhlIHNoYWRlciBjb2RlIHRvIHBhcnNlXG4gICAqIEByZXR1cm4ge29iamVjdH0gbWFwcGluZyBvZiB1bmlmb3JtIG5hbWVzIHRvIHRoZWlyIGdsc2wgdHlwZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2hhZGVyVW5pZm9ybVR5cGVzKHNoYWRlcikge1xuICAgIGxldCB1bmlmb3JtUkUgPSAvXFxidW5pZm9ybVxccysoaW50fGZsb2F0fHZlY1syMzRdfG1hdFszNF0pXFxzKyhbQS1aYS16X11bXFx3XSopL2c7XG4gICAgbGV0IHVuaWZvcm1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IHVuaWZvcm1SRS5leGVjKHNoYWRlcikpICE9PSBudWxsKSB7XG4gICAgICB1bmlmb3Jtc1ttYXRjaFsyXV0gPSBtYXRjaFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaWZvcm1zXG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZvciBzbW9vdGhpbmcgb3V0IHRoZSBgbS5nZXRJbnZlcnNlKHgpYCAtLT4gYG0uY29weSh4KS5pbnZlcnQoKWAgY29udmVyc2lvblxuICAgKiB0aGF0IGhhcHBlbmVkIGluIFRocmVlSlMgcjEyMy5cbiAgICogQHBhcmFtIHtNYXRyaXg0fSBzcmNNYXRyaXhcbiAgICogQHBhcmFtIHtNYXRyaXg0fSBbdGd0TWF0cml4XVxuICAgKi9cbiAgZnVuY3Rpb24gaW52ZXJ0TWF0cml4NChzcmNNYXRyaXgsIHRndE1hdHJpeCA9IG5ldyB0aHJlZS5NYXRyaXg0KCkpIHtcbiAgICBpZiAodHlwZW9mIHRndE1hdHJpeC5pbnZlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRndE1hdHJpeC5jb3B5KHNyY01hdHJpeCkuaW52ZXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRndE1hdHJpeC5nZXRJbnZlcnNlKHNyY01hdHJpeCk7XG4gICAgfVxuICAgIHJldHVybiB0Z3RNYXRyaXhcbiAgfVxuXG4gIC8qXG4gIElucHV0IGdlb21ldHJ5IGlzIGEgY3lsaW5kZXIgd2l0aCByPTEsIGhlaWdodCBpbiB5IGRpbWVuc2lvbiBmcm9tIDAgdG8gMSxcbiAgZGl2aWRlZCBpbnRvIGEgcmVhc29uYWJsZSBudW1iZXIgb2YgaGVpZ2h0IHNlZ21lbnRzLlxuICAqL1xuXG4gIGNvbnN0IHZlcnRleERlZnMgPSBgXG51bmlmb3JtIHZlYzMgcG9pbnRBO1xudW5pZm9ybSB2ZWMzIGNvbnRyb2xBO1xudW5pZm9ybSB2ZWMzIGNvbnRyb2xCO1xudW5pZm9ybSB2ZWMzIHBvaW50QjtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xudmFyeWluZyBmbG9hdCBiZXppZXJUO1xuXG52ZWMzIGN1YmljQmV6aWVyKHZlYzMgcDEsIHZlYzMgYzEsIHZlYzMgYzIsIHZlYzMgcDIsIGZsb2F0IHQpIHtcbiAgZmxvYXQgdDIgPSAxLjAgLSB0O1xuICBmbG9hdCBiMCA9IHQyICogdDIgKiB0MjtcbiAgZmxvYXQgYjEgPSAzLjAgKiB0ICogdDIgKiB0MjtcbiAgZmxvYXQgYjIgPSAzLjAgKiB0ICogdCAqIHQyO1xuICBmbG9hdCBiMyA9IHQgKiB0ICogdDtcbiAgcmV0dXJuIGIwICogcDEgKyBiMSAqIGMxICsgYjIgKiBjMiArIGIzICogcDI7XG59XG5cbnZlYzMgY3ViaWNCZXppZXJEZXJpdmF0aXZlKHZlYzMgcDEsIHZlYzMgYzEsIHZlYzMgYzIsIHZlYzMgcDIsIGZsb2F0IHQpIHtcbiAgZmxvYXQgdDIgPSAxLjAgLSB0O1xuICByZXR1cm4gLTMuMCAqIHAxICogdDIgKiB0MiArXG4gICAgYzEgKiAoMy4wICogdDIgKiB0MiAtIDYuMCAqIHQyICogdCkgK1xuICAgIGMyICogKDYuMCAqIHQyICogdCAtIDMuMCAqIHQgKiB0KSArXG4gICAgMy4wICogcDIgKiB0ICogdDtcbn1cbmA7XG5cbiAgY29uc3QgdmVydGV4VHJhbnNmb3JtID0gYFxuZmxvYXQgdCA9IHBvc2l0aW9uLnk7XG5iZXppZXJUID0gdDtcbnZlYzMgYmV6aWVyQ2VudGVyUG9zID0gY3ViaWNCZXppZXIocG9pbnRBLCBjb250cm9sQSwgY29udHJvbEIsIHBvaW50QiwgdCk7XG52ZWMzIGJlemllckRpciA9IG5vcm1hbGl6ZShjdWJpY0JlemllckRlcml2YXRpdmUocG9pbnRBLCBjb250cm9sQSwgY29udHJvbEIsIHBvaW50QiwgdCkpO1xuXG4vLyBNYWtlIFwic2lkZXdheXNcIiBhbHdheXMgcGVycGVuZGljdWxhciB0byB0aGUgY2FtZXJhIHJheTsgdGhpcyBlbnN1cmVzIHRoYXQgYW55IHR3aXN0c1xuLy8gaW4gdGhlIGN5bGluZGVyIG9jY3VyIHdoZXJlIHlvdSB3b24ndCBzZWUgdGhlbTogXG52ZWMzIHZpZXdEaXJlY3Rpb24gPSBub3JtYWxNYXRyaXggKiB2ZWMzKDAuMCwgMC4wLCAxLjApO1xuaWYgKGJlemllckRpciA9PSB2aWV3RGlyZWN0aW9uKSB7XG4gIGJlemllckRpciA9IG5vcm1hbGl6ZShjdWJpY0JlemllckRlcml2YXRpdmUocG9pbnRBLCBjb250cm9sQSwgY29udHJvbEIsIHBvaW50QiwgdCA9PSAxLjAgPyB0IC0gMC4wMDAxIDogdCArIDAuMDAwMSkpO1xufVxudmVjMyBzaWRld2F5cyA9IG5vcm1hbGl6ZShjcm9zcyhiZXppZXJEaXIsIHZpZXdEaXJlY3Rpb24pKTtcbnZlYzMgdXBpc2ggPSBub3JtYWxpemUoY3Jvc3Moc2lkZXdheXMsIGJlemllckRpcikpO1xuXG4vLyBCdWlsZCBhIG1hdHJpeCBmb3IgdHJhbnNmb3JtaW5nIHRoaXMgZGlzYyBpbiB0aGUgY3lsaW5kZXI6XG5tYXQ0IGRpc2NUeDtcbmRpc2NUeFswXS54eXogPSBzaWRld2F5cyAqIHJhZGl1cztcbmRpc2NUeFsxXS54eXogPSBiZXppZXJEaXIgKiByYWRpdXM7XG5kaXNjVHhbMl0ueHl6ID0gdXBpc2ggKiByYWRpdXM7XG5kaXNjVHhbM10ueHl6ID0gYmV6aWVyQ2VudGVyUG9zO1xuZGlzY1R4WzNdWzNdID0gMS4wO1xuXG4vLyBBcHBseSB0cmFuc2Zvcm0sIGlnbm9yaW5nIG9yaWdpbmFsIHlcbnBvc2l0aW9uID0gKGRpc2NUeCAqIHZlYzQocG9zaXRpb24ueCwgMC4wLCBwb3NpdGlvbi56LCAxLjApKS54eXo7XG5ub3JtYWwgPSBub3JtYWxpemUobWF0MyhkaXNjVHgpICogbm9ybWFsKTtcbmA7XG5cbiAgY29uc3QgZnJhZ21lbnREZWZzID0gYFxudW5pZm9ybSB2ZWMzIGRhc2hpbmc7XG52YXJ5aW5nIGZsb2F0IGJlemllclQ7XG5gO1xuXG4gIGNvbnN0IGZyYWdtZW50TWFpbkludHJvID0gYFxuaWYgKGRhc2hpbmcueCArIGRhc2hpbmcueSA+IDAuMCkge1xuICBmbG9hdCBkYXNoRnJhYyA9IG1vZChiZXppZXJUIC0gZGFzaGluZy56LCBkYXNoaW5nLnggKyBkYXNoaW5nLnkpO1xuICBpZiAoZGFzaEZyYWMgPiBkYXNoaW5nLngpIHtcbiAgICBkaXNjYXJkO1xuICB9XG59XG5gO1xuXG4gIC8vIERlYnVnZ2luZzogc2VwYXJhdGUgY29sb3IgZm9yIGVhY2ggb2YgdGhlIDYgc2lkZXM6XG4gIC8vIGNvbnN0IGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gPSBgXG4gIC8vIGZsb2F0IHNpZGVOdW0gPSBmbG9vcih2VVYueCAqIDYuMCk7XG4gIC8vIHZlYzMgbWl4Q29sb3IgPSBzaWRlTnVtIDwgMS4wID8gdmVjMygxLjAsIDAuMCwgMC4wKSA6XG4gIC8vICAgc2lkZU51bSA8IDIuMCA/IHZlYzMoMC4wLCAxLjAsIDEuMCkgOlxuICAvLyAgIHNpZGVOdW0gPCAzLjAgPyB2ZWMzKDEuMCwgMS4wLCAwLjApIDpcbiAgLy8gICBzaWRlTnVtIDwgNC4wID8gdmVjMygwLjAsIDAuMCwgMS4wKSA6XG4gIC8vICAgc2lkZU51bSA8IDUuMCA/IHZlYzMoMC4wLCAxLjAsIDAuMCkgOlxuICAvLyAgIHZlYzMoMS4wLCAwLjAsIDEuMCk7XG4gIC8vIGdsX0ZyYWdDb2xvci54eXogPSBtaXgoZ2xfRnJhZ0NvbG9yLnh5eiwgbWl4Q29sb3IsIDAuNSk7XG4gIC8vIGBcblxuXG5cbiAgZnVuY3Rpb24gY3JlYXRlQmV6aWVyTWVzaE1hdGVyaWFsKGJhc2VNYXRlcmlhbCkge1xuICAgIHJldHVybiBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoXG4gICAgICBiYXNlTWF0ZXJpYWwsXG4gICAgICB7XG4gICAgICAgIGNoYWluZWQ6IHRydWUsXG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgcG9pbnRBOiB7dmFsdWU6IG5ldyB0aHJlZS5WZWN0b3IzKCl9LFxuICAgICAgICAgIGNvbnRyb2xBOiB7dmFsdWU6IG5ldyB0aHJlZS5WZWN0b3IzKCl9LFxuICAgICAgICAgIGNvbnRyb2xCOiB7dmFsdWU6IG5ldyB0aHJlZS5WZWN0b3IzKCl9LFxuICAgICAgICAgIHBvaW50Qjoge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpfSxcbiAgICAgICAgICByYWRpdXM6IHt2YWx1ZTogMC4wMX0sXG4gICAgICAgICAgZGFzaGluZzoge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpfSAvL29uLCBvZmYsIG9mZnNldFxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0ZXhEZWZzLFxuICAgICAgICB2ZXJ0ZXhUcmFuc2Zvcm0sXG4gICAgICAgIGZyYWdtZW50RGVmcyxcbiAgICAgICAgZnJhZ21lbnRNYWluSW50cm9cbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBsZXQgZ2VvbWV0cnkgPSBudWxsO1xuXG4gIGNvbnN0IGRlZmF1bHRCYXNlTWF0ZXJpYWwgPSAvKiNfX1BVUkVfXyovbmV3IHRocmVlLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtjb2xvcjogMHhmZmZmZmYsIHNpZGU6IHRocmVlLkRvdWJsZVNpZGV9KTtcblxuXG4gIC8qKlxuICAgKiBBIFRocmVlSlMgYE1lc2hgIHRoYXQgYmVuZHMgYSB0dWJlIHNoYXBlIGFsb25nIGEgM0QgY3ViaWMgYmV6aWVyIHBhdGguIFRoZSBiZW5kaW5nIGlzIGRvbmVcbiAgICogYnkgZGVmb3JtaW5nIGEgc3RyYWlnaHQgY3lsaW5kcmljYWwgZ2VvbWV0cnkgaW4gdGhlIHZlcnRleCBzaGFkZXIgYmFzZWQgb24gYSBzZXQgb2YgZm91clxuICAgKiBjb250cm9sIHBvaW50IHVuaWZvcm1zLiBJdCBwYXRjaGVzIHRoZSBuZWNlc3NhcnkgR0xTTCBpbnRvIHRoZSBtZXNoJ3MgYXNzaWduZWQgYG1hdGVyaWFsYFxuICAgKiBhdXRvbWF0aWNhbGx5LlxuICAgKlxuICAgKiBUaGUgY3ViaXogYmV6aWVyIHBhdGggaXMgZGV0ZXJtaW5lZCBieSBpdHMgZm91ciBgVmVjdG9yM2AgcHJvcGVydGllczpcbiAgICogLSBgcG9pbnRBYFxuICAgKiAtIGBjb250cm9sQWBcbiAgICogLSBgY29udHJvbEJgXG4gICAqIC0gYHBvaW50QmBcbiAgICpcbiAgICogVGhlIHR1YmUncyByYWRpdXMgaXMgY29udHJvbGxlZCBieSBpdHMgYHJhZGl1c2AgcHJvcGVydHksIHdoaWNoIGRlZmF1bHRzIHRvIGAwLjAxYC5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIGdpdmUgdGhlIHR1YmUgYSBkYXNoZWQgYXBwZWFyYW5jZSB3aXRoIHR3byBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAtIGBkYXNoQXJyYXlgIC0gYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMsIGRlZmluaW5nIHRoZSBsZW5ndGggb2YgXCJvblwiIGFuZCBcIm9mZlwiIHBhcnRzIG9mXG4gICAqICAgdGhlIGRhc2guIEVhY2ggaXMgYSAwLTEgcmF0aW8gb2YgdGhlIGVudGlyZSBwYXRoJ3MgbGVuZ3RoLiAoQWN0dWFsbHkgdGhpcyBpcyB0aGUgYHRgIGxlbmd0aFxuICAgKiAgIHVzZWQgYXMgaW5wdXQgdG8gdGhlIGN1YmljIGJlemllciBmdW5jdGlvbiwgbm90IGl0cyB2aXNpYmxlIGxlbmd0aC4pXG4gICAqIC0gYGRhc2hPZmZzZXRgIC0gb2Zmc2V0IG9mIHdoZXJlIHRoZSBkYXNoIHN0YXJ0cy4gWW91IGNhbiBhbmltYXRlIHRoaXMgdG8gbWFrZSB0aGUgZGFzaGVzIG1vdmUuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgZGFzaGVzIHdpbGwgYXBwZWFyIGxpa2UgYSBob2xsb3cgdHViZSwgbm90IHNvbGlkLiBUaGlzIHdpbGwgYmUgbW9yZSBhcHBhcmVudCBvblxuICAgKiB0aGlja2VyIHR1YmVzLlxuICAgKlxuICAgKiBUT0RPOiBwcm9wZXIgZ2VvbWV0cnkgYm91bmRpbmcgc3BoZXJlIGFuZCByYXljYXN0aW5nXG4gICAqIFRPRE86IGFsbG93IGNvbnRyb2wgb2YgdGhlIGdlb21ldHJ5J3Mgc2VnbWVudCBjb3VudHNcbiAgICovXG4gIGNsYXNzIEJlemllck1lc2ggZXh0ZW5kcyB0aHJlZS5NZXNoIHtcbiAgICBzdGF0aWMgZ2V0R2VvbWV0cnkoKSB7XG4gICAgICByZXR1cm4gZ2VvbWV0cnkgfHwgKGdlb21ldHJ5ID1cbiAgICAgICAgbmV3IHRocmVlLkN5bGluZGVyR2VvbWV0cnkoMSwgMSwgMSwgNiwgNjQpLnRyYW5zbGF0ZSgwLCAwLjUsIDApXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcihcbiAgICAgICAgQmV6aWVyTWVzaC5nZXRHZW9tZXRyeSgpLFxuICAgICAgICBkZWZhdWx0QmFzZU1hdGVyaWFsXG4gICAgICApO1xuXG4gICAgICB0aGlzLnBvaW50QSA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG4gICAgICB0aGlzLmNvbnRyb2xBID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcbiAgICAgIHRoaXMuY29udHJvbEIgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuICAgICAgdGhpcy5wb2ludEIgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuICAgICAgdGhpcy5yYWRpdXMgPSAwLjAxO1xuICAgICAgdGhpcy5kYXNoQXJyYXkgPSBuZXcgdGhyZWUuVmVjdG9yMigpO1xuICAgICAgdGhpcy5kYXNoT2Zmc2V0ID0gMDtcblxuICAgICAgLy8gVE9ETyAtIGRpc2FibGluZyBmcnVzdHVtIGN1bGxpbmcgdW50aWwgSSBmaWd1cmUgb3V0IGhvdyB0byBjdXN0b21pemUgdGhlXG4gICAgICAvLyAgZ2VvbWV0cnkncyBib3VuZGluZyBzcGhlcmUgdGhhdCBnZXRzIHVzZWRcbiAgICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZXIgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgdGhlIGJhc2UgbWF0ZXJpYWwgd2l0aCBvdXIgdXBncmFkZXMuIFdlIGRvIHRoZSB3cmFwcGluZ1xuICAgIC8vIGxhemlseSBvbiBfcmVhZF8gcmF0aGVyIHRoYW4gd3JpdGUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd3JhcHBpbmcgb24gdHJhbnNpZW50IHZhbHVlcy5cbiAgICBnZXQgbWF0ZXJpYWwoKSB7XG4gICAgICBsZXQgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsO1xuICAgICAgY29uc3QgYmFzZU1hdGVyaWFsID0gdGhpcy5fYmFzZU1hdGVyaWFsIHx8IHRoaXMuX2RlZmF1bHRNYXRlcmlhbCB8fCAodGhpcy5fZGVmYXVsdE1hdGVyaWFsID0gZGVmYXVsdEJhc2VNYXRlcmlhbC5jbG9uZSgpKTtcbiAgICAgIGlmICghZGVyaXZlZE1hdGVyaWFsIHx8IGRlcml2ZWRNYXRlcmlhbC5iYXNlTWF0ZXJpYWwgIT09IGJhc2VNYXRlcmlhbCkge1xuICAgICAgICBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBjcmVhdGVCZXppZXJNZXNoTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKTtcbiAgICAgICAgLy8gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCB3aGVuIGl0cyBiYXNlIG1hdGVyaWFsIGlzIGRpc3Bvc2VkOlxuICAgICAgICBiYXNlTWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIGZ1bmN0aW9uIG9uRGlzcG9zZSgpIHtcbiAgICAgICAgICBiYXNlTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgICAgZGVyaXZlZE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVyaXZlZE1hdGVyaWFsXG4gICAgfVxuICAgIHNldCBtYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW5kIHVwZGF0ZSBtYXRlcmlhbCBmb3Igc2hhZG93cyB1cG9uIHJlcXVlc3Q6XG4gICAgZ2V0IGN1c3RvbURlcHRoTWF0ZXJpYWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRlcmlhbC5nZXREZXB0aE1hdGVyaWFsKClcbiAgICB9XG4gICAgZ2V0IGN1c3RvbURpc3RhbmNlTWF0ZXJpYWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRlcmlhbC5nZXREaXN0YW5jZU1hdGVyaWFsKClcbiAgICB9XG5cbiAgICBvbkJlZm9yZVJlbmRlcigpIHtcbiAgICAgIGNvbnN0IHt1bmlmb3Jtc30gPSB0aGlzLm1hdGVyaWFsO1xuICAgICAgY29uc3Qge3BvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHJhZGl1cywgZGFzaEFycmF5LCBkYXNoT2Zmc2V0fSA9IHRoaXM7XG4gICAgICB1bmlmb3Jtcy5wb2ludEEudmFsdWUuY29weShwb2ludEEpO1xuICAgICAgdW5pZm9ybXMuY29udHJvbEEudmFsdWUuY29weShjb250cm9sQSk7XG4gICAgICB1bmlmb3Jtcy5jb250cm9sQi52YWx1ZS5jb3B5KGNvbnRyb2xCKTtcbiAgICAgIHVuaWZvcm1zLnBvaW50Qi52YWx1ZS5jb3B5KHBvaW50Qik7XG4gICAgICB1bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSByYWRpdXM7XG4gICAgICB1bmlmb3Jtcy5kYXNoaW5nLnZhbHVlLnNldChkYXNoQXJyYXkueCwgZGFzaEFycmF5LnksIGRhc2hPZmZzZXQgfHwgMCk7XG4gICAgfVxuXG4gICAgcmF5Y2FzdCgvKnJheWNhc3RlciwgaW50ZXJzZWN0cyovKSB7XG4gICAgICAvLyBUT0RPIC0ganVzdCBmYWlsIGZvciBub3dcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLkJlemllck1lc2ggPSBCZXppZXJNZXNoO1xuICBleHBvcnRzLmNyZWF0ZURlcml2ZWRNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbDtcbiAgZXhwb3J0cy5leHBhbmRTaGFkZXJJbmNsdWRlcyA9IGV4cGFuZFNoYWRlckluY2x1ZGVzO1xuICBleHBvcnRzLmdldFNoYWRlclVuaWZvcm1UeXBlcyA9IGdldFNoYWRlclVuaWZvcm1UeXBlcztcbiAgZXhwb3J0cy5nZXRTaGFkZXJzRm9yTWF0ZXJpYWwgPSBnZXRTaGFkZXJzRm9yTWF0ZXJpYWw7XG4gIGV4cG9ydHMuaW52ZXJ0TWF0cml4NCA9IGludmVydE1hdHJpeDQ7XG4gIGV4cG9ydHMudm9pZE1haW5SZWdFeHAgPSB2b2lkTWFpblJlZ0V4cDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.umd.js\n");

/***/ })

};
;