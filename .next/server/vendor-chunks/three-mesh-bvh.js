/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-mesh-bvh";
exports.ids = ["vendor-chunks/three-mesh-bvh"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-mesh-bvh/build/index.umd.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/three-mesh-bvh/build/index.umd.cjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? factory(exports, __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\")) :\n\t0;\n})(this, (function (exports, three) { 'use strict';\n\n\t// Split strategy constants\n\tconst CENTER = 0;\n\tconst AVERAGE = 1;\n\tconst SAH = 2;\n\n\t// Traversal constants\n\tconst NOT_INTERSECTED = 0;\n\tconst INTERSECTED = 1;\n\tconst CONTAINED = 2;\n\n\t// SAH cost constants\n\t// TODO: hone these costs more. The relative difference between them should be the\n\t// difference in measured time to perform a triangle intersection vs traversing\n\t// bounds.\n\tconst TRIANGLE_INTERSECT_COST = 1.25;\n\tconst TRAVERSAL_COST = 1;\n\n\n\t// Build constants\n\tconst BYTES_PER_NODE = 6 * 4 + 4 + 4;\n\tconst IS_LEAFNODE_FLAG = 0xFFFF;\n\n\t// EPSILON for computing floating point error during build\n\t// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\n\tconst FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\n\tclass MeshBVHNode {\n\n\t\tconstructor() {\n\n\t\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\t}\n\n\t}\n\n\tfunction arrayToBox( nodeIndex32, array, target ) {\n\n\t\ttarget.min.x = array[ nodeIndex32 ];\n\t\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\t\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\t\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\t\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\t\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\t\treturn target;\n\n\t}\n\n\tfunction makeEmptyBounds( target ) {\n\n\t\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\t\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n\t}\n\n\tfunction getLongestEdgeIndex( bounds ) {\n\n\t\tlet splitDimIdx = - 1;\n\t\tlet splitDist = - Infinity;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\t\tif ( dist > splitDist ) {\n\n\t\t\t\tsplitDist = dist;\n\t\t\t\tsplitDimIdx = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn splitDimIdx;\n\n\t}\n\n\t// copies bounds a into bounds b\n\tfunction copyBounds( source, target ) {\n\n\t\ttarget.set( source );\n\n\t}\n\n\t// sets bounds target to the union of bounds a and b\n\tfunction unionBounds( a, b, target ) {\n\n\t\tlet aVal, bVal;\n\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\tconst d3 = d + 3;\n\n\t\t\t// set the minimum values\n\t\t\taVal = a[ d ];\n\t\t\tbVal = b[ d ];\n\t\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t\t// set the max values\n\t\t\taVal = a[ d3 ];\n\t\t\tbVal = b[ d3 ];\n\t\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t\t}\n\n\t}\n\n\t// expands the given bounds by the provided triangle bounds\n\tfunction expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\t\tconst tMin = tCenter - tHalf;\n\t\t\tconst tMax = tCenter + tHalf;\n\n\t\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\t\tbounds[ d ] = tMin;\n\n\t\t\t}\n\n\t\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// compute bounds surface area\n\tfunction computeSurfaceArea( bounds ) {\n\n\t\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\t\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\t\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\t\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n\t}\n\n\tfunction ensureIndex( geo, options ) {\n\n\t\tif ( ! geo.index ) {\n\n\t\t\tconst vertexCount = geo.attributes.position.count;\n\t\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\t\tlet index;\n\t\t\tif ( vertexCount > 65535 ) {\n\n\t\t\t\tindex = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t\t\t} else {\n\n\t\t\t\tindex = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t\t\t}\n\n\t\t\tgeo.setIndex( new three.BufferAttribute( index, 1 ) );\n\n\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\tindex[ i ] = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n\t// region in the geometry index that belongs to a different set of material groups requires\n\t// a separate BVH root, so that triangles indices belonging to one group never get swapped\n\t// with triangle indices belongs to another group. For example, if the groups were like this:\n\t//\n\t// [-------------------------------------------------------------]\n\t// |__________________|\n\t//   g0 = [0, 20]  |______________________||_____________________|\n\t//                      g1 = [16, 40]           g2 = [41, 60]\n\t//\n\t// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\n\tfunction getRootIndexRanges( geo ) {\n\n\t\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\n\n\t\t}\n\n\t\tconst ranges = [];\n\t\tconst rangeBoundaries = new Set();\n\t\tfor ( const group of geo.groups ) {\n\n\t\t\trangeBoundaries.add( group.start );\n\t\t\trangeBoundaries.add( group.start + group.count );\n\n\t\t}\n\n\t\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\t\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\t\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\n\t\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\n\n\t\t}\n\n\t\treturn ranges;\n\n\t}\n\n\t// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n\t// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n\t// These are computed together to avoid redundant accesses to bounds array.\n\tfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\t\tlet minx = Infinity;\n\t\tlet miny = Infinity;\n\t\tlet minz = Infinity;\n\t\tlet maxx = - Infinity;\n\t\tlet maxy = - Infinity;\n\t\tlet maxz = - Infinity;\n\n\t\tlet cminx = Infinity;\n\t\tlet cminy = Infinity;\n\t\tlet cminz = Infinity;\n\t\tlet cmaxx = - Infinity;\n\t\tlet cmaxy = - Infinity;\n\t\tlet cmaxz = - Infinity;\n\n\t\tconst includeCentroid = centroidTarget !== null;\n\t\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\t\tconst cx = triangleBounds[ i + 0 ];\n\t\t\tconst hx = triangleBounds[ i + 1 ];\n\t\t\tconst lx = cx - hx;\n\t\t\tconst rx = cx + hx;\n\t\t\tif ( lx < minx ) minx = lx;\n\t\t\tif ( rx > maxx ) maxx = rx;\n\t\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\t\tconst cy = triangleBounds[ i + 2 ];\n\t\t\tconst hy = triangleBounds[ i + 3 ];\n\t\t\tconst ly = cy - hy;\n\t\t\tconst ry = cy + hy;\n\t\t\tif ( ly < miny ) miny = ly;\n\t\t\tif ( ry > maxy ) maxy = ry;\n\t\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\t\tconst cz = triangleBounds[ i + 4 ];\n\t\t\tconst hz = triangleBounds[ i + 5 ];\n\t\t\tconst lz = cz - hz;\n\t\t\tconst rz = cz + hz;\n\t\t\tif ( lz < minz ) minz = lz;\n\t\t\tif ( rz > maxz ) maxz = rz;\n\t\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t\t}\n\n\t\ttarget[ 0 ] = minx;\n\t\ttarget[ 1 ] = miny;\n\t\ttarget[ 2 ] = minz;\n\n\t\ttarget[ 3 ] = maxx;\n\t\ttarget[ 4 ] = maxy;\n\t\ttarget[ 5 ] = maxz;\n\n\t\tif ( includeCentroid ) {\n\n\t\t\tcentroidTarget[ 0 ] = cminx;\n\t\t\tcentroidTarget[ 1 ] = cminy;\n\t\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t\t}\n\n\t}\n\n\t// A stand alone function for retrieving the centroid bounds.\n\tfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\t\tlet cminx = Infinity;\n\t\tlet cminy = Infinity;\n\t\tlet cminz = Infinity;\n\t\tlet cmaxx = - Infinity;\n\t\tlet cmaxy = - Infinity;\n\t\tlet cmaxz = - Infinity;\n\n\t\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\t\tconst cx = triangleBounds[ i + 0 ];\n\t\t\tif ( cx < cminx ) cminx = cx;\n\t\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\t\tconst cy = triangleBounds[ i + 2 ];\n\t\t\tif ( cy < cminy ) cminy = cy;\n\t\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\t\tconst cz = triangleBounds[ i + 4 ];\n\t\t\tif ( cz < cminz ) cminz = cz;\n\t\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t\t}\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n\n\t// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n\t// will be on the left and elements on the right side of the split will be on the right. returns the index\n\t// of the first element on the right side, or offset + count if there are no elements on the right side.\n\tfunction partition( index, triangleBounds, offset, count, split ) {\n\n\t\tlet left = offset;\n\t\tlet right = offset + count - 1;\n\t\tconst pos = split.pos;\n\t\tconst axisOffset = split.axis * 2;\n\n\t\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\t\twhile ( true ) {\n\n\t\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\t\tleft ++;\n\n\t\t\t}\n\n\n\t\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\t\tright --;\n\n\t\t\t}\n\n\t\t\tif ( left < right ) {\n\n\t\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t\t// and perhaps the SAH planes\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\n\t\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\n\t\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\n\n\t\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\n\t\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\n\t\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\n\n\t\t\t\t}\n\n\t\t\t\tleft ++;\n\t\t\t\tright --;\n\n\t\t\t} else {\n\n\t\t\t\treturn left;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst BIN_COUNT = 32;\n\tconst binsSort = ( a, b ) => a.candidate - b.candidate;\n\tconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\t\treturn {\n\n\t\t\tcount: 0,\n\t\t\tbounds: new Float32Array( 6 ),\n\t\t\trightCacheBounds: new Float32Array( 6 ),\n\t\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\t\tcandidate: 0,\n\n\t\t};\n\n\t} );\n\tconst leftBounds = new Float32Array( 6 );\n\n\tfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\t\tlet axis = - 1;\n\t\tlet pos = 0;\n\n\t\t// Center\n\t\tif ( strategy === CENTER ) {\n\n\t\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\t\tif ( axis !== - 1 ) {\n\n\t\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t\t}\n\n\t\t} else if ( strategy === AVERAGE ) {\n\n\t\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\t\tif ( axis !== - 1 ) {\n\n\t\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t\t}\n\n\t\t} else if ( strategy === SAH ) {\n\n\t\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t\t// iterate over all axes\n\t\t\tconst cStart = offset * 6;\n\t\t\tconst cEnd = ( offset + count ) * 6;\n\t\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t\t// the triangle positions because it will be faster.\n\t\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t\t// initialize the bin candidates\n\t\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t\t// set the candidates\n\t\t\t\t\tlet b = 0;\n\t\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\tbounds,\n\t\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t\t} = bin;\n\t\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t\t// remove redundant splits\n\t\t\t\t\tlet splitCount = count;\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// expand all the bounds\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t\t// check the cost of this split\n\t\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// reset the bins\n\t\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\t\tbin.count = 0;\n\t\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// iterate over all center positions\n\t\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet leftCount = 0;\n\t\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t\t// check the cost of this split\n\t\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t\t}\n\n\t\treturn { axis, pos };\n\n\t}\n\n\t// returns the average coordinate on the specified axis of the all the provided triangles\n\tfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\t\tlet avg = 0;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t\t}\n\n\t\treturn avg / count;\n\n\t}\n\n\t// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n\t// result is an array of size tris.length * 6 where triangle i maps to a\n\t// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n\t// representing the center and half-extent in each dimension of triangle i\n\tfunction computeTriangleBounds( geo, fullBounds ) {\n\n\t\t// clear the bounds to empty\n\t\tmakeEmptyBounds( fullBounds );\n\n\t\tconst posAttr = geo.attributes.position;\n\t\tconst index = geo.index.array;\n\t\tconst triCount = index.length / 3;\n\t\tconst triangleBounds = new Float32Array( triCount * 6 );\n\t\tconst normalized = posAttr.normalized;\n\n\t\t// used for non-normalized positions\n\t\tconst posArr = posAttr.array;\n\n\t\t// support for an interleaved position buffer\n\t\tconst bufferOffset = posAttr.offset || 0;\n\t\tlet stride = 3;\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\t\tstride = posAttr.data.stride;\n\n\t\t}\n\n\t\t// used for normalized positions\n\t\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\t\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\t\tconst tri3 = tri * 3;\n\t\t\tconst tri6 = tri * 6;\n\n\t\t\tlet ai, bi, ci;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\tai = index[ tri3 + 0 ];\n\t\t\t\tbi = index[ tri3 + 1 ];\n\t\t\t\tci = index[ tri3 + 2 ];\n\n\t\t\t} else {\n\n\t\t\t\tai = index[ tri3 + 0 ] * stride + bufferOffset;\n\t\t\t\tbi = index[ tri3 + 1 ] * stride + bufferOffset;\n\t\t\t\tci = index[ tri3 + 2 ] * stride + bufferOffset;\n\n\t\t\t}\n\n\t\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\t\tlet a, b, c;\n\n\t\t\t\tif ( normalized ) {\n\n\t\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t\t}\n\n\t\t\t\tlet min = a;\n\t\t\t\tif ( b < min ) min = b;\n\t\t\t\tif ( c < min ) min = c;\n\n\t\t\t\tlet max = a;\n\t\t\t\tif ( b > max ) max = b;\n\t\t\t\tif ( c > max ) max = c;\n\n\t\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t\t// worked with.\n\t\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\t\tconst el2 = el * 2;\n\t\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\n\t\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangleBounds;\n\n\t}\n\n\tfunction buildTree( geo, options ) {\n\n\t\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\t\tif ( onProgress ) {\n\n\t\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\t\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\t\treachedMaxDepth = true;\n\t\t\t\tif ( verbose ) {\n\n\t\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\t\tconsole.warn( geo );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// early out if we've met our capacity\n\t\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\t\ttriggerProgress( offset + count );\n\t\t\t\tnode.offset = offset;\n\t\t\t\tnode.count = count;\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\t// Find where to split the volume\n\t\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\t\tif ( split.axis === - 1 ) {\n\n\t\t\t\ttriggerProgress( offset + count );\n\t\t\t\tnode.offset = offset;\n\t\t\t\tnode.count = count;\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\tconst splitOffset = partition( indexArray, triangleBounds, offset, count, split );\n\n\t\t\t// create the two new child nodes\n\t\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\t\ttriggerProgress( offset + count );\n\t\t\t\tnode.offset = offset;\n\t\t\t\tnode.count = count;\n\n\t\t\t} else {\n\n\t\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t\t// create the left child and compute its bounding box\n\t\t\t\tconst left = new MeshBVHNode();\n\t\t\t\tconst lstart = offset;\n\t\t\t\tconst lcount = splitOffset - offset;\n\t\t\t\tnode.left = left;\n\t\t\t\tleft.boundingData = new Float32Array( 6 );\n\n\t\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t\t// repeat for right\n\t\t\t\tconst right = new MeshBVHNode();\n\t\t\t\tconst rstart = splitOffset;\n\t\t\t\tconst rcount = count - lcount;\n\t\t\t\tnode.right = right;\n\t\t\t\tright.boundingData = new Float32Array( 6 );\n\n\t\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t}\n\n\t\tensureIndex( geo, options );\n\n\t\t// Compute the full bounds of the geometry at the same time as triangle bounds because\n\t\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\n\t\t// We can't use the geometrying bounding box if it's available because it may be out of date.\n\t\tconst fullBounds = new Float32Array( 6 );\n\t\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\t\tconst triangleBounds = computeTriangleBounds( geo, fullBounds );\n\t\tconst indexArray = geo.index.array;\n\t\tconst maxDepth = options.maxDepth;\n\t\tconst verbose = options.verbose;\n\t\tconst maxLeafTris = options.maxLeafTris;\n\t\tconst strategy = options.strategy;\n\t\tconst onProgress = options.onProgress;\n\t\tconst totalTriangles = geo.index.count / 3;\n\t\tlet reachedMaxDepth = false;\n\n\t\tconst roots = [];\n\t\tconst ranges = getRootIndexRanges( geo );\n\n\t\tif ( ranges.length === 1 ) {\n\n\t\t\tconst range = ranges[ 0 ];\n\t\t\tconst root = new MeshBVHNode();\n\t\t\troot.boundingData = fullBounds;\n\t\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\n\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\troots.push( root );\n\n\t\t} else {\n\n\t\t\tfor ( let range of ranges ) {\n\n\t\t\t\tconst root = new MeshBVHNode();\n\t\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\t\troots.push( root );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn roots;\n\n\t}\n\n\tfunction buildPackedTree( geo, options ) {\n\n\t\t// boundingData  \t\t\t\t: 6 float32\n\t\t// right / offset \t\t\t\t: 1 uint32\n\t\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\t\tconst roots = buildTree( geo, options );\n\n\t\tlet float32Array;\n\t\tlet uint32Array;\n\t\tlet uint16Array;\n\t\tconst packedRoots = [];\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tfor ( let i = 0; i < roots.length; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tlet nodeCount = countNodes( root );\n\n\t\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tpopulateBuffer( 0, root );\n\t\t\tpackedRoots.push( buffer );\n\n\t\t}\n\n\t\treturn packedRoots;\n\n\t\tfunction countNodes( node ) {\n\n\t\t\tif ( node.count ) {\n\n\t\t\t\treturn 1;\n\n\t\t\t} else {\n\n\t\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction populateBuffer( byteOffset, node ) {\n\n\t\t\tconst stride4Offset = byteOffset / 4;\n\t\t\tconst stride2Offset = byteOffset / 2;\n\t\t\tconst isLeaf = ! ! node.count;\n\t\t\tconst boundingData = node.boundingData;\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t\t}\n\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = node.offset;\n\t\t\t\tconst count = node.count;\n\t\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node.left;\n\t\t\t\tconst right = node.right;\n\t\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\t\tlet nextUnusedPointer;\n\t\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\n\n\t\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t\t}\n\n\t\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\n\n\t\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\t\treturn nextUnusedPointer;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tclass SeparatingAxisBounds {\n\n\t\tconstructor() {\n\n\t\t\tthis.min = Infinity;\n\t\t\tthis.max = - Infinity;\n\n\t\t}\n\n\t\tsetFromPointsField( points, field ) {\n\n\t\t\tlet min = Infinity;\n\t\t\tlet max = - Infinity;\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\t\t\t\tconst val = p[ field ];\n\t\t\t\tmin = val < min ? val : min;\n\t\t\t\tmax = val > max ? val : max;\n\n\t\t\t}\n\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\n\t\t}\n\n\t\tsetFromPoints( axis, points ) {\n\n\t\t\tlet min = Infinity;\n\t\t\tlet max = - Infinity;\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\t\t\t\tconst val = axis.dot( p );\n\t\t\t\tmin = val < min ? val : min;\n\t\t\t\tmax = val > max ? val : max;\n\n\t\t\t}\n\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\n\t\t}\n\n\t\tisSeparated( other ) {\n\n\t\t\treturn this.min > other.max || other.min > this.max;\n\n\t\t}\n\n\t}\n\n\tSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\t\tconst p = new three.Vector3();\n\t\treturn function setFromBox( axis, box ) {\n\n\t\t\tconst boxMin = box.min;\n\t\t\tconst boxMax = box.max;\n\t\t\tlet min = Infinity;\n\t\t\tlet max = - Infinity;\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\n\t\t};\n\n\t} )();\n\n\tconst areIntersecting = ( function () {\n\n\t\tconst cacheSatBounds = new SeparatingAxisBounds();\n\t\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\t\tconst points1 = shape1.points;\n\t\t\tconst satAxes1 = shape1.satAxes;\n\t\t\tconst satBounds1 = shape1.satBounds;\n\n\t\t\tconst points2 = shape2.points;\n\t\t\tconst satAxes2 = shape2.satAxes;\n\t\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t\t// check axes of the first shape\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check axes of the second shape\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t};\n\n\t} )();\n\n\tconst closestPointLineToLine = ( function () {\n\n\t\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\t\tconst dir1 = new three.Vector3();\n\t\tconst dir2 = new three.Vector3();\n\t\tconst v02 = new three.Vector3();\n\t\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\t\tconst v0 = l1.start;\n\t\t\tconst v10 = dir1;\n\t\t\tconst v2 = l2.start;\n\t\t\tconst v32 = dir2;\n\n\t\t\tv02.subVectors( v0, v2 );\n\t\t\tdir1.subVectors( l1.end, l1.start );\n\t\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t\t// float d0232 = v02.Dot(v32);\n\t\t\tconst d0232 = v02.dot( v32 );\n\n\t\t\t// float d3210 = v32.Dot(v10);\n\t\t\tconst d3210 = v32.dot( v10 );\n\n\t\t\t// float d3232 = v32.Dot(v32);\n\t\t\tconst d3232 = v32.dot( v32 );\n\n\t\t\t// float d0210 = v02.Dot(v10);\n\t\t\tconst d0210 = v02.dot( v10 );\n\n\t\t\t// float d1010 = v10.Dot(v10);\n\t\t\tconst d1010 = v10.dot( v10 );\n\n\t\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\t\tlet d, d2;\n\t\t\tif ( denom !== 0 ) {\n\n\t\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t\t} else {\n\n\t\t\t\td = 0;\n\n\t\t\t}\n\n\t\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\t\tresult.x = d;\n\t\t\tresult.y = d2;\n\n\t\t};\n\n\t} )();\n\n\tconst closestPointsSegmentToSegment = ( function () {\n\n\t\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\t\tconst paramResult = new three.Vector2();\n\t\tconst temp1 = new three.Vector3();\n\t\tconst temp2 = new three.Vector3();\n\t\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\t\tlet d = paramResult.x;\n\t\t\tlet d2 = paramResult.y;\n\t\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t\tl1.at( d, target1 );\n\t\t\t\tl2.at( d2, target2 );\n\n\t\t\t\treturn;\n\n\t\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t\t// Only d2 is out of bounds.\n\t\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t\t}\n\n\t\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\t\treturn;\n\n\t\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t\t// Only d is out of bounds.\n\t\t\t\tif ( d < 0 ) {\n\n\t\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t\t}\n\n\t\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\t// Both u and u2 are out of bounds.\n\t\t\t\tlet p;\n\t\t\t\tif ( d < 0 ) {\n\n\t\t\t\t\tp = l1.start;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp = l1.end;\n\n\t\t\t\t}\n\n\t\t\t\tlet p2;\n\t\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\t\tp2 = l2.start;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp2 = l2.end;\n\n\t\t\t\t}\n\n\t\t\t\tconst closestPoint = temp1;\n\t\t\t\tconst closestPoint2 = temp2;\n\t\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\t\ttarget2.copy( p2 );\n\t\t\t\t\treturn;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget1.copy( p );\n\t\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t} )();\n\n\n\tconst sphereIntersectTriangle = ( function () {\n\n\t\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\t\tconst closestPointTemp = new three.Vector3();\n\t\tconst projectedPointTemp = new three.Vector3();\n\t\tconst planeTemp = new three.Plane();\n\t\tconst lineTemp = new three.Line3();\n\t\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\t\tconst { radius, center } = sphere;\n\t\t\tconst { a, b, c } = triangle;\n\n\t\t\t// phase 1\n\t\t\tlineTemp.start = a;\n\t\t\tlineTemp.end = b;\n\t\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\t\tlineTemp.start = a;\n\t\t\tlineTemp.end = c;\n\t\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\t\tlineTemp.start = b;\n\t\t\tlineTemp.end = c;\n\t\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t\t// phase 2\n\t\t\tconst plane = triangle.getPlane( planeTemp );\n\t\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\t\tif ( dp <= radius ) {\n\n\t\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\t\tif ( cp ) return true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t} )();\n\n\tconst DIST_EPSILON = 1e-15;\n\tfunction isNearZero( value ) {\n\n\t\treturn Math.abs( value ) < DIST_EPSILON;\n\n\t}\n\n\tclass ExtendedTriangle extends three.Triangle {\n\n\t\tconstructor( ...args ) {\n\n\t\t\tsuper( ...args );\n\n\t\t\tthis.isExtendedTriangle = true;\n\t\t\tthis.satAxes = new Array( 4 ).fill().map( () => new three.Vector3() );\n\t\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\t\tthis.points = [ this.a, this.b, this.c ];\n\t\t\tthis.sphere = new three.Sphere();\n\t\t\tthis.plane = new three.Plane();\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tintersectsSphere( sphere ) {\n\n\t\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t\t}\n\n\t\tupdate() {\n\n\t\t\tconst a = this.a;\n\t\t\tconst b = this.b;\n\t\t\tconst c = this.c;\n\t\t\tconst points = this.points;\n\n\t\t\tconst satAxes = this.satAxes;\n\t\t\tconst satBounds = this.satBounds;\n\n\t\t\tconst axis0 = satAxes[ 0 ];\n\t\t\tconst sab0 = satBounds[ 0 ];\n\t\t\tthis.getNormal( axis0 );\n\t\t\tsab0.setFromPoints( axis0, points );\n\n\t\t\tconst axis1 = satAxes[ 1 ];\n\t\t\tconst sab1 = satBounds[ 1 ];\n\t\t\taxis1.subVectors( a, b );\n\t\t\tsab1.setFromPoints( axis1, points );\n\n\t\t\tconst axis2 = satAxes[ 2 ];\n\t\t\tconst sab2 = satBounds[ 2 ];\n\t\t\taxis2.subVectors( b, c );\n\t\t\tsab2.setFromPoints( axis2, points );\n\n\t\t\tconst axis3 = satAxes[ 3 ];\n\t\t\tconst sab3 = satBounds[ 3 ];\n\t\t\taxis3.subVectors( c, a );\n\t\t\tsab3.setFromPoints( axis3, points );\n\n\t\t\tthis.sphere.setFromPoints( this.points );\n\t\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t}\n\n\tExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\t\tconst point1 = new three.Vector3();\n\t\tconst point2 = new three.Vector3();\n\t\tconst edge = new three.Line3();\n\n\t\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\t\tconst { start, end } = segment;\n\t\t\tconst points = this.points;\n\t\t\tlet distSq;\n\t\t\tlet closestDistanceSq = Infinity;\n\n\t\t\t// check the triangle edges\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\t\tedge.start.copy( points[ i ] );\n\t\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// check end points\n\t\t\tthis.closestPointToPoint( start, point1 );\n\t\t\tdistSq = start.distanceToSquared( point1 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t\t}\n\n\t\t\tthis.closestPointToPoint( end, point1 );\n\t\t\tdistSq = end.distanceToSquared( point1 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t\t}\n\n\t\t\treturn Math.sqrt( closestDistanceSq );\n\n\t\t};\n\n\t} )();\n\n\tExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\t\tconst saTri2 = new ExtendedTriangle();\n\t\tconst arr1 = new Array( 3 );\n\t\tconst arr2 = new Array( 3 );\n\t\tconst cachedSatBounds = new SeparatingAxisBounds();\n\t\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\t\tconst cachedAxis = new three.Vector3();\n\t\tconst dir1 = new three.Vector3();\n\t\tconst dir2 = new three.Vector3();\n\t\tconst tempDir = new three.Vector3();\n\t\tconst edge = new three.Line3();\n\t\tconst edge1 = new three.Line3();\n\t\tconst edge2 = new three.Line3();\n\n\t\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\t\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\t\tsaTri2.copy( other );\n\t\t\t\tsaTri2.update();\n\t\t\t\tother = saTri2;\n\n\t\t\t} else if ( other.needsUpdate ) {\n\n\t\t\t\tother.update();\n\n\t\t\t}\n\n\t\t\tconst plane1 = this.plane;\n\t\t\tconst plane2 = other.plane;\n\n\t\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\t\tconst satBounds1 = this.satBounds;\n\t\t\t\tconst satAxes1 = this.satAxes;\n\t\t\t\tarr2[ 0 ] = other.a;\n\t\t\t\tarr2[ 1 ] = other.b;\n\t\t\t\tarr2[ 2 ] = other.c;\n\t\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\tconst satBounds2 = other.satBounds;\n\t\t\t\tconst satAxes2 = other.satAxes;\n\t\t\t\tarr1[ 0 ] = this.a;\n\t\t\t\tarr1[ 1 ] = this.b;\n\t\t\t\tarr1[ 2 ] = this.c;\n\t\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\t// check crossed axes\n\t\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\t// find the edge that intersects the other triangle plane\n\t\t\t\tconst points1 = this.points;\n\t\t\t\tlet found1 = false;\n\t\t\t\tlet count1 = 0;\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst p = points1[ i ];\n\t\t\t\t\tconst pNext = points1[ ( i + 1 ) % 3 ];\n\n\t\t\t\t\tedge.start.copy( p );\n\t\t\t\t\tedge.end.copy( pNext );\n\t\t\t\t\tedge.delta( dir1 );\n\n\t\t\t\t\tconst targetPoint = found1 ? edge1.start : edge1.end;\n\t\t\t\t\tconst startIntersects = isNearZero( plane2.distanceToPoint( p ) );\n\t\t\t\t\tif ( isNearZero( plane2.normal.dot( dir1 ) ) && startIntersects ) {\n\n\t\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\t\tedge1.copy( edge );\n\t\t\t\t\t\tcount1 = 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\t\tconst doesIntersect = plane2.intersectLine( edge, targetPoint ) || startIntersects;\n\t\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\n\n\t\t\t\t\t\tcount1 ++;\n\t\t\t\t\t\tif ( found1 ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfound1 = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\t\tif ( target ) {\n\n\t\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// find the other triangles edge that intersects this plane\n\t\t\t\tconst points2 = other.points;\n\t\t\t\tlet found2 = false;\n\t\t\t\tlet count2 = 0;\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst p = points2[ i ];\n\t\t\t\t\tconst pNext = points2[ ( i + 1 ) % 3 ];\n\n\t\t\t\t\tedge.start.copy( p );\n\t\t\t\t\tedge.end.copy( pNext );\n\t\t\t\t\tedge.delta( dir2 );\n\n\t\t\t\t\tconst targetPoint = found2 ? edge2.start : edge2.end;\n\t\t\t\t\tconst startIntersects = isNearZero( plane1.distanceToPoint( p ) );\n\t\t\t\t\tif ( isNearZero( plane1.normal.dot( dir2 ) ) && startIntersects ) {\n\n\t\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\t\tedge2.copy( edge );\n\t\t\t\t\t\tcount2 = 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\t\tconst doesIntersect = plane1.intersectLine( edge, targetPoint ) || startIntersects;\n\t\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\n\n\t\t\t\t\t\tcount2 ++;\n\t\t\t\t\t\tif ( found2 ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfound2 = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\t\tif ( target ) {\n\n\t\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\t\tedge1.delta( dir1 );\n\t\t\t\tedge2.delta( dir2 );\n\n\t\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\t\tlet tmp = edge2.start;\n\t\t\t\t\tedge2.start = edge2.end;\n\t\t\t\t\tedge2.end = tmp;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the edges are overlapping\n\t\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\t\tconst separated1 = e1 < s2;\n\t\t\t\tconst separated2 = s1 < e2;\n\n\t\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// assign the target output\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t};\n\n\t} )();\n\n\n\tExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\t\tconst target = new three.Vector3();\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tthis.closestPointToPoint( point, target );\n\t\t\treturn point.distanceTo( target );\n\n\t\t};\n\n\t} )();\n\n\n\tExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\t\tconst point = new three.Vector3();\n\t\tconst point2 = new three.Vector3();\n\t\tconst cornerFields = [ 'a', 'b', 'c' ];\n\t\tconst line1 = new three.Line3();\n\t\tconst line2 = new three.Line3();\n\n\t\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t\t}\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tlet closestDistanceSq = Infinity;\n\n\t\t\t// check all point distances\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet dist;\n\t\t\t\tconst field = cornerFields[ i ];\n\t\t\t\tconst otherVec = other[ field ];\n\t\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t\t}\n\n\n\t\t\t\tconst thisVec = this[ field ];\n\t\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst f11 = cornerFields[ i ];\n\t\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Math.sqrt( closestDistanceSq );\n\n\t\t};\n\n\t} )();\n\n\tclass OrientedBox {\n\n\t\tconstructor( min, max, matrix ) {\n\n\t\t\tthis.isOrientedBox = true;\n\t\t\tthis.min = new three.Vector3();\n\t\t\tthis.max = new three.Vector3();\n\t\t\tthis.matrix = new three.Matrix4();\n\t\t\tthis.invMatrix = new three.Matrix4();\n\t\t\tthis.points = new Array( 8 ).fill().map( () => new three.Vector3() );\n\t\t\tthis.satAxes = new Array( 3 ).fill().map( () => new three.Vector3() );\n\t\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\t\tthis.needsUpdate = false;\n\n\t\t\tif ( min ) this.min.copy( min );\n\t\t\tif ( max ) this.max.copy( max );\n\t\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t\t}\n\n\t\tset( min, max, matrix ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\t\t\tthis.matrix.copy( matrix );\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tcopy( other ) {\n\n\t\t\tthis.min.copy( other.min );\n\t\t\tthis.max.copy( other.max );\n\t\t\tthis.matrix.copy( other.matrix );\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tOrientedBox.prototype.update = ( function () {\n\n\t\treturn function update() {\n\n\t\t\tconst matrix = this.matrix;\n\t\t\tconst min = this.min;\n\t\t\tconst max = this.max;\n\n\t\t\tconst points = this.points;\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst satBounds = this.satBounds;\n\t\t\tconst satAxes = this.satAxes;\n\t\t\tconst minVec = points[ 0 ];\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst axis = satAxes[ i ];\n\t\t\t\tconst sb = satBounds[ i ];\n\t\t\t\tconst index = 1 << i;\n\t\t\t\tconst pi = points[ index ];\n\n\t\t\t\taxis.subVectors( minVec, pi );\n\t\t\t\tsb.setFromPoints( axis, points );\n\n\t\t\t}\n\n\t\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\t\tthis.needsUpdate = false;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.intersectsBox = ( function () {\n\n\t\tconst aabbBounds = new SeparatingAxisBounds();\n\t\treturn function intersectsBox( box ) {\n\n\t\t\t// TODO: should this be doing SAT against the AABB?\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tconst min = box.min;\n\t\t\tconst max = box.max;\n\t\t\tconst satBounds = this.satBounds;\n\t\t\tconst satAxes = this.satAxes;\n\t\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\t\taabbBounds.min = min.x;\n\t\t\taabbBounds.max = max.x;\n\t\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\t\taabbBounds.min = min.y;\n\t\t\taabbBounds.max = max.y;\n\t\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\t\taabbBounds.min = min.z;\n\t\t\taabbBounds.max = max.z;\n\t\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst axis = satAxes[ i ];\n\t\t\t\tconst sb = satBounds[ i ];\n\t\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\t\tconst saTri = new ExtendedTriangle();\n\t\tconst pointsArr = new Array( 3 );\n\t\tconst cachedSatBounds = new SeparatingAxisBounds();\n\t\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\t\tconst cachedAxis = new three.Vector3();\n\t\treturn function intersectsTriangle( triangle ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\t\tsaTri.copy( triangle );\n\t\t\t\tsaTri.update();\n\t\t\t\ttriangle = saTri;\n\n\t\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\t\ttriangle.update();\n\n\t\t\t}\n\n\t\t\tconst satBounds = this.satBounds;\n\t\t\tconst satAxes = this.satAxes;\n\n\t\t\tpointsArr[ 0 ] = triangle.a;\n\t\t\tpointsArr[ 1 ] = triangle.b;\n\t\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = satBounds[ i ];\n\t\t\t\tconst sa = satAxes[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst triSatBounds = triangle.satBounds;\n\t\t\tconst triSatAxes = triangle.satAxes;\n\t\t\tconst points = this.points;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = triSatBounds[ i ];\n\t\t\t\tconst sa = triSatAxes[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\t\treturn function closestPointToPoint( point, target1 ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\ttarget1\n\t\t\t\t.copy( point )\n\t\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t\t.clamp( this.min, this.max )\n\t\t\t\t.applyMatrix4( this.matrix );\n\n\t\t\treturn target1;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.distanceToPoint = ( function () {\n\n\t\tconst target = new three.Vector3();\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tthis.closestPointToPoint( point, target );\n\t\t\treturn point.distanceTo( target );\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.distanceToBox = ( function () {\n\n\t\tconst xyzFields = [ 'x', 'y', 'z' ];\n\t\tconst segments1 = new Array( 12 ).fill().map( () => new three.Line3() );\n\t\tconst segments2 = new Array( 12 ).fill().map( () => new three.Line3() );\n\n\t\tconst point1 = new three.Vector3();\n\t\tconst point2 = new three.Vector3();\n\n\t\t// early out if we find a value below threshold\n\t\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\t\tbox.getCenter( point2 );\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tconst threshold2 = threshold * threshold;\n\t\t\tconst min = box.min;\n\t\t\tconst max = box.max;\n\t\t\tconst points = this.points;\n\n\n\t\t\t// iterate over every edge and compare distances\n\t\t\tlet closestDistanceSq = Infinity;\n\n\t\t\t// check over all these points\n\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\t\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// generate and check all line segment distances\n\t\t\tlet count = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t\t// get obb line segments\n\t\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t\t// get aabb line segments\n\t\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// check all the other boxes point\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\t\tconst l1 = segments1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Math.sqrt( closestDistanceSq );\n\n\t\t};\n\n\t} )();\n\n\t// Ripped and modified From THREE.js Mesh raycast\n\t// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\n\tconst _vA = /* @__PURE__ */ new three.Vector3();\n\tconst _vB = /* @__PURE__ */ new three.Vector3();\n\tconst _vC = /* @__PURE__ */ new three.Vector3();\n\n\tconst _uvA = /* @__PURE__ */ new three.Vector2();\n\tconst _uvB = /* @__PURE__ */ new three.Vector2();\n\tconst _uvC = /* @__PURE__ */ new three.Vector2();\n\n\tconst _normalA = /* @__PURE__ */ new three.Vector3();\n\tconst _normalB = /* @__PURE__ */ new three.Vector3();\n\tconst _normalC = /* @__PURE__ */ new three.Vector3();\n\n\tconst _intersectionPoint = /* @__PURE__ */ new three.Vector3();\n\tfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\t\tlet intersect;\n\t\tif ( side === three.BackSide ) {\n\n\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t} else {\n\n\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== three.DoubleSide, point );\n\n\t\t}\n\n\t\tif ( intersect === null ) return null;\n\n\t\tconst distance = ray.origin.distanceTo( point );\n\n\t\treturn {\n\n\t\t\tdistance: distance,\n\t\t\tpoint: point.clone(),\n\n\t\t};\n\n\t}\n\n\tfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side ) {\n\n\t\t_vA.fromBufferAttribute( position, a );\n\t\t_vB.fromBufferAttribute( position, b );\n\t\t_vC.fromBufferAttribute( position, c );\n\n\t\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side );\n\n\t\tif ( intersection ) {\n\n\t\t\tif ( uv ) {\n\n\t\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\t\tintersection.uv = three.Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new three.Vector2() );\n\n\t\t\t}\n\n\t\t\tif ( uv1 ) {\n\n\t\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\t\tintersection.uv1 = three.Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new three.Vector2() );\n\n\t\t\t}\n\n\t\t\tif ( normal ) {\n\n\t\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\t\tintersection.normal = three.Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new three.Vector3() );\n\t\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst face = {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tnormal: new three.Vector3(),\n\t\t\t\tmaterialIndex: 0\n\t\t\t};\n\n\t\t\tthree.Triangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\t\tintersection.face = face;\n\t\t\tintersection.faceIndex = a;\n\n\t\t}\n\n\t\treturn intersection;\n\n\t}\n\n\t// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\n\tfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\t\tconst triOffset = tri * 3;\n\t\tconst a = geo.index.getX( triOffset );\n\t\tconst b = geo.index.getX( triOffset + 1 );\n\t\tconst c = geo.index.getX( triOffset + 2 );\n\n\t\tconst { position, normal, uv, uv1 } = geo.attributes;\n\t\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side );\n\n\t\tif ( intersection ) {\n\n\t\t\tintersection.faceIndex = tri;\n\t\t\tif ( intersections ) intersections.push( intersection );\n\t\t\treturn intersection;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tfunction intersectTris( geo, side, ray, offset, count, intersections ) {\n\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tintersectTri( geo, side, ray, i, intersections );\n\n\t\t}\n\n\t}\n\n\tfunction intersectClosestTri( geo, side, ray, offset, count ) {\n\n\t\tlet dist = Infinity;\n\t\tlet res = null;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tconst intersection = intersectTri( geo, side, ray, i );\n\t\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\t\tres = intersection;\n\t\t\t\tdist = intersection.distance;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t}\n\n\t// converts the given BVH raycast intersection to align with the three.js raycast\n\t// structure (include object, world space distance and point).\n\tfunction convertRaycastIntersect( hit, object, raycaster ) {\n\n\t\tif ( hit === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\thit.point.applyMatrix4( object.matrixWorld );\n\t\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\t\thit.object = object;\n\n\t\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\n\n\t\t\treturn null;\n\n\t\t} else {\n\n\t\t\treturn hit;\n\n\t\t}\n\n\t}\n\n\t// sets the vertices of triangle `tri` with the 3 vertices after i\n\tfunction setTriangle( tri, i, index, pos ) {\n\n\t\tconst ta = tri.a;\n\t\tconst tb = tri.b;\n\t\tconst tc = tri.c;\n\n\t\tlet i0 = i;\n\t\tlet i1 = i + 1;\n\t\tlet i2 = i + 2;\n\t\tif ( index ) {\n\n\t\t\ti0 = index.getX( i );\n\t\t\ti1 = index.getX( i + 1 );\n\t\t\ti2 = index.getX( i + 2 );\n\n\t\t}\n\n\t\tta.x = pos.getX( i0 );\n\t\tta.y = pos.getY( i0 );\n\t\tta.z = pos.getZ( i0 );\n\n\t\ttb.x = pos.getX( i1 );\n\t\ttb.y = pos.getY( i1 );\n\t\ttb.z = pos.getZ( i1 );\n\n\t\ttc.x = pos.getX( i2 );\n\t\ttc.y = pos.getY( i2 );\n\t\ttc.z = pos.getZ( i2 );\n\n\t}\n\n\tfunction iterateOverTriangles(\n\t\toffset,\n\t\tcount,\n\t\tgeometry,\n\t\tintersectsTriangleFunc,\n\t\tcontained,\n\t\tdepth,\n\t\ttriangle\n\t) {\n\n\t\tconst index = geometry.index;\n\t\tconst pos = geometry.attributes.position;\n\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\tsetTriangle( triangle, i * 3, index, pos );\n\t\t\ttriangle.needsUpdate = true;\n\n\t\t\tif ( intersectsTriangleFunc( triangle, i, contained, depth ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tconst tempV1 = /* @__PURE__ */ new three.Vector3();\n\tconst tempV2 = /* @__PURE__ */ new three.Vector3();\n\tconst tempV3 = /* @__PURE__ */ new three.Vector3();\n\tconst tempUV1 = /* @__PURE__ */ new three.Vector2();\n\tconst tempUV2 = /* @__PURE__ */ new three.Vector2();\n\tconst tempUV3 = /* @__PURE__ */ new three.Vector2();\n\n\tfunction getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\t\tconst indices = geometry.getIndex().array;\n\t\tconst positions = geometry.getAttribute( 'position' );\n\t\tconst uvs = geometry.getAttribute( 'uv' );\n\n\t\tconst a = indices[ triangleIndex * 3 ];\n\t\tconst b = indices[ triangleIndex * 3 + 1 ];\n\t\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\t\ttempV1.fromBufferAttribute( positions, a );\n\t\ttempV2.fromBufferAttribute( positions, b );\n\t\ttempV3.fromBufferAttribute( positions, c );\n\n\t\t// find the associated material index\n\t\tlet materialIndex = 0;\n\t\tconst groups = geometry.groups;\n\t\tconst firstVertexIndex = triangleIndex * 3;\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tconst { start, count } = group;\n\t\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\t\tmaterialIndex = group.materialIndex;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// extract uvs\n\t\tlet uv = null;\n\t\tif ( uvs ) {\n\n\t\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\t\tif ( target && target.uv ) uv = target.uv;\n\t\t\telse uv = new three.Vector2();\n\n\t\t\tthree.Triangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t\t}\n\n\t\t// adjust the provided target or create a new one\n\t\tif ( target ) {\n\n\t\t\tif ( ! target.face ) target.face = { };\n\t\t\ttarget.face.a = a;\n\t\t\ttarget.face.b = b;\n\t\t\ttarget.face.c = c;\n\t\t\ttarget.face.materialIndex = materialIndex;\n\t\t\tif ( ! target.face.normal ) target.face.normal = new three.Vector3();\n\t\t\tthree.Triangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\t\tif ( uv ) target.uv = uv;\n\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn {\n\t\t\t\tface: {\n\t\t\t\t\ta: a,\n\t\t\t\t\tb: b,\n\t\t\t\t\tc: c,\n\t\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\t\tnormal: three.Triangle.getNormal( tempV1, tempV2, tempV3, new three.Vector3() )\n\t\t\t\t},\n\t\t\t\tuv: uv\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\tclass PrimitivePool {\n\n\t\tconstructor( getNewPrimitive ) {\n\n\t\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\t\tthis._primitives = [];\n\n\t\t}\n\n\t\tgetPrimitive() {\n\n\t\t\tconst primitives = this._primitives;\n\t\t\tif ( primitives.length === 0 ) {\n\n\t\t\t\treturn this._getNewPrimitive();\n\n\t\t\t} else {\n\n\t\t\t\treturn primitives.pop();\n\n\t\t\t}\n\n\t\t}\n\n\t\treleasePrimitive( primitive ) {\n\n\t\t\tthis._primitives.push( primitive );\n\n\t\t}\n\n\t}\n\n\tfunction IS_LEAF( n16, uint16Array ) {\n\n\t\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n\t}\n\n\tfunction OFFSET( n32, uint32Array ) {\n\n\t\treturn uint32Array[ n32 + 6 ];\n\n\t}\n\n\tfunction COUNT( n16, uint16Array ) {\n\n\t\treturn uint16Array[ n16 + 14 ];\n\n\t}\n\n\tfunction LEFT_NODE( n32 ) {\n\n\t\treturn n32 + 8;\n\n\t}\n\n\tfunction RIGHT_NODE( n32, uint32Array ) {\n\n\t\treturn uint32Array[ n32 + 6 ];\n\n\t}\n\n\tfunction SPLIT_AXIS( n32, uint32Array ) {\n\n\t\treturn uint32Array[ n32 + 7 ];\n\n\t}\n\n\tfunction BOUNDING_DATA_INDEX( n32 ) {\n\n\t\treturn n32;\n\n\t}\n\n\tconst boundingBox$1 = new three.Box3();\n\tconst boxIntersection = new three.Vector3();\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\n\tfunction raycast( nodeIndex32, geometry, side, ray, intersects ) {\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\tintersectTris( geometry, side, ray, offset, count, intersects );\n\n\t\t} else {\n\n\t\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\t\tif ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\t\traycast( leftIndex, geometry, side, ray, intersects );\n\n\t\t\t}\n\n\t\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tif ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\t\traycast( rightIndex, geometry, side, ray, intersects );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction raycastFirst( nodeIndex32, geometry, side, ray ) {\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\treturn intersectClosestTri( geometry, side, ray, offset, count );\n\n\t\t} else {\n\n\t\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\t\tconst xyzAxis = xyzFields[ splitAxis ];\n\t\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\t\tconst leftToRight = rayDir >= 0;\n\n\t\t\t// c1 is the child to check first\n\t\t\tlet c1, c2;\n\t\t\tif ( leftToRight ) {\n\n\t\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t} else {\n\n\t\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t\t}\n\n\t\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );\n\t\t\tconst c1Result = c1Intersection ? raycastFirst( c1, geometry, side, ray ) : null;\n\n\t\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\t\tif ( c1Result ) {\n\n\t\t\t\t// check if the point is within the second bounds\n\t\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\t\tconst isOutside = leftToRight ?\n\t\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\t\tif ( isOutside ) {\n\n\t\t\t\t\treturn c1Result;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );\n\t\t\tconst c2Result = c2Intersection ? raycastFirst( c2, geometry, side, ray ) : null;\n\n\t\t\tif ( c1Result && c2Result ) {\n\n\t\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t\t} else {\n\n\t\t\t\treturn c1Result || c2Result || null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst shapecast = ( function () {\n\n\t\tlet _box1, _box2;\n\t\tconst boxStack = [];\n\t\tconst boxPool = new PrimitivePool( () => new three.Box3() );\n\n\t\treturn function shapecast( ...args ) {\n\n\t\t\t_box1 = boxPool.getPrimitive();\n\t\t\t_box2 = boxPool.getPrimitive();\n\t\t\tboxStack.push( _box1, _box2 );\n\n\t\t\tconst result = shapecastTraverse( ...args );\n\n\t\t\tboxPool.releasePrimitive( _box1 );\n\t\t\tboxPool.releasePrimitive( _box2 );\n\t\t\tboxStack.pop();\n\t\t\tboxStack.pop();\n\n\t\t\tconst length = boxStack.length;\n\t\t\tif ( length > 0 ) {\n\n\t\t\t\t_box2 = boxStack[ length - 1 ];\n\t\t\t\t_box1 = boxStack[ length - 2 ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t};\n\n\t\tfunction shapecastTraverse(\n\t\t\tnodeIndex32,\n\t\t\tgeometry,\n\t\t\tintersectsBoundsFunc,\n\t\t\tintersectsRangeFunc,\n\t\t\tnodeScoreFunc = null,\n\t\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\t\t\tdepth = 0\n\t\t) {\n\n\t\t\t// Define these inside the function so it has access to the local variables needed\n\t\t\t// when converting to the buffer equivalents\n\t\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t\t// traverse until we find a leaf\n\t\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t}\n\n\t\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t\t}\n\n\t\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t\t// traverse until we find a leaf\n\t\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t\t// adjust offset to point to the right node\n\t\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t}\n\n\t\t\t\t// return the end offset of the triangle range\n\t\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t\t}\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t\t\t} else {\n\n\t\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tlet c1 = left;\n\t\t\t\tlet c2 = right;\n\n\t\t\t\tlet score1, score2;\n\t\t\t\tlet box1, box2;\n\t\t\t\tif ( nodeScoreFunc ) {\n\n\t\t\t\t\tbox1 = _box1;\n\t\t\t\t\tbox2 = _box2;\n\n\t\t\t\t\t// bounding data is not offset\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\t\t\tc1 = right;\n\t\t\t\t\t\tc2 = left;\n\n\t\t\t\t\t\tconst temp = score1;\n\t\t\t\t\t\tscore1 = score2;\n\t\t\t\t\t\tscore2 = temp;\n\n\t\t\t\t\t\tbox1 = box2;\n\t\t\t\t\t\t// box2 is always set before use below\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Check box 1 intersection\n\t\t\t\tif ( ! box1 ) {\n\n\t\t\t\t\tbox1 = _box1;\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t\t\t}\n\n\t\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\t\t\tlet c1StopTraversal;\n\t\t\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\t\t\tconst count = end - offset;\n\n\t\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc1StopTraversal =\n\t\t\t\t\t\tc1Intersection &&\n\t\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\t\tc1,\n\t\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( c1StopTraversal ) return true;\n\n\t\t\t\t// Check box 2 intersection\n\t\t\t\t// cached box2 will have been overwritten by previous traversal\n\t\t\t\tbox2 = _box2;\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\t\t\tlet c2StopTraversal;\n\t\t\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\t\t\tconst count = end - offset;\n\n\t\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc2StopTraversal =\n\t\t\t\t\t\tc2Intersection &&\n\t\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\t\tc2,\n\t\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( c2StopTraversal ) return true;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t} )();\n\n\tconst intersectsGeometry = ( function () {\n\n\t\tconst triangle = new ExtendedTriangle();\n\t\tconst triangle2 = new ExtendedTriangle();\n\t\tconst invertedMat = new three.Matrix4();\n\n\t\tconst obb = new OrientedBox();\n\t\tconst obb2 = new OrientedBox();\n\n\t\treturn function intersectsGeometry( nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\tif ( cachedObb === null ) {\n\n\t\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t\t}\n\n\t\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\t\tcachedObb = obb;\n\n\t\t\t}\n\n\t\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst thisGeometry = geometry;\n\t\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\t\tconst index = otherGeometry.index;\n\t\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t\t// here.\n\t\t\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn res;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = nodeIndex32 + 8;\n\t\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox$1 );\n\t\t\t\tconst leftIntersection =\n\t\t\t\t\tcachedObb.intersectsBox( boundingBox$1 ) &&\n\t\t\t\t\tintersectsGeometry( left, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\t\tif ( leftIntersection ) return true;\n\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox$1 );\n\t\t\t\tconst rightIntersection =\n\t\t\t\t\tcachedObb.intersectsBox( boundingBox$1 ) &&\n\t\t\t\t\tintersectsGeometry( right, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\t\tif ( rightIntersection ) return true;\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t};\n\n\t} )();\n\n\tfunction intersectRay( nodeIndex32, array, ray, target ) {\n\n\t\tarrayToBox( nodeIndex32, array, boundingBox$1 );\n\t\treturn ray.intersectBox( boundingBox$1, target );\n\n\t}\n\n\tconst bufferStack = [];\n\tlet _prevBuffer;\n\tlet _float32Array;\n\tlet _uint16Array;\n\tlet _uint32Array;\n\tfunction setBuffer( buffer ) {\n\n\t\tif ( _prevBuffer ) {\n\n\t\t\tbufferStack.push( _prevBuffer );\n\n\t\t}\n\n\t\t_prevBuffer = buffer;\n\t\t_float32Array = new Float32Array( buffer );\n\t\t_uint16Array = new Uint16Array( buffer );\n\t\t_uint32Array = new Uint32Array( buffer );\n\n\t}\n\n\tfunction clearBuffer() {\n\n\t\t_prevBuffer = null;\n\t\t_float32Array = null;\n\t\t_uint16Array = null;\n\t\t_uint32Array = null;\n\n\t\tif ( bufferStack.length ) {\n\n\t\t\tsetBuffer( bufferStack.pop() );\n\n\t\t}\n\n\t}\n\n\tconst SKIP_GENERATION = Symbol( 'skip tree generation' );\n\n\tconst aabb = /* @__PURE__ */ new three.Box3();\n\tconst aabb2 = /* @__PURE__ */ new three.Box3();\n\tconst tempMatrix = /* @__PURE__ */ new three.Matrix4();\n\tconst obb = /* @__PURE__ */ new OrientedBox();\n\tconst obb2 = /* @__PURE__ */ new OrientedBox();\n\tconst temp = /* @__PURE__ */ new three.Vector3();\n\tconst temp1 = /* @__PURE__ */ new three.Vector3();\n\tconst temp2 = /* @__PURE__ */ new three.Vector3();\n\tconst temp3 = /* @__PURE__ */ new three.Vector3();\n\tconst temp4 = /* @__PURE__ */ new three.Vector3();\n\tconst tempBox = /* @__PURE__ */ new three.Box3();\n\tconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new ExtendedTriangle() );\n\n\tclass MeshBVH {\n\n\t\tstatic serialize( bvh, options = {} ) {\n\n\t\t\tif ( options.isBufferGeometry ) {\n\n\t\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\t\treturn MeshBVH.serialize(\n\t\t\t\t\targuments[ 0 ],\n\t\t\t\t\t{\n\t\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\toptions = {\n\t\t\t\tcloneBuffers: true,\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst geometry = bvh.geometry;\n\t\t\tconst rootData = bvh._roots;\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tlet result;\n\t\t\tif ( options.cloneBuffers ) {\n\n\t\t\t\tresult = {\n\t\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tresult = {\n\t\t\t\t\troots: rootData,\n\t\t\t\t\tindex: indexAttribute.array,\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\t\tif ( typeof options === 'boolean' ) {\n\n\t\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\t\treturn MeshBVH.deserialize(\n\t\t\t\t\targuments[ 0 ],\n\t\t\t\t\targuments[ 1 ],\n\t\t\t\t\t{\n\t\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\toptions = {\n\t\t\t\tsetIndex: true,\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst { index, roots } = data;\n\t\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\t\tbvh._roots = roots;\n\n\t\t\tif ( options.setIndex ) {\n\n\t\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\t\tconst newIndex = new three.BufferAttribute( data.index, 1, false );\n\t\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bvh;\n\n\t\t}\n\n\t\tconstructor( geometry, options = {} ) {\n\n\t\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t\t}\n\n\t\t\t// default options\n\t\t\toptions = Object.assign( {\n\n\t\t\t\tstrategy: CENTER,\n\t\t\t\tmaxDepth: 40,\n\t\t\t\tmaxLeafTris: 10,\n\t\t\t\tverbose: true,\n\t\t\t\tuseSharedArrayBuffer: false,\n\t\t\t\tsetBoundingBox: true,\n\t\t\t\tonProgress: null,\n\n\t\t\t\t// undocumented options\n\n\t\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t\t}, options );\n\n\t\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t\t}\n\n\t\t\tthis._roots = null;\n\t\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\t\tthis._roots = buildPackedTree( geometry, options );\n\n\t\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new three.Box3() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// retain references to the geometry so we can use them it without having to\n\t\t\t// take a geometry reference in every function.\n\t\t\tthis.geometry = geometry;\n\n\t\t}\n\n\t\trefit( nodeIndices = null ) {\n\n\t\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t\t}\n\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst indexArr = geometry.index.array;\n\t\t\tconst posAttr = geometry.attributes.position;\n\n\t\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\t\tlet byteOffset = 0;\n\t\t\tconst roots = this._roots;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tbuffer = roots[ i ];\n\t\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t\t_traverse( 0, byteOffset );\n\t\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t\t}\n\n\t\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\t\tconst node16Index = node32Index * 2;\n\t\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\t\tlet minx = Infinity;\n\t\t\t\t\tlet miny = Infinity;\n\t\t\t\t\tlet minz = Infinity;\n\t\t\t\t\tlet maxx = - Infinity;\n\t\t\t\t\tlet maxy = - Infinity;\n\t\t\t\t\tlet maxz = - Infinity;\n\n\t\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\t\t\tconst index = indexArr[ i ];\n\t\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t\t) {\n\n\t\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst left = node32Index + 8;\n\t\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\t\tlet forceChildren = force;\n\t\t\t\t\tlet includesLeft = false;\n\t\t\t\t\tlet includesRight = false;\n\n\t\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\t\tlet leftChange = false;\n\t\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightChange = false;\n\t\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn didChange;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttraverse( callback, rootIndex = 0 ) {\n\n\t\t\tconst buffer = this._roots[ rootIndex ];\n\t\t\tconst uint32Array = new Uint32Array( buffer );\n\t\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t\t_traverse( 0 );\n\n\t\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\t\tconst node16Index = node32Index * 2;\n\t\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// TODO: use node functions here\n\t\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Core Cast Functions */\n\t\traycast( ray, materialOrSide = three.FrontSide ) {\n\n\t\t\tconst roots = this._roots;\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst intersects = [];\n\t\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\t\tconst groups = geometry.groups;\n\t\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\t\tconst startCount = intersects.length;\n\n\t\t\t\tsetBuffer( roots[ i ] );\n\t\t\t\traycast( 0, geometry, materialSide, ray, intersects );\n\t\t\t\tclearBuffer();\n\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t\traycastFirst( ray, materialOrSide = three.FrontSide ) {\n\n\t\t\tconst roots = this._roots;\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\t\tlet closestResult = null;\n\n\t\t\tconst groups = geometry.groups;\n\t\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\n\t\t\t\tsetBuffer( roots[ i ] );\n\t\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\n\t\t\t\tclearBuffer();\n\n\t\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\t\tclosestResult = result;\n\t\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn closestResult;\n\n\t\t}\n\n\t\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\t\tconst geometry = this.geometry;\n\t\t\tlet result = false;\n\t\t\tfor ( const root of this._roots ) {\n\n\t\t\t\tsetBuffer( root );\n\t\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\n\t\t\t\tclearBuffer();\n\n\t\t\t\tif ( result ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\n\n\t\t\tconst geometry = this.geometry;\n\t\t\tif ( callbacks instanceof Function ) {\n\n\t\t\t\tif ( _intersectsTriangleFunc ) {\n\n\t\t\t\t\t// Support the previous function signature that provided three sequential index buffer\n\t\t\t\t\t// indices here.\n\t\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\n\t\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\n\n\t\t\t\t\t\tconst i3 = index * 3;\n\t\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\n\n\t\t\t\t\t};\n\n\n\t\t\t\t}\n\n\t\t\t\tcallbacks = {\n\n\t\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\n\t\t\t\t\tintersectsBounds: callbacks,\n\t\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\n\t\t\t\t\tintersectsRange: null,\n\n\t\t\t\t};\n\n\t\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\n\n\t\t\t}\n\n\t\t\tconst triangle = trianglePool.getPrimitive();\n\t\t\tlet {\n\t\t\t\tboundsTraverseOrder,\n\t\t\t\tintersectsBounds,\n\t\t\t\tintersectsRange,\n\t\t\t\tintersectsTriangle,\n\t\t\t} = callbacks;\n\n\t\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else if ( ! intersectsRange ) {\n\n\t\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\t\treturn contained;\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet result = false;\n\t\t\tlet byteOffset = 0;\n\t\t\tfor ( const root of this._roots ) {\n\n\t\t\t\tsetBuffer( root );\n\t\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\t\t\t\tclearBuffer();\n\n\t\t\t\tif ( result ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbyteOffset += root.byteLength;\n\n\t\t\t}\n\n\t\t\ttrianglePool.releasePrimitive( triangle );\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n\t\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\n\n\t\t\tlet {\n\t\t\t\tintersectsRanges,\n\t\t\t\tintersectsTriangles,\n\t\t\t} = callbacks;\n\n\t\t\tconst indexAttr = this.geometry.index;\n\t\t\tconst positionAttr = this.geometry.attributes.position;\n\n\t\t\tconst otherIndexAttr = otherBvh.geometry.index;\n\t\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\n\n\t\t\ttempMatrix.copy( matrixToLocal ).invert();\n\n\t\t\tconst triangle = trianglePool.getPrimitive();\n\t\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\t\tif ( intersectsTriangles ) {\n\n\t\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\totherBvh.getBoundingBox( aabb2 );\n\t\t\taabb2.applyMatrix4( matrixToLocal );\n\t\t\tconst result = this.shapecast( {\n\n\t\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\n\n\t\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\n\n\t\t\t\t\taabb.copy( box );\n\t\t\t\t\taabb.applyMatrix4( tempMatrix );\n\t\t\t\t\treturn otherBvh.shapecast( {\n\n\t\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\n\n\t\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\n\n\t\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\ttrianglePool.releasePrimitive( triangle );\n\t\t\ttrianglePool.releasePrimitive( triangle2 );\n\t\t\treturn result;\n\n\t\t}\n\n\t\t/* Derived Cast Functions */\n\t\tintersectsBox( box, boxToMesh ) {\n\n\t\t\tobb.set( box.min, box.max, boxToMesh );\n\t\t\tobb.needsUpdate = true;\n\n\t\t\treturn this.shapecast(\n\t\t\t\t{\n\t\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\tintersectsSphere( sphere ) {\n\n\t\t\treturn this.shapecast(\n\t\t\t\t{\n\t\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tobb.needsUpdate = true;\n\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst pos = geometry.attributes.position;\n\t\t\tconst index = geometry.index;\n\t\t\tconst otherPos = otherGeometry.attributes.position;\n\t\t\tconst otherIndex = otherGeometry.index;\n\t\t\tconst triangle = trianglePool.getPrimitive();\n\t\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\t\tlet tempTarget1 = temp1;\n\t\t\tlet tempTargetDest1 = temp2;\n\t\t\tlet tempTarget2 = null;\n\t\t\tlet tempTargetDest2 = null;\n\n\t\t\tif ( target2 ) {\n\n\t\t\t\ttempTarget2 = temp3;\n\t\t\t\ttempTargetDest2 = temp4;\n\n\t\t\t}\n\n\t\t\tlet closestDistance = Infinity;\n\t\t\tlet closestDistanceTriIndex = null;\n\t\t\tlet closestDistanceOtherTriIndex = null;\n\t\t\ttempMatrix.copy( geometryToBvh ).invert();\n\t\t\tobb2.matrix.copy( tempMatrix );\n\t\t\tthis.shapecast(\n\t\t\t\t{\n\n\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t\t\t},\n\n\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\n\t\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\n\t\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\n\t\t\t\t}\n\n\t\t\t);\n\n\t\t\ttrianglePool.releasePrimitive( triangle );\n\t\t\ttrianglePool.releasePrimitive( triangle2 );\n\n\t\t\tif ( closestDistance === Infinity ) return null;\n\n\t\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\n\t\t\telse target1.point.copy( tempTargetDest1 );\n\t\t\ttarget1.distance = closestDistance,\n\t\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\t\tif ( target2 ) {\n\n\t\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t\t}\n\n\t\t\treturn target1;\n\n\t\t}\n\n\t\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t\t// early out if under minThreshold\n\t\t\t// skip checking if over maxThreshold\n\t\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t\t\t// returns Infinity if no value found\n\t\t\tconst minThresholdSq = minThreshold * minThreshold;\n\t\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\t\t\tlet closestDistanceSq = Infinity;\n\t\t\tlet closestDistanceTriIndex = null;\n\t\t\tthis.shapecast(\n\n\t\t\t\t{\n\n\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t\t\t},\n\n\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\n\t\t\t\t}\n\n\t\t\t);\n\n\t\t\tif ( closestDistanceSq === Infinity ) return null;\n\n\t\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\t\t\tif ( ! target.point ) target.point = temp1.clone();\n\t\t\telse target.point.copy( temp1 );\n\t\t\ttarget.distance = closestDistance,\n\t\t\ttarget.faceIndex = closestDistanceTriIndex;\n\n\t\t\treturn target;\n\n\t\t}\n\n\t\tgetBoundingBox( target ) {\n\n\t\t\ttarget.makeEmpty();\n\n\t\t\tconst roots = this._roots;\n\t\t\troots.forEach( buffer => {\n\n\t\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\t\ttarget.union( tempBox );\n\n\t\t\t} );\n\n\t\t\treturn target;\n\n\t\t}\n\n\t}\n\n\tconst boundingBox = /* @__PURE__ */ new three.Box3();\n\tclass MeshBVHRootVisualizer extends three.Object3D {\n\n\t\tget isMesh() {\n\n\t\t\treturn ! this.displayEdges;\n\n\t\t}\n\n\t\tget isLineSegments() {\n\n\t\t\treturn this.displayEdges;\n\n\t\t}\n\n\t\tget isLine() {\n\n\t\t\treturn this.displayEdges;\n\n\t\t}\n\n\t\tconstructor( mesh, material, depth = 10, group = 0 ) {\n\n\t\t\tsuper();\n\n\t\t\tthis.material = material;\n\t\t\tthis.geometry = new three.BufferGeometry();\n\t\t\tthis.name = 'MeshBVHRootVisualizer';\n\t\t\tthis.depth = depth;\n\t\t\tthis.displayParents = false;\n\t\t\tthis.mesh = mesh;\n\t\t\tthis.displayEdges = true;\n\t\t\tthis._group = group;\n\n\t\t}\n\n\t\traycast() {}\n\n\t\tupdate() {\n\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst boundsTree = this.mesh.geometry.boundsTree;\n\t\t\tconst group = this._group;\n\t\t\tgeometry.dispose();\n\t\t\tthis.visible = false;\n\t\t\tif ( boundsTree ) {\n\n\t\t\t\t// count the number of bounds required\n\t\t\t\tconst targetDepth = this.depth - 1;\n\t\t\t\tconst displayParents = this.displayParents;\n\t\t\t\tlet boundsCount = 0;\n\t\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\t\tif ( depth === targetDepth || isLeaf ) {\n\n\t\t\t\t\t\tboundsCount ++;\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}, group );\n\n\t\t\t\t// fill in the position buffer with the bounds corners\n\t\t\t\tlet posIndex = 0;\n\t\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\t\tconst terminate = depth === targetDepth || isLeaf;\n\t\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn terminate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}, group );\n\n\t\t\t\tlet indexArray;\n\t\t\t\tlet indices;\n\t\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t\t// x axis\n\t\t\t\t\t\t0, 4,\n\t\t\t\t\t\t1, 5,\n\t\t\t\t\t\t2, 6,\n\t\t\t\t\t\t3, 7,\n\n\t\t\t\t\t\t// y axis\n\t\t\t\t\t\t0, 2,\n\t\t\t\t\t\t1, 3,\n\t\t\t\t\t\t4, 6,\n\t\t\t\t\t\t5, 7,\n\n\t\t\t\t\t\t// z axis\n\t\t\t\t\t\t0, 1,\n\t\t\t\t\t\t2, 3,\n\t\t\t\t\t\t4, 5,\n\t\t\t\t\t\t6, 7,\n\t\t\t\t\t] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t\t// X-, X+\n\t\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t\t] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t\t}\n\n\t\t\t\tconst indexLength = indices.length;\n\t\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\t\tconst posOffset = i * 8;\n\t\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// update the geometry\n\t\t\t\tgeometry.setIndex(\n\t\t\t\t\tnew three.BufferAttribute( indexArray, 1, false ),\n\t\t\t\t);\n\t\t\t\tgeometry.setAttribute(\n\t\t\t\t\t'position',\n\t\t\t\t\tnew three.BufferAttribute( positionArray, 3, false ),\n\t\t\t\t);\n\t\t\t\tthis.visible = true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tclass MeshBVHVisualizer extends three.Group {\n\n\t\tget color() {\n\n\t\t\treturn this.edgeMaterial.color;\n\n\t\t}\n\n\t\tget opacity() {\n\n\t\t\treturn this.edgeMaterial.opacity;\n\n\t\t}\n\n\t\tset opacity( v ) {\n\n\t\t\tthis.edgeMaterial.opacity = v;\n\t\t\tthis.meshMaterial.opacity = v;\n\n\t\t}\n\n\t\tconstructor( mesh, depth = 10 ) {\n\n\t\t\tsuper();\n\n\t\t\tthis.name = 'MeshBVHVisualizer';\n\t\t\tthis.depth = depth;\n\t\t\tthis.mesh = mesh;\n\t\t\tthis.displayParents = false;\n\t\t\tthis.displayEdges = true;\n\t\t\tthis._roots = [];\n\n\t\t\tconst edgeMaterial = new three.LineBasicMaterial( {\n\t\t\t\tcolor: 0x00FF88,\n\t\t\t\ttransparent: true,\n\t\t\t\topacity: 0.3,\n\t\t\t\tdepthWrite: false,\n\t\t\t} );\n\n\t\t\tconst meshMaterial = new three.MeshBasicMaterial( {\n\t\t\t\tcolor: 0x00FF88,\n\t\t\t\ttransparent: true,\n\t\t\t\topacity: 0.3,\n\t\t\t\tdepthWrite: false,\n\t\t\t} );\n\n\t\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\t\tthis.edgeMaterial = edgeMaterial;\n\t\t\tthis.meshMaterial = meshMaterial;\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tupdate() {\n\n\t\t\tconst bvh = this.mesh.geometry.boundsTree;\n\t\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\t\tconst root = this._roots.pop();\n\t\t\t\troot.geometry.dispose();\n\t\t\t\tthis.remove( root );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\t\tconst root = new MeshBVHRootVisualizer( this.mesh, this.edgeMaterial, this.depth, i );\n\t\t\t\t\tthis.add( root );\n\t\t\t\t\tthis._roots.push( root );\n\n\t\t\t\t}\n\n\t\t\t\tconst root = this._roots[ i ];\n\t\t\t\troot.depth = this.depth;\n\t\t\t\troot.mesh = this.mesh;\n\t\t\t\troot.displayParents = this.displayParents;\n\t\t\t\troot.displayEdges = this.displayEdges;\n\t\t\t\troot.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\n\t\t\t\troot.update();\n\n\t\t\t}\n\n\t\t}\n\n\t\tupdateMatrixWorld( ...args ) {\n\n\t\t\tthis.position.copy( this.mesh.position );\n\t\t\tthis.rotation.copy( this.mesh.rotation );\n\t\t\tthis.scale.copy( this.mesh.scale );\n\n\t\t\tsuper.updateMatrixWorld( ...args );\n\n\t\t}\n\n\t\tcopy( source ) {\n\n\t\t\tthis.depth = source.depth;\n\t\t\tthis.mesh = source.mesh;\n\n\t\t}\n\n\t\tclone() {\n\n\t\t\treturn new MeshBVHVisualizer( this.mesh, this.depth );\n\n\t\t}\n\n\t\tdispose() {\n\n\t\t\tthis.edgeMaterial.dispose();\n\t\t\tthis.meshMaterial.dispose();\n\n\t\t\tconst children = this.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst _box1 = /* @__PURE__ */ new three.Box3();\n\tconst _box2 = /* @__PURE__ */ new three.Box3();\n\tconst _vec = /* @__PURE__ */ new three.Vector3();\n\n\t// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\n\tfunction getPrimitiveSize( el ) {\n\n\t\tswitch ( typeof el ) {\n\n\t\t\tcase 'number':\n\t\t\t\treturn 8;\n\t\t\tcase 'string':\n\t\t\t\treturn el.length * 2;\n\t\t\tcase 'boolean':\n\t\t\t\treturn 4;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tfunction isTypedArray( arr ) {\n\n\t\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\n\t\treturn regex.test( arr.constructor.name );\n\n\t}\n\n\tfunction getRootExtremes( bvh, group ) {\n\n\t\tconst result = {\n\t\t\tnodeCount: 0,\n\t\t\tleafNodeCount: 0,\n\n\t\t\tdepth: {\n\t\t\t\tmin: Infinity, max: - Infinity\n\t\t\t},\n\t\t\ttris: {\n\t\t\t\tmin: Infinity, max: - Infinity\n\t\t\t},\n\t\t\tsplits: [ 0, 0, 0 ],\n\t\t\tsurfaceAreaScore: 0,\n\t\t};\n\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\n\n\t\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\n\t\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\n\t\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\n\n\t\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\n\n\t\t\tresult.nodeCount ++;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tresult.leafNodeCount ++;\n\n\t\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\n\t\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\n\n\t\t\t\tresult.tris.min = Math.min( count, result.tris.min );\n\t\t\t\tresult.tris.max = Math.max( count, result.tris.max );\n\n\t\t\t\tresult.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\n\n\t\t\t} else {\n\n\t\t\t\tresult.splits[ offsetOrSplit ] ++;\n\n\t\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\n\n\t\t\t}\n\n\t\t}, group );\n\n\t\t// If there are no leaf nodes because the tree hasn't finished generating yet.\n\t\tif ( result.tris.min === Infinity ) {\n\n\t\t\tresult.tris.min = 0;\n\t\t\tresult.tris.max = 0;\n\n\t\t}\n\n\t\tif ( result.depth.min === Infinity ) {\n\n\t\t\tresult.depth.min = 0;\n\t\t\tresult.depth.max = 0;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction getBVHExtremes( bvh ) {\n\n\t\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\n\n\t}\n\n\tfunction estimateMemoryInBytes( obj ) {\n\n\t\tconst traversed = new Set();\n\t\tconst stack = [ obj ];\n\t\tlet bytes = 0;\n\n\t\twhile ( stack.length ) {\n\n\t\t\tconst curr = stack.pop();\n\t\t\tif ( traversed.has( curr ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\ttraversed.add( curr );\n\n\t\t\tfor ( let key in curr ) {\n\n\t\t\t\tif ( ! curr.hasOwnProperty( key ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tbytes += getPrimitiveSize( key );\n\n\t\t\t\tconst value = curr[ key ];\n\t\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\n\n\t\t\t\t\tif ( isTypedArray( value ) ) {\n\n\t\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstack.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbytes += getPrimitiveSize( value );\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bytes;\n\n\t}\n\n\tfunction validateBounds( bvh ) {\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst depthStack = [];\n\t\tconst index = geometry.index;\n\t\tconst position = geometry.getAttribute( 'position' );\n\t\tlet passes = true;\n\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\t\tconst info = {\n\t\t\t\tdepth,\n\t\t\t\tisLeaf,\n\t\t\t\tboundingData,\n\t\t\t\toffset,\n\t\t\t\tcount,\n\t\t\t};\n\t\t\tdepthStack[ depth ] = info;\n\n\t\t\tarrayToBox( 0, boundingData, _box1 );\n\t\t\tconst parent = depthStack[ depth - 1 ];\n\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\t// check triangles\n\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\tconst i0 = index.getX( i );\n\t\t\t\t\tconst i1 = index.getX( i + 1 );\n\t\t\t\t\tconst i2 = index.getX( i + 2 );\n\n\t\t\t\t\tlet isContained;\n\n\t\t\t\t\t_vec.fromBufferAttribute( position, i0 );\n\t\t\t\t\tisContained = _box1.containsPoint( _vec );\n\n\t\t\t\t\t_vec.fromBufferAttribute( position, i1 );\n\t\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t\t_vec.fromBufferAttribute( position, i2 );\n\t\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\n\t\t\t\t\tpasses = passes && isContained;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( parent ) {\n\n\t\t\t\t// check if my bounds fit in my parents\n\t\t\t\tarrayToBox( 0, boundingData, _box2 );\n\n\t\t\t\tconst isContained = _box2.containsBox( _box1 );\n\t\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\n\t\t\t\tpasses = passes && isContained;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn passes;\n\n\t}\n\n\t// Returns a simple, human readable object that represents the BVH.\n\tfunction getJSONStructure( bvh ) {\n\n\t\tconst depthStack = [];\n\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\t\tconst info = {\n\t\t\t\tbounds: arrayToBox( 0, boundingData, new three.Box3() ),\n\t\t\t};\n\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tinfo.count = count;\n\t\t\t\tinfo.offset = offset;\n\n\t\t\t} else {\n\n\t\t\t\tinfo.left = null;\n\t\t\t\tinfo.right = null;\n\n\t\t\t}\n\n\t\t\tdepthStack[ depth ] = info;\n\n\t\t\t// traversal hits the left then right node\n\t\t\tconst parent = depthStack[ depth - 1 ];\n\t\t\tif ( parent ) {\n\n\t\t\t\tif ( parent.left === null ) {\n\n\t\t\t\t\tparent.left = info;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tparent.right = info;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn depthStack[ 0 ];\n\n\t}\n\n\tconst ray = /* @__PURE__ */ new three.Ray();\n\tconst tmpInverseMatrix = /* @__PURE__ */ new three.Matrix4();\n\tconst origMeshRaycastFunc = three.Mesh.prototype.raycast;\n\n\tfunction acceleratedRaycast( raycaster, intersects ) {\n\n\t\tif ( this.geometry.boundsTree ) {\n\n\t\t\tif ( this.material === undefined ) return;\n\n\t\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\t\tconst bvh = this.geometry.boundsTree;\n\t\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst hits = bvh.raycast( ray, this.material );\n\t\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\t\tif ( hit ) {\n\n\t\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tfunction computeBoundsTree( options ) {\n\n\t\tthis.boundsTree = new MeshBVH( this, options );\n\t\treturn this.boundsTree;\n\n\t}\n\n\tfunction disposeBoundsTree() {\n\n\t\tthis.boundsTree = null;\n\n\t}\n\n\tfunction countToStringFormat( count ) {\n\n\t\tswitch ( count ) {\n\n\t\t\tcase 1: return 'R';\n\t\t\tcase 2: return 'RG';\n\t\t\tcase 3: return 'RGBA';\n\t\t\tcase 4: return 'RGBA';\n\n\t\t}\n\n\t\tthrow new Error();\n\n\t}\n\n\tfunction countToFormat( count ) {\n\n\t\tswitch ( count ) {\n\n\t\t\tcase 1: return three.RedFormat;\n\t\t\tcase 2: return three.RGFormat;\n\t\t\tcase 3: return three.RGBAFormat;\n\t\t\tcase 4: return three.RGBAFormat;\n\n\t\t}\n\n\t}\n\n\tfunction countToIntFormat( count ) {\n\n\t\tswitch ( count ) {\n\n\t\t\tcase 1: return three.RedIntegerFormat;\n\t\t\tcase 2: return three.RGIntegerFormat;\n\t\t\tcase 3: return three.RGBAIntegerFormat;\n\t\t\tcase 4: return three.RGBAIntegerFormat;\n\n\t\t}\n\n\t}\n\n\tclass VertexAttributeTexture extends three.DataTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis.minFilter = three.NearestFilter;\n\t\t\tthis.magFilter = three.NearestFilter;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.overrideItemSize = null;\n\t\t\tthis._forcedType = null;\n\n\t\t}\n\n\t\tupdateFrom( attr ) {\n\n\t\t\tconst overrideItemSize = this.overrideItemSize;\n\t\t\tconst originalItemSize = attr.itemSize;\n\t\t\tconst originalCount = attr.count;\n\t\t\tif ( overrideItemSize !== null ) {\n\n\t\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t\t}\n\n\t\t\t\tattr.itemSize = overrideItemSize;\n\t\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t\t}\n\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tconst count = attr.count;\n\t\t\tconst normalized = attr.normalized;\n\t\t\tconst originalBufferCons = attr.array.constructor;\n\t\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\t\tlet targetType = this._forcedType;\n\t\t\tlet finalStride = itemSize;\n\n\t\t\t// derive the type of texture this should be in the shader\n\t\t\tif ( targetType === null ) {\n\n\t\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\t\tcase Float32Array:\n\t\t\t\t\t\ttargetType = three.FloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Uint8Array:\n\t\t\t\t\tcase Uint16Array:\n\t\t\t\t\tcase Uint32Array:\n\t\t\t\t\t\ttargetType = three.UnsignedIntType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Int8Array:\n\t\t\t\t\tcase Int16Array:\n\t\t\t\t\tcase Int32Array:\n\t\t\t\t\t\ttargetType = three.IntType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// get the target format to store the texture as\n\t\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\t\tswitch ( targetType ) {\n\n\t\t\t\tcase three.FloatType:\n\t\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\t\ttype = three.UnsignedByteType;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttype = three.ByteType;\n\t\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\t\ttype = three.FloatType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase three.IntType:\n\t\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\t\ttype = three.ByteType;\n\n\t\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\t\ttype = three.ShortType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\t\ttype = three.IntType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase three.UnsignedIntType:\n\t\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\t\ttype = three.UnsignedByteType;\n\n\t\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\t\ttype = three.UnsignedShortType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\t\ttype = three.UnsignedIntType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// there will be a mismatch between format length and final length because\n\t\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\t\tif ( finalStride === 3 && ( format === three.RGBAFormat || format === three.RGBAIntegerFormat ) ) {\n\n\t\t\t\tfinalStride = 4;\n\n\t\t\t}\n\n\t\t\t// copy the data over to the new texture array\n\t\t\tconst dimension = Math.ceil( Math.sqrt( count ) );\n\t\t\tconst length = finalStride * dimension * dimension;\n\t\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\t\tconst originalNormalized = attr.normalized;\n\t\t\tattr.normalized = false;\n\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\tconst ii = finalStride * i;\n\t\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tattr.normalized = originalNormalized;\n\n\t\t\tthis.internalFormat = internalFormat;\n\t\t\tthis.format = format;\n\t\t\tthis.type = type;\n\t\t\tthis.image.width = dimension;\n\t\t\tthis.image.height = dimension;\n\t\t\tthis.image.data = dataArray;\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.dispose();\n\n\t\t\tattr.itemSize = originalItemSize;\n\t\t\tattr.count = originalCount;\n\n\t\t}\n\n\t}\n\n\tclass UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis._forcedType = three.UnsignedIntType;\n\n\t\t}\n\n\t}\n\n\tclass IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis._forcedType = three.IntType;\n\n\t\t}\n\n\n\t}\n\n\tclass FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis._forcedType = three.FloatType;\n\n\t\t}\n\n\t}\n\n\tfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\t\tconst roots = bvh._roots;\n\n\t\tif ( roots.length !== 1 ) {\n\n\t\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t\t}\n\n\t\tconst root = roots[ 0 ];\n\t\tconst uint16Array = new Uint16Array( root );\n\t\tconst uint32Array = new Uint32Array( root );\n\t\tconst float32Array = new Float32Array( root );\n\n\t\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t\t// the width so we can expand the row by two and still have a square texture\n\t\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\t\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\t\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\t\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\t\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\t\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t\t}\n\n\t\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\t\tconst mergedLeafCount = 0xffff0000 | count;\n\t\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t\t} else {\n\n\t\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\n\t\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tboundsTexture.image.data = boundsArray;\n\t\tboundsTexture.image.width = boundsDimension;\n\t\tboundsTexture.image.height = boundsDimension;\n\t\tboundsTexture.format = three.RGBAFormat;\n\t\tboundsTexture.type = three.FloatType;\n\t\tboundsTexture.internalFormat = 'RGBA32F';\n\t\tboundsTexture.minFilter = three.NearestFilter;\n\t\tboundsTexture.magFilter = three.NearestFilter;\n\t\tboundsTexture.generateMipmaps = false;\n\t\tboundsTexture.needsUpdate = true;\n\t\tboundsTexture.dispose();\n\n\t\tcontentsTexture.image.data = contentsArray;\n\t\tcontentsTexture.image.width = contentsDimension;\n\t\tcontentsTexture.image.height = contentsDimension;\n\t\tcontentsTexture.format = three.RGIntegerFormat;\n\t\tcontentsTexture.type = three.UnsignedIntType;\n\t\tcontentsTexture.internalFormat = 'RG32UI';\n\t\tcontentsTexture.minFilter = three.NearestFilter;\n\t\tcontentsTexture.magFilter = three.NearestFilter;\n\t\tcontentsTexture.generateMipmaps = false;\n\t\tcontentsTexture.needsUpdate = true;\n\t\tcontentsTexture.dispose();\n\n\t}\n\n\tclass MeshBVHUniformStruct {\n\n\t\tconstructor() {\n\n\t\t\tthis.autoDispose = true;\n\t\t\tthis.index = new UIntVertexAttributeTexture();\n\t\t\tthis.position = new FloatVertexAttributeTexture();\n\t\t\tthis.bvhBounds = new three.DataTexture();\n\t\t\tthis.bvhContents = new three.DataTexture();\n\n\t\t\tthis.index.overrideItemSize = 3;\n\n\t\t}\n\n\t\tupdateFrom( bvh ) {\n\n\t\t\tconst { geometry } = bvh;\n\n\t\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\t\tthis.index.updateFrom( geometry.index );\n\t\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t\t}\n\n\t\tdispose() {\n\n\t\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\t\tif ( index ) index.dispose();\n\t\t\tif ( position ) position.dispose();\n\t\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t\t}\n\n\t}\n\n\t// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n\t// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n\t// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\n\tconst shaderStructs = /* glsl */`\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n\n\tconst shaderIntersectFunction = /* glsl */`\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n\n// Raycasting\nfloat intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tfloat dist = max( t0, 0.0 );\n\n\treturn t1 >= dist ? dist : INFINITY;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,\n\tinout float minDistance,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nfloat intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );\n\n}\n\nbool bvhIntersectFirstHit(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = 1e20;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n\n\t// Distance to Point\n\tconst shaderDistanceFunction = /* glsl */`\n\nfloat dot2( in vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\tBVH bvh, vec3 point, uint offset, uint count, float closestDistanceSquared,\n\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord, out float side, out vec3 outPoint\n) {\n\n\tbool found = false;\n\tuvec3 localIndices;\n\tvec3 localBarycoord;\n\tvec3 localNormal;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\nfloat bvhClosestPointToPoint(\n\tBVH bvh, vec3 point,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh, point, offset, count, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n\n\tconst _positionVector = /*@__PURE__*/ new three.Vector3();\n\tconst _normalVector = /*@__PURE__*/ new three.Vector3();\n\tconst _tangentVector = /*@__PURE__*/ new three.Vector3();\n\tconst _tangentVector4 = /*@__PURE__*/ new three.Vector4();\n\n\tconst _morphVector = /*@__PURE__*/ new three.Vector3();\n\tconst _temp = /*@__PURE__*/ new three.Vector3();\n\n\tconst _skinIndex = /*@__PURE__*/ new three.Vector4();\n\tconst _skinWeight = /*@__PURE__*/ new three.Vector4();\n\tconst _matrix = /*@__PURE__*/ new three.Matrix4();\n\tconst _boneMatrix = /*@__PURE__*/ new three.Matrix4();\n\n\t// Confirms that the two provided attributes are compatible\n\tfunction validateAttributes( attr1, attr2 ) {\n\n\t\tif ( ! attr1 && ! attr2 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst sameCount = attr1.count === attr2.count;\n\t\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\t\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\t\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\t\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t}\n\n\t// Clones the given attribute with a new compatible buffer attribute but no data\n\tfunction createAttributeClone( attr, countOverride = null ) {\n\n\t\tconst cons = attr.array.constructor;\n\t\tconst normalized = attr.normalized;\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = countOverride === null ? attr.count : countOverride;\n\n\t\treturn new three.BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n\t}\n\n\t// target offset is the number of elements in the target buffer stride to skip before copying the\n\t// attributes contents in to.\n\tfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\t\tconst io = i + targetOffset;\n\t\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst array = target.array;\n\t\t\tconst cons = array.constructor;\n\t\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\t\ttemp.set( attr.array );\n\n\t\t}\n\n\t}\n\n\t// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\n\tfunction addScaledMatrix( target, matrix, scale ) {\n\n\t\tconst targetArray = target.elements;\n\t\tconst matrixArray = matrix.elements;\n\t\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t\t}\n\n\t}\n\n\t// A version of \"SkinnedMesh.boneTransform\" for normals\n\tfunction boneNormalTransform( mesh, index, target ) {\n\n\t\tconst skeleton = mesh.skeleton;\n\t\tconst geometry = mesh.geometry;\n\t\tconst bones = skeleton.bones;\n\t\tconst boneInverses = skeleton.boneInverses;\n\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t_matrix.elements.fill( 0 );\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\t\ttarget.transformDirection( _matrix );\n\n\t\treturn target;\n\n\t}\n\n\t// Applies the morph target data to the target vector\n\tfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t\t_morphVector.set( 0, 0, 0 );\n\t\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\t\tconst influence = morphInfluences[ j ];\n\t\t\tconst morphAttribute = morphData[ j ];\n\n\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t\t} else {\n\n\t\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t\t}\n\n\t\t}\n\n\t\ttarget.add( _morphVector );\n\n\t}\n\n\t// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\n\tfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new three.BufferGeometry() ) {\n\n\t\tconst isIndexed = geometries[ 0 ].index !== null;\n\t\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\n\n\t\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\t\tconst attributes = {};\n\n\t\tlet offset = 0;\n\n\t\ttargetGeometry.clearGroups();\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst geometry = geometries[ i ];\n\t\t\tlet attributesCount = 0;\n\n\t\t\t// ensure that all geometries are indexed, or none\n\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\t// gather attributes, exit early if they're different\n\t\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes[ name ] === undefined ) {\n\n\t\t\t\t\tattributes[ name ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\t\t\t\tattributesCount ++;\n\n\t\t\t}\n\n\t\t\t// ensure geometries have the same number of attributes\n\t\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\n\n\t\t\t}\n\n\t\t\tif ( useGroups ) {\n\n\t\t\t\tlet count;\n\t\t\t\tif ( isIndexed ) {\n\n\t\t\t\t\tcount = geometry.index.count;\n\n\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\n\n\t\t\t\t}\n\n\t\t\t\ttargetGeometry.addGroup( offset, count, i );\n\t\t\t\toffset += count;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge indices\n\t\tif ( isIndexed ) {\n\n\t\t\tlet forceUpdateIndex = false;\n\t\t\tif ( ! targetGeometry.index ) {\n\n\t\t\t\tlet indexCount = 0;\n\t\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\t\tindexCount += geometries[ i ].index.count;\n\n\t\t\t\t}\n\n\t\t\t\ttargetGeometry.setIndex( new three.BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\n\t\t\t\tforceUpdateIndex = true;\n\n\t\t\t}\n\n\t\t\tif ( updateIndex || forceUpdateIndex ) {\n\n\t\t\t\tconst targetIndex = targetGeometry.index;\n\t\t\t\tlet targetOffset = 0;\n\t\t\t\tlet indexOffset = 0;\n\t\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\t\tconst index = geometry.index;\n\t\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\n\t\t\t\t\t\t\ttargetOffset ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindexOffset += geometry.attributes.position.count;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge attributes\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attrList = attributes[ name ];\n\t\t\tif ( ! ( name in targetGeometry.attributes ) ) {\n\n\t\t\t\tlet count = 0;\n\t\t\t\tfor ( const key in attrList ) {\n\n\t\t\t\t\tcount += attrList[ key ].count;\n\n\t\t\t\t}\n\n\t\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\n\n\t\t\t}\n\n\t\t\tconst targetAttribute = targetGeometry.attributes[ name ];\n\t\t\tlet offset = 0;\n\t\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\n\n\t\t\t\tconst attr = attrList[ i ];\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t\t}\n\n\t\t\t\toffset += attr.count;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n\tfunction checkTypedArrayEquality( a, b ) {\n\n\t\tif ( a === null || b === null ) {\n\n\t\t\treturn a === b;\n\n\t\t}\n\n\t\tif ( a.length !== b.length ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\tif ( a[ i ] !== b[ i ] ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t// Checks whether the geometry changed between this and last evaluation\n\tclass GeometryDiff {\n\n\t\tconstructor( mesh ) {\n\n\t\t\tthis.matrixWorld = new three.Matrix4();\n\t\t\tthis.geometryHash = null;\n\t\t\tthis.boneMatrices = null;\n\t\t\tthis.primitiveCount = - 1;\n\t\t\tthis.mesh = mesh;\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tupdate() {\n\n\t\t\tconst mesh = this.mesh;\n\t\t\tconst geometry = mesh.geometry;\n\t\t\tconst skeleton = mesh.skeleton;\n\t\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\t\tthis.geometryHash = geometry.attributes.position.version;\n\t\t\tthis.primitiveCount = primitiveCount;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\t// ensure the bone matrix array is updated to the appropriate length\n\t\t\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\t\t\tskeleton.computeBoneTexture();\n\n\t\t\t\t}\n\n\t\t\t\tskeleton.update();\n\n\t\t\t\t// copy data if possible otherwise clone it\n\t\t\t\tconst boneMatrices = skeleton.boneMatrices;\n\t\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\n\n\t\t\t\t\tthis.boneMatrices = boneMatrices.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.boneMatrices.set( boneMatrices );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.boneMatrices = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdidChange() {\n\n\t\t\tconst mesh = this.mesh;\n\t\t\tconst geometry = mesh.geometry;\n\t\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\t\tconst identical =\n\t\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\t\tthis.geometryHash === geometry.attributes.position.version &&\n\t\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\n\t\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\t\treturn ! identical;\n\n\t\t}\n\n\t}\n\n\tclass StaticGeometryGenerator {\n\n\t\tconstructor( meshes ) {\n\n\t\t\tif ( ! Array.isArray( meshes ) ) {\n\n\t\t\t\tmeshes = [ meshes ];\n\n\t\t\t}\n\n\t\t\tconst finalMeshes = [];\n\t\t\tmeshes.forEach( object => {\n\n\t\t\t\tobject.traverseVisible( c => {\n\n\t\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\t\tfinalMeshes.push( c );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\tthis.meshes = finalMeshes;\n\t\t\tthis.useGroups = true;\n\t\t\tthis.applyWorldTransforms = true;\n\t\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new three.BufferGeometry() );\n\t\t\tthis._diffMap = new WeakMap();\n\n\t\t}\n\n\t\tgetMaterials() {\n\n\t\t\tconst materials = [];\n\t\t\tthis.meshes.forEach( mesh => {\n\n\t\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\t\tmaterials.push( ...mesh.material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( mesh.material );\n\n\t\t\t\t}\n\n\t\t\t} );\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tgenerate( targetGeometry = new three.BufferGeometry() ) {\n\n\t\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\t\tlet skipAttributes = [];\n\t\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\n\t\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\t\tconst mesh = meshes[ i ];\n\t\t\t\tconst geom = _intermediateGeometry[ i ];\n\t\t\t\tconst diff = _diffMap.get( mesh );\n\t\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\n\n\t\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\n\t\t\t\t\tskipAttributes.push( false );\n\n\t\t\t\t\tif ( ! diff ) {\n\n\t\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdiff.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tskipAttributes.push( true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\n\n\t\t\tfor ( const key in targetGeometry.attributes ) {\n\n\t\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\n\n\t\t\t}\n\n\t\t\treturn targetGeometry;\n\n\t\t}\n\n\t\t_convertToStaticGeometry( mesh, targetGeometry = new three.BufferGeometry() ) {\n\n\t\t\tconst geometry = mesh.geometry;\n\t\t\tconst applyWorldTransforms = this.applyWorldTransforms;\n\t\t\tconst includeNormal = this.attributes.includes( 'normal' );\n\t\t\tconst includeTangent = this.attributes.includes( 'tangent' );\n\t\t\tconst attributes = geometry.attributes;\n\t\t\tconst targetAttributes = targetGeometry.attributes;\n\n\t\t\t// initialize the attributes if they don't exist\n\t\t\tif ( ! targetGeometry.index ) {\n\n\t\t\t\ttargetGeometry.index = geometry.index;\n\n\t\t\t}\n\n\t\t\tif ( ! targetAttributes.position ) {\n\n\t\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t\t\t}\n\n\t\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t\t\t}\n\n\t\t\t// ensure the attributes are consistent\n\t\t\tvalidateAttributes( geometry.index, targetGeometry.index );\n\t\t\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\t\t\tif ( includeNormal ) {\n\n\t\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t\t\t}\n\n\t\t\tif ( includeTangent ) {\n\n\t\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t\t\t}\n\n\t\t\t// generate transformed vertex attribute data\n\t\t\tconst position = attributes.position;\n\t\t\tconst normal = includeNormal ? attributes.normal : null;\n\t\t\tconst tangent = includeTangent ? attributes.tangent : null;\n\t\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\t\tconst morphNormal = geometry.morphAttributes.normal;\n\t\t\tconst morphTangent = geometry.morphAttributes.tangent;\n\t\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\t\tconst morphInfluences = mesh.morphTargetInfluences;\n\t\t\tconst normalMatrix = new three.Matrix3();\n\t\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t\t\t_positionVector.fromBufferAttribute( position, i );\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t\t\t}\n\n\t\t\t\t// apply morph target transform\n\t\t\t\tif ( morphInfluences ) {\n\n\t\t\t\t\tif ( morphPosition ) {\n\n\t\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( morphNormal ) {\n\n\t\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( morphTangent ) {\n\n\t\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// apply bone transform\n\t\t\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\t\t\tmesh.applyBoneTransform( i, _positionVector );\n\t\t\t\t\tif ( normal ) {\n\n\t\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// update the vectors of the attributes\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// copy other attributes over\n\t\t\tfor ( const i in this.attributes ) {\n\n\t\t\t\tconst key = this.attributes[ i ];\n\t\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t\t\t}\n\n\t\t\treturn targetGeometry;\n\n\t\t}\n\n\t}\n\n\texports.AVERAGE = AVERAGE;\n\texports.CENTER = CENTER;\n\texports.CONTAINED = CONTAINED;\n\texports.ExtendedTriangle = ExtendedTriangle;\n\texports.FloatVertexAttributeTexture = FloatVertexAttributeTexture;\n\texports.INTERSECTED = INTERSECTED;\n\texports.IntVertexAttributeTexture = IntVertexAttributeTexture;\n\texports.MeshBVH = MeshBVH;\n\texports.MeshBVHUniformStruct = MeshBVHUniformStruct;\n\texports.MeshBVHVisualizer = MeshBVHVisualizer;\n\texports.NOT_INTERSECTED = NOT_INTERSECTED;\n\texports.OrientedBox = OrientedBox;\n\texports.SAH = SAH;\n\texports.StaticGeometryGenerator = StaticGeometryGenerator;\n\texports.UIntVertexAttributeTexture = UIntVertexAttributeTexture;\n\texports.VertexAttributeTexture = VertexAttributeTexture;\n\texports.acceleratedRaycast = acceleratedRaycast;\n\texports.computeBoundsTree = computeBoundsTree;\n\texports.disposeBoundsTree = disposeBoundsTree;\n\texports.estimateMemoryInBytes = estimateMemoryInBytes;\n\texports.getBVHExtremes = getBVHExtremes;\n\texports.getJSONStructure = getJSONStructure;\n\texports.getTriangleHitPointInfo = getTriangleHitPointInfo;\n\texports.shaderDistanceFunction = shaderDistanceFunction;\n\texports.shaderIntersectFunction = shaderIntersectFunction;\n\texports.shaderStructs = shaderStructs;\n\texports.validateBounds = validateBounds;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=index.umd.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvYnVpbGQvaW5kZXgudW1kLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLENBQUMsS0FBNEQsb0JBQW9CLG1CQUFPLENBQUMseURBQU87QUFDaEcsQ0FBQyxDQUM4STtBQUMvSSxDQUFDLHFDQUFxQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLGlCQUFpQjs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsd0NBQXdDOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFpQzs7QUFFcEQ7QUFDQSxrQkFBa0Isb0RBQW9EOztBQUV0RTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBELFNBQVM7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQsU0FBUzs7QUFFbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHVCQUF1QixPQUFPOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLFVBQVU7O0FBRXJDO0FBQ0Esd0JBQXdCLGlCQUFpQjs7QUFFekM7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsaUJBQWlCOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQSxzQkFBc0IsZUFBZTs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLE9BQU87O0FBRTlCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsVUFBVTs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFROztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQW1COztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLDJEQUEyRCxXQUFXOztBQUV0RTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsU0FBUzs7QUFFdkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGdCQUFnQjs7QUFFckM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLFFBQVE7O0FBRTdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLFdBQVc7QUFDeEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87O0FBRTlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFROztBQUU1QixxQkFBcUIsUUFBUTs7QUFFN0Isc0JBQXNCLFFBQVE7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQSx1QkFBdUIsUUFBUTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFROztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFFBQVE7O0FBRTVCLHFCQUFxQixRQUFROztBQUU3QixzQkFBc0IsUUFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQSxzQkFBc0IsUUFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQixzQkFBc0IsU0FBUzs7QUFFL0IsdUJBQXVCLFNBQVM7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsUUFBUTs7QUFFNUIscUJBQXFCLFFBQVE7O0FBRTdCLHNCQUFzQixRQUFROztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsUUFBUTs7QUFFNUI7QUFDQSxzQkFBc0IsU0FBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsNEJBQTRCO0FBQ3RDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsU0FBUzs7QUFFdkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxTQUFTOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxPQUFPOztBQUVuRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBLFdBQVcsZUFBZTtBQUMxQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUosaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZELE9BQU87O0FBRXBFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUEsTUFBTTs7QUFFTiwyREFBMkQsT0FBTzs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTOztBQUVuRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0M7O0FBRXRDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbURBQW1EOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGVBQWU7QUFDMUIsd0NBQXdDLHdDQUF3QztBQUNoRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQzs7QUFFdEM7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJEQUEyRCxPQUFPOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLE9BQU87O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTzs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1REFBdUQsUUFBUTs7QUFFL0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvREFBb0QsU0FBUzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQsU0FBUzs7QUFFOUQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQLE9BQU87O0FBRVA7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUVBQXFFLGVBQWU7O0FBRXBGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUEsZ0ZBQWdGLFNBQVM7O0FBRXpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0VBQWdFLE9BQU87O0FBRXZFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1QsU0FBUzs7QUFFVCxRQUFROztBQUVSO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsT0FBTzs7QUFFckU7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxXQUFXO0FBQ3pCLHlCQUF5QixRQUFROztBQUVqQztBQUNBLDBCQUEwQixRQUFROztBQUVsQztBQUNBLDJCQUEyQixRQUFROztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsaUJBQWlCOztBQUV0QztBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsZ0JBQWdCOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxPQUFPOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBEQUEwRCxPQUFPOztBQUVqRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQSxzQ0FBc0MsT0FBTzs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVzs7QUFFL0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsZUFBZTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyxXQUFXOztBQUV0Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsMENBQTBDOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSx5SUFBeUk7QUFDekk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQyxPQUFPOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTzs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxRQUFROztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx5REFBeUQsMERBQTBEOztBQUVuSDtBQUNBLFVBQVUsOERBQThEOztBQUV4RTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLHVCQUF1Qjs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtGQUErRjs7QUFFL0Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxnR0FBZ0c7O0FBRWhHOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix1QkFBdUI7O0FBRTVDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1Qjs7QUFFNUM7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7O0FBRXhDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxPQUFPOztBQUVoRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlDQUFpQyxPQUFPOztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcscURBQXFEO0FBQ2hFLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQSxtREFBbUQsMkJBQTJCOztBQUU5RTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsT0FBTzs7QUFFMUQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxhQUFhOztBQUU3RCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZXJzb25hbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL2J1aWxkL2luZGV4LnVtZC5janM/NGZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3RocmVlJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICd0aHJlZSddLCBmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLk1lc2hCVkhMaWIgPSBnbG9iYWwuTWVzaEJWSExpYiB8fCB7fSwgZ2xvYmFsLlRIUkVFKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIHRocmVlKSB7ICd1c2Ugc3RyaWN0JztcblxuXHQvLyBTcGxpdCBzdHJhdGVneSBjb25zdGFudHNcblx0Y29uc3QgQ0VOVEVSID0gMDtcblx0Y29uc3QgQVZFUkFHRSA9IDE7XG5cdGNvbnN0IFNBSCA9IDI7XG5cblx0Ly8gVHJhdmVyc2FsIGNvbnN0YW50c1xuXHRjb25zdCBOT1RfSU5URVJTRUNURUQgPSAwO1xuXHRjb25zdCBJTlRFUlNFQ1RFRCA9IDE7XG5cdGNvbnN0IENPTlRBSU5FRCA9IDI7XG5cblx0Ly8gU0FIIGNvc3QgY29uc3RhbnRzXG5cdC8vIFRPRE86IGhvbmUgdGhlc2UgY29zdHMgbW9yZS4gVGhlIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVtIHNob3VsZCBiZSB0aGVcblx0Ly8gZGlmZmVyZW5jZSBpbiBtZWFzdXJlZCB0aW1lIHRvIHBlcmZvcm0gYSB0cmlhbmdsZSBpbnRlcnNlY3Rpb24gdnMgdHJhdmVyc2luZ1xuXHQvLyBib3VuZHMuXG5cdGNvbnN0IFRSSUFOR0xFX0lOVEVSU0VDVF9DT1NUID0gMS4yNTtcblx0Y29uc3QgVFJBVkVSU0FMX0NPU1QgPSAxO1xuXG5cblx0Ly8gQnVpbGQgY29uc3RhbnRzXG5cdGNvbnN0IEJZVEVTX1BFUl9OT0RFID0gNiAqIDQgKyA0ICsgNDtcblx0Y29uc3QgSVNfTEVBRk5PREVfRkxBRyA9IDB4RkZGRjtcblxuXHQvLyBFUFNJTE9OIGZvciBjb21wdXRpbmcgZmxvYXRpbmcgcG9pbnQgZXJyb3IgZHVyaW5nIGJ1aWxkXG5cdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hY2hpbmVfZXBzaWxvbiNWYWx1ZXNfZm9yX3N0YW5kYXJkX2hhcmR3YXJlX2Zsb2F0aW5nX3BvaW50X2FyaXRobWV0aWNzXG5cdGNvbnN0IEZMT0FUMzJfRVBTSUxPTiA9IE1hdGgucG93KCAyLCAtIDI0ICk7XG5cblx0Y2xhc3MgTWVzaEJWSE5vZGUge1xuXG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRcdC8vIGludGVybmFsIG5vZGVzIGhhdmUgYm91bmRpbmdEYXRhLCBsZWZ0LCByaWdodCwgYW5kIHNwbGl0QXhpc1xuXHRcdFx0Ly8gbGVhZiBub2RlcyBoYXZlIG9mZnNldCBhbmQgY291bnQgKHJlZmVycmluZyB0byBwcmltaXRpdmVzIGluIHRoZSBtZXNoIGdlb21ldHJ5KVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBhcnJheVRvQm94KCBub2RlSW5kZXgzMiwgYXJyYXksIHRhcmdldCApIHtcblxuXHRcdHRhcmdldC5taW4ueCA9IGFycmF5WyBub2RlSW5kZXgzMiBdO1xuXHRcdHRhcmdldC5taW4ueSA9IGFycmF5WyBub2RlSW5kZXgzMiArIDEgXTtcblx0XHR0YXJnZXQubWluLnogPSBhcnJheVsgbm9kZUluZGV4MzIgKyAyIF07XG5cblx0XHR0YXJnZXQubWF4LnggPSBhcnJheVsgbm9kZUluZGV4MzIgKyAzIF07XG5cdFx0dGFyZ2V0Lm1heC55ID0gYXJyYXlbIG5vZGVJbmRleDMyICsgNCBdO1xuXHRcdHRhcmdldC5tYXgueiA9IGFycmF5WyBub2RlSW5kZXgzMiArIDUgXTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VFbXB0eUJvdW5kcyggdGFyZ2V0ICkge1xuXG5cdFx0dGFyZ2V0WyAwIF0gPSB0YXJnZXRbIDEgXSA9IHRhcmdldFsgMiBdID0gSW5maW5pdHk7XG5cdFx0dGFyZ2V0WyAzIF0gPSB0YXJnZXRbIDQgXSA9IHRhcmdldFsgNSBdID0gLSBJbmZpbml0eTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TG9uZ2VzdEVkZ2VJbmRleCggYm91bmRzICkge1xuXG5cdFx0bGV0IHNwbGl0RGltSWR4ID0gLSAxO1xuXHRcdGxldCBzcGxpdERpc3QgPSAtIEluZmluaXR5O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgZGlzdCA9IGJvdW5kc1sgaSArIDMgXSAtIGJvdW5kc1sgaSBdO1xuXHRcdFx0aWYgKCBkaXN0ID4gc3BsaXREaXN0ICkge1xuXG5cdFx0XHRcdHNwbGl0RGlzdCA9IGRpc3Q7XG5cdFx0XHRcdHNwbGl0RGltSWR4ID0gaTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNwbGl0RGltSWR4O1xuXG5cdH1cblxuXHQvLyBjb3BpZXMgYm91bmRzIGEgaW50byBib3VuZHMgYlxuXHRmdW5jdGlvbiBjb3B5Qm91bmRzKCBzb3VyY2UsIHRhcmdldCApIHtcblxuXHRcdHRhcmdldC5zZXQoIHNvdXJjZSApO1xuXG5cdH1cblxuXHQvLyBzZXRzIGJvdW5kcyB0YXJnZXQgdG8gdGhlIHVuaW9uIG9mIGJvdW5kcyBhIGFuZCBiXG5cdGZ1bmN0aW9uIHVuaW9uQm91bmRzKCBhLCBiLCB0YXJnZXQgKSB7XG5cblx0XHRsZXQgYVZhbCwgYlZhbDtcblx0XHRmb3IgKCBsZXQgZCA9IDA7IGQgPCAzOyBkICsrICkge1xuXG5cdFx0XHRjb25zdCBkMyA9IGQgKyAzO1xuXG5cdFx0XHQvLyBzZXQgdGhlIG1pbmltdW0gdmFsdWVzXG5cdFx0XHRhVmFsID0gYVsgZCBdO1xuXHRcdFx0YlZhbCA9IGJbIGQgXTtcblx0XHRcdHRhcmdldFsgZCBdID0gYVZhbCA8IGJWYWwgPyBhVmFsIDogYlZhbDtcblxuXHRcdFx0Ly8gc2V0IHRoZSBtYXggdmFsdWVzXG5cdFx0XHRhVmFsID0gYVsgZDMgXTtcblx0XHRcdGJWYWwgPSBiWyBkMyBdO1xuXHRcdFx0dGFyZ2V0WyBkMyBdID0gYVZhbCA+IGJWYWwgPyBhVmFsIDogYlZhbDtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gZXhwYW5kcyB0aGUgZ2l2ZW4gYm91bmRzIGJ5IHRoZSBwcm92aWRlZCB0cmlhbmdsZSBib3VuZHNcblx0ZnVuY3Rpb24gZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyggc3RhcnRJbmRleCwgdHJpYW5nbGVCb3VuZHMsIGJvdW5kcyApIHtcblxuXHRcdGZvciAoIGxldCBkID0gMDsgZCA8IDM7IGQgKysgKSB7XG5cblx0XHRcdGNvbnN0IHRDZW50ZXIgPSB0cmlhbmdsZUJvdW5kc1sgc3RhcnRJbmRleCArIDIgKiBkIF07XG5cdFx0XHRjb25zdCB0SGFsZiA9IHRyaWFuZ2xlQm91bmRzWyBzdGFydEluZGV4ICsgMiAqIGQgKyAxIF07XG5cblx0XHRcdGNvbnN0IHRNaW4gPSB0Q2VudGVyIC0gdEhhbGY7XG5cdFx0XHRjb25zdCB0TWF4ID0gdENlbnRlciArIHRIYWxmO1xuXG5cdFx0XHRpZiAoIHRNaW4gPCBib3VuZHNbIGQgXSApIHtcblxuXHRcdFx0XHRib3VuZHNbIGQgXSA9IHRNaW47XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0TWF4ID4gYm91bmRzWyBkICsgMyBdICkge1xuXG5cdFx0XHRcdGJvdW5kc1sgZCArIDMgXSA9IHRNYXg7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gY29tcHV0ZSBib3VuZHMgc3VyZmFjZSBhcmVhXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdXJmYWNlQXJlYSggYm91bmRzICkge1xuXG5cdFx0Y29uc3QgZDAgPSBib3VuZHNbIDMgXSAtIGJvdW5kc1sgMCBdO1xuXHRcdGNvbnN0IGQxID0gYm91bmRzWyA0IF0gLSBib3VuZHNbIDEgXTtcblx0XHRjb25zdCBkMiA9IGJvdW5kc1sgNSBdIC0gYm91bmRzWyAyIF07XG5cblx0XHRyZXR1cm4gMiAqICggZDAgKiBkMSArIGQxICogZDIgKyBkMiAqIGQwICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGVuc3VyZUluZGV4KCBnZW8sIG9wdGlvbnMgKSB7XG5cblx0XHRpZiAoICEgZ2VvLmluZGV4ICkge1xuXG5cdFx0XHRjb25zdCB2ZXJ0ZXhDb3VudCA9IGdlby5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuXHRcdFx0Y29uc3QgQnVmZmVyQ29uc3RydWN0b3IgPSBvcHRpb25zLnVzZVNoYXJlZEFycmF5QnVmZmVyID8gU2hhcmVkQXJyYXlCdWZmZXIgOiBBcnJheUJ1ZmZlcjtcblx0XHRcdGxldCBpbmRleDtcblx0XHRcdGlmICggdmVydGV4Q291bnQgPiA2NTUzNSApIHtcblxuXHRcdFx0XHRpbmRleCA9IG5ldyBVaW50MzJBcnJheSggbmV3IEJ1ZmZlckNvbnN0cnVjdG9yKCA0ICogdmVydGV4Q291bnQgKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGluZGV4ID0gbmV3IFVpbnQxNkFycmF5KCBuZXcgQnVmZmVyQ29uc3RydWN0b3IoIDIgKiB2ZXJ0ZXhDb3VudCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvLnNldEluZGV4KCBuZXcgdGhyZWUuQnVmZmVyQXR0cmlidXRlKCBpbmRleCwgMSApICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdGluZGV4WyBpIF0gPSBpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIENvbXB1dGVzIHRoZSBzZXQgb2YgeyBvZmZzZXQsIGNvdW50IH0gcmFuZ2VzIHdoaWNoIG5lZWQgaW5kZXBlbmRlbnQgQlZIIHJvb3RzLiBFYWNoXG5cdC8vIHJlZ2lvbiBpbiB0aGUgZ2VvbWV0cnkgaW5kZXggdGhhdCBiZWxvbmdzIHRvIGEgZGlmZmVyZW50IHNldCBvZiBtYXRlcmlhbCBncm91cHMgcmVxdWlyZXNcblx0Ly8gYSBzZXBhcmF0ZSBCVkggcm9vdCwgc28gdGhhdCB0cmlhbmdsZXMgaW5kaWNlcyBiZWxvbmdpbmcgdG8gb25lIGdyb3VwIG5ldmVyIGdldCBzd2FwcGVkXG5cdC8vIHdpdGggdHJpYW5nbGUgaW5kaWNlcyBiZWxvbmdzIHRvIGFub3RoZXIgZ3JvdXAuIEZvciBleGFtcGxlLCBpZiB0aGUgZ3JvdXBzIHdlcmUgbGlrZSB0aGlzOlxuXHQvL1xuXHQvLyBbLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLV1cblx0Ly8gfF9fX19fX19fX19fX19fX19fX3xcblx0Ly8gICBnMCA9IFswLCAyMF0gIHxfX19fX19fX19fX19fX19fX19fX19ffHxfX19fX19fX19fX19fX19fX19fX198XG5cdC8vICAgICAgICAgICAgICAgICAgICAgIGcxID0gWzE2LCA0MF0gICAgICAgICAgIGcyID0gWzQxLCA2MF1cblx0Ly9cblx0Ly8gd2Ugd291bGQgbmVlZCBmb3VyIEJWSCByb290czogWzAsIDE1XSwgWzE2LCAyMF0sIFsyMSwgNDBdLCBbNDEsIDYwXS5cblx0ZnVuY3Rpb24gZ2V0Um9vdEluZGV4UmFuZ2VzKCBnZW8gKSB7XG5cblx0XHRpZiAoICEgZ2VvLmdyb3VwcyB8fCAhIGdlby5ncm91cHMubGVuZ3RoICkge1xuXG5cdFx0XHRyZXR1cm4gWyB7IG9mZnNldDogMCwgY291bnQ6IGdlby5pbmRleC5jb3VudCAvIDMgfSBdO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcmFuZ2VzID0gW107XG5cdFx0Y29uc3QgcmFuZ2VCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuXHRcdGZvciAoIGNvbnN0IGdyb3VwIG9mIGdlby5ncm91cHMgKSB7XG5cblx0XHRcdHJhbmdlQm91bmRhcmllcy5hZGQoIGdyb3VwLnN0YXJ0ICk7XG5cdFx0XHRyYW5nZUJvdW5kYXJpZXMuYWRkKCBncm91cC5zdGFydCArIGdyb3VwLmNvdW50ICk7XG5cblx0XHR9XG5cblx0XHQvLyBub3RlIHRoYXQgaWYgeW91IGRvbid0IHBhc3MgaW4gYSBjb21wYXJhdG9yLCBpdCBzb3J0cyB0aGVtIGxleGljb2dyYXBoaWNhbGx5IGFzIHN0cmluZ3MgOi0oXG5cdFx0Y29uc3Qgc29ydGVkQm91bmRhcmllcyA9IEFycmF5LmZyb20oIHJhbmdlQm91bmRhcmllcy52YWx1ZXMoKSApLnNvcnQoICggYSwgYiApID0+IGEgLSBiICk7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgc29ydGVkQm91bmRhcmllcy5sZW5ndGggLSAxOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBzdGFydCA9IHNvcnRlZEJvdW5kYXJpZXNbIGkgXSwgZW5kID0gc29ydGVkQm91bmRhcmllc1sgaSArIDEgXTtcblx0XHRcdHJhbmdlcy5wdXNoKCB7IG9mZnNldDogKCBzdGFydCAvIDMgKSwgY291bnQ6ICggZW5kIC0gc3RhcnQgKSAvIDMgfSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJhbmdlcztcblxuXHR9XG5cblx0Ly8gY29tcHV0ZXMgdGhlIHVuaW9uIG9mIHRoZSBib3VuZHMgb2YgYWxsIG9mIHRoZSBnaXZlbiB0cmlhbmdsZXMgYW5kIHB1dHMgdGhlIHJlc3VsdGluZyBib3ggaW4gdGFyZ2V0LiBJZlxuXHQvLyBjZW50cm9pZFRhcmdldCBpcyBwcm92aWRlZCB0aGVuIGEgYm91bmRpbmcgYm94IGlzIGNvbXB1dGVkIGZvciB0aGUgY2VudHJvaWRzIG9mIHRoZSB0cmlhbmdsZXMsIGFzIHdlbGwuXG5cdC8vIFRoZXNlIGFyZSBjb21wdXRlZCB0b2dldGhlciB0byBhdm9pZCByZWR1bmRhbnQgYWNjZXNzZXMgdG8gYm91bmRzIGFycmF5LlxuXHRmdW5jdGlvbiBnZXRCb3VuZHMoIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCB0YXJnZXQsIGNlbnRyb2lkVGFyZ2V0ID0gbnVsbCApIHtcblxuXHRcdGxldCBtaW54ID0gSW5maW5pdHk7XG5cdFx0bGV0IG1pbnkgPSBJbmZpbml0eTtcblx0XHRsZXQgbWlueiA9IEluZmluaXR5O1xuXHRcdGxldCBtYXh4ID0gLSBJbmZpbml0eTtcblx0XHRsZXQgbWF4eSA9IC0gSW5maW5pdHk7XG5cdFx0bGV0IG1heHogPSAtIEluZmluaXR5O1xuXG5cdFx0bGV0IGNtaW54ID0gSW5maW5pdHk7XG5cdFx0bGV0IGNtaW55ID0gSW5maW5pdHk7XG5cdFx0bGV0IGNtaW56ID0gSW5maW5pdHk7XG5cdFx0bGV0IGNtYXh4ID0gLSBJbmZpbml0eTtcblx0XHRsZXQgY21heHkgPSAtIEluZmluaXR5O1xuXHRcdGxldCBjbWF4eiA9IC0gSW5maW5pdHk7XG5cblx0XHRjb25zdCBpbmNsdWRlQ2VudHJvaWQgPSBjZW50cm9pZFRhcmdldCAhPT0gbnVsbDtcblx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCAqIDYsIGVuZCA9ICggb2Zmc2V0ICsgY291bnQgKSAqIDY7IGkgPCBlbmQ7IGkgKz0gNiApIHtcblxuXHRcdFx0Y29uc3QgY3ggPSB0cmlhbmdsZUJvdW5kc1sgaSArIDAgXTtcblx0XHRcdGNvbnN0IGh4ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyAxIF07XG5cdFx0XHRjb25zdCBseCA9IGN4IC0gaHg7XG5cdFx0XHRjb25zdCByeCA9IGN4ICsgaHg7XG5cdFx0XHRpZiAoIGx4IDwgbWlueCApIG1pbnggPSBseDtcblx0XHRcdGlmICggcnggPiBtYXh4ICkgbWF4eCA9IHJ4O1xuXHRcdFx0aWYgKCBpbmNsdWRlQ2VudHJvaWQgJiYgY3ggPCBjbWlueCApIGNtaW54ID0gY3g7XG5cdFx0XHRpZiAoIGluY2x1ZGVDZW50cm9pZCAmJiBjeCA+IGNtYXh4ICkgY21heHggPSBjeDtcblxuXHRcdFx0Y29uc3QgY3kgPSB0cmlhbmdsZUJvdW5kc1sgaSArIDIgXTtcblx0XHRcdGNvbnN0IGh5ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyAzIF07XG5cdFx0XHRjb25zdCBseSA9IGN5IC0gaHk7XG5cdFx0XHRjb25zdCByeSA9IGN5ICsgaHk7XG5cdFx0XHRpZiAoIGx5IDwgbWlueSApIG1pbnkgPSBseTtcblx0XHRcdGlmICggcnkgPiBtYXh5ICkgbWF4eSA9IHJ5O1xuXHRcdFx0aWYgKCBpbmNsdWRlQ2VudHJvaWQgJiYgY3kgPCBjbWlueSApIGNtaW55ID0gY3k7XG5cdFx0XHRpZiAoIGluY2x1ZGVDZW50cm9pZCAmJiBjeSA+IGNtYXh5ICkgY21heHkgPSBjeTtcblxuXHRcdFx0Y29uc3QgY3ogPSB0cmlhbmdsZUJvdW5kc1sgaSArIDQgXTtcblx0XHRcdGNvbnN0IGh6ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyA1IF07XG5cdFx0XHRjb25zdCBseiA9IGN6IC0gaHo7XG5cdFx0XHRjb25zdCByeiA9IGN6ICsgaHo7XG5cdFx0XHRpZiAoIGx6IDwgbWlueiApIG1pbnogPSBsejtcblx0XHRcdGlmICggcnogPiBtYXh6ICkgbWF4eiA9IHJ6O1xuXHRcdFx0aWYgKCBpbmNsdWRlQ2VudHJvaWQgJiYgY3ogPCBjbWlueiApIGNtaW56ID0gY3o7XG5cdFx0XHRpZiAoIGluY2x1ZGVDZW50cm9pZCAmJiBjeiA+IGNtYXh6ICkgY21heHogPSBjejtcblxuXHRcdH1cblxuXHRcdHRhcmdldFsgMCBdID0gbWlueDtcblx0XHR0YXJnZXRbIDEgXSA9IG1pbnk7XG5cdFx0dGFyZ2V0WyAyIF0gPSBtaW56O1xuXG5cdFx0dGFyZ2V0WyAzIF0gPSBtYXh4O1xuXHRcdHRhcmdldFsgNCBdID0gbWF4eTtcblx0XHR0YXJnZXRbIDUgXSA9IG1heHo7XG5cblx0XHRpZiAoIGluY2x1ZGVDZW50cm9pZCApIHtcblxuXHRcdFx0Y2VudHJvaWRUYXJnZXRbIDAgXSA9IGNtaW54O1xuXHRcdFx0Y2VudHJvaWRUYXJnZXRbIDEgXSA9IGNtaW55O1xuXHRcdFx0Y2VudHJvaWRUYXJnZXRbIDIgXSA9IGNtaW56O1xuXG5cdFx0XHRjZW50cm9pZFRhcmdldFsgMyBdID0gY21heHg7XG5cdFx0XHRjZW50cm9pZFRhcmdldFsgNCBdID0gY21heHk7XG5cdFx0XHRjZW50cm9pZFRhcmdldFsgNSBdID0gY21heHo7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIEEgc3RhbmQgYWxvbmUgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIGNlbnRyb2lkIGJvdW5kcy5cblx0ZnVuY3Rpb24gZ2V0Q2VudHJvaWRCb3VuZHMoIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBjZW50cm9pZFRhcmdldCApIHtcblxuXHRcdGxldCBjbWlueCA9IEluZmluaXR5O1xuXHRcdGxldCBjbWlueSA9IEluZmluaXR5O1xuXHRcdGxldCBjbWlueiA9IEluZmluaXR5O1xuXHRcdGxldCBjbWF4eCA9IC0gSW5maW5pdHk7XG5cdFx0bGV0IGNtYXh5ID0gLSBJbmZpbml0eTtcblx0XHRsZXQgY21heHogPSAtIEluZmluaXR5O1xuXG5cdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQgKiA2LCBlbmQgPSAoIG9mZnNldCArIGNvdW50ICkgKiA2OyBpIDwgZW5kOyBpICs9IDYgKSB7XG5cblx0XHRcdGNvbnN0IGN4ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyAwIF07XG5cdFx0XHRpZiAoIGN4IDwgY21pbnggKSBjbWlueCA9IGN4O1xuXHRcdFx0aWYgKCBjeCA+IGNtYXh4ICkgY21heHggPSBjeDtcblxuXHRcdFx0Y29uc3QgY3kgPSB0cmlhbmdsZUJvdW5kc1sgaSArIDIgXTtcblx0XHRcdGlmICggY3kgPCBjbWlueSApIGNtaW55ID0gY3k7XG5cdFx0XHRpZiAoIGN5ID4gY21heHkgKSBjbWF4eSA9IGN5O1xuXG5cdFx0XHRjb25zdCBjeiA9IHRyaWFuZ2xlQm91bmRzWyBpICsgNCBdO1xuXHRcdFx0aWYgKCBjeiA8IGNtaW56ICkgY21pbnogPSBjejtcblx0XHRcdGlmICggY3ogPiBjbWF4eiApIGNtYXh6ID0gY3o7XG5cblx0XHR9XG5cblx0XHRjZW50cm9pZFRhcmdldFsgMCBdID0gY21pbng7XG5cdFx0Y2VudHJvaWRUYXJnZXRbIDEgXSA9IGNtaW55O1xuXHRcdGNlbnRyb2lkVGFyZ2V0WyAyIF0gPSBjbWluejtcblxuXHRcdGNlbnRyb2lkVGFyZ2V0WyAzIF0gPSBjbWF4eDtcblx0XHRjZW50cm9pZFRhcmdldFsgNCBdID0gY21heHk7XG5cdFx0Y2VudHJvaWRUYXJnZXRbIDUgXSA9IGNtYXh6O1xuXG5cdH1cblxuXG5cdC8vIHJlb3JkZXJzIGB0cmlzYCBzdWNoIHRoYXQgZm9yIGBjb3VudGAgZWxlbWVudHMgYWZ0ZXIgYG9mZnNldGAsIGVsZW1lbnRzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHNwbGl0XG5cdC8vIHdpbGwgYmUgb24gdGhlIGxlZnQgYW5kIGVsZW1lbnRzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBzcGxpdCB3aWxsIGJlIG9uIHRoZSByaWdodC4gcmV0dXJucyB0aGUgaW5kZXhcblx0Ly8gb2YgdGhlIGZpcnN0IGVsZW1lbnQgb24gdGhlIHJpZ2h0IHNpZGUsIG9yIG9mZnNldCArIGNvdW50IGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyBvbiB0aGUgcmlnaHQgc2lkZS5cblx0ZnVuY3Rpb24gcGFydGl0aW9uKCBpbmRleCwgdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIHNwbGl0ICkge1xuXG5cdFx0bGV0IGxlZnQgPSBvZmZzZXQ7XG5cdFx0bGV0IHJpZ2h0ID0gb2Zmc2V0ICsgY291bnQgLSAxO1xuXHRcdGNvbnN0IHBvcyA9IHNwbGl0LnBvcztcblx0XHRjb25zdCBheGlzT2Zmc2V0ID0gc3BsaXQuYXhpcyAqIDI7XG5cblx0XHQvLyBob2FyZSBwYXJ0aXRpb25pbmcsIHNlZSBlLmcuIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1F1aWNrc29ydCNIb2FyZV9wYXJ0aXRpb25fc2NoZW1lXG5cdFx0d2hpbGUgKCB0cnVlICkge1xuXG5cdFx0XHR3aGlsZSAoIGxlZnQgPD0gcmlnaHQgJiYgdHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgYXhpc09mZnNldCBdIDwgcG9zICkge1xuXG5cdFx0XHRcdGxlZnQgKys7XG5cblx0XHRcdH1cblxuXG5cdFx0XHQvLyBpZiBhIHRyaWFuZ2xlIGNlbnRlciBsaWVzIG9uIHRoZSBwYXJ0aXRpb24gcGxhbmUgaXQgaXMgY29uc2lkZXJlZCB0byBiZSBvbiB0aGUgcmlnaHQgc2lkZVxuXHRcdFx0d2hpbGUgKCBsZWZ0IDw9IHJpZ2h0ICYmIHRyaWFuZ2xlQm91bmRzWyByaWdodCAqIDYgKyBheGlzT2Zmc2V0IF0gPj0gcG9zICkge1xuXG5cdFx0XHRcdHJpZ2h0IC0tO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbGVmdCA8IHJpZ2h0ICkge1xuXG5cdFx0XHRcdC8vIHdlIG5lZWQgdG8gc3dhcCBhbGwgb2YgdGhlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHJpYW5nbGVzIGF0IGluZGV4XG5cdFx0XHRcdC8vIGxlZnQgYW5kIHJpZ2h0OyB0aGF0J3MgdGhlIHZlcnRzIGluIHRoZSBnZW9tZXRyeSBpbmRleCwgdGhlIGJvdW5kcyxcblx0XHRcdFx0Ly8gYW5kIHBlcmhhcHMgdGhlIFNBSCBwbGFuZXNcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bGV0IHQwID0gaW5kZXhbIGxlZnQgKiAzICsgaSBdO1xuXHRcdFx0XHRcdGluZGV4WyBsZWZ0ICogMyArIGkgXSA9IGluZGV4WyByaWdodCAqIDMgKyBpIF07XG5cdFx0XHRcdFx0aW5kZXhbIHJpZ2h0ICogMyArIGkgXSA9IHQwO1xuXG5cdFx0XHRcdFx0bGV0IHQxID0gdHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgaSAqIDIgKyAwIF07XG5cdFx0XHRcdFx0dHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgaSAqIDIgKyAwIF0gPSB0cmlhbmdsZUJvdW5kc1sgcmlnaHQgKiA2ICsgaSAqIDIgKyAwIF07XG5cdFx0XHRcdFx0dHJpYW5nbGVCb3VuZHNbIHJpZ2h0ICogNiArIGkgKiAyICsgMCBdID0gdDE7XG5cblx0XHRcdFx0XHRsZXQgdDIgPSB0cmlhbmdsZUJvdW5kc1sgbGVmdCAqIDYgKyBpICogMiArIDEgXTtcblx0XHRcdFx0XHR0cmlhbmdsZUJvdW5kc1sgbGVmdCAqIDYgKyBpICogMiArIDEgXSA9IHRyaWFuZ2xlQm91bmRzWyByaWdodCAqIDYgKyBpICogMiArIDEgXTtcblx0XHRcdFx0XHR0cmlhbmdsZUJvdW5kc1sgcmlnaHQgKiA2ICsgaSAqIDIgKyAxIF0gPSB0MjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGVmdCArKztcblx0XHRcdFx0cmlnaHQgLS07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIGxlZnQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgQklOX0NPVU5UID0gMzI7XG5cdGNvbnN0IGJpbnNTb3J0ID0gKCBhLCBiICkgPT4gYS5jYW5kaWRhdGUgLSBiLmNhbmRpZGF0ZTtcblx0Y29uc3Qgc2FoQmlucyA9IG5ldyBBcnJheSggQklOX0NPVU5UICkuZmlsbCgpLm1hcCggKCkgPT4ge1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0Y291bnQ6IDAsXG5cdFx0XHRib3VuZHM6IG5ldyBGbG9hdDMyQXJyYXkoIDYgKSxcblx0XHRcdHJpZ2h0Q2FjaGVCb3VuZHM6IG5ldyBGbG9hdDMyQXJyYXkoIDYgKSxcblx0XHRcdGxlZnRDYWNoZUJvdW5kczogbmV3IEZsb2F0MzJBcnJheSggNiApLFxuXHRcdFx0Y2FuZGlkYXRlOiAwLFxuXG5cdFx0fTtcblxuXHR9ICk7XG5cdGNvbnN0IGxlZnRCb3VuZHMgPSBuZXcgRmxvYXQzMkFycmF5KCA2ICk7XG5cblx0ZnVuY3Rpb24gZ2V0T3B0aW1hbFNwbGl0KCBub2RlQm91bmRpbmdEYXRhLCBjZW50cm9pZEJvdW5kaW5nRGF0YSwgdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIHN0cmF0ZWd5ICkge1xuXG5cdFx0bGV0IGF4aXMgPSAtIDE7XG5cdFx0bGV0IHBvcyA9IDA7XG5cblx0XHQvLyBDZW50ZXJcblx0XHRpZiAoIHN0cmF0ZWd5ID09PSBDRU5URVIgKSB7XG5cblx0XHRcdGF4aXMgPSBnZXRMb25nZXN0RWRnZUluZGV4KCBjZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRcdFx0aWYgKCBheGlzICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0cG9zID0gKCBjZW50cm9pZEJvdW5kaW5nRGF0YVsgYXhpcyBdICsgY2VudHJvaWRCb3VuZGluZ0RhdGFbIGF4aXMgKyAzIF0gKSAvIDI7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHN0cmF0ZWd5ID09PSBBVkVSQUdFICkge1xuXG5cdFx0XHRheGlzID0gZ2V0TG9uZ2VzdEVkZ2VJbmRleCggbm9kZUJvdW5kaW5nRGF0YSApO1xuXHRcdFx0aWYgKCBheGlzICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0cG9zID0gZ2V0QXZlcmFnZSggdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIGF4aXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggc3RyYXRlZ3kgPT09IFNBSCApIHtcblxuXHRcdFx0Y29uc3Qgcm9vdFN1cmZhY2VBcmVhID0gY29tcHV0ZVN1cmZhY2VBcmVhKCBub2RlQm91bmRpbmdEYXRhICk7XG5cdFx0XHRsZXQgYmVzdENvc3QgPSBUUklBTkdMRV9JTlRFUlNFQ1RfQ09TVCAqIGNvdW50O1xuXG5cdFx0XHQvLyBpdGVyYXRlIG92ZXIgYWxsIGF4ZXNcblx0XHRcdGNvbnN0IGNTdGFydCA9IG9mZnNldCAqIDY7XG5cdFx0XHRjb25zdCBjRW5kID0gKCBvZmZzZXQgKyBjb3VudCApICogNjtcblx0XHRcdGZvciAoIGxldCBhID0gMDsgYSA8IDM7IGEgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXhpc0xlZnQgPSBjZW50cm9pZEJvdW5kaW5nRGF0YVsgYSBdO1xuXHRcdFx0XHRjb25zdCBheGlzUmlnaHQgPSBjZW50cm9pZEJvdW5kaW5nRGF0YVsgYSArIDMgXTtcblx0XHRcdFx0Y29uc3QgYXhpc0xlbmd0aCA9IGF4aXNSaWdodCAtIGF4aXNMZWZ0O1xuXHRcdFx0XHRjb25zdCBiaW5XaWR0aCA9IGF4aXNMZW5ndGggLyBCSU5fQ09VTlQ7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBmZXdlciB0cmlhbmdsZXMgdGhhbiB3ZSdyZSBwbGFubmluZyB0byBzcGxpdCB0aGVuIGp1c3QgY2hlY2sgYWxsXG5cdFx0XHRcdC8vIHRoZSB0cmlhbmdsZSBwb3NpdGlvbnMgYmVjYXVzZSBpdCB3aWxsIGJlIGZhc3Rlci5cblx0XHRcdFx0aWYgKCBjb3VudCA8IEJJTl9DT1VOVCAvIDQgKSB7XG5cblx0XHRcdFx0XHQvLyBpbml0aWFsaXplIHRoZSBiaW4gY2FuZGlkYXRlc1xuXHRcdFx0XHRcdGNvbnN0IHRydW5jYXRlZEJpbnMgPSBbIC4uLnNhaEJpbnMgXTtcblx0XHRcdFx0XHR0cnVuY2F0ZWRCaW5zLmxlbmd0aCA9IGNvdW50O1xuXG5cdFx0XHRcdFx0Ly8gc2V0IHRoZSBjYW5kaWRhdGVzXG5cdFx0XHRcdFx0bGV0IGIgPSAwO1xuXHRcdFx0XHRcdGZvciAoIGxldCBjID0gY1N0YXJ0OyBjIDwgY0VuZDsgYyArPSA2LCBiICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBiaW4gPSB0cnVuY2F0ZWRCaW5zWyBiIF07XG5cdFx0XHRcdFx0XHRiaW4uY2FuZGlkYXRlID0gdHJpYW5nbGVCb3VuZHNbIGMgKyAyICogYSBdO1xuXHRcdFx0XHRcdFx0YmluLmNvdW50ID0gMDtcblxuXHRcdFx0XHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRcdFx0XHRib3VuZHMsXG5cdFx0XHRcdFx0XHRcdGxlZnRDYWNoZUJvdW5kcyxcblx0XHRcdFx0XHRcdFx0cmlnaHRDYWNoZUJvdW5kcyxcblx0XHRcdFx0XHRcdH0gPSBiaW47XG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgZCA9IDA7IGQgPCAzOyBkICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHJpZ2h0Q2FjaGVCb3VuZHNbIGQgXSA9IEluZmluaXR5O1xuXHRcdFx0XHRcdFx0XHRyaWdodENhY2hlQm91bmRzWyBkICsgMyBdID0gLSBJbmZpbml0eTtcblxuXHRcdFx0XHRcdFx0XHRsZWZ0Q2FjaGVCb3VuZHNbIGQgXSA9IEluZmluaXR5O1xuXHRcdFx0XHRcdFx0XHRsZWZ0Q2FjaGVCb3VuZHNbIGQgKyAzIF0gPSAtIEluZmluaXR5O1xuXG5cdFx0XHRcdFx0XHRcdGJvdW5kc1sgZCBdID0gSW5maW5pdHk7XG5cdFx0XHRcdFx0XHRcdGJvdW5kc1sgZCArIDMgXSA9IC0gSW5maW5pdHk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyggYywgdHJpYW5nbGVCb3VuZHMsIGJvdW5kcyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHJ1bmNhdGVkQmlucy5zb3J0KCBiaW5zU29ydCApO1xuXG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIHJlZHVuZGFudCBzcGxpdHNcblx0XHRcdFx0XHRsZXQgc3BsaXRDb3VudCA9IGNvdW50O1xuXHRcdFx0XHRcdGZvciAoIGxldCBiaSA9IDA7IGJpIDwgc3BsaXRDb3VudDsgYmkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGJpbiA9IHRydW5jYXRlZEJpbnNbIGJpIF07XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGJpICsgMSA8IHNwbGl0Q291bnQgJiYgdHJ1bmNhdGVkQmluc1sgYmkgKyAxIF0uY2FuZGlkYXRlID09PSBiaW4uY2FuZGlkYXRlICkge1xuXG5cdFx0XHRcdFx0XHRcdHRydW5jYXRlZEJpbnMuc3BsaWNlKCBiaSArIDEsIDEgKTtcblx0XHRcdFx0XHRcdFx0c3BsaXRDb3VudCAtLTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZmluZCB0aGUgYXBwcm9wcmlhdGUgYmluIGZvciBlYWNoIHRyaWFuZ2xlIGFuZCBleHBhbmQgdGhlIGJvdW5kcy5cblx0XHRcdFx0XHRmb3IgKCBsZXQgYyA9IGNTdGFydDsgYyA8IGNFbmQ7IGMgKz0gNiApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY2VudGVyID0gdHJpYW5nbGVCb3VuZHNbIGMgKyAyICogYSBdO1xuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGJpID0gMDsgYmkgPCBzcGxpdENvdW50OyBiaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBiaW4gPSB0cnVuY2F0ZWRCaW5zWyBiaSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNlbnRlciA+PSBiaW4uY2FuZGlkYXRlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0ZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyggYywgdHJpYW5nbGVCb3VuZHMsIGJpbi5yaWdodENhY2hlQm91bmRzICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdGV4cGFuZEJ5VHJpYW5nbGVCb3VuZHMoIGMsIHRyaWFuZ2xlQm91bmRzLCBiaW4ubGVmdENhY2hlQm91bmRzICk7XG5cdFx0XHRcdFx0XHRcdFx0YmluLmNvdW50ICsrO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZXhwYW5kIGFsbCB0aGUgYm91bmRzXG5cdFx0XHRcdFx0Zm9yICggbGV0IGJpID0gMDsgYmkgPCBzcGxpdENvdW50OyBiaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gdHJ1bmNhdGVkQmluc1sgYmkgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGxlZnRDb3VudCA9IGJpbi5jb3VudDtcblx0XHRcdFx0XHRcdGNvbnN0IHJpZ2h0Q291bnQgPSBjb3VudCAtIGJpbi5jb3VudDtcblxuXHRcdFx0XHRcdFx0Ly8gY2hlY2sgdGhlIGNvc3Qgb2YgdGhpcyBzcGxpdFxuXHRcdFx0XHRcdFx0Y29uc3QgbGVmdEJvdW5kcyA9IGJpbi5sZWZ0Q2FjaGVCb3VuZHM7XG5cdFx0XHRcdFx0XHRjb25zdCByaWdodEJvdW5kcyA9IGJpbi5yaWdodENhY2hlQm91bmRzO1xuXG5cdFx0XHRcdFx0XHRsZXQgbGVmdFByb2IgPSAwO1xuXHRcdFx0XHRcdFx0aWYgKCBsZWZ0Q291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0bGVmdFByb2IgPSBjb21wdXRlU3VyZmFjZUFyZWEoIGxlZnRCb3VuZHMgKSAvIHJvb3RTdXJmYWNlQXJlYTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRsZXQgcmlnaHRQcm9iID0gMDtcblx0XHRcdFx0XHRcdGlmICggcmlnaHRDb3VudCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRyaWdodFByb2IgPSBjb21wdXRlU3VyZmFjZUFyZWEoIHJpZ2h0Qm91bmRzICkgLyByb290U3VyZmFjZUFyZWE7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgY29zdCA9IFRSQVZFUlNBTF9DT1NUICsgVFJJQU5HTEVfSU5URVJTRUNUX0NPU1QgKiAoXG5cdFx0XHRcdFx0XHRcdGxlZnRQcm9iICogbGVmdENvdW50ICsgcmlnaHRQcm9iICogcmlnaHRDb3VudFxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBjb3N0IDwgYmVzdENvc3QgKSB7XG5cblx0XHRcdFx0XHRcdFx0YXhpcyA9IGE7XG5cdFx0XHRcdFx0XHRcdGJlc3RDb3N0ID0gY29zdDtcblx0XHRcdFx0XHRcdFx0cG9zID0gYmluLmNhbmRpZGF0ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyByZXNldCB0aGUgYmluc1xuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IEJJTl9DT1VOVDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgaSBdO1xuXHRcdFx0XHRcdFx0YmluLmNvdW50ID0gMDtcblx0XHRcdFx0XHRcdGJpbi5jYW5kaWRhdGUgPSBheGlzTGVmdCArIGJpbldpZHRoICsgaSAqIGJpbldpZHRoO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBib3VuZHMgPSBiaW4uYm91bmRzO1xuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGQgPSAwOyBkIDwgMzsgZCArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRib3VuZHNbIGQgXSA9IEluZmluaXR5O1xuXHRcdFx0XHRcdFx0XHRib3VuZHNbIGQgKyAzIF0gPSAtIEluZmluaXR5O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBpdGVyYXRlIG92ZXIgYWxsIGNlbnRlciBwb3NpdGlvbnNcblx0XHRcdFx0XHRmb3IgKCBsZXQgYyA9IGNTdGFydDsgYyA8IGNFbmQ7IGMgKz0gNiApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdHJpQ2VudGVyID0gdHJpYW5nbGVCb3VuZHNbIGMgKyAyICogYSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVsYXRpdmVDZW50ZXIgPSB0cmlDZW50ZXIgLSBheGlzTGVmdDtcblxuXHRcdFx0XHRcdFx0Ly8gaW4gdGhlIHBhcnRpdGlvbiBmdW5jdGlvbiBpZiB0aGUgY2VudHJvaWQgbGllcyBvbiB0aGUgc3BsaXQgcGxhbmUgdGhlbiBpdCBpc1xuXHRcdFx0XHRcdFx0Ly8gY29uc2lkZXJlZCB0byBiZSBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc3BsaXRcblx0XHRcdFx0XHRcdGxldCBiaW5JbmRleCA9IH4gfiAoIHJlbGF0aXZlQ2VudGVyIC8gYmluV2lkdGggKTtcblx0XHRcdFx0XHRcdGlmICggYmluSW5kZXggPj0gQklOX0NPVU5UICkgYmluSW5kZXggPSBCSU5fQ09VTlQgLSAxO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBiaW4gPSBzYWhCaW5zWyBiaW5JbmRleCBdO1xuXHRcdFx0XHRcdFx0YmluLmNvdW50ICsrO1xuXG5cdFx0XHRcdFx0XHRleHBhbmRCeVRyaWFuZ2xlQm91bmRzKCBjLCB0cmlhbmdsZUJvdW5kcywgYmluLmJvdW5kcyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY2FjaGUgdGhlIHVuaW9uZWQgYm91bmRzIGZyb20gcmlnaHQgdG8gbGVmdCBzbyB3ZSBkb24ndCBoYXZlIHRvIHJlZ2VuZXJhdGUgdGhlbSBlYWNoIHRpbWVcblx0XHRcdFx0XHRjb25zdCBsYXN0QmluID0gc2FoQmluc1sgQklOX0NPVU5UIC0gMSBdO1xuXHRcdFx0XHRcdGNvcHlCb3VuZHMoIGxhc3RCaW4uYm91bmRzLCBsYXN0QmluLnJpZ2h0Q2FjaGVCb3VuZHMgKTtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IEJJTl9DT1VOVCAtIDI7IGkgPj0gMDsgaSAtLSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgaSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV4dEJpbiA9IHNhaEJpbnNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHR1bmlvbkJvdW5kcyggYmluLmJvdW5kcywgbmV4dEJpbi5yaWdodENhY2hlQm91bmRzLCBiaW4ucmlnaHRDYWNoZUJvdW5kcyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IGxlZnRDb3VudCA9IDA7XG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgQklOX0NPVU5UIC0gMTsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgaSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgYmluQ291bnQgPSBiaW4uY291bnQ7XG5cdFx0XHRcdFx0XHRjb25zdCBib3VuZHMgPSBiaW4uYm91bmRzO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBuZXh0QmluID0gc2FoQmluc1sgaSArIDEgXTtcblx0XHRcdFx0XHRcdGNvbnN0IHJpZ2h0Qm91bmRzID0gbmV4dEJpbi5yaWdodENhY2hlQm91bmRzO1xuXG5cdFx0XHRcdFx0XHQvLyBkb24ndCBkbyBhbnl0aGluZyB3aXRoIHRoZSBib3VuZHMgaWYgdGhlIG5ldyBib3VuZHMgaGF2ZSBubyB0cmlhbmdsZXNcblx0XHRcdFx0XHRcdGlmICggYmluQ291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBsZWZ0Q291bnQgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb3B5Qm91bmRzKCBib3VuZHMsIGxlZnRCb3VuZHMgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0dW5pb25Cb3VuZHMoIGJvdW5kcywgbGVmdEJvdW5kcywgbGVmdEJvdW5kcyApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRsZWZ0Q291bnQgKz0gYmluQ291bnQ7XG5cblx0XHRcdFx0XHRcdC8vIGNoZWNrIHRoZSBjb3N0IG9mIHRoaXMgc3BsaXRcblx0XHRcdFx0XHRcdGxldCBsZWZ0UHJvYiA9IDA7XG5cdFx0XHRcdFx0XHRsZXQgcmlnaHRQcm9iID0gMDtcblxuXHRcdFx0XHRcdFx0aWYgKCBsZWZ0Q291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0bGVmdFByb2IgPSBjb21wdXRlU3VyZmFjZUFyZWEoIGxlZnRCb3VuZHMgKSAvIHJvb3RTdXJmYWNlQXJlYTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb25zdCByaWdodENvdW50ID0gY291bnQgLSBsZWZ0Q291bnQ7XG5cdFx0XHRcdFx0XHRpZiAoIHJpZ2h0Q291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmlnaHRQcm9iID0gY29tcHV0ZVN1cmZhY2VBcmVhKCByaWdodEJvdW5kcyApIC8gcm9vdFN1cmZhY2VBcmVhO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IGNvc3QgPSBUUkFWRVJTQUxfQ09TVCArIFRSSUFOR0xFX0lOVEVSU0VDVF9DT1NUICogKFxuXHRcdFx0XHRcdFx0XHRsZWZ0UHJvYiAqIGxlZnRDb3VudCArIHJpZ2h0UHJvYiAqIHJpZ2h0Q291bnRcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGlmICggY29zdCA8IGJlc3RDb3N0ICkge1xuXG5cdFx0XHRcdFx0XHRcdGF4aXMgPSBhO1xuXHRcdFx0XHRcdFx0XHRiZXN0Q29zdCA9IGNvc3Q7XG5cdFx0XHRcdFx0XHRcdHBvcyA9IGJpbi5jYW5kaWRhdGU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggYE1lc2hCVkg6IEludmFsaWQgYnVpbGQgc3RyYXRlZ3kgdmFsdWUgJHsgc3RyYXRlZ3kgfSB1c2VkLmAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB7IGF4aXMsIHBvcyB9O1xuXG5cdH1cblxuXHQvLyByZXR1cm5zIHRoZSBhdmVyYWdlIGNvb3JkaW5hdGUgb24gdGhlIHNwZWNpZmllZCBheGlzIG9mIHRoZSBhbGwgdGhlIHByb3ZpZGVkIHRyaWFuZ2xlc1xuXHRmdW5jdGlvbiBnZXRBdmVyYWdlKCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgYXhpcyApIHtcblxuXHRcdGxldCBhdmcgPSAwO1xuXHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBlbmQgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGVuZDsgaSArKyApIHtcblxuXHRcdFx0YXZnICs9IHRyaWFuZ2xlQm91bmRzWyBpICogNiArIGF4aXMgKiAyIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYXZnIC8gY291bnQ7XG5cblx0fVxuXG5cdC8vIHByZWNvbXB1dGVzIHRoZSBib3VuZGluZyBib3ggZm9yIGVhY2ggdHJpYW5nbGU7IHJlcXVpcmVkIGZvciBxdWlja2x5IGNhbGN1bGF0aW5nIHRyZWUgc3BsaXRzLlxuXHQvLyByZXN1bHQgaXMgYW4gYXJyYXkgb2Ygc2l6ZSB0cmlzLmxlbmd0aCAqIDYgd2hlcmUgdHJpYW5nbGUgaSBtYXBzIHRvIGFcblx0Ly8gW3hfY2VudGVyLCB4X2RlbHRhLCB5X2NlbnRlciwgeV9kZWx0YSwgel9jZW50ZXIsIHpfZGVsdGFdIHR1cGxlIHN0YXJ0aW5nIGF0IGluZGV4IGkgKiA2LFxuXHQvLyByZXByZXNlbnRpbmcgdGhlIGNlbnRlciBhbmQgaGFsZi1leHRlbnQgaW4gZWFjaCBkaW1lbnNpb24gb2YgdHJpYW5nbGUgaVxuXHRmdW5jdGlvbiBjb21wdXRlVHJpYW5nbGVCb3VuZHMoIGdlbywgZnVsbEJvdW5kcyApIHtcblxuXHRcdC8vIGNsZWFyIHRoZSBib3VuZHMgdG8gZW1wdHlcblx0XHRtYWtlRW1wdHlCb3VuZHMoIGZ1bGxCb3VuZHMgKTtcblxuXHRcdGNvbnN0IHBvc0F0dHIgPSBnZW8uYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBpbmRleCA9IGdlby5pbmRleC5hcnJheTtcblx0XHRjb25zdCB0cmlDb3VudCA9IGluZGV4Lmxlbmd0aCAvIDM7XG5cdFx0Y29uc3QgdHJpYW5nbGVCb3VuZHMgPSBuZXcgRmxvYXQzMkFycmF5KCB0cmlDb3VudCAqIDYgKTtcblx0XHRjb25zdCBub3JtYWxpemVkID0gcG9zQXR0ci5ub3JtYWxpemVkO1xuXG5cdFx0Ly8gdXNlZCBmb3Igbm9uLW5vcm1hbGl6ZWQgcG9zaXRpb25zXG5cdFx0Y29uc3QgcG9zQXJyID0gcG9zQXR0ci5hcnJheTtcblxuXHRcdC8vIHN1cHBvcnQgZm9yIGFuIGludGVybGVhdmVkIHBvc2l0aW9uIGJ1ZmZlclxuXHRcdGNvbnN0IGJ1ZmZlck9mZnNldCA9IHBvc0F0dHIub2Zmc2V0IHx8IDA7XG5cdFx0bGV0IHN0cmlkZSA9IDM7XG5cdFx0aWYgKCBwb3NBdHRyLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdHN0cmlkZSA9IHBvc0F0dHIuZGF0YS5zdHJpZGU7XG5cblx0XHR9XG5cblx0XHQvLyB1c2VkIGZvciBub3JtYWxpemVkIHBvc2l0aW9uc1xuXHRcdGNvbnN0IGdldHRlcnMgPSBbICdnZXRYJywgJ2dldFknLCAnZ2V0WicgXTtcblxuXHRcdGZvciAoIGxldCB0cmkgPSAwOyB0cmkgPCB0cmlDb3VudDsgdHJpICsrICkge1xuXG5cdFx0XHRjb25zdCB0cmkzID0gdHJpICogMztcblx0XHRcdGNvbnN0IHRyaTYgPSB0cmkgKiA2O1xuXG5cdFx0XHRsZXQgYWksIGJpLCBjaTtcblxuXHRcdFx0aWYgKCBub3JtYWxpemVkICkge1xuXG5cdFx0XHRcdGFpID0gaW5kZXhbIHRyaTMgKyAwIF07XG5cdFx0XHRcdGJpID0gaW5kZXhbIHRyaTMgKyAxIF07XG5cdFx0XHRcdGNpID0gaW5kZXhbIHRyaTMgKyAyIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YWkgPSBpbmRleFsgdHJpMyArIDAgXSAqIHN0cmlkZSArIGJ1ZmZlck9mZnNldDtcblx0XHRcdFx0YmkgPSBpbmRleFsgdHJpMyArIDEgXSAqIHN0cmlkZSArIGJ1ZmZlck9mZnNldDtcblx0XHRcdFx0Y2kgPSBpbmRleFsgdHJpMyArIDIgXSAqIHN0cmlkZSArIGJ1ZmZlck9mZnNldDtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgZWwgPSAwOyBlbCA8IDM7IGVsICsrICkge1xuXG5cdFx0XHRcdGxldCBhLCBiLCBjO1xuXG5cdFx0XHRcdGlmICggbm9ybWFsaXplZCApIHtcblxuXHRcdFx0XHRcdGEgPSBwb3NBdHRyWyBnZXR0ZXJzWyBlbCBdIF0oIGFpICk7XG5cdFx0XHRcdFx0YiA9IHBvc0F0dHJbIGdldHRlcnNbIGVsIF0gXSggYmkgKTtcblx0XHRcdFx0XHRjID0gcG9zQXR0clsgZ2V0dGVyc1sgZWwgXSBdKCBjaSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRhID0gcG9zQXJyWyBhaSArIGVsIF07XG5cdFx0XHRcdFx0YiA9IHBvc0FyclsgYmkgKyBlbCBdO1xuXHRcdFx0XHRcdGMgPSBwb3NBcnJbIGNpICsgZWwgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IG1pbiA9IGE7XG5cdFx0XHRcdGlmICggYiA8IG1pbiApIG1pbiA9IGI7XG5cdFx0XHRcdGlmICggYyA8IG1pbiApIG1pbiA9IGM7XG5cblx0XHRcdFx0bGV0IG1heCA9IGE7XG5cdFx0XHRcdGlmICggYiA+IG1heCApIG1heCA9IGI7XG5cdFx0XHRcdGlmICggYyA+IG1heCApIG1heCA9IGM7XG5cblx0XHRcdFx0Ly8gSW5jcmVhc2UgdGhlIGJvdW5kcyBzaXplIGJ5IGZsb2F0MzIgZXBzaWxvbiB0byBhdm9pZCBwcmVjaXNpb24gZXJyb3JzIHdoZW5cblx0XHRcdFx0Ly8gY29udmVydGluZyB0byAzMiBiaXQgZmxvYXQuIFNjYWxlIHRoZSBlcHNpbG9uIGJ5IHRoZSBzaXplIG9mIHRoZSBudW1iZXJzIGJlaW5nXG5cdFx0XHRcdC8vIHdvcmtlZCB3aXRoLlxuXHRcdFx0XHRjb25zdCBoYWxmRXh0ZW50cyA9ICggbWF4IC0gbWluICkgLyAyO1xuXHRcdFx0XHRjb25zdCBlbDIgPSBlbCAqIDI7XG5cdFx0XHRcdHRyaWFuZ2xlQm91bmRzWyB0cmk2ICsgZWwyICsgMCBdID0gbWluICsgaGFsZkV4dGVudHM7XG5cdFx0XHRcdHRyaWFuZ2xlQm91bmRzWyB0cmk2ICsgZWwyICsgMSBdID0gaGFsZkV4dGVudHMgKyAoIE1hdGguYWJzKCBtaW4gKSArIGhhbGZFeHRlbnRzICkgKiBGTE9BVDMyX0VQU0lMT047XG5cblx0XHRcdFx0aWYgKCBtaW4gPCBmdWxsQm91bmRzWyBlbCBdICkgZnVsbEJvdW5kc1sgZWwgXSA9IG1pbjtcblx0XHRcdFx0aWYgKCBtYXggPiBmdWxsQm91bmRzWyBlbCArIDMgXSApIGZ1bGxCb3VuZHNbIGVsICsgMyBdID0gbWF4O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJpYW5nbGVCb3VuZHM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGJ1aWxkVHJlZSggZ2VvLCBvcHRpb25zICkge1xuXG5cdFx0ZnVuY3Rpb24gdHJpZ2dlclByb2dyZXNzKCB0cmlhbmdsZXNQcm9jZXNzZWQgKSB7XG5cblx0XHRcdGlmICggb25Qcm9ncmVzcyApIHtcblxuXHRcdFx0XHRvblByb2dyZXNzKCB0cmlhbmdsZXNQcm9jZXNzZWQgLyB0b3RhbFRyaWFuZ2xlcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBlaXRoZXIgcmVjdXJzaXZlbHkgc3BsaXRzIHRoZSBnaXZlbiBub2RlLCBjcmVhdGluZyBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBmb3IgaXQsIG9yIG1ha2VzIGl0IGEgbGVhZiBub2RlLFxuXHRcdC8vIHJlY29yZGluZyB0aGUgb2Zmc2V0IGFuZCBjb3VudCBvZiBpdHMgdHJpYW5nbGVzIGFuZCB3cml0aW5nIHRoZW0gaW50byB0aGUgcmVvcmRlcmVkIGdlb21ldHJ5IGluZGV4LlxuXHRcdGZ1bmN0aW9uIHNwbGl0Tm9kZSggbm9kZSwgb2Zmc2V0LCBjb3VudCwgY2VudHJvaWRCb3VuZGluZ0RhdGEgPSBudWxsLCBkZXB0aCA9IDAgKSB7XG5cblx0XHRcdGlmICggISByZWFjaGVkTWF4RGVwdGggJiYgZGVwdGggPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0cmVhY2hlZE1heERlcHRoID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB2ZXJib3NlICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCBgTWVzaEJWSDogTWF4IGRlcHRoIG9mICR7IG1heERlcHRoIH0gcmVhY2hlZCB3aGVuIGdlbmVyYXRpbmcgQlZILiBDb25zaWRlciBpbmNyZWFzaW5nIG1heERlcHRoLmAgKTtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oIGdlbyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBlYXJseSBvdXQgaWYgd2UndmUgbWV0IG91ciBjYXBhY2l0eVxuXHRcdFx0aWYgKCBjb3VudCA8PSBtYXhMZWFmVHJpcyB8fCBkZXB0aCA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHR0cmlnZ2VyUHJvZ3Jlc3MoIG9mZnNldCArIGNvdW50ICk7XG5cdFx0XHRcdG5vZGUub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdFx0XHRub2RlLmNvdW50ID0gY291bnQ7XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpbmQgd2hlcmUgdG8gc3BsaXQgdGhlIHZvbHVtZVxuXHRcdFx0Y29uc3Qgc3BsaXQgPSBnZXRPcHRpbWFsU3BsaXQoIG5vZGUuYm91bmRpbmdEYXRhLCBjZW50cm9pZEJvdW5kaW5nRGF0YSwgdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIHN0cmF0ZWd5ICk7XG5cdFx0XHRpZiAoIHNwbGl0LmF4aXMgPT09IC0gMSApIHtcblxuXHRcdFx0XHR0cmlnZ2VyUHJvZ3Jlc3MoIG9mZnNldCArIGNvdW50ICk7XG5cdFx0XHRcdG5vZGUub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdFx0XHRub2RlLmNvdW50ID0gY291bnQ7XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNwbGl0T2Zmc2V0ID0gcGFydGl0aW9uKCBpbmRleEFycmF5LCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgc3BsaXQgKTtcblxuXHRcdFx0Ly8gY3JlYXRlIHRoZSB0d28gbmV3IGNoaWxkIG5vZGVzXG5cdFx0XHRpZiAoIHNwbGl0T2Zmc2V0ID09PSBvZmZzZXQgfHwgc3BsaXRPZmZzZXQgPT09IG9mZnNldCArIGNvdW50ICkge1xuXG5cdFx0XHRcdHRyaWdnZXJQcm9ncmVzcyggb2Zmc2V0ICsgY291bnQgKTtcblx0XHRcdFx0bm9kZS5vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0XHRcdG5vZGUuY291bnQgPSBjb3VudDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRub2RlLnNwbGl0QXhpcyA9IHNwbGl0LmF4aXM7XG5cblx0XHRcdFx0Ly8gY3JlYXRlIHRoZSBsZWZ0IGNoaWxkIGFuZCBjb21wdXRlIGl0cyBib3VuZGluZyBib3hcblx0XHRcdFx0Y29uc3QgbGVmdCA9IG5ldyBNZXNoQlZITm9kZSgpO1xuXHRcdFx0XHRjb25zdCBsc3RhcnQgPSBvZmZzZXQ7XG5cdFx0XHRcdGNvbnN0IGxjb3VudCA9IHNwbGl0T2Zmc2V0IC0gb2Zmc2V0O1xuXHRcdFx0XHRub2RlLmxlZnQgPSBsZWZ0O1xuXHRcdFx0XHRsZWZ0LmJvdW5kaW5nRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoIDYgKTtcblxuXHRcdFx0XHRnZXRCb3VuZHMoIHRyaWFuZ2xlQm91bmRzLCBsc3RhcnQsIGxjb3VudCwgbGVmdC5ib3VuZGluZ0RhdGEsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblx0XHRcdFx0c3BsaXROb2RlKCBsZWZ0LCBsc3RhcnQsIGxjb3VudCwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSwgZGVwdGggKyAxICk7XG5cblx0XHRcdFx0Ly8gcmVwZWF0IGZvciByaWdodFxuXHRcdFx0XHRjb25zdCByaWdodCA9IG5ldyBNZXNoQlZITm9kZSgpO1xuXHRcdFx0XHRjb25zdCByc3RhcnQgPSBzcGxpdE9mZnNldDtcblx0XHRcdFx0Y29uc3QgcmNvdW50ID0gY291bnQgLSBsY291bnQ7XG5cdFx0XHRcdG5vZGUucmlnaHQgPSByaWdodDtcblx0XHRcdFx0cmlnaHQuYm91bmRpbmdEYXRhID0gbmV3IEZsb2F0MzJBcnJheSggNiApO1xuXG5cdFx0XHRcdGdldEJvdW5kcyggdHJpYW5nbGVCb3VuZHMsIHJzdGFydCwgcmNvdW50LCByaWdodC5ib3VuZGluZ0RhdGEsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblx0XHRcdFx0c3BsaXROb2RlKCByaWdodCwgcnN0YXJ0LCByY291bnQsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEsIGRlcHRoICsgMSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0fVxuXG5cdFx0ZW5zdXJlSW5kZXgoIGdlbywgb3B0aW9ucyApO1xuXG5cdFx0Ly8gQ29tcHV0ZSB0aGUgZnVsbCBib3VuZHMgb2YgdGhlIGdlb21ldHJ5IGF0IHRoZSBzYW1lIHRpbWUgYXMgdHJpYW5nbGUgYm91bmRzIGJlY2F1c2Vcblx0XHQvLyB3ZSdsbCBuZWVkIGl0IGZvciB0aGUgcm9vdCBib3VuZHMgaW4gdGhlIGNhc2Ugd2l0aCBubyBncm91cHMgYW5kIGl0IHNob3VsZCBiZSBmYXN0IGhlcmUuXG5cdFx0Ly8gV2UgY2FuJ3QgdXNlIHRoZSBnZW9tZXRyeWluZyBib3VuZGluZyBib3ggaWYgaXQncyBhdmFpbGFibGUgYmVjYXVzZSBpdCBtYXkgYmUgb3V0IG9mIGRhdGUuXG5cdFx0Y29uc3QgZnVsbEJvdW5kcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDYgKTtcblx0XHRjb25zdCBjYWNoZUNlbnRyb2lkQm91bmRpbmdEYXRhID0gbmV3IEZsb2F0MzJBcnJheSggNiApO1xuXHRcdGNvbnN0IHRyaWFuZ2xlQm91bmRzID0gY29tcHV0ZVRyaWFuZ2xlQm91bmRzKCBnZW8sIGZ1bGxCb3VuZHMgKTtcblx0XHRjb25zdCBpbmRleEFycmF5ID0gZ2VvLmluZGV4LmFycmF5O1xuXHRcdGNvbnN0IG1heERlcHRoID0gb3B0aW9ucy5tYXhEZXB0aDtcblx0XHRjb25zdCB2ZXJib3NlID0gb3B0aW9ucy52ZXJib3NlO1xuXHRcdGNvbnN0IG1heExlYWZUcmlzID0gb3B0aW9ucy5tYXhMZWFmVHJpcztcblx0XHRjb25zdCBzdHJhdGVneSA9IG9wdGlvbnMuc3RyYXRlZ3k7XG5cdFx0Y29uc3Qgb25Qcm9ncmVzcyA9IG9wdGlvbnMub25Qcm9ncmVzcztcblx0XHRjb25zdCB0b3RhbFRyaWFuZ2xlcyA9IGdlby5pbmRleC5jb3VudCAvIDM7XG5cdFx0bGV0IHJlYWNoZWRNYXhEZXB0aCA9IGZhbHNlO1xuXG5cdFx0Y29uc3Qgcm9vdHMgPSBbXTtcblx0XHRjb25zdCByYW5nZXMgPSBnZXRSb290SW5kZXhSYW5nZXMoIGdlbyApO1xuXG5cdFx0aWYgKCByYW5nZXMubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRjb25zdCByYW5nZSA9IHJhbmdlc1sgMCBdO1xuXHRcdFx0Y29uc3Qgcm9vdCA9IG5ldyBNZXNoQlZITm9kZSgpO1xuXHRcdFx0cm9vdC5ib3VuZGluZ0RhdGEgPSBmdWxsQm91bmRzO1xuXHRcdFx0Z2V0Q2VudHJvaWRCb3VuZHMoIHRyaWFuZ2xlQm91bmRzLCByYW5nZS5vZmZzZXQsIHJhbmdlLmNvdW50LCBjYWNoZUNlbnRyb2lkQm91bmRpbmdEYXRhICk7XG5cblx0XHRcdHNwbGl0Tm9kZSggcm9vdCwgcmFuZ2Uub2Zmc2V0LCByYW5nZS5jb3VudCwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRcdFx0cm9vdHMucHVzaCggcm9vdCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Zm9yICggbGV0IHJhbmdlIG9mIHJhbmdlcyApIHtcblxuXHRcdFx0XHRjb25zdCByb290ID0gbmV3IE1lc2hCVkhOb2RlKCk7XG5cdFx0XHRcdHJvb3QuYm91bmRpbmdEYXRhID0gbmV3IEZsb2F0MzJBcnJheSggNiApO1xuXHRcdFx0XHRnZXRCb3VuZHMoIHRyaWFuZ2xlQm91bmRzLCByYW5nZS5vZmZzZXQsIHJhbmdlLmNvdW50LCByb290LmJvdW5kaW5nRGF0YSwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXG5cdFx0XHRcdHNwbGl0Tm9kZSggcm9vdCwgcmFuZ2Uub2Zmc2V0LCByYW5nZS5jb3VudCwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRcdFx0XHRyb290cy5wdXNoKCByb290ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiByb290cztcblxuXHR9XG5cblx0ZnVuY3Rpb24gYnVpbGRQYWNrZWRUcmVlKCBnZW8sIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBib3VuZGluZ0RhdGEgIFx0XHRcdFx0OiA2IGZsb2F0MzJcblx0XHQvLyByaWdodCAvIG9mZnNldCBcdFx0XHRcdDogMSB1aW50MzJcblx0XHQvLyBzcGxpdEF4aXMgLyBpc0xlYWYgKyBjb3VudCBcdDogMSB1aW50MzIgLyAyIHVpbnQxNlxuXHRcdGNvbnN0IHJvb3RzID0gYnVpbGRUcmVlKCBnZW8sIG9wdGlvbnMgKTtcblxuXHRcdGxldCBmbG9hdDMyQXJyYXk7XG5cdFx0bGV0IHVpbnQzMkFycmF5O1xuXHRcdGxldCB1aW50MTZBcnJheTtcblx0XHRjb25zdCBwYWNrZWRSb290cyA9IFtdO1xuXHRcdGNvbnN0IEJ1ZmZlckNvbnN0cnVjdG9yID0gb3B0aW9ucy51c2VTaGFyZWRBcnJheUJ1ZmZlciA/IFNoYXJlZEFycmF5QnVmZmVyIDogQXJyYXlCdWZmZXI7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcm9vdHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCByb290ID0gcm9vdHNbIGkgXTtcblx0XHRcdGxldCBub2RlQ291bnQgPSBjb3VudE5vZGVzKCByb290ICk7XG5cblx0XHRcdGNvbnN0IGJ1ZmZlciA9IG5ldyBCdWZmZXJDb25zdHJ1Y3RvciggQllURVNfUEVSX05PREUgKiBub2RlQ291bnQgKTtcblx0XHRcdGZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRcdFx0dWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRcdFx0dWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIGJ1ZmZlciApO1xuXHRcdFx0cG9wdWxhdGVCdWZmZXIoIDAsIHJvb3QgKTtcblx0XHRcdHBhY2tlZFJvb3RzLnB1c2goIGJ1ZmZlciApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhY2tlZFJvb3RzO1xuXG5cdFx0ZnVuY3Rpb24gY291bnROb2Rlcyggbm9kZSApIHtcblxuXHRcdFx0aWYgKCBub2RlLmNvdW50ICkge1xuXG5cdFx0XHRcdHJldHVybiAxO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiAxICsgY291bnROb2Rlcyggbm9kZS5sZWZ0ICkgKyBjb3VudE5vZGVzKCBub2RlLnJpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBvcHVsYXRlQnVmZmVyKCBieXRlT2Zmc2V0LCBub2RlICkge1xuXG5cdFx0XHRjb25zdCBzdHJpZGU0T2Zmc2V0ID0gYnl0ZU9mZnNldCAvIDQ7XG5cdFx0XHRjb25zdCBzdHJpZGUyT2Zmc2V0ID0gYnl0ZU9mZnNldCAvIDI7XG5cdFx0XHRjb25zdCBpc0xlYWYgPSAhICEgbm9kZS5jb3VudDtcblx0XHRcdGNvbnN0IGJvdW5kaW5nRGF0YSA9IG5vZGUuYm91bmRpbmdEYXRhO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIHN0cmlkZTRPZmZzZXQgKyBpIF0gPSBib3VuZGluZ0RhdGFbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSBub2RlLm9mZnNldDtcblx0XHRcdFx0Y29uc3QgY291bnQgPSBub2RlLmNvdW50O1xuXHRcdFx0XHR1aW50MzJBcnJheVsgc3RyaWRlNE9mZnNldCArIDYgXSA9IG9mZnNldDtcblx0XHRcdFx0dWludDE2QXJyYXlbIHN0cmlkZTJPZmZzZXQgKyAxNCBdID0gY291bnQ7XG5cdFx0XHRcdHVpbnQxNkFycmF5WyBzdHJpZGUyT2Zmc2V0ICsgMTUgXSA9IElTX0xFQUZOT0RFX0ZMQUc7XG5cdFx0XHRcdHJldHVybiBieXRlT2Zmc2V0ICsgQllURVNfUEVSX05PREU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgbGVmdCA9IG5vZGUubGVmdDtcblx0XHRcdFx0Y29uc3QgcmlnaHQgPSBub2RlLnJpZ2h0O1xuXHRcdFx0XHRjb25zdCBzcGxpdEF4aXMgPSBub2RlLnNwbGl0QXhpcztcblxuXHRcdFx0XHRsZXQgbmV4dFVudXNlZFBvaW50ZXI7XG5cdFx0XHRcdG5leHRVbnVzZWRQb2ludGVyID0gcG9wdWxhdGVCdWZmZXIoIGJ5dGVPZmZzZXQgKyBCWVRFU19QRVJfTk9ERSwgbGVmdCApO1xuXG5cdFx0XHRcdGlmICggKCBuZXh0VW51c2VkUG9pbnRlciAvIDQgKSA+IE1hdGgucG93KCAyLCAzMiApICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTWVzaEJWSDogQ2Fubm90IHN0b3JlIGNoaWxkIHBvaW50ZXIgZ3JlYXRlciB0aGFuIDMyIGJpdHMuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1aW50MzJBcnJheVsgc3RyaWRlNE9mZnNldCArIDYgXSA9IG5leHRVbnVzZWRQb2ludGVyIC8gNDtcblx0XHRcdFx0bmV4dFVudXNlZFBvaW50ZXIgPSBwb3B1bGF0ZUJ1ZmZlciggbmV4dFVudXNlZFBvaW50ZXIsIHJpZ2h0ICk7XG5cblx0XHRcdFx0dWludDMyQXJyYXlbIHN0cmlkZTRPZmZzZXQgKyA3IF0gPSBzcGxpdEF4aXM7XG5cdFx0XHRcdHJldHVybiBuZXh0VW51c2VkUG9pbnRlcjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBTZXBhcmF0aW5nQXhpc0JvdW5kcyB7XG5cblx0XHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdFx0dGhpcy5taW4gPSBJbmZpbml0eTtcblx0XHRcdHRoaXMubWF4ID0gLSBJbmZpbml0eTtcblxuXHRcdH1cblxuXHRcdHNldEZyb21Qb2ludHNGaWVsZCggcG9pbnRzLCBmaWVsZCApIHtcblxuXHRcdFx0bGV0IG1pbiA9IEluZmluaXR5O1xuXHRcdFx0bGV0IG1heCA9IC0gSW5maW5pdHk7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBwID0gcG9pbnRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHZhbCA9IHBbIGZpZWxkIF07XG5cdFx0XHRcdG1pbiA9IHZhbCA8IG1pbiA/IHZhbCA6IG1pbjtcblx0XHRcdFx0bWF4ID0gdmFsID4gbWF4ID8gdmFsIDogbWF4O1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWluID0gbWluO1xuXHRcdFx0dGhpcy5tYXggPSBtYXg7XG5cblx0XHR9XG5cblx0XHRzZXRGcm9tUG9pbnRzKCBheGlzLCBwb2ludHMgKSB7XG5cblx0XHRcdGxldCBtaW4gPSBJbmZpbml0eTtcblx0XHRcdGxldCBtYXggPSAtIEluZmluaXR5O1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgcCA9IHBvaW50c1sgaSBdO1xuXHRcdFx0XHRjb25zdCB2YWwgPSBheGlzLmRvdCggcCApO1xuXHRcdFx0XHRtaW4gPSB2YWwgPCBtaW4gPyB2YWwgOiBtaW47XG5cdFx0XHRcdG1heCA9IHZhbCA+IG1heCA/IHZhbCA6IG1heDtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1pbiA9IG1pbjtcblx0XHRcdHRoaXMubWF4ID0gbWF4O1xuXG5cdFx0fVxuXG5cdFx0aXNTZXBhcmF0ZWQoIG90aGVyICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5taW4gPiBvdGhlci5tYXggfHwgb3RoZXIubWluID4gdGhpcy5tYXg7XG5cblx0XHR9XG5cblx0fVxuXG5cdFNlcGFyYXRpbmdBeGlzQm91bmRzLnByb3RvdHlwZS5zZXRGcm9tQm94ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zdCBwID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbUJveCggYXhpcywgYm94ICkge1xuXG5cdFx0XHRjb25zdCBib3hNaW4gPSBib3gubWluO1xuXHRcdFx0Y29uc3QgYm94TWF4ID0gYm94Lm1heDtcblx0XHRcdGxldCBtaW4gPSBJbmZpbml0eTtcblx0XHRcdGxldCBtYXggPSAtIEluZmluaXR5O1xuXHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDw9IDE7IHggKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IHkgPSAwOyB5IDw9IDE7IHkgKysgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgeiA9IDA7IHogPD0gMTsgeiArKyApIHtcblxuXHRcdFx0XHRcdFx0cC54ID0gYm94TWluLnggKiB4ICsgYm94TWF4LnggKiAoIDEgLSB4ICk7XG5cdFx0XHRcdFx0XHRwLnkgPSBib3hNaW4ueSAqIHkgKyBib3hNYXgueSAqICggMSAtIHkgKTtcblx0XHRcdFx0XHRcdHAueiA9IGJveE1pbi56ICogeiArIGJveE1heC56ICogKCAxIC0geiApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCB2YWwgPSBheGlzLmRvdCggcCApO1xuXHRcdFx0XHRcdFx0bWluID0gTWF0aC5taW4oIHZhbCwgbWluICk7XG5cdFx0XHRcdFx0XHRtYXggPSBNYXRoLm1heCggdmFsLCBtYXggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5taW4gPSBtaW47XG5cdFx0XHR0aGlzLm1heCA9IG1heDtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0Y29uc3QgYXJlSW50ZXJzZWN0aW5nID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zdCBjYWNoZVNhdEJvdW5kcyA9IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBhcmVJbnRlcnNlY3RpbmcoIHNoYXBlMSwgc2hhcGUyICkge1xuXG5cdFx0XHRjb25zdCBwb2ludHMxID0gc2hhcGUxLnBvaW50cztcblx0XHRcdGNvbnN0IHNhdEF4ZXMxID0gc2hhcGUxLnNhdEF4ZXM7XG5cdFx0XHRjb25zdCBzYXRCb3VuZHMxID0gc2hhcGUxLnNhdEJvdW5kcztcblxuXHRcdFx0Y29uc3QgcG9pbnRzMiA9IHNoYXBlMi5wb2ludHM7XG5cdFx0XHRjb25zdCBzYXRBeGVzMiA9IHNoYXBlMi5zYXRBeGVzO1xuXHRcdFx0Y29uc3Qgc2F0Qm91bmRzMiA9IHNoYXBlMi5zYXRCb3VuZHM7XG5cblx0XHRcdC8vIGNoZWNrIGF4ZXMgb2YgdGhlIGZpcnN0IHNoYXBlXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzMVsgaSBdO1xuXHRcdFx0XHRjb25zdCBzYSA9IHNhdEF4ZXMxWyBpIF07XG5cdFx0XHRcdGNhY2hlU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIHNhLCBwb2ludHMyICk7XG5cdFx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGNhY2hlU2F0Qm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgYXhlcyBvZiB0aGUgc2Vjb25kIHNoYXBlXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzMlsgaSBdO1xuXHRcdFx0XHRjb25zdCBzYSA9IHNhdEF4ZXMyWyBpIF07XG5cdFx0XHRcdGNhY2hlU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIHNhLCBwb2ludHMxICk7XG5cdFx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGNhY2hlU2F0Qm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0Y29uc3QgY2xvc2VzdFBvaW50TGluZVRvTGluZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2p1ai9NYXRoR2VvTGliL2Jsb2IvbWFzdGVyL3NyYy9HZW9tZXRyeS9MaW5lLmNwcCNMNTZcblx0XHRjb25zdCBkaXIxID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCBkaXIyID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCB2MDIgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRMaW5lVG9MaW5lKCBsMSwgbDIsIHJlc3VsdCApIHtcblxuXHRcdFx0Y29uc3QgdjAgPSBsMS5zdGFydDtcblx0XHRcdGNvbnN0IHYxMCA9IGRpcjE7XG5cdFx0XHRjb25zdCB2MiA9IGwyLnN0YXJ0O1xuXHRcdFx0Y29uc3QgdjMyID0gZGlyMjtcblxuXHRcdFx0djAyLnN1YlZlY3RvcnMoIHYwLCB2MiApO1xuXHRcdFx0ZGlyMS5zdWJWZWN0b3JzKCBsMS5lbmQsIGwxLnN0YXJ0ICk7XG5cdFx0XHRkaXIyLnN1YlZlY3RvcnMoIGwyLmVuZCwgbDIuc3RhcnQgKTtcblxuXHRcdFx0Ly8gZmxvYXQgZDAyMzIgPSB2MDIuRG90KHYzMik7XG5cdFx0XHRjb25zdCBkMDIzMiA9IHYwMi5kb3QoIHYzMiApO1xuXG5cdFx0XHQvLyBmbG9hdCBkMzIxMCA9IHYzMi5Eb3QodjEwKTtcblx0XHRcdGNvbnN0IGQzMjEwID0gdjMyLmRvdCggdjEwICk7XG5cblx0XHRcdC8vIGZsb2F0IGQzMjMyID0gdjMyLkRvdCh2MzIpO1xuXHRcdFx0Y29uc3QgZDMyMzIgPSB2MzIuZG90KCB2MzIgKTtcblxuXHRcdFx0Ly8gZmxvYXQgZDAyMTAgPSB2MDIuRG90KHYxMCk7XG5cdFx0XHRjb25zdCBkMDIxMCA9IHYwMi5kb3QoIHYxMCApO1xuXG5cdFx0XHQvLyBmbG9hdCBkMTAxMCA9IHYxMC5Eb3QodjEwKTtcblx0XHRcdGNvbnN0IGQxMDEwID0gdjEwLmRvdCggdjEwICk7XG5cblx0XHRcdC8vIGZsb2F0IGRlbm9tID0gZDEwMTAqZDMyMzIgLSBkMzIxMCpkMzIxMDtcblx0XHRcdGNvbnN0IGRlbm9tID0gZDEwMTAgKiBkMzIzMiAtIGQzMjEwICogZDMyMTA7XG5cblx0XHRcdGxldCBkLCBkMjtcblx0XHRcdGlmICggZGVub20gIT09IDAgKSB7XG5cblx0XHRcdFx0ZCA9ICggZDAyMzIgKiBkMzIxMCAtIGQwMjEwICogZDMyMzIgKSAvIGRlbm9tO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGQgPSAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdGQyID0gKCBkMDIzMiArIGQgKiBkMzIxMCApIC8gZDMyMzI7XG5cblx0XHRcdHJlc3VsdC54ID0gZDtcblx0XHRcdHJlc3VsdC55ID0gZDI7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdGNvbnN0IGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanVqL01hdGhHZW9MaWIvYmxvYi9tYXN0ZXIvc3JjL0dlb21ldHJ5L0xpbmVTZWdtZW50LmNwcCNMMTg3XG5cdFx0Y29uc3QgcGFyYW1SZXN1bHQgPSBuZXcgdGhyZWUuVmVjdG9yMigpO1xuXHRcdGNvbnN0IHRlbXAxID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCB0ZW1wMiA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50KCBsMSwgbDIsIHRhcmdldDEsIHRhcmdldDIgKSB7XG5cblx0XHRcdGNsb3Nlc3RQb2ludExpbmVUb0xpbmUoIGwxLCBsMiwgcGFyYW1SZXN1bHQgKTtcblxuXHRcdFx0bGV0IGQgPSBwYXJhbVJlc3VsdC54O1xuXHRcdFx0bGV0IGQyID0gcGFyYW1SZXN1bHQueTtcblx0XHRcdGlmICggZCA+PSAwICYmIGQgPD0gMSAmJiBkMiA+PSAwICYmIGQyIDw9IDEgKSB7XG5cblx0XHRcdFx0bDEuYXQoIGQsIHRhcmdldDEgKTtcblx0XHRcdFx0bDIuYXQoIGQyLCB0YXJnZXQyICk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBkID49IDAgJiYgZCA8PSAxICkge1xuXG5cdFx0XHRcdC8vIE9ubHkgZDIgaXMgb3V0IG9mIGJvdW5kcy5cblx0XHRcdFx0aWYgKCBkMiA8IDAgKSB7XG5cblx0XHRcdFx0XHRsMi5hdCggMCwgdGFyZ2V0MiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRsMi5hdCggMSwgdGFyZ2V0MiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsMS5jbG9zZXN0UG9pbnRUb1BvaW50KCB0YXJnZXQyLCB0cnVlLCB0YXJnZXQxICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fSBlbHNlIGlmICggZDIgPj0gMCAmJiBkMiA8PSAxICkge1xuXG5cdFx0XHRcdC8vIE9ubHkgZCBpcyBvdXQgb2YgYm91bmRzLlxuXHRcdFx0XHRpZiAoIGQgPCAwICkge1xuXG5cdFx0XHRcdFx0bDEuYXQoIDAsIHRhcmdldDEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bDEuYXQoIDEsIHRhcmdldDEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bDIuY2xvc2VzdFBvaW50VG9Qb2ludCggdGFyZ2V0MSwgdHJ1ZSwgdGFyZ2V0MiApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gQm90aCB1IGFuZCB1MiBhcmUgb3V0IG9mIGJvdW5kcy5cblx0XHRcdFx0bGV0IHA7XG5cdFx0XHRcdGlmICggZCA8IDAgKSB7XG5cblx0XHRcdFx0XHRwID0gbDEuc3RhcnQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHAgPSBsMS5lbmQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBwMjtcblx0XHRcdFx0aWYgKCBkMiA8IDAgKSB7XG5cblx0XHRcdFx0XHRwMiA9IGwyLnN0YXJ0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwMiA9IGwyLmVuZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgY2xvc2VzdFBvaW50ID0gdGVtcDE7XG5cdFx0XHRcdGNvbnN0IGNsb3Nlc3RQb2ludDIgPSB0ZW1wMjtcblx0XHRcdFx0bDEuY2xvc2VzdFBvaW50VG9Qb2ludCggcDIsIHRydWUsIHRlbXAxICk7XG5cdFx0XHRcdGwyLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHAsIHRydWUsIHRlbXAyICk7XG5cblx0XHRcdFx0aWYgKCBjbG9zZXN0UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICkgPD0gY2xvc2VzdFBvaW50Mi5kaXN0YW5jZVRvU3F1YXJlZCggcCApICkge1xuXG5cdFx0XHRcdFx0dGFyZ2V0MS5jb3B5KCBjbG9zZXN0UG9pbnQgKTtcblx0XHRcdFx0XHR0YXJnZXQyLmNvcHkoIHAyICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0YXJnZXQxLmNvcHkoIHAgKTtcblx0XHRcdFx0XHR0YXJnZXQyLmNvcHkoIGNsb3Nlc3RQb2ludDIgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cblx0Y29uc3Qgc3BoZXJlSW50ZXJzZWN0VHJpYW5nbGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM0MDQzOTU1L2RldGVjdC1jb2xsaXNpb24tYmV0d2Vlbi1zcGhlcmUtYW5kLXRyaWFuZ2xlLWluLXRocmVlLWpzXG5cdFx0Y29uc3QgY2xvc2VzdFBvaW50VGVtcCA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdFx0Y29uc3QgcHJvamVjdGVkUG9pbnRUZW1wID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCBwbGFuZVRlbXAgPSBuZXcgdGhyZWUuUGxhbmUoKTtcblx0XHRjb25zdCBsaW5lVGVtcCA9IG5ldyB0aHJlZS5MaW5lMygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBzcGhlcmVJbnRlcnNlY3RUcmlhbmdsZSggc3BoZXJlLCB0cmlhbmdsZSApIHtcblxuXHRcdFx0Y29uc3QgeyByYWRpdXMsIGNlbnRlciB9ID0gc3BoZXJlO1xuXHRcdFx0Y29uc3QgeyBhLCBiLCBjIH0gPSB0cmlhbmdsZTtcblxuXHRcdFx0Ly8gcGhhc2UgMVxuXHRcdFx0bGluZVRlbXAuc3RhcnQgPSBhO1xuXHRcdFx0bGluZVRlbXAuZW5kID0gYjtcblx0XHRcdGNvbnN0IGNsb3Nlc3RQb2ludDEgPSBsaW5lVGVtcC5jbG9zZXN0UG9pbnRUb1BvaW50KCBjZW50ZXIsIHRydWUsIGNsb3Nlc3RQb2ludFRlbXAgKTtcblx0XHRcdGlmICggY2xvc2VzdFBvaW50MS5kaXN0YW5jZVRvKCBjZW50ZXIgKSA8PSByYWRpdXMgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0bGluZVRlbXAuc3RhcnQgPSBhO1xuXHRcdFx0bGluZVRlbXAuZW5kID0gYztcblx0XHRcdGNvbnN0IGNsb3Nlc3RQb2ludDIgPSBsaW5lVGVtcC5jbG9zZXN0UG9pbnRUb1BvaW50KCBjZW50ZXIsIHRydWUsIGNsb3Nlc3RQb2ludFRlbXAgKTtcblx0XHRcdGlmICggY2xvc2VzdFBvaW50Mi5kaXN0YW5jZVRvKCBjZW50ZXIgKSA8PSByYWRpdXMgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0bGluZVRlbXAuc3RhcnQgPSBiO1xuXHRcdFx0bGluZVRlbXAuZW5kID0gYztcblx0XHRcdGNvbnN0IGNsb3Nlc3RQb2ludDMgPSBsaW5lVGVtcC5jbG9zZXN0UG9pbnRUb1BvaW50KCBjZW50ZXIsIHRydWUsIGNsb3Nlc3RQb2ludFRlbXAgKTtcblx0XHRcdGlmICggY2xvc2VzdFBvaW50My5kaXN0YW5jZVRvKCBjZW50ZXIgKSA8PSByYWRpdXMgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0Ly8gcGhhc2UgMlxuXHRcdFx0Y29uc3QgcGxhbmUgPSB0cmlhbmdsZS5nZXRQbGFuZSggcGxhbmVUZW1wICk7XG5cdFx0XHRjb25zdCBkcCA9IE1hdGguYWJzKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApICk7XG5cdFx0XHRpZiAoIGRwIDw9IHJhZGl1cyApIHtcblxuXHRcdFx0XHRjb25zdCBwcCA9IHBsYW5lLnByb2plY3RQb2ludCggY2VudGVyLCBwcm9qZWN0ZWRQb2ludFRlbXAgKTtcblx0XHRcdFx0Y29uc3QgY3AgPSB0cmlhbmdsZS5jb250YWluc1BvaW50KCBwcCApO1xuXHRcdFx0XHRpZiAoIGNwICkgcmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRjb25zdCBESVNUX0VQU0lMT04gPSAxZS0xNTtcblx0ZnVuY3Rpb24gaXNOZWFyWmVybyggdmFsdWUgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHZhbHVlICkgPCBESVNUX0VQU0lMT047XG5cblx0fVxuXG5cdGNsYXNzIEV4dGVuZGVkVHJpYW5nbGUgZXh0ZW5kcyB0aHJlZS5UcmlhbmdsZSB7XG5cblx0XHRjb25zdHJ1Y3RvciggLi4uYXJncyApIHtcblxuXHRcdFx0c3VwZXIoIC4uLmFyZ3MgKTtcblxuXHRcdFx0dGhpcy5pc0V4dGVuZGVkVHJpYW5nbGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5zYXRBeGVzID0gbmV3IEFycmF5KCA0ICkuZmlsbCgpLm1hcCggKCkgPT4gbmV3IHRocmVlLlZlY3RvcjMoKSApO1xuXHRcdFx0dGhpcy5zYXRCb3VuZHMgPSBuZXcgQXJyYXkoIDQgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKSApO1xuXHRcdFx0dGhpcy5wb2ludHMgPSBbIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgXTtcblx0XHRcdHRoaXMuc3BoZXJlID0gbmV3IHRocmVlLlNwaGVyZSgpO1xuXHRcdFx0dGhpcy5wbGFuZSA9IG5ldyB0aHJlZS5QbGFuZSgpO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHRcdHJldHVybiBzcGhlcmVJbnRlcnNlY3RUcmlhbmdsZSggc3BoZXJlLCB0aGlzICk7XG5cblx0XHR9XG5cblx0XHR1cGRhdGUoKSB7XG5cblx0XHRcdGNvbnN0IGEgPSB0aGlzLmE7XG5cdFx0XHRjb25zdCBiID0gdGhpcy5iO1xuXHRcdFx0Y29uc3QgYyA9IHRoaXMuYztcblx0XHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXG5cdFx0XHRjb25zdCBzYXRBeGVzID0gdGhpcy5zYXRBeGVzO1xuXHRcdFx0Y29uc3Qgc2F0Qm91bmRzID0gdGhpcy5zYXRCb3VuZHM7XG5cblx0XHRcdGNvbnN0IGF4aXMwID0gc2F0QXhlc1sgMCBdO1xuXHRcdFx0Y29uc3Qgc2FiMCA9IHNhdEJvdW5kc1sgMCBdO1xuXHRcdFx0dGhpcy5nZXROb3JtYWwoIGF4aXMwICk7XG5cdFx0XHRzYWIwLnNldEZyb21Qb2ludHMoIGF4aXMwLCBwb2ludHMgKTtcblxuXHRcdFx0Y29uc3QgYXhpczEgPSBzYXRBeGVzWyAxIF07XG5cdFx0XHRjb25zdCBzYWIxID0gc2F0Qm91bmRzWyAxIF07XG5cdFx0XHRheGlzMS5zdWJWZWN0b3JzKCBhLCBiICk7XG5cdFx0XHRzYWIxLnNldEZyb21Qb2ludHMoIGF4aXMxLCBwb2ludHMgKTtcblxuXHRcdFx0Y29uc3QgYXhpczIgPSBzYXRBeGVzWyAyIF07XG5cdFx0XHRjb25zdCBzYWIyID0gc2F0Qm91bmRzWyAyIF07XG5cdFx0XHRheGlzMi5zdWJWZWN0b3JzKCBiLCBjICk7XG5cdFx0XHRzYWIyLnNldEZyb21Qb2ludHMoIGF4aXMyLCBwb2ludHMgKTtcblxuXHRcdFx0Y29uc3QgYXhpczMgPSBzYXRBeGVzWyAzIF07XG5cdFx0XHRjb25zdCBzYWIzID0gc2F0Qm91bmRzWyAzIF07XG5cdFx0XHRheGlzMy5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0XHRzYWIzLnNldEZyb21Qb2ludHMoIGF4aXMzLCBwb2ludHMgKTtcblxuXHRcdFx0dGhpcy5zcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy5wb2ludHMgKTtcblx0XHRcdHRoaXMucGxhbmUuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIGF4aXMwLCBhICk7XG5cdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHR9XG5cblx0fVxuXG5cdEV4dGVuZGVkVHJpYW5nbGUucHJvdG90eXBlLmNsb3Nlc3RQb2ludFRvU2VnbWVudCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc3QgcG9pbnQxID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCBwb2ludDIgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IGVkZ2UgPSBuZXcgdGhyZWUuTGluZTMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvU2VnbWVudCggc2VnbWVudCwgdGFyZ2V0MSA9IG51bGwsIHRhcmdldDIgPSBudWxsICkge1xuXG5cdFx0XHRjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHNlZ21lbnQ7XG5cdFx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRcdGxldCBkaXN0U3E7XG5cdFx0XHRsZXQgY2xvc2VzdERpc3RhbmNlU3EgPSBJbmZpbml0eTtcblxuXHRcdFx0Ly8gY2hlY2sgdGhlIHRyaWFuZ2xlIGVkZ2VzXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IG5leHRpID0gKCBpICsgMSApICUgMztcblx0XHRcdFx0ZWRnZS5zdGFydC5jb3B5KCBwb2ludHNbIGkgXSApO1xuXHRcdFx0XHRlZGdlLmVuZC5jb3B5KCBwb2ludHNbIG5leHRpIF0gKTtcblxuXHRcdFx0XHRjbG9zZXN0UG9pbnRzU2VnbWVudFRvU2VnbWVudCggZWRnZSwgc2VnbWVudCwgcG9pbnQxLCBwb2ludDIgKTtcblxuXHRcdFx0XHRkaXN0U3EgPSBwb2ludDEuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MiApO1xuXHRcdFx0XHRpZiAoIGRpc3RTcSA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0U3E7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwb2ludDEgKTtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBlbmQgcG9pbnRzXG5cdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHN0YXJ0LCBwb2ludDEgKTtcblx0XHRcdGRpc3RTcSA9IHN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludDEgKTtcblx0XHRcdGlmICggZGlzdFNxIDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0U3E7XG5cdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggc3RhcnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIGVuZCwgcG9pbnQxICk7XG5cdFx0XHRkaXN0U3EgPSBlbmQuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MSApO1xuXHRcdFx0aWYgKCBkaXN0U3EgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3RTcTtcblx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwb2ludDEgKTtcblx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBlbmQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBjbG9zZXN0RGlzdGFuY2VTcSApO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRFeHRlbmRlZFRyaWFuZ2xlLnByb3RvdHlwZS5pbnRlcnNlY3RzVHJpYW5nbGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHNhVHJpMiA9IG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCk7XG5cdFx0Y29uc3QgYXJyMSA9IG5ldyBBcnJheSggMyApO1xuXHRcdGNvbnN0IGFycjIgPSBuZXcgQXJyYXkoIDMgKTtcblx0XHRjb25zdCBjYWNoZWRTYXRCb3VuZHMgPSBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKTtcblx0XHRjb25zdCBjYWNoZWRTYXRCb3VuZHMyID0gbmV3IFNlcGFyYXRpbmdBeGlzQm91bmRzKCk7XG5cdFx0Y29uc3QgY2FjaGVkQXhpcyA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdFx0Y29uc3QgZGlyMSA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdFx0Y29uc3QgZGlyMiA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdFx0Y29uc3QgdGVtcERpciA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdFx0Y29uc3QgZWRnZSA9IG5ldyB0aHJlZS5MaW5lMygpO1xuXHRcdGNvbnN0IGVkZ2UxID0gbmV3IHRocmVlLkxpbmUzKCk7XG5cdFx0Y29uc3QgZWRnZTIgPSBuZXcgdGhyZWUuTGluZTMoKTtcblxuXHRcdC8vIFRPRE86IElmIHRoZSB0cmlhbmdsZXMgYXJlIGNvcGxhbmFyIGFuZCBpbnRlcnNlY3RpbmcgdGhlIHRhcmdldCBpcyBub25zZW5zaWNhbC4gSXQgc2hvdWxkIGF0IGxlYXN0XG5cdFx0Ly8gYmUgYSBsaW5lIGNvbnRhaW5lZCBieSBib3RoIHRyaWFuZ2xlcyBpZiBub3QgYSBkaWZmZXJlbnQgc3BlY2lhbCBjYXNlIHNvbWVob3cgcmVwcmVzZW50ZWQgaW4gdGhlIHJldHVybiByZXN1bHQuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNUcmlhbmdsZSggb3RoZXIsIHRhcmdldCA9IG51bGwsIHN1cHByZXNzTG9nID0gZmFsc2UgKSB7XG5cblx0XHRcdGlmICggdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISBvdGhlci5pc0V4dGVuZGVkVHJpYW5nbGUgKSB7XG5cblx0XHRcdFx0c2FUcmkyLmNvcHkoIG90aGVyICk7XG5cdFx0XHRcdHNhVHJpMi51cGRhdGUoKTtcblx0XHRcdFx0b3RoZXIgPSBzYVRyaTI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG90aGVyLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdG90aGVyLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHBsYW5lMSA9IHRoaXMucGxhbmU7XG5cdFx0XHRjb25zdCBwbGFuZTIgPSBvdGhlci5wbGFuZTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggcGxhbmUxLm5vcm1hbC5kb3QoIHBsYW5lMi5ub3JtYWwgKSApID4gMS4wIC0gMWUtMTAgKSB7XG5cblx0XHRcdFx0Ly8gcGVyZm9ybSBzZXBhcmF0aW5nIGF4aXMgaW50ZXJzZWN0aW9uIHRlc3Qgb25seSBmb3IgY29wbGFuYXIgdHJpYW5nbGVzXG5cdFx0XHRcdGNvbnN0IHNhdEJvdW5kczEgPSB0aGlzLnNhdEJvdW5kcztcblx0XHRcdFx0Y29uc3Qgc2F0QXhlczEgPSB0aGlzLnNhdEF4ZXM7XG5cdFx0XHRcdGFycjJbIDAgXSA9IG90aGVyLmE7XG5cdFx0XHRcdGFycjJbIDEgXSA9IG90aGVyLmI7XG5cdFx0XHRcdGFycjJbIDIgXSA9IG90aGVyLmM7XG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBzYiA9IHNhdEJvdW5kczFbIGkgXTtcblx0XHRcdFx0XHRjb25zdCBzYSA9IHNhdEF4ZXMxWyBpIF07XG5cdFx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIHNhLCBhcnIyICk7XG5cdFx0XHRcdFx0aWYgKCBzYi5pc1NlcGFyYXRlZCggY2FjaGVkU2F0Qm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHNhdEJvdW5kczIgPSBvdGhlci5zYXRCb3VuZHM7XG5cdFx0XHRcdGNvbnN0IHNhdEF4ZXMyID0gb3RoZXIuc2F0QXhlcztcblx0XHRcdFx0YXJyMVsgMCBdID0gdGhpcy5hO1xuXHRcdFx0XHRhcnIxWyAxIF0gPSB0aGlzLmI7XG5cdFx0XHRcdGFycjFbIDIgXSA9IHRoaXMuYztcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzMlsgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IHNhID0gc2F0QXhlczJbIGkgXTtcblx0XHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIGFycjEgKTtcblx0XHRcdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY2hlY2sgY3Jvc3NlZCBheGVzXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBzYTEgPSBzYXRBeGVzMVsgaSBdO1xuXHRcdFx0XHRcdGZvciAoIGxldCBpMiA9IDA7IGkyIDwgNDsgaTIgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHNhMiA9IHNhdEF4ZXMyWyBpMiBdO1xuXHRcdFx0XHRcdFx0Y2FjaGVkQXhpcy5jcm9zc1ZlY3RvcnMoIHNhMSwgc2EyICk7XG5cdFx0XHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggY2FjaGVkQXhpcywgYXJyMSApO1xuXHRcdFx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzMi5zZXRGcm9tUG9pbnRzKCBjYWNoZWRBeGlzLCBhcnIyICk7XG5cdFx0XHRcdFx0XHRpZiAoIGNhY2hlZFNhdEJvdW5kcy5pc1NlcGFyYXRlZCggY2FjaGVkU2F0Qm91bmRzMiApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRhcmdldCApIHtcblxuXHRcdFx0XHRcdC8vIFRPRE8gZmluZCB0d28gcG9pbnRzIHRoYXQgaW50ZXJzZWN0IG9uIHRoZSBlZGdlcyBhbmQgbWFrZSB0aGF0IHRoZSByZXN1bHRcblx0XHRcdFx0XHRpZiAoICEgc3VwcHJlc3NMb2cgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ0V4dGVuZGVkVHJpYW5nbGUuaW50ZXJzZWN0c1RyaWFuZ2xlOiBUcmlhbmdsZXMgYXJlIGNvcGxhbmFyIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgYW4gb3V0cHV0IGVkZ2UuIFNldHRpbmcgZWRnZSB0byAwLCAwLCAwLicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRhcmdldC5zdGFydC5zZXQoIDAsIDAsIDAgKTtcblx0XHRcdFx0XHR0YXJnZXQuZW5kLnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBmaW5kIHRoZSBlZGdlIHRoYXQgaW50ZXJzZWN0cyB0aGUgb3RoZXIgdHJpYW5nbGUgcGxhbmVcblx0XHRcdFx0Y29uc3QgcG9pbnRzMSA9IHRoaXMucG9pbnRzO1xuXHRcdFx0XHRsZXQgZm91bmQxID0gZmFsc2U7XG5cdFx0XHRcdGxldCBjb3VudDEgPSAwO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgcCA9IHBvaW50czFbIGkgXTtcblx0XHRcdFx0XHRjb25zdCBwTmV4dCA9IHBvaW50czFbICggaSArIDEgKSAlIDMgXTtcblxuXHRcdFx0XHRcdGVkZ2Uuc3RhcnQuY29weSggcCApO1xuXHRcdFx0XHRcdGVkZ2UuZW5kLmNvcHkoIHBOZXh0ICk7XG5cdFx0XHRcdFx0ZWRnZS5kZWx0YSggZGlyMSApO1xuXG5cdFx0XHRcdFx0Y29uc3QgdGFyZ2V0UG9pbnQgPSBmb3VuZDEgPyBlZGdlMS5zdGFydCA6IGVkZ2UxLmVuZDtcblx0XHRcdFx0XHRjb25zdCBzdGFydEludGVyc2VjdHMgPSBpc05lYXJaZXJvKCBwbGFuZTIuZGlzdGFuY2VUb1BvaW50KCBwICkgKTtcblx0XHRcdFx0XHRpZiAoIGlzTmVhclplcm8oIHBsYW5lMi5ub3JtYWwuZG90KCBkaXIxICkgKSAmJiBzdGFydEludGVyc2VjdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBlZGdlIGxpZXMgb24gdGhlIHBsYW5lIHRoZW4gdGFrZSB0aGUgbGluZVxuXHRcdFx0XHRcdFx0ZWRnZTEuY29weSggZWRnZSApO1xuXHRcdFx0XHRcdFx0Y291bnQxID0gMjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHN0YXJ0IHBvaW50IGlzIG5lYXIgdGhlIHBsYW5lIGJlY2F1c2UgXCJpbnRlcnNlY3RMaW5lXCIgaXMgbm90IHJvYnVzdCB0byB0aGF0IGNhc2Vcblx0XHRcdFx0XHRjb25zdCBkb2VzSW50ZXJzZWN0ID0gcGxhbmUyLmludGVyc2VjdExpbmUoIGVkZ2UsIHRhcmdldFBvaW50ICkgfHwgc3RhcnRJbnRlcnNlY3RzO1xuXHRcdFx0XHRcdGlmICggZG9lc0ludGVyc2VjdCAmJiAhIGlzTmVhclplcm8oIHRhcmdldFBvaW50LmRpc3RhbmNlVG8oIHBOZXh0ICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Y291bnQxICsrO1xuXHRcdFx0XHRcdFx0aWYgKCBmb3VuZDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Zm91bmQxID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjb3VudDEgPT09IDEgJiYgb3RoZXIuY29udGFpbnNQb2ludCggZWRnZTEuZW5kICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHRhcmdldCApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0LmNvcHkoIGVkZ2UxLmVuZCApO1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmVuZC5jb3B5KCBlZGdlMS5lbmQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvdW50MSAhPT0gMiApIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZmluZCB0aGUgb3RoZXIgdHJpYW5nbGVzIGVkZ2UgdGhhdCBpbnRlcnNlY3RzIHRoaXMgcGxhbmVcblx0XHRcdFx0Y29uc3QgcG9pbnRzMiA9IG90aGVyLnBvaW50cztcblx0XHRcdFx0bGV0IGZvdW5kMiA9IGZhbHNlO1xuXHRcdFx0XHRsZXQgY291bnQyID0gMDtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHAgPSBwb2ludHMyWyBpIF07XG5cdFx0XHRcdFx0Y29uc3QgcE5leHQgPSBwb2ludHMyWyAoIGkgKyAxICkgJSAzIF07XG5cblx0XHRcdFx0XHRlZGdlLnN0YXJ0LmNvcHkoIHAgKTtcblx0XHRcdFx0XHRlZGdlLmVuZC5jb3B5KCBwTmV4dCApO1xuXHRcdFx0XHRcdGVkZ2UuZGVsdGEoIGRpcjIgKTtcblxuXHRcdFx0XHRcdGNvbnN0IHRhcmdldFBvaW50ID0gZm91bmQyID8gZWRnZTIuc3RhcnQgOiBlZGdlMi5lbmQ7XG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnRJbnRlcnNlY3RzID0gaXNOZWFyWmVybyggcGxhbmUxLmRpc3RhbmNlVG9Qb2ludCggcCApICk7XG5cdFx0XHRcdFx0aWYgKCBpc05lYXJaZXJvKCBwbGFuZTEubm9ybWFsLmRvdCggZGlyMiApICkgJiYgc3RhcnRJbnRlcnNlY3RzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgZWRnZSBsaWVzIG9uIHRoZSBwbGFuZSB0aGVuIHRha2UgdGhlIGxpbmVcblx0XHRcdFx0XHRcdGVkZ2UyLmNvcHkoIGVkZ2UgKTtcblx0XHRcdFx0XHRcdGNvdW50MiA9IDI7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIHRoZSBzdGFydCBwb2ludCBpcyBuZWFyIHRoZSBwbGFuZSBiZWNhdXNlIFwiaW50ZXJzZWN0TGluZVwiIGlzIG5vdCByb2J1c3QgdG8gdGhhdCBjYXNlXG5cdFx0XHRcdFx0Y29uc3QgZG9lc0ludGVyc2VjdCA9IHBsYW5lMS5pbnRlcnNlY3RMaW5lKCBlZGdlLCB0YXJnZXRQb2ludCApIHx8IHN0YXJ0SW50ZXJzZWN0cztcblx0XHRcdFx0XHRpZiAoIGRvZXNJbnRlcnNlY3QgJiYgISBpc05lYXJaZXJvKCB0YXJnZXRQb2ludC5kaXN0YW5jZVRvKCBwTmV4dCApICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvdW50MiArKztcblx0XHRcdFx0XHRcdGlmICggZm91bmQyICkge1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZvdW5kMiA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY291bnQyID09PSAxICYmIHRoaXMuY29udGFpbnNQb2ludCggZWRnZTIuZW5kICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHRhcmdldCApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0LmNvcHkoIGVkZ2UyLmVuZCApO1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmVuZC5jb3B5KCBlZGdlMi5lbmQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvdW50MiAhPT0gMiApIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZmluZCBzd2FwIHRoZSBzZWNvbmQgZWRnZSBzbyBib3RoIGxpbmVzIGFyZSBydW5uaW5nIHRoZSBzYW1lIGRpcmVjdGlvblxuXHRcdFx0XHRlZGdlMS5kZWx0YSggZGlyMSApO1xuXHRcdFx0XHRlZGdlMi5kZWx0YSggZGlyMiApO1xuXG5cdFx0XHRcdGlmICggZGlyMS5kb3QoIGRpcjIgKSA8IDAgKSB7XG5cblx0XHRcdFx0XHRsZXQgdG1wID0gZWRnZTIuc3RhcnQ7XG5cdFx0XHRcdFx0ZWRnZTIuc3RhcnQgPSBlZGdlMi5lbmQ7XG5cdFx0XHRcdFx0ZWRnZTIuZW5kID0gdG1wO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgZWRnZXMgYXJlIG92ZXJsYXBwaW5nXG5cdFx0XHRcdGNvbnN0IHMxID0gZWRnZTEuc3RhcnQuZG90KCBkaXIxICk7XG5cdFx0XHRcdGNvbnN0IGUxID0gZWRnZTEuZW5kLmRvdCggZGlyMSApO1xuXHRcdFx0XHRjb25zdCBzMiA9IGVkZ2UyLnN0YXJ0LmRvdCggZGlyMSApO1xuXHRcdFx0XHRjb25zdCBlMiA9IGVkZ2UyLmVuZC5kb3QoIGRpcjEgKTtcblx0XHRcdFx0Y29uc3Qgc2VwYXJhdGVkMSA9IGUxIDwgczI7XG5cdFx0XHRcdGNvbnN0IHNlcGFyYXRlZDIgPSBzMSA8IGUyO1xuXG5cdFx0XHRcdGlmICggczEgIT09IGUyICYmIHMyICE9PSBlMSAmJiBzZXBhcmF0ZWQxID09PSBzZXBhcmF0ZWQyICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhc3NpZ24gdGhlIHRhcmdldCBvdXRwdXRcblx0XHRcdFx0aWYgKCB0YXJnZXQgKSB7XG5cblx0XHRcdFx0XHR0ZW1wRGlyLnN1YlZlY3RvcnMoIGVkZ2UxLnN0YXJ0LCBlZGdlMi5zdGFydCApO1xuXHRcdFx0XHRcdGlmICggdGVtcERpci5kb3QoIGRpcjEgKSA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdHRhcmdldC5zdGFydC5jb3B5KCBlZGdlMS5zdGFydCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0LmNvcHkoIGVkZ2UyLnN0YXJ0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZW1wRGlyLnN1YlZlY3RvcnMoIGVkZ2UxLmVuZCwgZWRnZTIuZW5kICk7XG5cdFx0XHRcdFx0aWYgKCB0ZW1wRGlyLmRvdCggZGlyMSApIDwgMCApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0LmVuZC5jb3B5KCBlZGdlMS5lbmQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRhcmdldC5lbmQuY29weSggZWRnZTIuZW5kICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cblx0RXh0ZW5kZWRUcmlhbmdsZS5wcm90b3R5cGUuZGlzdGFuY2VUb1BvaW50ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zdCB0YXJnZXQgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCB0YXJnZXQgKTtcblx0XHRcdHJldHVybiBwb2ludC5kaXN0YW5jZVRvKCB0YXJnZXQgKTtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblxuXHRFeHRlbmRlZFRyaWFuZ2xlLnByb3RvdHlwZS5kaXN0YW5jZVRvVHJpYW5nbGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCBwb2ludDIgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IGNvcm5lckZpZWxkcyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXHRcdGNvbnN0IGxpbmUxID0gbmV3IHRocmVlLkxpbmUzKCk7XG5cdFx0Y29uc3QgbGluZTIgPSBuZXcgdGhyZWUuTGluZTMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvVHJpYW5nbGUoIG90aGVyLCB0YXJnZXQxID0gbnVsbCwgdGFyZ2V0MiA9IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IGxpbmVUYXJnZXQgPSB0YXJnZXQxIHx8IHRhcmdldDIgPyBsaW5lMSA6IG51bGw7XG5cdFx0XHRpZiAoIHRoaXMuaW50ZXJzZWN0c1RyaWFuZ2xlKCBvdGhlciwgbGluZVRhcmdldCApICkge1xuXG5cdFx0XHRcdGlmICggdGFyZ2V0MSB8fCB0YXJnZXQyICkge1xuXG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQxICkgbGluZVRhcmdldC5nZXRDZW50ZXIoIHRhcmdldDEgKTtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSBsaW5lVGFyZ2V0LmdldENlbnRlciggdGFyZ2V0MiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgY2xvc2VzdERpc3RhbmNlU3EgPSBJbmZpbml0eTtcblxuXHRcdFx0Ly8gY2hlY2sgYWxsIHBvaW50IGRpc3RhbmNlc1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRsZXQgZGlzdDtcblx0XHRcdFx0Y29uc3QgZmllbGQgPSBjb3JuZXJGaWVsZHNbIGkgXTtcblx0XHRcdFx0Y29uc3Qgb3RoZXJWZWMgPSBvdGhlclsgZmllbGQgXTtcblx0XHRcdFx0dGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KCBvdGhlclZlYywgcG9pbnQgKTtcblxuXHRcdFx0XHRkaXN0ID0gb3RoZXJWZWMuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwb2ludCApO1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggb3RoZXJWZWMgKTtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRjb25zdCB0aGlzVmVjID0gdGhpc1sgZmllbGQgXTtcblx0XHRcdFx0b3RoZXIuY2xvc2VzdFBvaW50VG9Qb2ludCggdGhpc1ZlYywgcG9pbnQgKTtcblxuXHRcdFx0XHRkaXN0ID0gdGhpc1ZlYy5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdDtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHRoaXNWZWMgKTtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgZjExID0gY29ybmVyRmllbGRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGYxMiA9IGNvcm5lckZpZWxkc1sgKCBpICsgMSApICUgMyBdO1xuXHRcdFx0XHRsaW5lMS5zZXQoIHRoaXNbIGYxMSBdLCB0aGlzWyBmMTIgXSApO1xuXHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwOyBpMiA8IDM7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZjIxID0gY29ybmVyRmllbGRzWyBpMiBdO1xuXHRcdFx0XHRcdGNvbnN0IGYyMiA9IGNvcm5lckZpZWxkc1sgKCBpMiArIDEgKSAlIDMgXTtcblx0XHRcdFx0XHRsaW5lMi5zZXQoIG90aGVyWyBmMjEgXSwgb3RoZXJbIGYyMiBdICk7XG5cblx0XHRcdFx0XHRjbG9zZXN0UG9pbnRzU2VnbWVudFRvU2VnbWVudCggbGluZTEsIGxpbmUyLCBwb2ludCwgcG9pbnQyICk7XG5cblx0XHRcdFx0XHRjb25zdCBkaXN0ID0gcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MiApO1xuXHRcdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50ICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBjbG9zZXN0RGlzdGFuY2VTcSApO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRjbGFzcyBPcmllbnRlZEJveCB7XG5cblx0XHRjb25zdHJ1Y3RvciggbWluLCBtYXgsIG1hdHJpeCApIHtcblxuXHRcdFx0dGhpcy5pc09yaWVudGVkQm94ID0gdHJ1ZTtcblx0XHRcdHRoaXMubWluID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRcdHRoaXMubWF4ID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRcdHRoaXMubWF0cml4ID0gbmV3IHRocmVlLk1hdHJpeDQoKTtcblx0XHRcdHRoaXMuaW52TWF0cml4ID0gbmV3IHRocmVlLk1hdHJpeDQoKTtcblx0XHRcdHRoaXMucG9pbnRzID0gbmV3IEFycmF5KCA4ICkuZmlsbCgpLm1hcCggKCkgPT4gbmV3IHRocmVlLlZlY3RvcjMoKSApO1xuXHRcdFx0dGhpcy5zYXRBeGVzID0gbmV3IEFycmF5KCAzICkuZmlsbCgpLm1hcCggKCkgPT4gbmV3IHRocmVlLlZlY3RvcjMoKSApO1xuXHRcdFx0dGhpcy5zYXRCb3VuZHMgPSBuZXcgQXJyYXkoIDMgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKSApO1xuXHRcdFx0dGhpcy5hbGlnbmVkU2F0Qm91bmRzID0gbmV3IEFycmF5KCAzICkuZmlsbCgpLm1hcCggKCkgPT4gbmV3IFNlcGFyYXRpbmdBeGlzQm91bmRzKCkgKTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBtaW4gKSB0aGlzLm1pbi5jb3B5KCBtaW4gKTtcblx0XHRcdGlmICggbWF4ICkgdGhpcy5tYXguY29weSggbWF4ICk7XG5cdFx0XHRpZiAoIG1hdHJpeCApIHRoaXMubWF0cml4LmNvcHkoIG1hdHJpeCApO1xuXG5cdFx0fVxuXG5cdFx0c2V0KCBtaW4sIG1heCwgbWF0cml4ICkge1xuXG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcblx0XHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xuXHRcdFx0dGhpcy5tYXRyaXguY29weSggbWF0cml4ICk7XG5cdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGNvcHkoIG90aGVyICkge1xuXG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBvdGhlci5taW4gKTtcblx0XHRcdHRoaXMubWF4LmNvcHkoIG90aGVyLm1heCApO1xuXHRcdFx0dGhpcy5tYXRyaXguY29weSggb3RoZXIubWF0cml4ICk7XG5cdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0T3JpZW50ZWRCb3gucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdFx0Y29uc3QgbWF0cml4ID0gdGhpcy5tYXRyaXg7XG5cdFx0XHRjb25zdCBtaW4gPSB0aGlzLm1pbjtcblx0XHRcdGNvbnN0IG1heCA9IHRoaXMubWF4O1xuXG5cdFx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRcdGZvciAoIGxldCB4ID0gMDsgeCA8PSAxOyB4ICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8PSAxOyB5ICsrICkge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IHogPSAwOyB6IDw9IDE7IHogKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGkgPSAoICggMSA8PCAwICkgKiB4ICkgfCAoICggMSA8PCAxICkgKiB5ICkgfCAoICggMSA8PCAyICkgKiB6ICk7XG5cdFx0XHRcdFx0XHRjb25zdCB2ID0gcG9pbnRzWyBpIF07XG5cdFx0XHRcdFx0XHR2LnggPSB4ID8gbWF4LnggOiBtaW4ueDtcblx0XHRcdFx0XHRcdHYueSA9IHkgPyBtYXgueSA6IG1pbi55O1xuXHRcdFx0XHRcdFx0di56ID0geiA/IG1heC56IDogbWluLno7XG5cblx0XHRcdFx0XHRcdHYuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2F0Qm91bmRzID0gdGhpcy5zYXRCb3VuZHM7XG5cdFx0XHRjb25zdCBzYXRBeGVzID0gdGhpcy5zYXRBeGVzO1xuXHRcdFx0Y29uc3QgbWluVmVjID0gcG9pbnRzWyAwIF07XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGF4aXMgPSBzYXRBeGVzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gMSA8PCBpO1xuXHRcdFx0XHRjb25zdCBwaSA9IHBvaW50c1sgaW5kZXggXTtcblxuXHRcdFx0XHRheGlzLnN1YlZlY3RvcnMoIG1pblZlYywgcGkgKTtcblx0XHRcdFx0c2Iuc2V0RnJvbVBvaW50cyggYXhpcywgcG9pbnRzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYWxpZ25lZFNhdEJvdW5kcyA9IHRoaXMuYWxpZ25lZFNhdEJvdW5kcztcblx0XHRcdGFsaWduZWRTYXRCb3VuZHNbIDAgXS5zZXRGcm9tUG9pbnRzRmllbGQoIHBvaW50cywgJ3gnICk7XG5cdFx0XHRhbGlnbmVkU2F0Qm91bmRzWyAxIF0uc2V0RnJvbVBvaW50c0ZpZWxkKCBwb2ludHMsICd5JyApO1xuXHRcdFx0YWxpZ25lZFNhdEJvdW5kc1sgMiBdLnNldEZyb21Qb2ludHNGaWVsZCggcG9pbnRzLCAneicgKTtcblxuXHRcdFx0dGhpcy5pbnZNYXRyaXguY29weSggdGhpcy5tYXRyaXggKS5pbnZlcnQoKTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0T3JpZW50ZWRCb3gucHJvdG90eXBlLmludGVyc2VjdHNCb3ggPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IGFhYmJCb3VuZHMgPSBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c0JveCggYm94ICkge1xuXG5cdFx0XHQvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBkb2luZyBTQVQgYWdhaW5zdCB0aGUgQUFCQj9cblx0XHRcdGlmICggdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG1pbiA9IGJveC5taW47XG5cdFx0XHRjb25zdCBtYXggPSBib3gubWF4O1xuXHRcdFx0Y29uc3Qgc2F0Qm91bmRzID0gdGhpcy5zYXRCb3VuZHM7XG5cdFx0XHRjb25zdCBzYXRBeGVzID0gdGhpcy5zYXRBeGVzO1xuXHRcdFx0Y29uc3QgYWxpZ25lZFNhdEJvdW5kcyA9IHRoaXMuYWxpZ25lZFNhdEJvdW5kcztcblxuXHRcdFx0YWFiYkJvdW5kcy5taW4gPSBtaW4ueDtcblx0XHRcdGFhYmJCb3VuZHMubWF4ID0gbWF4Lng7XG5cdFx0XHRpZiAoIGFsaWduZWRTYXRCb3VuZHNbIDAgXS5pc1NlcGFyYXRlZCggYWFiYkJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRhYWJiQm91bmRzLm1pbiA9IG1pbi55O1xuXHRcdFx0YWFiYkJvdW5kcy5tYXggPSBtYXgueTtcblx0XHRcdGlmICggYWxpZ25lZFNhdEJvdW5kc1sgMSBdLmlzU2VwYXJhdGVkKCBhYWJiQm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdGFhYmJCb3VuZHMubWluID0gbWluLno7XG5cdFx0XHRhYWJiQm91bmRzLm1heCA9IG1heC56O1xuXHRcdFx0aWYgKCBhbGlnbmVkU2F0Qm91bmRzWyAyIF0uaXNTZXBhcmF0ZWQoIGFhYmJCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBheGlzID0gc2F0QXhlc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBzYiA9IHNhdEJvdW5kc1sgaSBdO1xuXHRcdFx0XHRhYWJiQm91bmRzLnNldEZyb21Cb3goIGF4aXMsIGJveCApO1xuXHRcdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBhYWJiQm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdE9yaWVudGVkQm94LnByb3RvdHlwZS5pbnRlcnNlY3RzVHJpYW5nbGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHNhVHJpID0gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKTtcblx0XHRjb25zdCBwb2ludHNBcnIgPSBuZXcgQXJyYXkoIDMgKTtcblx0XHRjb25zdCBjYWNoZWRTYXRCb3VuZHMgPSBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKTtcblx0XHRjb25zdCBjYWNoZWRTYXRCb3VuZHMyID0gbmV3IFNlcGFyYXRpbmdBeGlzQm91bmRzKCk7XG5cdFx0Y29uc3QgY2FjaGVkQXhpcyA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUgKSB7XG5cblx0XHRcdGlmICggdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISB0cmlhbmdsZS5pc0V4dGVuZGVkVHJpYW5nbGUgKSB7XG5cblx0XHRcdFx0c2FUcmkuY29weSggdHJpYW5nbGUgKTtcblx0XHRcdFx0c2FUcmkudXBkYXRlKCk7XG5cdFx0XHRcdHRyaWFuZ2xlID0gc2FUcmk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRyaWFuZ2xlLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdHRyaWFuZ2xlLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNhdEJvdW5kcyA9IHRoaXMuc2F0Qm91bmRzO1xuXHRcdFx0Y29uc3Qgc2F0QXhlcyA9IHRoaXMuc2F0QXhlcztcblxuXHRcdFx0cG9pbnRzQXJyWyAwIF0gPSB0cmlhbmdsZS5hO1xuXHRcdFx0cG9pbnRzQXJyWyAxIF0gPSB0cmlhbmdsZS5iO1xuXHRcdFx0cG9pbnRzQXJyWyAyIF0gPSB0cmlhbmdsZS5jO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNhID0gc2F0QXhlc1sgaSBdO1xuXHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIHBvaW50c0FyciApO1xuXHRcdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0cmlTYXRCb3VuZHMgPSB0cmlhbmdsZS5zYXRCb3VuZHM7XG5cdFx0XHRjb25zdCB0cmlTYXRBeGVzID0gdHJpYW5nbGUuc2F0QXhlcztcblx0XHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBzYiA9IHRyaVNhdEJvdW5kc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBzYSA9IHRyaVNhdEF4ZXNbIGkgXTtcblx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIHNhLCBwb2ludHMgKTtcblx0XHRcdFx0aWYgKCBzYi5pc1NlcGFyYXRlZCggY2FjaGVkU2F0Qm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgY3Jvc3NlZCBheGVzXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNhMSA9IHNhdEF4ZXNbIGkgXTtcblx0XHRcdFx0Zm9yICggbGV0IGkyID0gMDsgaTIgPCA0OyBpMiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHNhMiA9IHRyaVNhdEF4ZXNbIGkyIF07XG5cdFx0XHRcdFx0Y2FjaGVkQXhpcy5jcm9zc1ZlY3RvcnMoIHNhMSwgc2EyICk7XG5cdFx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIGNhY2hlZEF4aXMsIHBvaW50c0FyciApO1xuXHRcdFx0XHRcdGNhY2hlZFNhdEJvdW5kczIuc2V0RnJvbVBvaW50cyggY2FjaGVkQXhpcywgcG9pbnRzICk7XG5cdFx0XHRcdFx0aWYgKCBjYWNoZWRTYXRCb3VuZHMuaXNTZXBhcmF0ZWQoIGNhY2hlZFNhdEJvdW5kczIgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdE9yaWVudGVkQm94LnByb3RvdHlwZS5jbG9zZXN0UG9pbnRUb1BvaW50ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIHRhcmdldDEgKSB7XG5cblx0XHRcdGlmICggdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRhcmdldDFcblx0XHRcdFx0LmNvcHkoIHBvaW50IClcblx0XHRcdFx0LmFwcGx5TWF0cml4NCggdGhpcy5pbnZNYXRyaXggKVxuXHRcdFx0XHQuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApXG5cdFx0XHRcdC5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdHJldHVybiB0YXJnZXQxO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRPcmllbnRlZEJveC5wcm90b3R5cGUuZGlzdGFuY2VUb1BvaW50ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zdCB0YXJnZXQgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCB0YXJnZXQgKTtcblx0XHRcdHJldHVybiBwb2ludC5kaXN0YW5jZVRvKCB0YXJnZXQgKTtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0T3JpZW50ZWRCb3gucHJvdG90eXBlLmRpc3RhbmNlVG9Cb3ggPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHh5ekZpZWxkcyA9IFsgJ3gnLCAneScsICd6JyBdO1xuXHRcdGNvbnN0IHNlZ21lbnRzMSA9IG5ldyBBcnJheSggMTIgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgdGhyZWUuTGluZTMoKSApO1xuXHRcdGNvbnN0IHNlZ21lbnRzMiA9IG5ldyBBcnJheSggMTIgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgdGhyZWUuTGluZTMoKSApO1xuXG5cdFx0Y29uc3QgcG9pbnQxID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCBwb2ludDIgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXG5cdFx0Ly8gZWFybHkgb3V0IGlmIHdlIGZpbmQgYSB2YWx1ZSBiZWxvdyB0aHJlc2hvbGRcblx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb0JveCggYm94LCB0aHJlc2hvbGQgPSAwLCB0YXJnZXQxID0gbnVsbCwgdGFyZ2V0MiA9IG51bGwgKSB7XG5cblx0XHRcdGlmICggdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5pbnRlcnNlY3RzQm94KCBib3ggKSApIHtcblxuXHRcdFx0XHRpZiAoIHRhcmdldDEgfHwgdGFyZ2V0MiApIHtcblxuXHRcdFx0XHRcdGJveC5nZXRDZW50ZXIoIHBvaW50MiApO1xuXHRcdFx0XHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQyLCBwb2ludDEgKTtcblx0XHRcdFx0XHRib3guY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQxLCBwb2ludDIgKTtcblxuXHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBwb2ludDIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIDA7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGhyZXNob2xkMiA9IHRocmVzaG9sZCAqIHRocmVzaG9sZDtcblx0XHRcdGNvbnN0IG1pbiA9IGJveC5taW47XG5cdFx0XHRjb25zdCBtYXggPSBib3gubWF4O1xuXHRcdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGV2ZXJ5IGVkZ2UgYW5kIGNvbXBhcmUgZGlzdGFuY2VzXG5cdFx0XHRsZXQgY2xvc2VzdERpc3RhbmNlU3EgPSBJbmZpbml0eTtcblxuXHRcdFx0Ly8gY2hlY2sgb3ZlciBhbGwgdGhlc2UgcG9pbnRzXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA4OyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHAgPSBwb2ludHNbIGkgXTtcblx0XHRcdFx0cG9pbnQyLmNvcHkoIHAgKS5jbGFtcCggbWluLCBtYXggKTtcblxuXHRcdFx0XHRjb25zdCBkaXN0ID0gcC5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQyICk7XG5cdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0O1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcCApO1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQyICk7XG5cblx0XHRcdFx0XHRpZiAoIGRpc3QgPCB0aHJlc2hvbGQyICkgcmV0dXJuIE1hdGguc3FydCggZGlzdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBnZW5lcmF0ZSBhbmQgY2hlY2sgYWxsIGxpbmUgc2VnbWVudCBkaXN0YW5jZXNcblx0XHRcdGxldCBjb3VudCA9IDA7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpMSA9IDA7IGkxIDw9IDE7IGkxICsrICkge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gMDsgaTIgPD0gMTsgaTIgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IG5leHRJbmRleCA9ICggaSArIDEgKSAlIDM7XG5cdFx0XHRcdFx0XHRjb25zdCBuZXh0SW5kZXgyID0gKCBpICsgMiApICUgMztcblxuXHRcdFx0XHRcdFx0Ly8gZ2V0IG9iYiBsaW5lIHNlZ21lbnRzXG5cdFx0XHRcdFx0XHRjb25zdCBpbmRleCA9IGkxIDw8IG5leHRJbmRleCB8IGkyIDw8IG5leHRJbmRleDI7XG5cdFx0XHRcdFx0XHRjb25zdCBpbmRleDIgPSAxIDw8IGkgfCBpMSA8PCBuZXh0SW5kZXggfCBpMiA8PCBuZXh0SW5kZXgyO1xuXHRcdFx0XHRcdFx0Y29uc3QgcDEgPSBwb2ludHNbIGluZGV4IF07XG5cdFx0XHRcdFx0XHRjb25zdCBwMiA9IHBvaW50c1sgaW5kZXgyIF07XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lMSA9IHNlZ21lbnRzMVsgY291bnQgXTtcblx0XHRcdFx0XHRcdGxpbmUxLnNldCggcDEsIHAyICk7XG5cblxuXHRcdFx0XHRcdFx0Ly8gZ2V0IGFhYmIgbGluZSBzZWdtZW50c1xuXHRcdFx0XHRcdFx0Y29uc3QgZjEgPSB4eXpGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGYyID0geHl6RmllbGRzWyBuZXh0SW5kZXggXTtcblx0XHRcdFx0XHRcdGNvbnN0IGYzID0geHl6RmllbGRzWyBuZXh0SW5kZXgyIF07XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lMiA9IHNlZ21lbnRzMlsgY291bnQgXTtcblx0XHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gbGluZTIuc3RhcnQ7XG5cdFx0XHRcdFx0XHRjb25zdCBlbmQgPSBsaW5lMi5lbmQ7XG5cblx0XHRcdFx0XHRcdHN0YXJ0WyBmMSBdID0gbWluWyBmMSBdO1xuXHRcdFx0XHRcdFx0c3RhcnRbIGYyIF0gPSBpMSA/IG1pblsgZjIgXSA6IG1heFsgZjIgXTtcblx0XHRcdFx0XHRcdHN0YXJ0WyBmMyBdID0gaTIgPyBtaW5bIGYzIF0gOiBtYXhbIGYyIF07XG5cblx0XHRcdFx0XHRcdGVuZFsgZjEgXSA9IG1heFsgZjEgXTtcblx0XHRcdFx0XHRcdGVuZFsgZjIgXSA9IGkxID8gbWluWyBmMiBdIDogbWF4WyBmMiBdO1xuXHRcdFx0XHRcdFx0ZW5kWyBmMyBdID0gaTIgPyBtaW5bIGYzIF0gOiBtYXhbIGYyIF07XG5cblx0XHRcdFx0XHRcdGNvdW50ICsrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBhbGwgdGhlIG90aGVyIGJveGVzIHBvaW50XG5cdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPD0gMTsgeCArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgeSA9IDA7IHkgPD0gMTsgeSArKyApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCB6ID0gMDsgeiA8PSAxOyB6ICsrICkge1xuXG5cdFx0XHRcdFx0XHRwb2ludDIueCA9IHggPyBtYXgueCA6IG1pbi54O1xuXHRcdFx0XHRcdFx0cG9pbnQyLnkgPSB5ID8gbWF4LnkgOiBtaW4ueTtcblx0XHRcdFx0XHRcdHBvaW50Mi56ID0geiA/IG1heC56IDogbWluLno7XG5cblx0XHRcdFx0XHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQyLCBwb2ludDEgKTtcblx0XHRcdFx0XHRcdGNvbnN0IGRpc3QgPSBwb2ludDIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MSApO1xuXHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0O1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50MSApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IHRocmVzaG9sZDIgKSByZXR1cm4gTWF0aC5zcXJ0KCBkaXN0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMTI7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbDEgPSBzZWdtZW50czFbIGkgXTtcblx0XHRcdFx0Zm9yICggbGV0IGkyID0gMDsgaTIgPCAxMjsgaTIgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBsMiA9IHNlZ21lbnRzMlsgaTIgXTtcblx0XHRcdFx0XHRjbG9zZXN0UG9pbnRzU2VnbWVudFRvU2VnbWVudCggbDEsIGwyLCBwb2ludDEsIHBvaW50MiApO1xuXHRcdFx0XHRcdGNvbnN0IGRpc3QgPSBwb2ludDEuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MiApO1xuXHRcdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50MSApO1xuXHRcdFx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBwb2ludDIgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgdGhyZXNob2xkMiApIHJldHVybiBNYXRoLnNxcnQoIGRpc3QgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIE1hdGguc3FydCggY2xvc2VzdERpc3RhbmNlU3EgKTtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0Ly8gUmlwcGVkIGFuZCBtb2RpZmllZCBGcm9tIFRIUkVFLmpzIE1lc2ggcmF5Y2FzdFxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2Jsb2IvMGFhODdjOTk5ZmU2MWUyMTZjMTEzM2ZiYTdhOTU3NzJiNTAzZWRkZi9zcmMvb2JqZWN0cy9NZXNoLmpzI0wxMTVcblx0Y29uc3QgX3ZBID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGNvbnN0IF92QiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCBfdkMgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblxuXHRjb25zdCBfdXZBID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IyKCk7XG5cdGNvbnN0IF91dkIgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjIoKTtcblx0Y29uc3QgX3V2QyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMigpO1xuXG5cdGNvbnN0IF9ub3JtYWxBID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGNvbnN0IF9ub3JtYWxCID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGNvbnN0IF9ub3JtYWxDID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cblx0Y29uc3QgX2ludGVyc2VjdGlvblBvaW50ID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKCByYXksIHBBLCBwQiwgcEMsIHBvaW50LCBzaWRlICkge1xuXG5cdFx0bGV0IGludGVyc2VjdDtcblx0XHRpZiAoIHNpZGUgPT09IHRocmVlLkJhY2tTaWRlICkge1xuXG5cdFx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBDLCBwQiwgcEEsIHRydWUsIHBvaW50ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBBLCBwQiwgcEMsIHNpZGUgIT09IHRocmVlLkRvdWJsZVNpZGUsIHBvaW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGludGVyc2VjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xuXG5cdFx0Y29uc3QgZGlzdGFuY2UgPSByYXkub3JpZ2luLmRpc3RhbmNlVG8oIHBvaW50ICk7XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRwb2ludDogcG9pbnQuY2xvbmUoKSxcblxuXHRcdH07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHJheSwgcG9zaXRpb24sIG5vcm1hbCwgdXYsIHV2MSwgYSwgYiwgYywgc2lkZSApIHtcblxuXHRcdF92QS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgYSApO1xuXHRcdF92Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgYiApO1xuXHRcdF92Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgYyApO1xuXG5cdFx0Y29uc3QgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIHJheSwgX3ZBLCBfdkIsIF92QywgX2ludGVyc2VjdGlvblBvaW50LCBzaWRlICk7XG5cblx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdFx0aWYgKCB1diApIHtcblxuXHRcdFx0XHRfdXZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBhICk7XG5cdFx0XHRcdF91dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGIgKTtcblx0XHRcdFx0X3V2Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYyApO1xuXG5cdFx0XHRcdGludGVyc2VjdGlvbi51diA9IHRocmVlLlRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IHRocmVlLlZlY3RvcjIoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXYxICkge1xuXG5cdFx0XHRcdF91dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYxLCBhICk7XG5cdFx0XHRcdF91dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYxLCBiICk7XG5cdFx0XHRcdF91dkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYxLCBjICk7XG5cblx0XHRcdFx0aW50ZXJzZWN0aW9uLnV2MSA9IHRocmVlLlRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IHRocmVlLlZlY3RvcjIoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdF9ub3JtYWxBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbCwgYSApO1xuXHRcdFx0XHRfbm9ybWFsQi5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIGIgKTtcblx0XHRcdFx0X25vcm1hbEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsLCBjICk7XG5cblx0XHRcdFx0aW50ZXJzZWN0aW9uLm5vcm1hbCA9IHRocmVlLlRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX25vcm1hbEEsIF9ub3JtYWxCLCBfbm9ybWFsQywgbmV3IHRocmVlLlZlY3RvcjMoKSApO1xuXHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbi5ub3JtYWwuZG90KCByYXkuZGlyZWN0aW9uICkgPiAwICkge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uLm5vcm1hbC5tdWx0aXBseVNjYWxhciggLSAxICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZhY2UgPSB7XG5cdFx0XHRcdGE6IGEsXG5cdFx0XHRcdGI6IGIsXG5cdFx0XHRcdGM6IGMsXG5cdFx0XHRcdG5vcm1hbDogbmV3IHRocmVlLlZlY3RvcjMoKSxcblx0XHRcdFx0bWF0ZXJpYWxJbmRleDogMFxuXHRcdFx0fTtcblxuXHRcdFx0dGhyZWUuVHJpYW5nbGUuZ2V0Tm9ybWFsKCBfdkEsIF92QiwgX3ZDLCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XG5cdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gYTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbnRlcnNlY3Rpb247XG5cblx0fVxuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi8wYWE4N2M5OTlmZTYxZTIxNmMxMTMzZmJhN2E5NTc3MmI1MDNlZGRmL3NyYy9vYmplY3RzL01lc2guanMjTDI1OFxuXHRmdW5jdGlvbiBpbnRlcnNlY3RUcmkoIGdlbywgc2lkZSwgcmF5LCB0cmksIGludGVyc2VjdGlvbnMgKSB7XG5cblx0XHRjb25zdCB0cmlPZmZzZXQgPSB0cmkgKiAzO1xuXHRcdGNvbnN0IGEgPSBnZW8uaW5kZXguZ2V0WCggdHJpT2Zmc2V0ICk7XG5cdFx0Y29uc3QgYiA9IGdlby5pbmRleC5nZXRYKCB0cmlPZmZzZXQgKyAxICk7XG5cdFx0Y29uc3QgYyA9IGdlby5pbmRleC5nZXRYKCB0cmlPZmZzZXQgKyAyICk7XG5cblx0XHRjb25zdCB7IHBvc2l0aW9uLCBub3JtYWwsIHV2LCB1djEgfSA9IGdlby5hdHRyaWJ1dGVzO1xuXHRcdGNvbnN0IGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHJheSwgcG9zaXRpb24sIG5vcm1hbCwgdXYsIHV2MSwgYSwgYiwgYywgc2lkZSApO1xuXG5cdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSB0cmk7XG5cdFx0XHRpZiAoIGludGVyc2VjdGlvbnMgKSBpbnRlcnNlY3Rpb25zLnB1c2goIGludGVyc2VjdGlvbiApO1xuXHRcdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RUcmlzKCBnZW8sIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgaW50ZXJzZWN0aW9ucyApIHtcblxuXHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBlbmQgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGVuZDsgaSArKyApIHtcblxuXHRcdFx0aW50ZXJzZWN0VHJpKCBnZW8sIHNpZGUsIHJheSwgaSwgaW50ZXJzZWN0aW9ucyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RDbG9zZXN0VHJpKCBnZW8sIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCApIHtcblxuXHRcdGxldCBkaXN0ID0gSW5maW5pdHk7XG5cdFx0bGV0IHJlcyA9IG51bGw7XG5cdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGNvdW50OyBpIDwgZW5kOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RUcmkoIGdlbywgc2lkZSwgcmF5LCBpICk7XG5cdFx0XHRpZiAoIGludGVyc2VjdGlvbiAmJiBpbnRlcnNlY3Rpb24uZGlzdGFuY2UgPCBkaXN0ICkge1xuXG5cdFx0XHRcdHJlcyA9IGludGVyc2VjdGlvbjtcblx0XHRcdFx0ZGlzdCA9IGludGVyc2VjdGlvbi5kaXN0YW5jZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlcztcblxuXHR9XG5cblx0Ly8gY29udmVydHMgdGhlIGdpdmVuIEJWSCByYXljYXN0IGludGVyc2VjdGlvbiB0byBhbGlnbiB3aXRoIHRoZSB0aHJlZS5qcyByYXljYXN0XG5cdC8vIHN0cnVjdHVyZSAoaW5jbHVkZSBvYmplY3QsIHdvcmxkIHNwYWNlIGRpc3RhbmNlIGFuZCBwb2ludCkuXG5cdGZ1bmN0aW9uIGNvbnZlcnRSYXljYXN0SW50ZXJzZWN0KCBoaXQsIG9iamVjdCwgcmF5Y2FzdGVyICkge1xuXG5cdFx0aWYgKCBoaXQgPT09IG51bGwgKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0aGl0LnBvaW50LmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0aGl0LmRpc3RhbmNlID0gaGl0LnBvaW50LmRpc3RhbmNlVG8oIHJheWNhc3Rlci5yYXkub3JpZ2luICk7XG5cdFx0aGl0Lm9iamVjdCA9IG9iamVjdDtcblxuXHRcdGlmICggaGl0LmRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgaGl0LmRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gaGl0O1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBzZXRzIHRoZSB2ZXJ0aWNlcyBvZiB0cmlhbmdsZSBgdHJpYCB3aXRoIHRoZSAzIHZlcnRpY2VzIGFmdGVyIGlcblx0ZnVuY3Rpb24gc2V0VHJpYW5nbGUoIHRyaSwgaSwgaW5kZXgsIHBvcyApIHtcblxuXHRcdGNvbnN0IHRhID0gdHJpLmE7XG5cdFx0Y29uc3QgdGIgPSB0cmkuYjtcblx0XHRjb25zdCB0YyA9IHRyaS5jO1xuXG5cdFx0bGV0IGkwID0gaTtcblx0XHRsZXQgaTEgPSBpICsgMTtcblx0XHRsZXQgaTIgPSBpICsgMjtcblx0XHRpZiAoIGluZGV4ICkge1xuXG5cdFx0XHRpMCA9IGluZGV4LmdldFgoIGkgKTtcblx0XHRcdGkxID0gaW5kZXguZ2V0WCggaSArIDEgKTtcblx0XHRcdGkyID0gaW5kZXguZ2V0WCggaSArIDIgKTtcblxuXHRcdH1cblxuXHRcdHRhLnggPSBwb3MuZ2V0WCggaTAgKTtcblx0XHR0YS55ID0gcG9zLmdldFkoIGkwICk7XG5cdFx0dGEueiA9IHBvcy5nZXRaKCBpMCApO1xuXG5cdFx0dGIueCA9IHBvcy5nZXRYKCBpMSApO1xuXHRcdHRiLnkgPSBwb3MuZ2V0WSggaTEgKTtcblx0XHR0Yi56ID0gcG9zLmdldFooIGkxICk7XG5cblx0XHR0Yy54ID0gcG9zLmdldFgoIGkyICk7XG5cdFx0dGMueSA9IHBvcy5nZXRZKCBpMiApO1xuXHRcdHRjLnogPSBwb3MuZ2V0WiggaTIgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaXRlcmF0ZU92ZXJUcmlhbmdsZXMoXG5cdFx0b2Zmc2V0LFxuXHRcdGNvdW50LFxuXHRcdGdlb21ldHJ5LFxuXHRcdGludGVyc2VjdHNUcmlhbmdsZUZ1bmMsXG5cdFx0Y29udGFpbmVkLFxuXHRcdGRlcHRoLFxuXHRcdHRyaWFuZ2xlXG5cdCkge1xuXG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBwb3MgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBsID0gY291bnQgKyBvZmZzZXQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIGkgKiAzLCBpbmRleCwgcG9zICk7XG5cdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdGlmICggaW50ZXJzZWN0c1RyaWFuZ2xlRnVuYyggdHJpYW5nbGUsIGksIGNvbnRhaW5lZCwgZGVwdGggKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHRjb25zdCB0ZW1wVjEgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcFYyID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGNvbnN0IHRlbXBWMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wVVYxID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IyKCk7XG5cdGNvbnN0IHRlbXBVVjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjIoKTtcblx0Y29uc3QgdGVtcFVWMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMigpO1xuXG5cdGZ1bmN0aW9uIGdldFRyaWFuZ2xlSGl0UG9pbnRJbmZvKCBwb2ludCwgZ2VvbWV0cnksIHRyaWFuZ2xlSW5kZXgsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5nZXRJbmRleCgpLmFycmF5O1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXHRcdGNvbnN0IHV2cyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3V2JyApO1xuXG5cdFx0Y29uc3QgYSA9IGluZGljZXNbIHRyaWFuZ2xlSW5kZXggKiAzIF07XG5cdFx0Y29uc3QgYiA9IGluZGljZXNbIHRyaWFuZ2xlSW5kZXggKiAzICsgMSBdO1xuXHRcdGNvbnN0IGMgPSBpbmRpY2VzWyB0cmlhbmdsZUluZGV4ICogMyArIDIgXTtcblxuXHRcdHRlbXBWMS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIGEgKTtcblx0XHR0ZW1wVjIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCBiICk7XG5cdFx0dGVtcFYzLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgYyApO1xuXG5cdFx0Ly8gZmluZCB0aGUgYXNzb2NpYXRlZCBtYXRlcmlhbCBpbmRleFxuXHRcdGxldCBtYXRlcmlhbEluZGV4ID0gMDtcblx0XHRjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cdFx0Y29uc3QgZmlyc3RWZXJ0ZXhJbmRleCA9IHRyaWFuZ2xlSW5kZXggKiAzO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0Y29uc3QgeyBzdGFydCwgY291bnQgfSA9IGdyb3VwO1xuXHRcdFx0aWYgKCBmaXJzdFZlcnRleEluZGV4ID49IHN0YXJ0ICYmIGZpcnN0VmVydGV4SW5kZXggPCBzdGFydCArIGNvdW50ICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBncm91cC5tYXRlcmlhbEluZGV4O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZXh0cmFjdCB1dnNcblx0XHRsZXQgdXYgPSBudWxsO1xuXHRcdGlmICggdXZzICkge1xuXG5cdFx0XHR0ZW1wVVYxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2cywgYSApO1xuXHRcdFx0dGVtcFVWMi5mcm9tQnVmZmVyQXR0cmlidXRlKCB1dnMsIGIgKTtcblx0XHRcdHRlbXBVVjMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXZzLCBjICk7XG5cblx0XHRcdGlmICggdGFyZ2V0ICYmIHRhcmdldC51diApIHV2ID0gdGFyZ2V0LnV2O1xuXHRcdFx0ZWxzZSB1diA9IG5ldyB0aHJlZS5WZWN0b3IyKCk7XG5cblx0XHRcdHRocmVlLlRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIHBvaW50LCB0ZW1wVjEsIHRlbXBWMiwgdGVtcFYzLCB0ZW1wVVYxLCB0ZW1wVVYyLCB0ZW1wVVYzLCB1diApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYWRqdXN0IHRoZSBwcm92aWRlZCB0YXJnZXQgb3IgY3JlYXRlIGEgbmV3IG9uZVxuXHRcdGlmICggdGFyZ2V0ICkge1xuXG5cdFx0XHRpZiAoICEgdGFyZ2V0LmZhY2UgKSB0YXJnZXQuZmFjZSA9IHsgfTtcblx0XHRcdHRhcmdldC5mYWNlLmEgPSBhO1xuXHRcdFx0dGFyZ2V0LmZhY2UuYiA9IGI7XG5cdFx0XHR0YXJnZXQuZmFjZS5jID0gYztcblx0XHRcdHRhcmdldC5mYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXHRcdFx0aWYgKCAhIHRhcmdldC5mYWNlLm5vcm1hbCApIHRhcmdldC5mYWNlLm5vcm1hbCA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdFx0XHR0aHJlZS5UcmlhbmdsZS5nZXROb3JtYWwoIHRlbXBWMSwgdGVtcFYyLCB0ZW1wVjMsIHRhcmdldC5mYWNlLm5vcm1hbCApO1xuXG5cdFx0XHRpZiAoIHV2ICkgdGFyZ2V0LnV2ID0gdXY7XG5cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRmYWNlOiB7XG5cdFx0XHRcdFx0YTogYSxcblx0XHRcdFx0XHRiOiBiLFxuXHRcdFx0XHRcdGM6IGMsXG5cdFx0XHRcdFx0bWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleCxcblx0XHRcdFx0XHRub3JtYWw6IHRocmVlLlRyaWFuZ2xlLmdldE5vcm1hbCggdGVtcFYxLCB0ZW1wVjIsIHRlbXBWMywgbmV3IHRocmVlLlZlY3RvcjMoKSApXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHV2OiB1dlxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgUHJpbWl0aXZlUG9vbCB7XG5cblx0XHRjb25zdHJ1Y3RvciggZ2V0TmV3UHJpbWl0aXZlICkge1xuXG5cdFx0XHR0aGlzLl9nZXROZXdQcmltaXRpdmUgPSBnZXROZXdQcmltaXRpdmU7XG5cdFx0XHR0aGlzLl9wcmltaXRpdmVzID0gW107XG5cblx0XHR9XG5cblx0XHRnZXRQcmltaXRpdmUoKSB7XG5cblx0XHRcdGNvbnN0IHByaW1pdGl2ZXMgPSB0aGlzLl9wcmltaXRpdmVzO1xuXHRcdFx0aWYgKCBwcmltaXRpdmVzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZ2V0TmV3UHJpbWl0aXZlKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIHByaW1pdGl2ZXMucG9wKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJlbGVhc2VQcmltaXRpdmUoIHByaW1pdGl2ZSApIHtcblxuXHRcdFx0dGhpcy5fcHJpbWl0aXZlcy5wdXNoKCBwcmltaXRpdmUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gSVNfTEVBRiggbjE2LCB1aW50MTZBcnJheSApIHtcblxuXHRcdHJldHVybiB1aW50MTZBcnJheVsgbjE2ICsgMTUgXSA9PT0gMHhGRkZGO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBPRkZTRVQoIG4zMiwgdWludDMyQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gdWludDMyQXJyYXlbIG4zMiArIDYgXTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gQ09VTlQoIG4xNiwgdWludDE2QXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gdWludDE2QXJyYXlbIG4xNiArIDE0IF07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIExFRlRfTk9ERSggbjMyICkge1xuXG5cdFx0cmV0dXJuIG4zMiArIDg7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFJJR0hUX05PREUoIG4zMiwgdWludDMyQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gdWludDMyQXJyYXlbIG4zMiArIDYgXTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gU1BMSVRfQVhJUyggbjMyLCB1aW50MzJBcnJheSApIHtcblxuXHRcdHJldHVybiB1aW50MzJBcnJheVsgbjMyICsgNyBdO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBCT1VORElOR19EQVRBX0lOREVYKCBuMzIgKSB7XG5cblx0XHRyZXR1cm4gbjMyO1xuXG5cdH1cblxuXHRjb25zdCBib3VuZGluZ0JveCQxID0gbmV3IHRocmVlLkJveDMoKTtcblx0Y29uc3QgYm94SW50ZXJzZWN0aW9uID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0Y29uc3QgeHl6RmllbGRzID0gWyAneCcsICd5JywgJ3onIF07XG5cblx0ZnVuY3Rpb24gcmF5Y2FzdCggbm9kZUluZGV4MzIsIGdlb21ldHJ5LCBzaWRlLCByYXksIGludGVyc2VjdHMgKSB7XG5cblx0XHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDIsIGZsb2F0MzJBcnJheSA9IF9mbG9hdDMyQXJyYXksIHVpbnQxNkFycmF5ID0gX3VpbnQxNkFycmF5LCB1aW50MzJBcnJheSA9IF91aW50MzJBcnJheTtcblxuXHRcdGNvbnN0IGlzTGVhZiA9IElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblx0XHRcdGludGVyc2VjdFRyaXMoIGdlb21ldHJ5LCBzaWRlLCByYXksIG9mZnNldCwgY291bnQsIGludGVyc2VjdHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGxlZnRJbmRleCA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblx0XHRcdGlmICggaW50ZXJzZWN0UmF5KCBsZWZ0SW5kZXgsIGZsb2F0MzJBcnJheSwgcmF5LCBib3hJbnRlcnNlY3Rpb24gKSApIHtcblxuXHRcdFx0XHRyYXljYXN0KCBsZWZ0SW5kZXgsIGdlb21ldHJ5LCBzaWRlLCByYXksIGludGVyc2VjdHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByaWdodEluZGV4ID0gUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRpZiAoIGludGVyc2VjdFJheSggcmlnaHRJbmRleCwgZmxvYXQzMkFycmF5LCByYXksIGJveEludGVyc2VjdGlvbiApICkge1xuXG5cdFx0XHRcdHJheWNhc3QoIHJpZ2h0SW5kZXgsIGdlb21ldHJ5LCBzaWRlLCByYXksIGludGVyc2VjdHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByYXljYXN0Rmlyc3QoIG5vZGVJbmRleDMyLCBnZW9tZXRyeSwgc2lkZSwgcmF5ICkge1xuXG5cdFx0bGV0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyLCBmbG9hdDMyQXJyYXkgPSBfZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSA9IF91aW50MTZBcnJheSwgdWludDMyQXJyYXkgPSBfdWludDMyQXJyYXk7XG5cblx0XHRjb25zdCBpc0xlYWYgPSBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGNvbnN0IGNvdW50ID0gQ09VTlQoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRcdFx0cmV0dXJuIGludGVyc2VjdENsb3Nlc3RUcmkoIGdlb21ldHJ5LCBzaWRlLCByYXksIG9mZnNldCwgY291bnQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGNvbnNpZGVyIHRoZSBwb3NpdGlvbiBvZiB0aGUgc3BsaXQgcGxhbmUgd2l0aCByZXNwZWN0IHRvIHRoZSBvbmNvbWluZyByYXk7IHdoaWNoZXZlciBkaXJlY3Rpb25cblx0XHRcdC8vIHRoZSByYXkgaXMgY29taW5nIGZyb20sIGxvb2sgZm9yIGFuIGludGVyc2VjdGlvbiBhbW9uZyB0aGF0IHNpZGUgb2YgdGhlIHRyZWUgZmlyc3Rcblx0XHRcdGNvbnN0IHNwbGl0QXhpcyA9IFNQTElUX0FYSVMoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0Y29uc3QgeHl6QXhpcyA9IHh5ekZpZWxkc1sgc3BsaXRBeGlzIF07XG5cdFx0XHRjb25zdCByYXlEaXIgPSByYXkuZGlyZWN0aW9uWyB4eXpBeGlzIF07XG5cdFx0XHRjb25zdCBsZWZ0VG9SaWdodCA9IHJheURpciA+PSAwO1xuXG5cdFx0XHQvLyBjMSBpcyB0aGUgY2hpbGQgdG8gY2hlY2sgZmlyc3Rcblx0XHRcdGxldCBjMSwgYzI7XG5cdFx0XHRpZiAoIGxlZnRUb1JpZ2h0ICkge1xuXG5cdFx0XHRcdGMxID0gTEVGVF9OT0RFKCBub2RlSW5kZXgzMiApO1xuXHRcdFx0XHRjMiA9IFJJR0hUX05PREUoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGMxID0gUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRcdGMyID0gTEVGVF9OT0RFKCBub2RlSW5kZXgzMiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGMxSW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0UmF5KCBjMSwgZmxvYXQzMkFycmF5LCByYXksIGJveEludGVyc2VjdGlvbiApO1xuXHRcdFx0Y29uc3QgYzFSZXN1bHQgPSBjMUludGVyc2VjdGlvbiA/IHJheWNhc3RGaXJzdCggYzEsIGdlb21ldHJ5LCBzaWRlLCByYXkgKSA6IG51bGw7XG5cblx0XHRcdC8vIGlmIHdlIGdvdCBhbiBpbnRlcnNlY3Rpb24gaW4gdGhlIGZpcnN0IG5vZGUgYW5kIGl0J3MgY2xvc2VyIHRoYW4gdGhlIHNlY29uZCBub2RlJ3MgYm91bmRpbmdcblx0XHRcdC8vIGJveCwgd2UgZG9uJ3QgbmVlZCB0byBjb25zaWRlciB0aGUgc2Vjb25kIG5vZGUgYmVjYXVzZSBpdCBjb3VsZG4ndCBwb3NzaWJseSBiZSBhIGJldHRlciByZXN1bHRcblx0XHRcdGlmICggYzFSZXN1bHQgKSB7XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgc2Vjb25kIGJvdW5kc1xuXHRcdFx0XHQvLyBcInBvaW50XCIgaXMgaW4gdGhlIGxvY2FsIGZyYW1lIG9mIHRoZSBidmhcblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBjMVJlc3VsdC5wb2ludFsgeHl6QXhpcyBdO1xuXHRcdFx0XHRjb25zdCBpc091dHNpZGUgPSBsZWZ0VG9SaWdodCA/XG5cdFx0XHRcdFx0cG9pbnQgPD0gZmxvYXQzMkFycmF5WyBjMiArIHNwbGl0QXhpcyBdIDogLy8gbWluIGJvdW5kaW5nIGRhdGFcblx0XHRcdFx0XHRwb2ludCA+PSBmbG9hdDMyQXJyYXlbIGMyICsgc3BsaXRBeGlzICsgMyBdOyAvLyBtYXggYm91bmRpbmcgZGF0YVxuXG5cdFx0XHRcdGlmICggaXNPdXRzaWRlICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGMxUmVzdWx0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBlaXRoZXIgdGhlcmUgd2FzIG5vIGludGVyc2VjdGlvbiBpbiB0aGUgZmlyc3Qgbm9kZSwgb3IgdGhlcmUgY291bGQgc3RpbGwgYmUgYSBjbG9zZXJcblx0XHRcdC8vIGludGVyc2VjdGlvbiBpbiB0aGUgc2Vjb25kLCBzbyBjaGVjayB0aGUgc2Vjb25kIG5vZGUgYW5kIHRoZW4gdGFrZSB0aGUgYmV0dGVyIG9mIHRoZSB0d29cblx0XHRcdGNvbnN0IGMySW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0UmF5KCBjMiwgZmxvYXQzMkFycmF5LCByYXksIGJveEludGVyc2VjdGlvbiApO1xuXHRcdFx0Y29uc3QgYzJSZXN1bHQgPSBjMkludGVyc2VjdGlvbiA/IHJheWNhc3RGaXJzdCggYzIsIGdlb21ldHJ5LCBzaWRlLCByYXkgKSA6IG51bGw7XG5cblx0XHRcdGlmICggYzFSZXN1bHQgJiYgYzJSZXN1bHQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGMxUmVzdWx0LmRpc3RhbmNlIDw9IGMyUmVzdWx0LmRpc3RhbmNlID8gYzFSZXN1bHQgOiBjMlJlc3VsdDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQgfHwgYzJSZXN1bHQgfHwgbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBzaGFwZWNhc3QgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGxldCBfYm94MSwgX2JveDI7XG5cdFx0Y29uc3QgYm94U3RhY2sgPSBbXTtcblx0XHRjb25zdCBib3hQb29sID0gbmV3IFByaW1pdGl2ZVBvb2woICgpID0+IG5ldyB0aHJlZS5Cb3gzKCkgKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBzaGFwZWNhc3QoIC4uLmFyZ3MgKSB7XG5cblx0XHRcdF9ib3gxID0gYm94UG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRcdF9ib3gyID0gYm94UG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRcdGJveFN0YWNrLnB1c2goIF9ib3gxLCBfYm94MiApO1xuXG5cdFx0XHRjb25zdCByZXN1bHQgPSBzaGFwZWNhc3RUcmF2ZXJzZSggLi4uYXJncyApO1xuXG5cdFx0XHRib3hQb29sLnJlbGVhc2VQcmltaXRpdmUoIF9ib3gxICk7XG5cdFx0XHRib3hQb29sLnJlbGVhc2VQcmltaXRpdmUoIF9ib3gyICk7XG5cdFx0XHRib3hTdGFjay5wb3AoKTtcblx0XHRcdGJveFN0YWNrLnBvcCgpO1xuXG5cdFx0XHRjb25zdCBsZW5ndGggPSBib3hTdGFjay5sZW5ndGg7XG5cdFx0XHRpZiAoIGxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0X2JveDIgPSBib3hTdGFja1sgbGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRfYm94MSA9IGJveFN0YWNrWyBsZW5ndGggLSAyIF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBzaGFwZWNhc3RUcmF2ZXJzZShcblx0XHRcdG5vZGVJbmRleDMyLFxuXHRcdFx0Z2VvbWV0cnksXG5cdFx0XHRpbnRlcnNlY3RzQm91bmRzRnVuYyxcblx0XHRcdGludGVyc2VjdHNSYW5nZUZ1bmMsXG5cdFx0XHRub2RlU2NvcmVGdW5jID0gbnVsbCxcblx0XHRcdG5vZGVJbmRleEJ5dGVPZmZzZXQgPSAwLCAvLyBvZmZzZXQgZm9yIHVuaXF1ZSBub2RlIGlkZW50aWZpZXJcblx0XHRcdGRlcHRoID0gMFxuXHRcdCkge1xuXG5cdFx0XHQvLyBEZWZpbmUgdGhlc2UgaW5zaWRlIHRoZSBmdW5jdGlvbiBzbyBpdCBoYXMgYWNjZXNzIHRvIHRoZSBsb2NhbCB2YXJpYWJsZXMgbmVlZGVkXG5cdFx0XHQvLyB3aGVuIGNvbnZlcnRpbmcgdG8gdGhlIGJ1ZmZlciBlcXVpdmFsZW50c1xuXHRcdFx0ZnVuY3Rpb24gZ2V0TGVmdE9mZnNldCggbm9kZUluZGV4MzIgKSB7XG5cblx0XHRcdFx0bGV0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyLCB1aW50MTZBcnJheSA9IF91aW50MTZBcnJheSwgdWludDMyQXJyYXkgPSBfdWludDMyQXJyYXk7XG5cblx0XHRcdFx0Ly8gdHJhdmVyc2UgdW50aWwgd2UgZmluZCBhIGxlYWZcblx0XHRcdFx0d2hpbGUgKCAhIElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApICkge1xuXG5cdFx0XHRcdFx0bm9kZUluZGV4MzIgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRcdFx0bm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldFJpZ2h0RW5kT2Zmc2V0KCBub2RlSW5kZXgzMiApIHtcblxuXHRcdFx0XHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDIsIHVpbnQxNkFycmF5ID0gX3VpbnQxNkFycmF5LCB1aW50MzJBcnJheSA9IF91aW50MzJBcnJheTtcblxuXHRcdFx0XHQvLyB0cmF2ZXJzZSB1bnRpbCB3ZSBmaW5kIGEgbGVhZlxuXHRcdFx0XHR3aGlsZSAoICEgSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICkgKSB7XG5cblx0XHRcdFx0XHQvLyBhZGp1c3Qgb2Zmc2V0IHRvIHBvaW50IHRvIHRoZSByaWdodCBub2RlXG5cdFx0XHRcdFx0bm9kZUluZGV4MzIgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdFx0XHRub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmV0dXJuIHRoZSBlbmQgb2Zmc2V0IG9mIHRoZSB0cmlhbmdsZSByYW5nZVxuXHRcdFx0XHRyZXR1cm4gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKSArIENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDIsIGZsb2F0MzJBcnJheSA9IF9mbG9hdDMyQXJyYXksIHVpbnQxNkFycmF5ID0gX3VpbnQxNkFycmF5LCB1aW50MzJBcnJheSA9IF91aW50MzJBcnJheTtcblxuXHRcdFx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdFx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbm9kZUluZGV4MzIgKSwgZmxvYXQzMkFycmF5LCBfYm94MSApO1xuXHRcdFx0XHRyZXR1cm4gaW50ZXJzZWN0c1JhbmdlRnVuYyggb2Zmc2V0LCBjb3VudCwgZmFsc2UsIGRlcHRoLCBub2RlSW5kZXhCeXRlT2Zmc2V0ICsgbm9kZUluZGV4MzIsIF9ib3gxICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgbGVmdCA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblx0XHRcdFx0Y29uc3QgcmlnaHQgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdFx0bGV0IGMxID0gbGVmdDtcblx0XHRcdFx0bGV0IGMyID0gcmlnaHQ7XG5cblx0XHRcdFx0bGV0IHNjb3JlMSwgc2NvcmUyO1xuXHRcdFx0XHRsZXQgYm94MSwgYm94Mjtcblx0XHRcdFx0aWYgKCBub2RlU2NvcmVGdW5jICkge1xuXG5cdFx0XHRcdFx0Ym94MSA9IF9ib3gxO1xuXHRcdFx0XHRcdGJveDIgPSBfYm94MjtcblxuXHRcdFx0XHRcdC8vIGJvdW5kaW5nIGRhdGEgaXMgbm90IG9mZnNldFxuXHRcdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGMxICksIGZsb2F0MzJBcnJheSwgYm94MSApO1xuXHRcdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGMyICksIGZsb2F0MzJBcnJheSwgYm94MiApO1xuXG5cdFx0XHRcdFx0c2NvcmUxID0gbm9kZVNjb3JlRnVuYyggYm94MSApO1xuXHRcdFx0XHRcdHNjb3JlMiA9IG5vZGVTY29yZUZ1bmMoIGJveDIgKTtcblxuXHRcdFx0XHRcdGlmICggc2NvcmUyIDwgc2NvcmUxICkge1xuXG5cdFx0XHRcdFx0XHRjMSA9IHJpZ2h0O1xuXHRcdFx0XHRcdFx0YzIgPSBsZWZ0O1xuXG5cdFx0XHRcdFx0XHRjb25zdCB0ZW1wID0gc2NvcmUxO1xuXHRcdFx0XHRcdFx0c2NvcmUxID0gc2NvcmUyO1xuXHRcdFx0XHRcdFx0c2NvcmUyID0gdGVtcDtcblxuXHRcdFx0XHRcdFx0Ym94MSA9IGJveDI7XG5cdFx0XHRcdFx0XHQvLyBib3gyIGlzIGFsd2F5cyBzZXQgYmVmb3JlIHVzZSBiZWxvd1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDaGVjayBib3ggMSBpbnRlcnNlY3Rpb25cblx0XHRcdFx0aWYgKCAhIGJveDEgKSB7XG5cblx0XHRcdFx0XHRib3gxID0gX2JveDE7XG5cdFx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggYzEgKSwgZmxvYXQzMkFycmF5LCBib3gxICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGlzQzFMZWFmID0gSVNfTEVBRiggYzEgKiAyLCB1aW50MTZBcnJheSApO1xuXHRcdFx0XHRjb25zdCBjMUludGVyc2VjdGlvbiA9IGludGVyc2VjdHNCb3VuZHNGdW5jKCBib3gxLCBpc0MxTGVhZiwgc2NvcmUxLCBkZXB0aCArIDEsIG5vZGVJbmRleEJ5dGVPZmZzZXQgKyBjMSApO1xuXG5cdFx0XHRcdGxldCBjMVN0b3BUcmF2ZXJzYWw7XG5cdFx0XHRcdGlmICggYzFJbnRlcnNlY3Rpb24gPT09IENPTlRBSU5FRCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IGdldExlZnRPZmZzZXQoIGMxICk7XG5cdFx0XHRcdFx0Y29uc3QgZW5kID0gZ2V0UmlnaHRFbmRPZmZzZXQoIGMxICk7XG5cdFx0XHRcdFx0Y29uc3QgY291bnQgPSBlbmQgLSBvZmZzZXQ7XG5cblx0XHRcdFx0XHRjMVN0b3BUcmF2ZXJzYWwgPSBpbnRlcnNlY3RzUmFuZ2VGdW5jKCBvZmZzZXQsIGNvdW50LCB0cnVlLCBkZXB0aCArIDEsIG5vZGVJbmRleEJ5dGVPZmZzZXQgKyBjMSwgYm94MSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjMVN0b3BUcmF2ZXJzYWwgPVxuXHRcdFx0XHRcdFx0YzFJbnRlcnNlY3Rpb24gJiZcblx0XHRcdFx0XHRcdHNoYXBlY2FzdFRyYXZlcnNlKFxuXHRcdFx0XHRcdFx0XHRjMSxcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnksXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHNGdW5jLFxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2VGdW5jLFxuXHRcdFx0XHRcdFx0XHRub2RlU2NvcmVGdW5jLFxuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXhCeXRlT2Zmc2V0LFxuXHRcdFx0XHRcdFx0XHRkZXB0aCArIDFcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggYzFTdG9wVHJhdmVyc2FsICkgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgYm94IDIgaW50ZXJzZWN0aW9uXG5cdFx0XHRcdC8vIGNhY2hlZCBib3gyIHdpbGwgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuIGJ5IHByZXZpb3VzIHRyYXZlcnNhbFxuXHRcdFx0XHRib3gyID0gX2JveDI7XG5cdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGMyICksIGZsb2F0MzJBcnJheSwgYm94MiApO1xuXG5cdFx0XHRcdGNvbnN0IGlzQzJMZWFmID0gSVNfTEVBRiggYzIgKiAyLCB1aW50MTZBcnJheSApO1xuXHRcdFx0XHRjb25zdCBjMkludGVyc2VjdGlvbiA9IGludGVyc2VjdHNCb3VuZHNGdW5jKCBib3gyLCBpc0MyTGVhZiwgc2NvcmUyLCBkZXB0aCArIDEsIG5vZGVJbmRleEJ5dGVPZmZzZXQgKyBjMiApO1xuXG5cdFx0XHRcdGxldCBjMlN0b3BUcmF2ZXJzYWw7XG5cdFx0XHRcdGlmICggYzJJbnRlcnNlY3Rpb24gPT09IENPTlRBSU5FRCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IGdldExlZnRPZmZzZXQoIGMyICk7XG5cdFx0XHRcdFx0Y29uc3QgZW5kID0gZ2V0UmlnaHRFbmRPZmZzZXQoIGMyICk7XG5cdFx0XHRcdFx0Y29uc3QgY291bnQgPSBlbmQgLSBvZmZzZXQ7XG5cblx0XHRcdFx0XHRjMlN0b3BUcmF2ZXJzYWwgPSBpbnRlcnNlY3RzUmFuZ2VGdW5jKCBvZmZzZXQsIGNvdW50LCB0cnVlLCBkZXB0aCArIDEsIG5vZGVJbmRleEJ5dGVPZmZzZXQgKyBjMiwgYm94MiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjMlN0b3BUcmF2ZXJzYWwgPVxuXHRcdFx0XHRcdFx0YzJJbnRlcnNlY3Rpb24gJiZcblx0XHRcdFx0XHRcdHNoYXBlY2FzdFRyYXZlcnNlKFxuXHRcdFx0XHRcdFx0XHRjMixcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnksXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHNGdW5jLFxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2VGdW5jLFxuXHRcdFx0XHRcdFx0XHRub2RlU2NvcmVGdW5jLFxuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXhCeXRlT2Zmc2V0LFxuXHRcdFx0XHRcdFx0XHRkZXB0aCArIDFcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggYzJTdG9wVHJhdmVyc2FsICkgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSApKCk7XG5cblx0Y29uc3QgaW50ZXJzZWN0c0dlb21ldHJ5ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zdCB0cmlhbmdsZSA9IG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCk7XG5cdFx0Y29uc3QgdHJpYW5nbGUyID0gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKTtcblx0XHRjb25zdCBpbnZlcnRlZE1hdCA9IG5ldyB0aHJlZS5NYXRyaXg0KCk7XG5cblx0XHRjb25zdCBvYmIgPSBuZXcgT3JpZW50ZWRCb3goKTtcblx0XHRjb25zdCBvYmIyID0gbmV3IE9yaWVudGVkQm94KCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c0dlb21ldHJ5KCBub2RlSW5kZXgzMiwgZ2VvbWV0cnksIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmgsIGNhY2hlZE9iYiA9IG51bGwgKSB7XG5cblx0XHRcdGxldCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMiwgZmxvYXQzMkFycmF5ID0gX2Zsb2F0MzJBcnJheSwgdWludDE2QXJyYXkgPSBfdWludDE2QXJyYXksIHVpbnQzMkFycmF5ID0gX3VpbnQzMkFycmF5O1xuXG5cdFx0XHRpZiAoIGNhY2hlZE9iYiA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRpZiAoICEgb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveCApIHtcblxuXHRcdFx0XHRcdG90aGVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iYi5zZXQoIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWluLCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heCwgZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRjYWNoZWRPYmIgPSBvYmI7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdFx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0XHRjb25zdCB0aGlzR2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHRcdFx0Y29uc3QgdGhpc0luZGV4ID0gdGhpc0dlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRjb25zdCB0aGlzUG9zID0gdGhpc0dlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdFx0Y29uc3QgaW5kZXggPSBvdGhlckdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRjb25zdCBwb3MgPSBvdGhlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblx0XHRcdFx0Ly8gZ2V0IHRoZSBpbnZlcnNlIG9mIHRoZSBnZW9tZXRyeSBtYXRyaXggc28gd2UgY2FuIHRyYW5zZm9ybSBvdXIgdHJpYW5nbGVzIGludG8gdGhlXG5cdFx0XHRcdC8vIGdlb21ldHJ5IHNwYWNlIHdlJ3JlIHRyeWluZyB0byB0ZXN0LiBXZSBhc3N1bWUgdGhlcmUgYXJlIGZld2VyIHRyaWFuZ2xlcyBiZWluZyBjaGVja2VkXG5cdFx0XHRcdC8vIGhlcmUuXG5cdFx0XHRcdGludmVydGVkTWF0LmNvcHkoIGdlb21ldHJ5VG9CdmggKS5pbnZlcnQoKTtcblxuXHRcdFx0XHRpZiAoIG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIG5vZGVJbmRleDMyICksIGZsb2F0MzJBcnJheSwgb2JiMiApO1xuXHRcdFx0XHRcdG9iYjIubWF0cml4LmNvcHkoIGludmVydGVkTWF0ICk7XG5cdFx0XHRcdFx0b2JiMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRjb25zdCByZXMgPSBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUuc2hhcGVjYXN0KCB7XG5cblx0XHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6IGJveCA9PiBvYmIyLmludGVyc2VjdHNCb3goIGJveCApLFxuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6IHRyaSA9PiB7XG5cblx0XHRcdFx0XHRcdFx0dHJpLmEuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdHRyaS5iLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHR0cmkuYy5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0dHJpLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCAqIDMsIGwgPSAoIGNvdW50ICsgb2Zmc2V0ICkgKiAzOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhpcyB0cmlhbmdsZSBuZWVkcyB0byBiZSB0cmFuc2Zvcm1lZCBpbnRvIHRoZSBjdXJyZW50IEJWSCBjb29yZGluYXRlIGZyYW1lXG5cdFx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgaSwgdGhpc0luZGV4LCB0aGlzUG9zICk7XG5cdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHRyaS5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlMiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCAqIDMsIGwgPSAoIGNvdW50ICsgb2Zmc2V0ICogMyApOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHQvLyB0aGlzIHRyaWFuZ2xlIG5lZWRzIHRvIGJlIHRyYW5zZm9ybWVkIGludG8gdGhlIGN1cnJlbnQgQlZIIGNvb3JkaW5hdGUgZnJhbWVcblx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgaSwgdGhpc0luZGV4LCB0aGlzUG9zICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZS5hLmFwcGx5TWF0cml4NCggaW52ZXJ0ZWRNYXQgKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlLmIuYXBwbHlNYXRyaXg0KCBpbnZlcnRlZE1hdCApO1xuXHRcdFx0XHRcdFx0dHJpYW5nbGUuYy5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0ICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBpMiA9IDAsIGwyID0gaW5kZXguY291bnQ7IGkyIDwgbDI7IGkyICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgaTIsIGluZGV4LCBwb3MgKTtcblx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHRyaWFuZ2xlLmludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUyICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgbGVmdCA9IG5vZGVJbmRleDMyICsgODtcblx0XHRcdFx0Y29uc3QgcmlnaHQgPSB1aW50MzJBcnJheVsgbm9kZUluZGV4MzIgKyA2IF07XG5cblx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbGVmdCApLCBmbG9hdDMyQXJyYXksIGJvdW5kaW5nQm94JDEgKTtcblx0XHRcdFx0Y29uc3QgbGVmdEludGVyc2VjdGlvbiA9XG5cdFx0XHRcdFx0Y2FjaGVkT2JiLmludGVyc2VjdHNCb3goIGJvdW5kaW5nQm94JDEgKSAmJlxuXHRcdFx0XHRcdGludGVyc2VjdHNHZW9tZXRyeSggbGVmdCwgZ2VvbWV0cnksIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmgsIGNhY2hlZE9iYiApO1xuXG5cdFx0XHRcdGlmICggbGVmdEludGVyc2VjdGlvbiApIHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIHJpZ2h0ICksIGZsb2F0MzJBcnJheSwgYm91bmRpbmdCb3gkMSApO1xuXHRcdFx0XHRjb25zdCByaWdodEludGVyc2VjdGlvbiA9XG5cdFx0XHRcdFx0Y2FjaGVkT2JiLmludGVyc2VjdHNCb3goIGJvdW5kaW5nQm94JDEgKSAmJlxuXHRcdFx0XHRcdGludGVyc2VjdHNHZW9tZXRyeSggcmlnaHQsIGdlb21ldHJ5LCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCBjYWNoZWRPYmIgKTtcblxuXHRcdFx0XHRpZiAoIHJpZ2h0SW50ZXJzZWN0aW9uICkgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdGZ1bmN0aW9uIGludGVyc2VjdFJheSggbm9kZUluZGV4MzIsIGFycmF5LCByYXksIHRhcmdldCApIHtcblxuXHRcdGFycmF5VG9Cb3goIG5vZGVJbmRleDMyLCBhcnJheSwgYm91bmRpbmdCb3gkMSApO1xuXHRcdHJldHVybiByYXkuaW50ZXJzZWN0Qm94KCBib3VuZGluZ0JveCQxLCB0YXJnZXQgKTtcblxuXHR9XG5cblx0Y29uc3QgYnVmZmVyU3RhY2sgPSBbXTtcblx0bGV0IF9wcmV2QnVmZmVyO1xuXHRsZXQgX2Zsb2F0MzJBcnJheTtcblx0bGV0IF91aW50MTZBcnJheTtcblx0bGV0IF91aW50MzJBcnJheTtcblx0ZnVuY3Rpb24gc2V0QnVmZmVyKCBidWZmZXIgKSB7XG5cblx0XHRpZiAoIF9wcmV2QnVmZmVyICkge1xuXG5cdFx0XHRidWZmZXJTdGFjay5wdXNoKCBfcHJldkJ1ZmZlciApO1xuXG5cdFx0fVxuXG5cdFx0X3ByZXZCdWZmZXIgPSBidWZmZXI7XG5cdFx0X2Zsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRcdF91aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0X3VpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY2xlYXJCdWZmZXIoKSB7XG5cblx0XHRfcHJldkJ1ZmZlciA9IG51bGw7XG5cdFx0X2Zsb2F0MzJBcnJheSA9IG51bGw7XG5cdFx0X3VpbnQxNkFycmF5ID0gbnVsbDtcblx0XHRfdWludDMyQXJyYXkgPSBudWxsO1xuXG5cdFx0aWYgKCBidWZmZXJTdGFjay5sZW5ndGggKSB7XG5cblx0XHRcdHNldEJ1ZmZlciggYnVmZmVyU3RhY2sucG9wKCkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgU0tJUF9HRU5FUkFUSU9OID0gU3ltYm9sKCAnc2tpcCB0cmVlIGdlbmVyYXRpb24nICk7XG5cblx0Y29uc3QgYWFiYiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuQm94MygpO1xuXHRjb25zdCBhYWJiMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuQm94MygpO1xuXHRjb25zdCB0ZW1wTWF0cml4ID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5NYXRyaXg0KCk7XG5cdGNvbnN0IG9iYiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblx0Y29uc3Qgb2JiMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblx0Y29uc3QgdGVtcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wNCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wQm94ID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5Cb3gzKCk7XG5cdGNvbnN0IHRyaWFuZ2xlUG9vbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUHJpbWl0aXZlUG9vbCggKCkgPT4gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKSApO1xuXG5cdGNsYXNzIE1lc2hCVkgge1xuXG5cdFx0c3RhdGljIHNlcmlhbGl6ZSggYnZoLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRcdGlmICggb3B0aW9ucy5pc0J1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ01lc2hCVkguc2VyaWFsaXplOiBUaGUgYXJndW1lbnRzIGZvciB0aGUgZnVuY3Rpb24gaGF2ZSBjaGFuZ2VkLiBTZWUgZG9jdW1lbnRhdGlvbiBmb3IgbmV3IHNpZ25hdHVyZS4nICk7XG5cblx0XHRcdFx0cmV0dXJuIE1lc2hCVkguc2VyaWFsaXplKFxuXHRcdFx0XHRcdGFyZ3VtZW50c1sgMCBdLFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNsb25lQnVmZmVyczogYXJndW1lbnRzWyAyIF0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbIDIgXSxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdFx0b3B0aW9ucyA9IHtcblx0XHRcdFx0Y2xvbmVCdWZmZXJzOiB0cnVlLFxuXHRcdFx0XHQuLi5vcHRpb25zLFxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCByb290RGF0YSA9IGJ2aC5fcm9vdHM7XG5cdFx0XHRjb25zdCBpbmRleEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cdFx0XHRsZXQgcmVzdWx0O1xuXHRcdFx0aWYgKCBvcHRpb25zLmNsb25lQnVmZmVycyApIHtcblxuXHRcdFx0XHRyZXN1bHQgPSB7XG5cdFx0XHRcdFx0cm9vdHM6IHJvb3REYXRhLm1hcCggcm9vdCA9PiByb290LnNsaWNlKCkgKSxcblx0XHRcdFx0XHRpbmRleDogaW5kZXhBdHRyaWJ1dGUuYXJyYXkuc2xpY2UoKSxcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXN1bHQgPSB7XG5cdFx0XHRcdFx0cm9vdHM6IHJvb3REYXRhLFxuXHRcdFx0XHRcdGluZGV4OiBpbmRleEF0dHJpYnV0ZS5hcnJheSxcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdFx0c3RhdGljIGRlc2VyaWFsaXplKCBkYXRhLCBnZW9tZXRyeSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnTWVzaEJWSC5kZXNlcmlhbGl6ZTogVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGZ1bmN0aW9uIGhhdmUgY2hhbmdlZC4gU2VlIGRvY3VtZW50YXRpb24gZm9yIG5ldyBzaWduYXR1cmUuJyApO1xuXG5cdFx0XHRcdHJldHVybiBNZXNoQlZILmRlc2VyaWFsaXplKFxuXHRcdFx0XHRcdGFyZ3VtZW50c1sgMCBdLFxuXHRcdFx0XHRcdGFyZ3VtZW50c1sgMSBdLFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHNldEluZGV4OiBhcmd1bWVudHNbIDIgXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sgMiBdLFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvcHRpb25zID0ge1xuXHRcdFx0XHRzZXRJbmRleDogdHJ1ZSxcblx0XHRcdFx0Li4ub3B0aW9ucyxcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IHsgaW5kZXgsIHJvb3RzIH0gPSBkYXRhO1xuXHRcdFx0Y29uc3QgYnZoID0gbmV3IE1lc2hCVkgoIGdlb21ldHJ5LCB7IC4uLm9wdGlvbnMsIFsgU0tJUF9HRU5FUkFUSU9OIF06IHRydWUgfSApO1xuXHRcdFx0YnZoLl9yb290cyA9IHJvb3RzO1xuXG5cdFx0XHRpZiAoIG9wdGlvbnMuc2V0SW5kZXggKSB7XG5cblx0XHRcdFx0Y29uc3QgaW5kZXhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRcdFx0XHRpZiAoIGluZGV4QXR0cmlidXRlID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbmV3SW5kZXggPSBuZXcgdGhyZWUuQnVmZmVyQXR0cmlidXRlKCBkYXRhLmluZGV4LCAxLCBmYWxzZSApO1xuXHRcdFx0XHRcdGdlb21ldHJ5LnNldEluZGV4KCBuZXdJbmRleCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGluZGV4QXR0cmlidXRlLmFycmF5ICE9PSBpbmRleCApIHtcblxuXHRcdFx0XHRcdGluZGV4QXR0cmlidXRlLmFycmF5LnNldCggaW5kZXggKTtcblx0XHRcdFx0XHRpbmRleEF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidmg7XG5cblx0XHR9XG5cblx0XHRjb25zdHJ1Y3RvciggZ2VvbWV0cnksIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdFx0aWYgKCAhIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTWVzaEJWSDogT25seSBCdWZmZXJHZW9tZXRyaWVzIGFyZSBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5pbmRleCAmJiBnZW9tZXRyeS5pbmRleC5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ01lc2hCVkg6IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoZSBpbmRleCBhdHRyaWJ1dGUuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGRlZmF1bHQgb3B0aW9uc1xuXHRcdFx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oIHtcblxuXHRcdFx0XHRzdHJhdGVneTogQ0VOVEVSLFxuXHRcdFx0XHRtYXhEZXB0aDogNDAsXG5cdFx0XHRcdG1heExlYWZUcmlzOiAxMCxcblx0XHRcdFx0dmVyYm9zZTogdHJ1ZSxcblx0XHRcdFx0dXNlU2hhcmVkQXJyYXlCdWZmZXI6IGZhbHNlLFxuXHRcdFx0XHRzZXRCb3VuZGluZ0JveDogdHJ1ZSxcblx0XHRcdFx0b25Qcm9ncmVzczogbnVsbCxcblxuXHRcdFx0XHQvLyB1bmRvY3VtZW50ZWQgb3B0aW9uc1xuXG5cdFx0XHRcdC8vIFdoZXRoZXIgdG8gc2tpcCBnZW5lcmF0aW5nIHRoZSB0cmVlLiBVc2VkIGZvciBkZXNlcmlhbGl6YXRpb24uXG5cdFx0XHRcdFsgU0tJUF9HRU5FUkFUSU9OIF06IGZhbHNlLFxuXG5cdFx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRcdGlmICggb3B0aW9ucy51c2VTaGFyZWRBcnJheUJ1ZmZlciAmJiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ01lc2hCVkg6IFNoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhdmFpbGFibGUuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3Jvb3RzID0gbnVsbDtcblx0XHRcdGlmICggISBvcHRpb25zWyBTS0lQX0dFTkVSQVRJT04gXSApIHtcblxuXHRcdFx0XHR0aGlzLl9yb290cyA9IGJ1aWxkUGFja2VkVHJlZSggZ2VvbWV0cnksIG9wdGlvbnMgKTtcblxuXHRcdFx0XHRpZiAoICEgZ2VvbWV0cnkuYm91bmRpbmdCb3ggJiYgb3B0aW9ucy5zZXRCb3VuZGluZ0JveCApIHtcblxuXHRcdFx0XHRcdGdlb21ldHJ5LmJvdW5kaW5nQm94ID0gdGhpcy5nZXRCb3VuZGluZ0JveCggbmV3IHRocmVlLkJveDMoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZXRhaW4gcmVmZXJlbmNlcyB0byB0aGUgZ2VvbWV0cnkgc28gd2UgY2FuIHVzZSB0aGVtIGl0IHdpdGhvdXQgaGF2aW5nIHRvXG5cdFx0XHQvLyB0YWtlIGEgZ2VvbWV0cnkgcmVmZXJlbmNlIGluIGV2ZXJ5IGZ1bmN0aW9uLlxuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0cmVmaXQoIG5vZGVJbmRpY2VzID0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCBub2RlSW5kaWNlcyAmJiBBcnJheS5pc0FycmF5KCBub2RlSW5kaWNlcyApICkge1xuXG5cdFx0XHRcdG5vZGVJbmRpY2VzID0gbmV3IFNldCggbm9kZUluZGljZXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBpbmRleEFyciA9IGdlb21ldHJ5LmluZGV4LmFycmF5O1xuXHRcdFx0Y29uc3QgcG9zQXR0ciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGxldCBidWZmZXIsIHVpbnQzMkFycmF5LCB1aW50MTZBcnJheSwgZmxvYXQzMkFycmF5O1xuXHRcdFx0bGV0IGJ5dGVPZmZzZXQgPSAwO1xuXHRcdFx0Y29uc3Qgcm9vdHMgPSB0aGlzLl9yb290cztcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YnVmZmVyID0gcm9vdHNbIGkgXTtcblx0XHRcdFx0dWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRcdFx0XHR1aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0XHRcdGZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciApO1xuXG5cdFx0XHRcdF90cmF2ZXJzZSggMCwgYnl0ZU9mZnNldCApO1xuXHRcdFx0XHRieXRlT2Zmc2V0ICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIF90cmF2ZXJzZSggbm9kZTMySW5kZXgsIGJ5dGVPZmZzZXQsIGZvcmNlID0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Y29uc3Qgbm9kZTE2SW5kZXggPSBub2RlMzJJbmRleCAqIDI7XG5cdFx0XHRcdGNvbnN0IGlzTGVhZiA9IHVpbnQxNkFycmF5WyBub2RlMTZJbmRleCArIDE1IF0gPT09IElTX0xFQUZOT0RFX0ZMQUc7XG5cdFx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gdWludDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNiBdO1xuXHRcdFx0XHRcdGNvbnN0IGNvdW50ID0gdWludDE2QXJyYXlbIG5vZGUxNkluZGV4ICsgMTQgXTtcblxuXHRcdFx0XHRcdGxldCBtaW54ID0gSW5maW5pdHk7XG5cdFx0XHRcdFx0bGV0IG1pbnkgPSBJbmZpbml0eTtcblx0XHRcdFx0XHRsZXQgbWlueiA9IEluZmluaXR5O1xuXHRcdFx0XHRcdGxldCBtYXh4ID0gLSBJbmZpbml0eTtcblx0XHRcdFx0XHRsZXQgbWF4eSA9IC0gSW5maW5pdHk7XG5cdFx0XHRcdFx0bGV0IG1heHogPSAtIEluZmluaXR5O1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAzICogb2Zmc2V0LCBsID0gMyAqICggb2Zmc2V0ICsgY291bnQgKTsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gaW5kZXhBcnJbIGkgXTtcblx0XHRcdFx0XHRcdGNvbnN0IHggPSBwb3NBdHRyLmdldFgoIGluZGV4ICk7XG5cdFx0XHRcdFx0XHRjb25zdCB5ID0gcG9zQXR0ci5nZXRZKCBpbmRleCApO1xuXHRcdFx0XHRcdFx0Y29uc3QgeiA9IHBvc0F0dHIuZ2V0WiggaW5kZXggKTtcblxuXHRcdFx0XHRcdFx0aWYgKCB4IDwgbWlueCApIG1pbnggPSB4O1xuXHRcdFx0XHRcdFx0aWYgKCB4ID4gbWF4eCApIG1heHggPSB4O1xuXG5cdFx0XHRcdFx0XHRpZiAoIHkgPCBtaW55ICkgbWlueSA9IHk7XG5cdFx0XHRcdFx0XHRpZiAoIHkgPiBtYXh5ICkgbWF4eSA9IHk7XG5cblx0XHRcdFx0XHRcdGlmICggeiA8IG1pbnogKSBtaW56ID0gejtcblx0XHRcdFx0XHRcdGlmICggeiA+IG1heHogKSBtYXh6ID0gejtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAwIF0gIT09IG1pbnggfHxcblx0XHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAxIF0gIT09IG1pbnkgfHxcblx0XHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAyIF0gIT09IG1pbnogfHxcblxuXHRcdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDMgXSAhPT0gbWF4eCB8fFxuXHRcdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDQgXSAhPT0gbWF4eSB8fFxuXHRcdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDUgXSAhPT0gbWF4elxuXHRcdFx0XHRcdCkge1xuXG5cdFx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMCBdID0gbWlueDtcblx0XHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAxIF0gPSBtaW55O1xuXHRcdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDIgXSA9IG1pbno7XG5cblx0XHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAzIF0gPSBtYXh4O1xuXHRcdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDQgXSA9IG1heHk7XG5cdFx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNSBdID0gbWF4ejtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnN0IGxlZnQgPSBub2RlMzJJbmRleCArIDg7XG5cdFx0XHRcdFx0Y29uc3QgcmlnaHQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cblx0XHRcdFx0XHQvLyB0aGUgaWRlbnRpZnlpbmcgbm9kZSBpbmRpY2VzIHByb3ZpZGVkIGJ5IHRoZSBzaGFwZWNhc3QgZnVuY3Rpb24gaW5jbHVkZSBvZmZzZXRzIG9mIGFsbFxuXHRcdFx0XHRcdC8vIHJvb3QgYnVmZmVycyB0byBndWFyYW50ZWUgdGhleSdyZSB1bmlxdWUgYmV0d2VlbiByb290cyBzbyBvZmZzZXQgbGVmdCBhbmQgcmlnaHQgaW5kaWNlcyBoZXJlLlxuXHRcdFx0XHRcdGNvbnN0IG9mZnNldExlZnQgPSBsZWZ0ICsgYnl0ZU9mZnNldDtcblx0XHRcdFx0XHRjb25zdCBvZmZzZXRSaWdodCA9IHJpZ2h0ICsgYnl0ZU9mZnNldDtcblx0XHRcdFx0XHRsZXQgZm9yY2VDaGlsZHJlbiA9IGZvcmNlO1xuXHRcdFx0XHRcdGxldCBpbmNsdWRlc0xlZnQgPSBmYWxzZTtcblx0XHRcdFx0XHRsZXQgaW5jbHVkZXNSaWdodCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBub2RlSW5kaWNlcyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgd2Ugc2VlIHRoYXQgbmVpdGhlciB0aGUgbGVmdCBvciByaWdodCBjaGlsZCBhcmUgaW5jbHVkZWQgaW4gdGhlIHNldCB0aGF0IG5lZWQgdG8gYmUgdXBkYXRlZFxuXHRcdFx0XHRcdFx0Ly8gdGhlbiB3ZSBhc3N1bWUgdGhhdCBhbGwgY2hpbGRyZW4gbmVlZCB0byBiZSB1cGRhdGVkLlxuXHRcdFx0XHRcdFx0aWYgKCAhIGZvcmNlQ2hpbGRyZW4gKSB7XG5cblx0XHRcdFx0XHRcdFx0aW5jbHVkZXNMZWZ0ID0gbm9kZUluZGljZXMuaGFzKCBvZmZzZXRMZWZ0ICk7XG5cdFx0XHRcdFx0XHRcdGluY2x1ZGVzUmlnaHQgPSBub2RlSW5kaWNlcy5oYXMoIG9mZnNldFJpZ2h0ICk7XG5cdFx0XHRcdFx0XHRcdGZvcmNlQ2hpbGRyZW4gPSAhIGluY2x1ZGVzTGVmdCAmJiAhIGluY2x1ZGVzUmlnaHQ7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGluY2x1ZGVzTGVmdCA9IHRydWU7XG5cdFx0XHRcdFx0XHRpbmNsdWRlc1JpZ2h0ID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHRyYXZlcnNlTGVmdCA9IGZvcmNlQ2hpbGRyZW4gfHwgaW5jbHVkZXNMZWZ0O1xuXHRcdFx0XHRcdGNvbnN0IHRyYXZlcnNlUmlnaHQgPSBmb3JjZUNoaWxkcmVuIHx8IGluY2x1ZGVzUmlnaHQ7XG5cblx0XHRcdFx0XHRsZXQgbGVmdENoYW5nZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmICggdHJhdmVyc2VMZWZ0ICkge1xuXG5cdFx0XHRcdFx0XHRsZWZ0Q2hhbmdlID0gX3RyYXZlcnNlKCBsZWZ0LCBieXRlT2Zmc2V0LCBmb3JjZUNoaWxkcmVuICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZXQgcmlnaHRDaGFuZ2UgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAoIHRyYXZlcnNlUmlnaHQgKSB7XG5cblx0XHRcdFx0XHRcdHJpZ2h0Q2hhbmdlID0gX3RyYXZlcnNlKCByaWdodCwgYnl0ZU9mZnNldCwgZm9yY2VDaGlsZHJlbiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29uc3QgZGlkQ2hhbmdlID0gbGVmdENoYW5nZSB8fCByaWdodENoYW5nZTtcblx0XHRcdFx0XHRpZiAoIGRpZENoYW5nZSApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBsZWZ0aSA9IGxlZnQgKyBpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCByaWdodGkgPSByaWdodCArIGk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG1pbkxlZnRWYWx1ZSA9IGZsb2F0MzJBcnJheVsgbGVmdGkgXTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWF4TGVmdFZhbHVlID0gZmxvYXQzMkFycmF5WyBsZWZ0aSArIDMgXTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWluUmlnaHRWYWx1ZSA9IGZsb2F0MzJBcnJheVsgcmlnaHRpIF07XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG1heFJpZ2h0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIHJpZ2h0aSArIDMgXTtcblxuXHRcdFx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgaSBdID0gbWluTGVmdFZhbHVlIDwgbWluUmlnaHRWYWx1ZSA/IG1pbkxlZnRWYWx1ZSA6IG1pblJpZ2h0VmFsdWU7XG5cdFx0XHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyBpICsgMyBdID0gbWF4TGVmdFZhbHVlID4gbWF4UmlnaHRWYWx1ZSA/IG1heExlZnRWYWx1ZSA6IG1heFJpZ2h0VmFsdWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBkaWRDaGFuZ2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0cmF2ZXJzZSggY2FsbGJhY2ssIHJvb3RJbmRleCA9IDAgKSB7XG5cblx0XHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3Jvb3RzWyByb290SW5kZXggXTtcblx0XHRcdGNvbnN0IHVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKTtcblx0XHRcdGNvbnN0IHVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCBidWZmZXIgKTtcblx0XHRcdF90cmF2ZXJzZSggMCApO1xuXG5cdFx0XHRmdW5jdGlvbiBfdHJhdmVyc2UoIG5vZGUzMkluZGV4LCBkZXB0aCA9IDAgKSB7XG5cblx0XHRcdFx0Y29uc3Qgbm9kZTE2SW5kZXggPSBub2RlMzJJbmRleCAqIDI7XG5cdFx0XHRcdGNvbnN0IGlzTGVhZiA9IHVpbnQxNkFycmF5WyBub2RlMTZJbmRleCArIDE1IF0gPT09IElTX0xFQUZOT0RFX0ZMQUc7XG5cdFx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gdWludDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNiBdO1xuXHRcdFx0XHRcdGNvbnN0IGNvdW50ID0gdWludDE2QXJyYXlbIG5vZGUxNkluZGV4ICsgMTQgXTtcblx0XHRcdFx0XHRjYWxsYmFjayggZGVwdGgsIGlzTGVhZiwgbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyLCBub2RlMzJJbmRleCAqIDQsIDYgKSwgb2Zmc2V0LCBjb3VudCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBUT0RPOiB1c2Ugbm9kZSBmdW5jdGlvbnMgaGVyZVxuXHRcdFx0XHRcdGNvbnN0IGxlZnQgPSBub2RlMzJJbmRleCArIEJZVEVTX1BFUl9OT0RFIC8gNDtcblx0XHRcdFx0XHRjb25zdCByaWdodCA9IHVpbnQzMkFycmF5WyBub2RlMzJJbmRleCArIDYgXTtcblx0XHRcdFx0XHRjb25zdCBzcGxpdEF4aXMgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA3IF07XG5cdFx0XHRcdFx0Y29uc3Qgc3RvcFRyYXZlcnNhbCA9IGNhbGxiYWNrKCBkZXB0aCwgaXNMZWFmLCBuZXcgRmxvYXQzMkFycmF5KCBidWZmZXIsIG5vZGUzMkluZGV4ICogNCwgNiApLCBzcGxpdEF4aXMgKTtcblxuXHRcdFx0XHRcdGlmICggISBzdG9wVHJhdmVyc2FsICkge1xuXG5cdFx0XHRcdFx0XHRfdHJhdmVyc2UoIGxlZnQsIGRlcHRoICsgMSApO1xuXHRcdFx0XHRcdFx0X3RyYXZlcnNlKCByaWdodCwgZGVwdGggKyAxICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvKiBDb3JlIENhc3QgRnVuY3Rpb25zICovXG5cdFx0cmF5Y2FzdCggcmF5LCBtYXRlcmlhbE9yU2lkZSA9IHRocmVlLkZyb250U2lkZSApIHtcblxuXHRcdFx0Y29uc3Qgcm9vdHMgPSB0aGlzLl9yb290cztcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IGludGVyc2VjdHMgPSBbXTtcblx0XHRcdGNvbnN0IGlzTWF0ZXJpYWwgPSBtYXRlcmlhbE9yU2lkZS5pc01hdGVyaWFsO1xuXHRcdFx0Y29uc3QgaXNBcnJheU1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggbWF0ZXJpYWxPclNpZGUgKTtcblxuXHRcdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXHRcdFx0Y29uc3Qgc2lkZSA9IGlzTWF0ZXJpYWwgPyBtYXRlcmlhbE9yU2lkZS5zaWRlIDogbWF0ZXJpYWxPclNpZGU7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSByb290cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsU2lkZSA9IGlzQXJyYXlNYXRlcmlhbCA/IG1hdGVyaWFsT3JTaWRlWyBncm91cHNbIGkgXS5tYXRlcmlhbEluZGV4IF0uc2lkZSA6IHNpZGU7XG5cdFx0XHRcdGNvbnN0IHN0YXJ0Q291bnQgPSBpbnRlcnNlY3RzLmxlbmd0aDtcblxuXHRcdFx0XHRzZXRCdWZmZXIoIHJvb3RzWyBpIF0gKTtcblx0XHRcdFx0cmF5Y2FzdCggMCwgZ2VvbWV0cnksIG1hdGVyaWFsU2lkZSwgcmF5LCBpbnRlcnNlY3RzICk7XG5cdFx0XHRcdGNsZWFyQnVmZmVyKCk7XG5cblx0XHRcdFx0aWYgKCBpc0FycmF5TWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbEluZGV4ID0gZ3JvdXBzWyBpIF0ubWF0ZXJpYWxJbmRleDtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IHN0YXJ0Q291bnQsIGpsID0gaW50ZXJzZWN0cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0c1sgaiBdLmZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG5cdFx0fVxuXG5cdFx0cmF5Y2FzdEZpcnN0KCByYXksIG1hdGVyaWFsT3JTaWRlID0gdGhyZWUuRnJvbnRTaWRlICkge1xuXG5cdFx0XHRjb25zdCByb290cyA9IHRoaXMuX3Jvb3RzO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3QgaXNNYXRlcmlhbCA9IG1hdGVyaWFsT3JTaWRlLmlzTWF0ZXJpYWw7XG5cdFx0XHRjb25zdCBpc0FycmF5TWF0ZXJpYWwgPSBBcnJheS5pc0FycmF5KCBtYXRlcmlhbE9yU2lkZSApO1xuXG5cdFx0XHRsZXQgY2xvc2VzdFJlc3VsdCA9IG51bGw7XG5cblx0XHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0XHRcdGNvbnN0IHNpZGUgPSBpc01hdGVyaWFsID8gbWF0ZXJpYWxPclNpZGUuc2lkZSA6IG1hdGVyaWFsT3JTaWRlO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBtYXRlcmlhbFNpZGUgPSBpc0FycmF5TWF0ZXJpYWwgPyBtYXRlcmlhbE9yU2lkZVsgZ3JvdXBzWyBpIF0ubWF0ZXJpYWxJbmRleCBdLnNpZGUgOiBzaWRlO1xuXG5cdFx0XHRcdHNldEJ1ZmZlciggcm9vdHNbIGkgXSApO1xuXHRcdFx0XHRjb25zdCByZXN1bHQgPSByYXljYXN0Rmlyc3QoIDAsIGdlb21ldHJ5LCBtYXRlcmlhbFNpZGUsIHJheSApO1xuXHRcdFx0XHRjbGVhckJ1ZmZlcigpO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ICE9IG51bGwgJiYgKCBjbG9zZXN0UmVzdWx0ID09IG51bGwgfHwgcmVzdWx0LmRpc3RhbmNlIDwgY2xvc2VzdFJlc3VsdC5kaXN0YW5jZSApICkge1xuXG5cdFx0XHRcdFx0Y2xvc2VzdFJlc3VsdCA9IHJlc3VsdDtcblx0XHRcdFx0XHRpZiAoIGlzQXJyYXlNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0cmVzdWx0LmZhY2UubWF0ZXJpYWxJbmRleCA9IGdyb3Vwc1sgaSBdLm1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjbG9zZXN0UmVzdWx0O1xuXG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c0dlb21ldHJ5KCBvdGhlckdlb21ldHJ5LCBnZW9tVG9NZXNoICkge1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRsZXQgcmVzdWx0ID0gZmFsc2U7XG5cdFx0XHRmb3IgKCBjb25zdCByb290IG9mIHRoaXMuX3Jvb3RzICkge1xuXG5cdFx0XHRcdHNldEJ1ZmZlciggcm9vdCApO1xuXHRcdFx0XHRyZXN1bHQgPSBpbnRlcnNlY3RzR2VvbWV0cnkoIDAsIGdlb21ldHJ5LCBvdGhlckdlb21ldHJ5LCBnZW9tVG9NZXNoICk7XG5cdFx0XHRcdGNsZWFyQnVmZmVyKCk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH1cblxuXHRcdHNoYXBlY2FzdCggY2FsbGJhY2tzLCBfaW50ZXJzZWN0c1RyaWFuZ2xlRnVuYywgX29yZGVyTm9kZXNGdW5jICkge1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrcyBpbnN0YW5jZW9mIEZ1bmN0aW9uICkge1xuXG5cdFx0XHRcdGlmICggX2ludGVyc2VjdHNUcmlhbmdsZUZ1bmMgKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0IHRoZSBwcmV2aW91cyBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdCBwcm92aWRlZCB0aHJlZSBzZXF1ZW50aWFsIGluZGV4IGJ1ZmZlclxuXHRcdFx0XHRcdC8vIGluZGljZXMgaGVyZS5cblx0XHRcdFx0XHRjb25zdCBvcmlnaW5hbFRyaWFuZ2xlRnVuYyA9IF9pbnRlcnNlY3RzVHJpYW5nbGVGdW5jO1xuXHRcdFx0XHRcdF9pbnRlcnNlY3RzVHJpYW5nbGVGdW5jID0gKCB0cmksIGluZGV4LCBjb250YWluZWQsIGRlcHRoICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBpMyA9IGluZGV4ICogMztcblx0XHRcdFx0XHRcdHJldHVybiBvcmlnaW5hbFRyaWFuZ2xlRnVuYyggdHJpLCBpMywgaTMgKyAxLCBpMyArIDIsIGNvbnRhaW5lZCwgZGVwdGggKTtcblxuXHRcdFx0XHRcdH07XG5cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2tzID0ge1xuXG5cdFx0XHRcdFx0Ym91bmRzVHJhdmVyc2VPcmRlcjogX29yZGVyTm9kZXNGdW5jLFxuXHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6IGNhbGxiYWNrcyxcblx0XHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6IF9pbnRlcnNlY3RzVHJpYW5nbGVGdW5jLFxuXHRcdFx0XHRcdGludGVyc2VjdHNSYW5nZTogbnVsbCxcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ01lc2hCVkg6IFNoYXBlY2FzdCBmdW5jdGlvbiBzaWduYXR1cmUgaGFzIGNoYW5nZWQgYW5kIG5vdyB0YWtlcyBhbiBvYmplY3Qgb2YgY2FsbGJhY2tzIGFzIGEgc2Vjb25kIGFyZ3VtZW50LiBTZWUgZG9jcyBmb3IgbmV3IHNpZ25hdHVyZS4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdHJpYW5nbGUgPSB0cmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdFx0XHRsZXQge1xuXHRcdFx0XHRib3VuZHNUcmF2ZXJzZU9yZGVyLFxuXHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzLFxuXHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2UsXG5cdFx0XHRcdGludGVyc2VjdHNUcmlhbmdsZSxcblx0XHRcdH0gPSBjYWxsYmFja3M7XG5cblx0XHRcdGlmICggaW50ZXJzZWN0c1JhbmdlICYmIGludGVyc2VjdHNUcmlhbmdsZSApIHtcblxuXHRcdFx0XHRjb25zdCBvcmlnaW5hbEludGVyc2VjdHNSYW5nZSA9IGludGVyc2VjdHNSYW5nZTtcblx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlID0gKCBvZmZzZXQsIGNvdW50LCBjb250YWluZWQsIGRlcHRoLCBub2RlSW5kZXggKSA9PiB7XG5cblx0XHRcdFx0XHRpZiAoICEgb3JpZ2luYWxJbnRlcnNlY3RzUmFuZ2UoIG9mZnNldCwgY291bnQsIGNvbnRhaW5lZCwgZGVwdGgsIG5vZGVJbmRleCApICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gaXRlcmF0ZU92ZXJUcmlhbmdsZXMoIG9mZnNldCwgY291bnQsIGdlb21ldHJ5LCBpbnRlcnNlY3RzVHJpYW5nbGUsIGNvbnRhaW5lZCwgZGVwdGgsIHRyaWFuZ2xlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCAhIGludGVyc2VjdHNSYW5nZSApIHtcblxuXHRcdFx0XHRpZiAoIGludGVyc2VjdHNUcmlhbmdsZSApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHNSYW5nZSA9ICggb2Zmc2V0LCBjb3VudCwgY29udGFpbmVkLCBkZXB0aCApID0+IHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZXJhdGVPdmVyVHJpYW5nbGVzKCBvZmZzZXQsIGNvdW50LCBnZW9tZXRyeSwgaW50ZXJzZWN0c1RyaWFuZ2xlLCBjb250YWluZWQsIGRlcHRoLCB0cmlhbmdsZSApO1xuXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlID0gKCBvZmZzZXQsIGNvdW50LCBjb250YWluZWQgKSA9PiB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBjb250YWluZWQ7XG5cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgcmVzdWx0ID0gZmFsc2U7XG5cdFx0XHRsZXQgYnl0ZU9mZnNldCA9IDA7XG5cdFx0XHRmb3IgKCBjb25zdCByb290IG9mIHRoaXMuX3Jvb3RzICkge1xuXG5cdFx0XHRcdHNldEJ1ZmZlciggcm9vdCApO1xuXHRcdFx0XHRyZXN1bHQgPSBzaGFwZWNhc3QoIDAsIGdlb21ldHJ5LCBpbnRlcnNlY3RzQm91bmRzLCBpbnRlcnNlY3RzUmFuZ2UsIGJvdW5kc1RyYXZlcnNlT3JkZXIsIGJ5dGVPZmZzZXQgKTtcblx0XHRcdFx0Y2xlYXJCdWZmZXIoKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRieXRlT2Zmc2V0ICs9IHJvb3QuYnl0ZUxlbmd0aDtcblxuXHRcdFx0fVxuXG5cdFx0XHR0cmlhbmdsZVBvb2wucmVsZWFzZVByaW1pdGl2ZSggdHJpYW5nbGUgKTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH1cblxuXHRcdGJ2aGNhc3QoIG90aGVyQnZoLCBtYXRyaXhUb0xvY2FsLCBjYWxsYmFja3MgKSB7XG5cblx0XHRcdC8vIEJWSENhc3QgZnVuY3Rpb24gZm9yIGludGVyc2VjdGluZyB0d28gQlZIcyBhZ2FpbnN0IGVhY2ggb3RoZXIuIFVsdGltYXRlbHkganVzdCB1c2VzIHR3byByZWN1cnNpdmUgc2hhcGVjYXN0IGNhbGxzIHJhdGhlclxuXHRcdFx0Ly8gdGhhbiBhbiBhcHByb2FjaCB0aGF0IHdhbGtzIGRvd24gdGhlIHRyZWUgKHNlZSBidmhjYXN0LmpzIGZpbGUgZm9yIG1vcmUgaW5mbykuXG5cblx0XHRcdGxldCB7XG5cdFx0XHRcdGludGVyc2VjdHNSYW5nZXMsXG5cdFx0XHRcdGludGVyc2VjdHNUcmlhbmdsZXMsXG5cdFx0XHR9ID0gY2FsbGJhY2tzO1xuXG5cdFx0XHRjb25zdCBpbmRleEF0dHIgPSB0aGlzLmdlb21ldHJ5LmluZGV4O1xuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRjb25zdCBvdGhlckluZGV4QXR0ciA9IG90aGVyQnZoLmdlb21ldHJ5LmluZGV4O1xuXHRcdFx0Y29uc3Qgb3RoZXJQb3NpdGlvbkF0dHIgPSBvdGhlckJ2aC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHR0ZW1wTWF0cml4LmNvcHkoIG1hdHJpeFRvTG9jYWwgKS5pbnZlcnQoKTtcblxuXHRcdFx0Y29uc3QgdHJpYW5nbGUgPSB0cmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdFx0XHRjb25zdCB0cmlhbmdsZTIgPSB0cmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cblx0XHRcdGlmICggaW50ZXJzZWN0c1RyaWFuZ2xlcyApIHtcblxuXHRcdFx0XHRmdW5jdGlvbiBpdGVyYXRlT3ZlckRvdWJsZVRyaWFuZ2xlcyggb2Zmc2V0MSwgY291bnQxLCBvZmZzZXQyLCBjb3VudDIsIGRlcHRoMSwgaW5kZXgxLCBkZXB0aDIsIGluZGV4MiApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpMiA9IG9mZnNldDIsIGwyID0gb2Zmc2V0MiArIGNvdW50MjsgaTIgPCBsMjsgaTIgKysgKSB7XG5cblx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTIsIGkyICogMywgb3RoZXJJbmRleEF0dHIsIG90aGVyUG9zaXRpb25BdHRyICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZTIuYS5hcHBseU1hdHJpeDQoIG1hdHJpeFRvTG9jYWwgKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5iLmFwcGx5TWF0cml4NCggbWF0cml4VG9Mb2NhbCApO1xuXHRcdFx0XHRcdFx0dHJpYW5nbGUyLmMuYXBwbHlNYXRyaXg0KCBtYXRyaXhUb0xvY2FsICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaTEgPSBvZmZzZXQxLCBsMSA9IG9mZnNldDEgKyBjb3VudDE7IGkxIDwgbDE7IGkxICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgaTEgKiAzLCBpbmRleEF0dHIsIHBvc2l0aW9uQXR0ciApO1xuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzVHJpYW5nbGVzKCB0cmlhbmdsZSwgdHJpYW5nbGUyLCBpMSwgaTIsIGRlcHRoMSwgaW5kZXgxLCBkZXB0aDIsIGluZGV4MiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaW50ZXJzZWN0c1JhbmdlcyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG9yaWdpbmFsSW50ZXJzZWN0c1JhbmdlcyA9IGludGVyc2VjdHNSYW5nZXM7XG5cdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlcyA9IGZ1bmN0aW9uICggb2Zmc2V0MSwgY291bnQxLCBvZmZzZXQyLCBjb3VudDIsIGRlcHRoMSwgaW5kZXgxLCBkZXB0aDIsIGluZGV4MiApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCAhIG9yaWdpbmFsSW50ZXJzZWN0c1Jhbmdlcyggb2Zmc2V0MSwgY291bnQxLCBvZmZzZXQyLCBjb3VudDIsIGRlcHRoMSwgaW5kZXgxLCBkZXB0aDIsIGluZGV4MiApICkge1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBpdGVyYXRlT3ZlckRvdWJsZVRyaWFuZ2xlcyggb2Zmc2V0MSwgY291bnQxLCBvZmZzZXQyLCBjb3VudDIsIGRlcHRoMSwgaW5kZXgxLCBkZXB0aDIsIGluZGV4MiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlcyA9IGl0ZXJhdGVPdmVyRG91YmxlVHJpYW5nbGVzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRvdGhlckJ2aC5nZXRCb3VuZGluZ0JveCggYWFiYjIgKTtcblx0XHRcdGFhYmIyLmFwcGx5TWF0cml4NCggbWF0cml4VG9Mb2NhbCApO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5zaGFwZWNhc3QoIHtcblxuXHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiBib3ggPT4gYWFiYjIuaW50ZXJzZWN0c0JveCggYm94ICksXG5cblx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlOiAoIG9mZnNldDEsIGNvdW50MSwgY29udGFpbmVkLCBkZXB0aDEsIG5vZGVJbmRleDEsIGJveCApID0+IHtcblxuXHRcdFx0XHRcdGFhYmIuY29weSggYm94ICk7XG5cdFx0XHRcdFx0YWFiYi5hcHBseU1hdHJpeDQoIHRlbXBNYXRyaXggKTtcblx0XHRcdFx0XHRyZXR1cm4gb3RoZXJCdmguc2hhcGVjYXN0KCB7XG5cblx0XHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6IGJveCA9PiBhYWJiLmludGVyc2VjdHNCb3goIGJveCApLFxuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2U6ICggb2Zmc2V0MiwgY291bnQyLCBjb250YWluZWQsIGRlcHRoMiwgbm9kZUluZGV4MiApID0+IHtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaW50ZXJzZWN0c1Jhbmdlcyggb2Zmc2V0MSwgY291bnQxLCBvZmZzZXQyLCBjb3VudDIsIGRlcHRoMSwgbm9kZUluZGV4MSwgZGVwdGgyLCBub2RlSW5kZXgyICk7XG5cblx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHRyaWFuZ2xlUG9vbC5yZWxlYXNlUHJpbWl0aXZlKCB0cmlhbmdsZSApO1xuXHRcdFx0dHJpYW5nbGVQb29sLnJlbGVhc2VQcmltaXRpdmUoIHRyaWFuZ2xlMiApO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH1cblxuXHRcdC8qIERlcml2ZWQgQ2FzdCBGdW5jdGlvbnMgKi9cblx0XHRpbnRlcnNlY3RzQm94KCBib3gsIGJveFRvTWVzaCApIHtcblxuXHRcdFx0b2JiLnNldCggYm94Lm1pbiwgYm94Lm1heCwgYm94VG9NZXNoICk7XG5cdFx0XHRvYmIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zaGFwZWNhc3QoXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiBib3ggPT4gb2JiLmludGVyc2VjdHNCb3goIGJveCApLFxuXHRcdFx0XHRcdGludGVyc2VjdHNUcmlhbmdsZTogdHJpID0+IG9iYi5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaSApXG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnNoYXBlY2FzdChcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6IGJveCA9PiBzcGhlcmUuaW50ZXJzZWN0c0JveCggYm94ICksXG5cdFx0XHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlOiB0cmkgPT4gdHJpLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApXG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHRjbG9zZXN0UG9pbnRUb0dlb21ldHJ5KCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCB0YXJnZXQxID0geyB9LCB0YXJnZXQyID0geyB9LCBtaW5UaHJlc2hvbGQgPSAwLCBtYXhUaHJlc2hvbGQgPSBJbmZpbml0eSApIHtcblxuXHRcdFx0aWYgKCAhIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3ggKSB7XG5cblx0XHRcdFx0b3RoZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvYmIuc2V0KCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1pbiwgb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveC5tYXgsIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdG9iYi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IHBvcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0Y29uc3Qgb3RoZXJQb3MgPSBvdGhlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBvdGhlckluZGV4ID0gb3RoZXJHZW9tZXRyeS5pbmRleDtcblx0XHRcdGNvbnN0IHRyaWFuZ2xlID0gdHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0Y29uc3QgdHJpYW5nbGUyID0gdHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXG5cdFx0XHRsZXQgdGVtcFRhcmdldDEgPSB0ZW1wMTtcblx0XHRcdGxldCB0ZW1wVGFyZ2V0RGVzdDEgPSB0ZW1wMjtcblx0XHRcdGxldCB0ZW1wVGFyZ2V0MiA9IG51bGw7XG5cdFx0XHRsZXQgdGVtcFRhcmdldERlc3QyID0gbnVsbDtcblxuXHRcdFx0aWYgKCB0YXJnZXQyICkge1xuXG5cdFx0XHRcdHRlbXBUYXJnZXQyID0gdGVtcDM7XG5cdFx0XHRcdHRlbXBUYXJnZXREZXN0MiA9IHRlbXA0O1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcblx0XHRcdGxldCBjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IG51bGw7XG5cdFx0XHRsZXQgY2xvc2VzdERpc3RhbmNlT3RoZXJUcmlJbmRleCA9IG51bGw7XG5cdFx0XHR0ZW1wTWF0cml4LmNvcHkoIGdlb21ldHJ5VG9CdmggKS5pbnZlcnQoKTtcblx0XHRcdG9iYjIubWF0cml4LmNvcHkoIHRlbXBNYXRyaXggKTtcblx0XHRcdHRoaXMuc2hhcGVjYXN0KFxuXHRcdFx0XHR7XG5cblx0XHRcdFx0XHRib3VuZHNUcmF2ZXJzZU9yZGVyOiBib3ggPT4ge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JiLmRpc3RhbmNlVG9Cb3goIGJveCApO1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6ICggYm94LCBpc0xlYWYsIHNjb3JlICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNjb3JlIDwgY2xvc2VzdERpc3RhbmNlICYmIHNjb3JlIDwgbWF4VGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHdlIGtub3cgdGhlIHRyaWFuZ2xlcyBvZiB0aGlzIGJvdW5kcyB3aWxsIGJlIGludGVyc2VjdGVkIG5leHQgdGhlblxuXHRcdFx0XHRcdFx0XHQvLyBzYXZlIHRoZSBib3VuZHMgdG8gdXNlIGR1cmluZyB0cmlhbmdsZSBjaGVja3MuXG5cdFx0XHRcdFx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0b2JiMi5taW4uY29weSggYm94Lm1pbiApO1xuXHRcdFx0XHRcdFx0XHRcdG9iYjIubWF4LmNvcHkoIGJveC5tYXggKTtcblx0XHRcdFx0XHRcdFx0XHRvYmIyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdGludGVyc2VjdHNSYW5nZTogKCBvZmZzZXQsIGNvdW50ICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgb3RoZXIgZ2VvbWV0cnkgaGFzIGEgYnZoIHRoZW4gdXNlIHRoZSBhY2NlbGVyYXRlZCBwYXRoIHdoZXJlIHdlIHVzZSBzaGFwZWNhc3QgdG8gZmluZFxuXHRcdFx0XHRcdFx0XHQvLyB0aGUgY2xvc2VzdCBib3VuZHMgaW4gdGhlIG90aGVyIGdlb21ldHJ5IHRvIGNoZWNrLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gb3RoZXJHZW9tZXRyeS5ib3VuZHNUcmVlLnNoYXBlY2FzdCgge1xuXHRcdFx0XHRcdFx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXI6IGJveCA9PiB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBvYmIyLmRpc3RhbmNlVG9Cb3goIGJveCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6ICggYm94LCBpc0xlYWYsIHNjb3JlICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gc2NvcmUgPCBjbG9zZXN0RGlzdGFuY2UgJiYgc2NvcmUgPCBtYXhUaHJlc2hvbGQ7XG5cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlOiAoIG90aGVyT2Zmc2V0LCBvdGhlckNvdW50ICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSBvdGhlck9mZnNldCAqIDMsIGwyID0gKCBvdGhlck9mZnNldCArIG90aGVyQ291bnQgKSAqIDM7IGkyIDwgbDI7IGkyICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgaTIsIG90aGVySW5kZXgsIG90aGVyUG9zICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5hLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYi5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQgKiAzLCBsID0gKCBvZmZzZXQgKyBjb3VudCApICogMzsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgaSwgaW5kZXgsIHBvcyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRpc3QgPSB0cmlhbmdsZS5kaXN0YW5jZVRvVHJpYW5nbGUoIHRyaWFuZ2xlMiwgdGVtcFRhcmdldDEsIHRlbXBUYXJnZXQyICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVGFyZ2V0RGVzdDEuY29weSggdGVtcFRhcmdldDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB0ZW1wVGFyZ2V0RGVzdDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QyLmNvcHkoIHRlbXBUYXJnZXQyICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlID0gZGlzdDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gaSAvIDM7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gaTIgLyAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gc3RvcCB0cmF2ZXJzYWwgaWYgd2UgZmluZCBhIHBvaW50IHRoYXQncyB1bmRlciB0aGUgZ2l2ZW4gdGhyZXNob2xkXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgbWluVGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBubyBib3VuZHMgdHJlZSB0aGVuIHdlJ2xsIGp1c3QgY2hlY2sgZXZlcnkgdHJpYW5nbGUuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHRyaUNvdW50ID0gb3RoZXJJbmRleCA/IG90aGVySW5kZXguY291bnQgOiBvdGhlclBvcy5jb3VudDtcblx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gMCwgbDIgPSB0cmlDb3VudDsgaTIgPCBsMjsgaTIgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTIsIGkyLCBvdGhlckluZGV4LCBvdGhlclBvcyApO1xuXHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5hLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5iLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5jLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCAqIDMsIGwgPSAoIG9mZnNldCArIGNvdW50ICkgKiAzOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIGksIGluZGV4LCBwb3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgZGlzdCA9IHRyaWFuZ2xlLmRpc3RhbmNlVG9UcmlhbmdsZSggdHJpYW5nbGUyLCB0ZW1wVGFyZ2V0MSwgdGVtcFRhcmdldDIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVGFyZ2V0RGVzdDEuY29weSggdGVtcFRhcmdldDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHRlbXBUYXJnZXREZXN0MiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0Mi5jb3B5KCB0ZW1wVGFyZ2V0MiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2UgPSBkaXN0O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IGkgLyAzO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gaTIgLyAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIHN0b3AgdHJhdmVyc2FsIGlmIHdlIGZpbmQgYSBwb2ludCB0aGF0J3MgdW5kZXIgdGhlIGdpdmVuIHRocmVzaG9sZFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgbWluVGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdH1cblxuXHRcdFx0KTtcblxuXHRcdFx0dHJpYW5nbGVQb29sLnJlbGVhc2VQcmltaXRpdmUoIHRyaWFuZ2xlICk7XG5cdFx0XHR0cmlhbmdsZVBvb2wucmVsZWFzZVByaW1pdGl2ZSggdHJpYW5nbGUyICk7XG5cblx0XHRcdGlmICggY2xvc2VzdERpc3RhbmNlID09PSBJbmZpbml0eSApIHJldHVybiBudWxsO1xuXG5cdFx0XHRpZiAoICEgdGFyZ2V0MS5wb2ludCApIHRhcmdldDEucG9pbnQgPSB0ZW1wVGFyZ2V0RGVzdDEuY2xvbmUoKTtcblx0XHRcdGVsc2UgdGFyZ2V0MS5wb2ludC5jb3B5KCB0ZW1wVGFyZ2V0RGVzdDEgKTtcblx0XHRcdHRhcmdldDEuZGlzdGFuY2UgPSBjbG9zZXN0RGlzdGFuY2UsXG5cdFx0XHR0YXJnZXQxLmZhY2VJbmRleCA9IGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4O1xuXG5cdFx0XHRpZiAoIHRhcmdldDIgKSB7XG5cblx0XHRcdFx0aWYgKCAhIHRhcmdldDIucG9pbnQgKSB0YXJnZXQyLnBvaW50ID0gdGVtcFRhcmdldERlc3QyLmNsb25lKCk7XG5cdFx0XHRcdGVsc2UgdGFyZ2V0Mi5wb2ludC5jb3B5KCB0ZW1wVGFyZ2V0RGVzdDIgKTtcblx0XHRcdFx0dGFyZ2V0Mi5wb2ludC5hcHBseU1hdHJpeDQoIHRlbXBNYXRyaXggKTtcblx0XHRcdFx0dGVtcFRhcmdldERlc3QxLmFwcGx5TWF0cml4NCggdGVtcE1hdHJpeCApO1xuXHRcdFx0XHR0YXJnZXQyLmRpc3RhbmNlID0gdGVtcFRhcmdldERlc3QxLnN1YiggdGFyZ2V0Mi5wb2ludCApLmxlbmd0aCgpO1xuXHRcdFx0XHR0YXJnZXQyLmZhY2VJbmRleCA9IGNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXg7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRhcmdldDE7XG5cblx0XHR9XG5cblx0XHRjbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGFyZ2V0ID0geyB9LCBtaW5UaHJlc2hvbGQgPSAwLCBtYXhUaHJlc2hvbGQgPSBJbmZpbml0eSApIHtcblxuXHRcdFx0Ly8gZWFybHkgb3V0IGlmIHVuZGVyIG1pblRocmVzaG9sZFxuXHRcdFx0Ly8gc2tpcCBjaGVja2luZyBpZiBvdmVyIG1heFRocmVzaG9sZFxuXHRcdFx0Ly8gc2V0IG1pblRocmVzaG9sZCA9IG1heFRocmVzaG9sZCB0byBxdWlja2x5IGNoZWNrIGlmIGEgcG9pbnQgaXMgd2l0aGluIGEgdGhyZXNob2xkXG5cdFx0XHQvLyByZXR1cm5zIEluZmluaXR5IGlmIG5vIHZhbHVlIGZvdW5kXG5cdFx0XHRjb25zdCBtaW5UaHJlc2hvbGRTcSA9IG1pblRocmVzaG9sZCAqIG1pblRocmVzaG9sZDtcblx0XHRcdGNvbnN0IG1heFRocmVzaG9sZFNxID0gbWF4VGhyZXNob2xkICogbWF4VGhyZXNob2xkO1xuXHRcdFx0bGV0IGNsb3Nlc3REaXN0YW5jZVNxID0gSW5maW5pdHk7XG5cdFx0XHRsZXQgY2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBudWxsO1xuXHRcdFx0dGhpcy5zaGFwZWNhc3QoXG5cblx0XHRcdFx0e1xuXG5cdFx0XHRcdFx0Ym91bmRzVHJhdmVyc2VPcmRlcjogYm94ID0+IHtcblxuXHRcdFx0XHRcdFx0dGVtcC5jb3B5KCBwb2ludCApLmNsYW1wKCBib3gubWluLCBib3gubWF4ICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGVtcC5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiAoIGJveCwgaXNMZWFmLCBzY29yZSApID0+IHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHNjb3JlIDwgY2xvc2VzdERpc3RhbmNlU3EgJiYgc2NvcmUgPCBtYXhUaHJlc2hvbGRTcTtcblxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6ICggdHJpLCB0cmlJbmRleCApID0+IHtcblxuXHRcdFx0XHRcdFx0dHJpLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCB0ZW1wICk7XG5cdFx0XHRcdFx0XHRjb25zdCBkaXN0U3EgPSBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGVtcCApO1xuXHRcdFx0XHRcdFx0aWYgKCBkaXN0U3EgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRcdFx0XHR0ZW1wMS5jb3B5KCB0ZW1wICk7XG5cdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdFNxO1xuXHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IHRyaUluZGV4O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggZGlzdFNxIDwgbWluVGhyZXNob2xkU3EgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdH1cblxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKCBjbG9zZXN0RGlzdGFuY2VTcSA9PT0gSW5maW5pdHkgKSByZXR1cm4gbnVsbDtcblxuXHRcdFx0Y29uc3QgY2xvc2VzdERpc3RhbmNlID0gTWF0aC5zcXJ0KCBjbG9zZXN0RGlzdGFuY2VTcSApO1xuXG5cdFx0XHRpZiAoICEgdGFyZ2V0LnBvaW50ICkgdGFyZ2V0LnBvaW50ID0gdGVtcDEuY2xvbmUoKTtcblx0XHRcdGVsc2UgdGFyZ2V0LnBvaW50LmNvcHkoIHRlbXAxICk7XG5cdFx0XHR0YXJnZXQuZGlzdGFuY2UgPSBjbG9zZXN0RGlzdGFuY2UsXG5cdFx0XHR0YXJnZXQuZmFjZUluZGV4ID0gY2xvc2VzdERpc3RhbmNlVHJpSW5kZXg7XG5cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cblx0XHR9XG5cblx0XHRnZXRCb3VuZGluZ0JveCggdGFyZ2V0ICkge1xuXG5cdFx0XHR0YXJnZXQubWFrZUVtcHR5KCk7XG5cblx0XHRcdGNvbnN0IHJvb3RzID0gdGhpcy5fcm9vdHM7XG5cdFx0XHRyb290cy5mb3JFYWNoKCBidWZmZXIgPT4ge1xuXG5cdFx0XHRcdGFycmF5VG9Cb3goIDAsIG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciApLCB0ZW1wQm94ICk7XG5cdFx0XHRcdHRhcmdldC51bmlvbiggdGVtcEJveCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IGJvdW5kaW5nQm94ID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5Cb3gzKCk7XG5cdGNsYXNzIE1lc2hCVkhSb290VmlzdWFsaXplciBleHRlbmRzIHRocmVlLk9iamVjdDNEIHtcblxuXHRcdGdldCBpc01lc2goKSB7XG5cblx0XHRcdHJldHVybiAhIHRoaXMuZGlzcGxheUVkZ2VzO1xuXG5cdFx0fVxuXG5cdFx0Z2V0IGlzTGluZVNlZ21lbnRzKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kaXNwbGF5RWRnZXM7XG5cblx0XHR9XG5cblx0XHRnZXQgaXNMaW5lKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kaXNwbGF5RWRnZXM7XG5cblx0XHR9XG5cblx0XHRjb25zdHJ1Y3RvciggbWVzaCwgbWF0ZXJpYWwsIGRlcHRoID0gMTAsIGdyb3VwID0gMCApIHtcblxuXHRcdFx0c3VwZXIoKTtcblxuXHRcdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IG5ldyB0aHJlZS5CdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0dGhpcy5uYW1lID0gJ01lc2hCVkhSb290VmlzdWFsaXplcic7XG5cdFx0XHR0aGlzLmRlcHRoID0gZGVwdGg7XG5cdFx0XHR0aGlzLmRpc3BsYXlQYXJlbnRzID0gZmFsc2U7XG5cdFx0XHR0aGlzLm1lc2ggPSBtZXNoO1xuXHRcdFx0dGhpcy5kaXNwbGF5RWRnZXMgPSB0cnVlO1xuXHRcdFx0dGhpcy5fZ3JvdXAgPSBncm91cDtcblxuXHRcdH1cblxuXHRcdHJheWNhc3QoKSB7fVxuXG5cdFx0dXBkYXRlKCkge1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBib3VuZHNUcmVlID0gdGhpcy5tZXNoLmdlb21ldHJ5LmJvdW5kc1RyZWU7XG5cdFx0XHRjb25zdCBncm91cCA9IHRoaXMuX2dyb3VwO1xuXHRcdFx0Z2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRpZiAoIGJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0Ly8gY291bnQgdGhlIG51bWJlciBvZiBib3VuZHMgcmVxdWlyZWRcblx0XHRcdFx0Y29uc3QgdGFyZ2V0RGVwdGggPSB0aGlzLmRlcHRoIC0gMTtcblx0XHRcdFx0Y29uc3QgZGlzcGxheVBhcmVudHMgPSB0aGlzLmRpc3BsYXlQYXJlbnRzO1xuXHRcdFx0XHRsZXQgYm91bmRzQ291bnQgPSAwO1xuXHRcdFx0XHRib3VuZHNUcmVlLnRyYXZlcnNlKCAoIGRlcHRoLCBpc0xlYWYgKSA9PiB7XG5cblx0XHRcdFx0XHRpZiAoIGRlcHRoID09PSB0YXJnZXREZXB0aCB8fCBpc0xlYWYgKSB7XG5cblx0XHRcdFx0XHRcdGJvdW5kc0NvdW50ICsrO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBkaXNwbGF5UGFyZW50cyApIHtcblxuXHRcdFx0XHRcdFx0Ym91bmRzQ291bnQgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSwgZ3JvdXAgKTtcblxuXHRcdFx0XHQvLyBmaWxsIGluIHRoZSBwb3NpdGlvbiBidWZmZXIgd2l0aCB0aGUgYm91bmRzIGNvcm5lcnNcblx0XHRcdFx0bGV0IHBvc0luZGV4ID0gMDtcblx0XHRcdFx0Y29uc3QgcG9zaXRpb25BcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKiAzICogYm91bmRzQ291bnQgKTtcblx0XHRcdFx0Ym91bmRzVHJlZS50cmF2ZXJzZSggKCBkZXB0aCwgaXNMZWFmLCBib3VuZGluZ0RhdGEgKSA9PiB7XG5cblx0XHRcdFx0XHRjb25zdCB0ZXJtaW5hdGUgPSBkZXB0aCA9PT0gdGFyZ2V0RGVwdGggfHwgaXNMZWFmO1xuXHRcdFx0XHRcdGlmICggdGVybWluYXRlIHx8IGRpc3BsYXlQYXJlbnRzICkge1xuXG5cdFx0XHRcdFx0XHRhcnJheVRvQm94KCAwLCBib3VuZGluZ0RhdGEsIGJvdW5kaW5nQm94ICk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHsgbWluLCBtYXggfSA9IGJvdW5kaW5nQm94O1xuXHRcdFx0XHRcdFx0Zm9yICggbGV0IHggPSAtIDE7IHggPD0gMTsgeCArPSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHhWYWwgPSB4IDwgMCA/IG1pbi54IDogbWF4Lng7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCB5ID0gLSAxOyB5IDw9IDE7IHkgKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHlWYWwgPSB5IDwgMCA/IG1pbi55IDogbWF4Lnk7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IHogPSAtIDE7IHogPD0gMTsgeiArPSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCB6VmFsID0geiA8IDAgPyBtaW4ueiA6IG1heC56O1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb25BcnJheVsgcG9zSW5kZXggKyAwIF0gPSB4VmFsO1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb25BcnJheVsgcG9zSW5kZXggKyAxIF0gPSB5VmFsO1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb25BcnJheVsgcG9zSW5kZXggKyAyIF0gPSB6VmFsO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRwb3NJbmRleCArPSAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGVybWluYXRlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sIGdyb3VwICk7XG5cblx0XHRcdFx0bGV0IGluZGV4QXJyYXk7XG5cdFx0XHRcdGxldCBpbmRpY2VzO1xuXHRcdFx0XHRpZiAoIHRoaXMuZGlzcGxheUVkZ2VzICkge1xuXG5cdFx0XHRcdFx0Ly8gZmlsbCBpbiB0aGUgaW5kZXggYnVmZmVyIHRvIHBvaW50IHRvIHRoZSBjb3JuZXIgcG9pbnRzXG5cdFx0XHRcdFx0aW5kaWNlcyA9IG5ldyBVaW50OEFycmF5KCBbXG5cdFx0XHRcdFx0XHQvLyB4IGF4aXNcblx0XHRcdFx0XHRcdDAsIDQsXG5cdFx0XHRcdFx0XHQxLCA1LFxuXHRcdFx0XHRcdFx0MiwgNixcblx0XHRcdFx0XHRcdDMsIDcsXG5cblx0XHRcdFx0XHRcdC8vIHkgYXhpc1xuXHRcdFx0XHRcdFx0MCwgMixcblx0XHRcdFx0XHRcdDEsIDMsXG5cdFx0XHRcdFx0XHQ0LCA2LFxuXHRcdFx0XHRcdFx0NSwgNyxcblxuXHRcdFx0XHRcdFx0Ly8geiBheGlzXG5cdFx0XHRcdFx0XHQwLCAxLFxuXHRcdFx0XHRcdFx0MiwgMyxcblx0XHRcdFx0XHRcdDQsIDUsXG5cdFx0XHRcdFx0XHQ2LCA3LFxuXHRcdFx0XHRcdF0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW5kaWNlcyA9IG5ldyBVaW50OEFycmF5KCBbXG5cblx0XHRcdFx0XHRcdC8vIFgtLCBYK1xuXHRcdFx0XHRcdFx0MCwgMSwgMixcblx0XHRcdFx0XHRcdDIsIDEsIDMsXG5cblx0XHRcdFx0XHRcdDQsIDYsIDUsXG5cdFx0XHRcdFx0XHQ2LCA3LCA1LFxuXG5cdFx0XHRcdFx0XHQvLyBZLSwgWStcblx0XHRcdFx0XHRcdDEsIDQsIDUsXG5cdFx0XHRcdFx0XHQwLCA0LCAxLFxuXG5cdFx0XHRcdFx0XHQyLCAzLCA2LFxuXHRcdFx0XHRcdFx0MywgNywgNixcblxuXHRcdFx0XHRcdFx0Ly8gWi0sIForXG5cdFx0XHRcdFx0XHQwLCAyLCA0LFxuXHRcdFx0XHRcdFx0MiwgNiwgNCxcblxuXHRcdFx0XHRcdFx0MSwgNSwgMyxcblx0XHRcdFx0XHRcdDMsIDUsIDcsXG5cblx0XHRcdFx0XHRdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggcG9zaXRpb25BcnJheS5sZW5ndGggPiA2NTUzNSApIHtcblxuXHRcdFx0XHRcdGluZGV4QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGluZGljZXMubGVuZ3RoICogYm91bmRzQ291bnQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW5kZXhBcnJheSA9IG5ldyBVaW50MTZBcnJheSggaW5kaWNlcy5sZW5ndGggKiBib3VuZHNDb3VudCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBpbmRleExlbmd0aCA9IGluZGljZXMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBib3VuZHNDb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHBvc09mZnNldCA9IGkgKiA4O1xuXHRcdFx0XHRcdGNvbnN0IGluZGV4T2Zmc2V0ID0gaSAqIGluZGV4TGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IGluZGV4TGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRpbmRleEFycmF5WyBpbmRleE9mZnNldCArIGogXSA9IHBvc09mZnNldCArIGluZGljZXNbIGogXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBnZW9tZXRyeVxuXHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleChcblx0XHRcdFx0XHRuZXcgdGhyZWUuQnVmZmVyQXR0cmlidXRlKCBpbmRleEFycmF5LCAxLCBmYWxzZSApLFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0J3Bvc2l0aW9uJyxcblx0XHRcdFx0XHRuZXcgdGhyZWUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkFycmF5LCAzLCBmYWxzZSApLFxuXHRcdFx0XHQpO1xuXHRcdFx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIE1lc2hCVkhWaXN1YWxpemVyIGV4dGVuZHMgdGhyZWUuR3JvdXAge1xuXG5cdFx0Z2V0IGNvbG9yKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5lZGdlTWF0ZXJpYWwuY29sb3I7XG5cblx0XHR9XG5cblx0XHRnZXQgb3BhY2l0eSgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZWRnZU1hdGVyaWFsLm9wYWNpdHk7XG5cblx0XHR9XG5cblx0XHRzZXQgb3BhY2l0eSggdiApIHtcblxuXHRcdFx0dGhpcy5lZGdlTWF0ZXJpYWwub3BhY2l0eSA9IHY7XG5cdFx0XHR0aGlzLm1lc2hNYXRlcmlhbC5vcGFjaXR5ID0gdjtcblxuXHRcdH1cblxuXHRcdGNvbnN0cnVjdG9yKCBtZXNoLCBkZXB0aCA9IDEwICkge1xuXG5cdFx0XHRzdXBlcigpO1xuXG5cdFx0XHR0aGlzLm5hbWUgPSAnTWVzaEJWSFZpc3VhbGl6ZXInO1xuXHRcdFx0dGhpcy5kZXB0aCA9IGRlcHRoO1xuXHRcdFx0dGhpcy5tZXNoID0gbWVzaDtcblx0XHRcdHRoaXMuZGlzcGxheVBhcmVudHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuZGlzcGxheUVkZ2VzID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3Jvb3RzID0gW107XG5cblx0XHRcdGNvbnN0IGVkZ2VNYXRlcmlhbCA9IG5ldyB0aHJlZS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuXHRcdFx0XHRjb2xvcjogMHgwMEZGODgsXG5cdFx0XHRcdHRyYW5zcGFyZW50OiB0cnVlLFxuXHRcdFx0XHRvcGFjaXR5OiAwLjMsXG5cdFx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxuXHRcdFx0fSApO1xuXG5cdFx0XHRjb25zdCBtZXNoTWF0ZXJpYWwgPSBuZXcgdGhyZWUuTWVzaEJhc2ljTWF0ZXJpYWwoIHtcblx0XHRcdFx0Y29sb3I6IDB4MDBGRjg4LFxuXHRcdFx0XHR0cmFuc3BhcmVudDogdHJ1ZSxcblx0XHRcdFx0b3BhY2l0eTogMC4zLFxuXHRcdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcblx0XHRcdH0gKTtcblxuXHRcdFx0bWVzaE1hdGVyaWFsLmNvbG9yID0gZWRnZU1hdGVyaWFsLmNvbG9yO1xuXG5cdFx0XHR0aGlzLmVkZ2VNYXRlcmlhbCA9IGVkZ2VNYXRlcmlhbDtcblx0XHRcdHRoaXMubWVzaE1hdGVyaWFsID0gbWVzaE1hdGVyaWFsO1xuXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0dXBkYXRlKCkge1xuXG5cdFx0XHRjb25zdCBidmggPSB0aGlzLm1lc2guZ2VvbWV0cnkuYm91bmRzVHJlZTtcblx0XHRcdGNvbnN0IHRvdGFsUm9vdHMgPSBidmggPyBidmguX3Jvb3RzLmxlbmd0aCA6IDA7XG5cdFx0XHR3aGlsZSAoIHRoaXMuX3Jvb3RzLmxlbmd0aCA+IHRvdGFsUm9vdHMgKSB7XG5cblx0XHRcdFx0Y29uc3Qgcm9vdCA9IHRoaXMuX3Jvb3RzLnBvcCgpO1xuXHRcdFx0XHRyb290Lmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRcdFx0dGhpcy5yZW1vdmUoIHJvb3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0b3RhbFJvb3RzOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggaSA+PSB0aGlzLl9yb290cy5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHRjb25zdCByb290ID0gbmV3IE1lc2hCVkhSb290VmlzdWFsaXplciggdGhpcy5tZXNoLCB0aGlzLmVkZ2VNYXRlcmlhbCwgdGhpcy5kZXB0aCwgaSApO1xuXHRcdFx0XHRcdHRoaXMuYWRkKCByb290ICk7XG5cdFx0XHRcdFx0dGhpcy5fcm9vdHMucHVzaCggcm9vdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCByb290ID0gdGhpcy5fcm9vdHNbIGkgXTtcblx0XHRcdFx0cm9vdC5kZXB0aCA9IHRoaXMuZGVwdGg7XG5cdFx0XHRcdHJvb3QubWVzaCA9IHRoaXMubWVzaDtcblx0XHRcdFx0cm9vdC5kaXNwbGF5UGFyZW50cyA9IHRoaXMuZGlzcGxheVBhcmVudHM7XG5cdFx0XHRcdHJvb3QuZGlzcGxheUVkZ2VzID0gdGhpcy5kaXNwbGF5RWRnZXM7XG5cdFx0XHRcdHJvb3QubWF0ZXJpYWwgPSB0aGlzLmRpc3BsYXlFZGdlcyA/IHRoaXMuZWRnZU1hdGVyaWFsIDogdGhpcy5tZXNoTWF0ZXJpYWw7XG5cdFx0XHRcdHJvb3QudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHVwZGF0ZU1hdHJpeFdvcmxkKCAuLi5hcmdzICkge1xuXG5cdFx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHRoaXMubWVzaC5wb3NpdGlvbiApO1xuXHRcdFx0dGhpcy5yb3RhdGlvbi5jb3B5KCB0aGlzLm1lc2gucm90YXRpb24gKTtcblx0XHRcdHRoaXMuc2NhbGUuY29weSggdGhpcy5tZXNoLnNjYWxlICk7XG5cblx0XHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCAuLi5hcmdzICk7XG5cblx0XHR9XG5cblx0XHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRcdHRoaXMuZGVwdGggPSBzb3VyY2UuZGVwdGg7XG5cdFx0XHR0aGlzLm1lc2ggPSBzb3VyY2UubWVzaDtcblxuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IE1lc2hCVkhWaXN1YWxpemVyKCB0aGlzLm1lc2gsIHRoaXMuZGVwdGggKTtcblxuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cblx0XHRcdHRoaXMuZWRnZU1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMubWVzaE1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjaGlsZHJlblsgaSBdLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBfYm94MSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuQm94MygpO1xuXHRjb25zdCBfYm94MiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuQm94MygpO1xuXHRjb25zdCBfdmVjID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cblx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI0ODMwMi9ob3ctdG8tZ2V0LXRoZS1zaXplLW9mLWEtamF2YXNjcmlwdC1vYmplY3Rcblx0ZnVuY3Rpb24gZ2V0UHJpbWl0aXZlU2l6ZSggZWwgKSB7XG5cblx0XHRzd2l0Y2ggKCB0eXBlb2YgZWwgKSB7XG5cblx0XHRcdGNhc2UgJ251bWJlcic6XG5cdFx0XHRcdHJldHVybiA4O1xuXHRcdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdFx0cmV0dXJuIGVsLmxlbmd0aCAqIDI7XG5cdFx0XHRjYXNlICdib29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIDQ7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gaXNUeXBlZEFycmF5KCBhcnIgKSB7XG5cblx0XHRjb25zdCByZWdleCA9IC8oVWludHxJbnR8RmxvYXQpKDh8MTZ8MzIpQXJyYXkvO1xuXHRcdHJldHVybiByZWdleC50ZXN0KCBhcnIuY29uc3RydWN0b3IubmFtZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRSb290RXh0cmVtZXMoIGJ2aCwgZ3JvdXAgKSB7XG5cblx0XHRjb25zdCByZXN1bHQgPSB7XG5cdFx0XHRub2RlQ291bnQ6IDAsXG5cdFx0XHRsZWFmTm9kZUNvdW50OiAwLFxuXG5cdFx0XHRkZXB0aDoge1xuXHRcdFx0XHRtaW46IEluZmluaXR5LCBtYXg6IC0gSW5maW5pdHlcblx0XHRcdH0sXG5cdFx0XHR0cmlzOiB7XG5cdFx0XHRcdG1pbjogSW5maW5pdHksIG1heDogLSBJbmZpbml0eVxuXHRcdFx0fSxcblx0XHRcdHNwbGl0czogWyAwLCAwLCAwIF0sXG5cdFx0XHRzdXJmYWNlQXJlYVNjb3JlOiAwLFxuXHRcdH07XG5cblx0XHRidmgudHJhdmVyc2UoICggZGVwdGgsIGlzTGVhZiwgYm91bmRpbmdEYXRhLCBvZmZzZXRPclNwbGl0LCBjb3VudCApID0+IHtcblxuXHRcdFx0Y29uc3QgbDAgPSBib3VuZGluZ0RhdGFbIDAgKyAzIF0gLSBib3VuZGluZ0RhdGFbIDAgXTtcblx0XHRcdGNvbnN0IGwxID0gYm91bmRpbmdEYXRhWyAxICsgMyBdIC0gYm91bmRpbmdEYXRhWyAxIF07XG5cdFx0XHRjb25zdCBsMiA9IGJvdW5kaW5nRGF0YVsgMiArIDMgXSAtIGJvdW5kaW5nRGF0YVsgMiBdO1xuXG5cdFx0XHRjb25zdCBzdXJmYWNlQXJlYSA9IDIgKiAoIGwwICogbDEgKyBsMSAqIGwyICsgbDIgKiBsMCApO1xuXG5cdFx0XHRyZXN1bHQubm9kZUNvdW50ICsrO1xuXHRcdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdFx0cmVzdWx0LmxlYWZOb2RlQ291bnQgKys7XG5cblx0XHRcdFx0cmVzdWx0LmRlcHRoLm1pbiA9IE1hdGgubWluKCBkZXB0aCwgcmVzdWx0LmRlcHRoLm1pbiApO1xuXHRcdFx0XHRyZXN1bHQuZGVwdGgubWF4ID0gTWF0aC5tYXgoIGRlcHRoLCByZXN1bHQuZGVwdGgubWF4ICk7XG5cblx0XHRcdFx0cmVzdWx0LnRyaXMubWluID0gTWF0aC5taW4oIGNvdW50LCByZXN1bHQudHJpcy5taW4gKTtcblx0XHRcdFx0cmVzdWx0LnRyaXMubWF4ID0gTWF0aC5tYXgoIGNvdW50LCByZXN1bHQudHJpcy5tYXggKTtcblxuXHRcdFx0XHRyZXN1bHQuc3VyZmFjZUFyZWFTY29yZSArPSBzdXJmYWNlQXJlYSAqIFRSSUFOR0xFX0lOVEVSU0VDVF9DT1NUICogY291bnQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVzdWx0LnNwbGl0c1sgb2Zmc2V0T3JTcGxpdCBdICsrO1xuXG5cdFx0XHRcdHJlc3VsdC5zdXJmYWNlQXJlYVNjb3JlICs9IHN1cmZhY2VBcmVhICogVFJBVkVSU0FMX0NPU1Q7XG5cblx0XHRcdH1cblxuXHRcdH0sIGdyb3VwICk7XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgbm8gbGVhZiBub2RlcyBiZWNhdXNlIHRoZSB0cmVlIGhhc24ndCBmaW5pc2hlZCBnZW5lcmF0aW5nIHlldC5cblx0XHRpZiAoIHJlc3VsdC50cmlzLm1pbiA9PT0gSW5maW5pdHkgKSB7XG5cblx0XHRcdHJlc3VsdC50cmlzLm1pbiA9IDA7XG5cdFx0XHRyZXN1bHQudHJpcy5tYXggPSAwO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCByZXN1bHQuZGVwdGgubWluID09PSBJbmZpbml0eSApIHtcblxuXHRcdFx0cmVzdWx0LmRlcHRoLm1pbiA9IDA7XG5cdFx0XHRyZXN1bHQuZGVwdGgubWF4ID0gMDtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEJWSEV4dHJlbWVzKCBidmggKSB7XG5cblx0XHRyZXR1cm4gYnZoLl9yb290cy5tYXAoICggcm9vdCwgaSApID0+IGdldFJvb3RFeHRyZW1lcyggYnZoLCBpICkgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZXN0aW1hdGVNZW1vcnlJbkJ5dGVzKCBvYmogKSB7XG5cblx0XHRjb25zdCB0cmF2ZXJzZWQgPSBuZXcgU2V0KCk7XG5cdFx0Y29uc3Qgc3RhY2sgPSBbIG9iaiBdO1xuXHRcdGxldCBieXRlcyA9IDA7XG5cblx0XHR3aGlsZSAoIHN0YWNrLmxlbmd0aCApIHtcblxuXHRcdFx0Y29uc3QgY3VyciA9IHN0YWNrLnBvcCgpO1xuXHRcdFx0aWYgKCB0cmF2ZXJzZWQuaGFzKCBjdXJyICkgKSB7XG5cblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0dHJhdmVyc2VkLmFkZCggY3VyciApO1xuXG5cdFx0XHRmb3IgKCBsZXQga2V5IGluIGN1cnIgKSB7XG5cblx0XHRcdFx0aWYgKCAhIGN1cnIuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJ5dGVzICs9IGdldFByaW1pdGl2ZVNpemUoIGtleSApO1xuXG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gY3Vyclsga2V5IF07XG5cdFx0XHRcdGlmICggdmFsdWUgJiYgKCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBpc1R5cGVkQXJyYXkoIHZhbHVlICkgKSB7XG5cblx0XHRcdFx0XHRcdGJ5dGVzICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICkge1xuXG5cdFx0XHRcdFx0XHRieXRlcyArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c3RhY2sucHVzaCggdmFsdWUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ynl0ZXMgKz0gZ2V0UHJpbWl0aXZlU2l6ZSggdmFsdWUgKTtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJ5dGVzO1xuXG5cdH1cblxuXHRmdW5jdGlvbiB2YWxpZGF0ZUJvdW5kcyggYnZoICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdFx0Y29uc3QgZGVwdGhTdGFjayA9IFtdO1xuXHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0XHRsZXQgcGFzc2VzID0gdHJ1ZTtcblxuXHRcdGJ2aC50cmF2ZXJzZSggKCBkZXB0aCwgaXNMZWFmLCBib3VuZGluZ0RhdGEsIG9mZnNldCwgY291bnQgKSA9PiB7XG5cblx0XHRcdGNvbnN0IGluZm8gPSB7XG5cdFx0XHRcdGRlcHRoLFxuXHRcdFx0XHRpc0xlYWYsXG5cdFx0XHRcdGJvdW5kaW5nRGF0YSxcblx0XHRcdFx0b2Zmc2V0LFxuXHRcdFx0XHRjb3VudCxcblx0XHRcdH07XG5cdFx0XHRkZXB0aFN0YWNrWyBkZXB0aCBdID0gaW5mbztcblxuXHRcdFx0YXJyYXlUb0JveCggMCwgYm91bmRpbmdEYXRhLCBfYm94MSApO1xuXHRcdFx0Y29uc3QgcGFyZW50ID0gZGVwdGhTdGFja1sgZGVwdGggLSAxIF07XG5cblx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdC8vIGNoZWNrIHRyaWFuZ2xlc1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCAqIDMsIGwgPSAoIG9mZnNldCArIGNvdW50ICkgKiAzOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgaTAgPSBpbmRleC5nZXRYKCBpICk7XG5cdFx0XHRcdFx0Y29uc3QgaTEgPSBpbmRleC5nZXRYKCBpICsgMSApO1xuXHRcdFx0XHRcdGNvbnN0IGkyID0gaW5kZXguZ2V0WCggaSArIDIgKTtcblxuXHRcdFx0XHRcdGxldCBpc0NvbnRhaW5lZDtcblxuXHRcdFx0XHRcdF92ZWMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGkwICk7XG5cdFx0XHRcdFx0aXNDb250YWluZWQgPSBfYm94MS5jb250YWluc1BvaW50KCBfdmVjICk7XG5cblx0XHRcdFx0XHRfdmVjLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpMSApO1xuXHRcdFx0XHRcdGlzQ29udGFpbmVkID0gaXNDb250YWluZWQgJiYgX2JveDEuY29udGFpbnNQb2ludCggX3ZlYyApO1xuXG5cdFx0XHRcdFx0X3ZlYy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaTIgKTtcblx0XHRcdFx0XHRpc0NvbnRhaW5lZCA9IGlzQ29udGFpbmVkICYmIF9ib3gxLmNvbnRhaW5zUG9pbnQoIF92ZWMgKTtcblxuXHRcdFx0XHRcdGNvbnNvbGUuYXNzZXJ0KCBpc0NvbnRhaW5lZCwgJ0xlYWYgYm91bmRzIGRvZXMgbm90IGZ1bGx5IGNvbnRhaW4gdHJpYW5nbGUuJyApO1xuXHRcdFx0XHRcdHBhc3NlcyA9IHBhc3NlcyAmJiBpc0NvbnRhaW5lZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgbXkgYm91bmRzIGZpdCBpbiBteSBwYXJlbnRzXG5cdFx0XHRcdGFycmF5VG9Cb3goIDAsIGJvdW5kaW5nRGF0YSwgX2JveDIgKTtcblxuXHRcdFx0XHRjb25zdCBpc0NvbnRhaW5lZCA9IF9ib3gyLmNvbnRhaW5zQm94KCBfYm94MSApO1xuXHRcdFx0XHRjb25zb2xlLmFzc2VydCggaXNDb250YWluZWQsICdQYXJlbnQgYm91bmRzIGRvZXMgbm90IGZ1bGx5IGNvbnRhaW4gY2hpbGQuJyApO1xuXHRcdFx0XHRwYXNzZXMgPSBwYXNzZXMgJiYgaXNDb250YWluZWQ7XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdHJldHVybiBwYXNzZXM7XG5cblx0fVxuXG5cdC8vIFJldHVybnMgYSBzaW1wbGUsIGh1bWFuIHJlYWRhYmxlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIEJWSC5cblx0ZnVuY3Rpb24gZ2V0SlNPTlN0cnVjdHVyZSggYnZoICkge1xuXG5cdFx0Y29uc3QgZGVwdGhTdGFjayA9IFtdO1xuXG5cdFx0YnZoLnRyYXZlcnNlKCAoIGRlcHRoLCBpc0xlYWYsIGJvdW5kaW5nRGF0YSwgb2Zmc2V0LCBjb3VudCApID0+IHtcblxuXHRcdFx0Y29uc3QgaW5mbyA9IHtcblx0XHRcdFx0Ym91bmRzOiBhcnJheVRvQm94KCAwLCBib3VuZGluZ0RhdGEsIG5ldyB0aHJlZS5Cb3gzKCkgKSxcblx0XHRcdH07XG5cblx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdGluZm8uY291bnQgPSBjb3VudDtcblx0XHRcdFx0aW5mby5vZmZzZXQgPSBvZmZzZXQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aW5mby5sZWZ0ID0gbnVsbDtcblx0XHRcdFx0aW5mby5yaWdodCA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdFx0ZGVwdGhTdGFja1sgZGVwdGggXSA9IGluZm87XG5cblx0XHRcdC8vIHRyYXZlcnNhbCBoaXRzIHRoZSBsZWZ0IHRoZW4gcmlnaHQgbm9kZVxuXHRcdFx0Y29uc3QgcGFyZW50ID0gZGVwdGhTdGFja1sgZGVwdGggLSAxIF07XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5sZWZ0ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0cGFyZW50LmxlZnQgPSBpbmZvO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwYXJlbnQucmlnaHQgPSBpbmZvO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIGRlcHRoU3RhY2tbIDAgXTtcblxuXHR9XG5cblx0Y29uc3QgcmF5ID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5SYXkoKTtcblx0Y29uc3QgdG1wSW52ZXJzZU1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuTWF0cml4NCgpO1xuXHRjb25zdCBvcmlnTWVzaFJheWNhc3RGdW5jID0gdGhyZWUuTWVzaC5wcm90b3R5cGUucmF5Y2FzdDtcblxuXHRmdW5jdGlvbiBhY2NlbGVyYXRlZFJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdGlmICggdGhpcy5nZW9tZXRyeS5ib3VuZHNUcmVlICkge1xuXG5cdFx0XHRpZiAoIHRoaXMubWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdFx0dG1wSW52ZXJzZU1hdHJpeC5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XG5cdFx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggdG1wSW52ZXJzZU1hdHJpeCApO1xuXG5cdFx0XHRjb25zdCBidmggPSB0aGlzLmdlb21ldHJ5LmJvdW5kc1RyZWU7XG5cdFx0XHRpZiAoIHJheWNhc3Rlci5maXJzdEhpdE9ubHkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Y29uc3QgaGl0ID0gY29udmVydFJheWNhc3RJbnRlcnNlY3QoIGJ2aC5yYXljYXN0Rmlyc3QoIHJheSwgdGhpcy5tYXRlcmlhbCApLCB0aGlzLCByYXljYXN0ZXIgKTtcblx0XHRcdFx0aWYgKCBoaXQgKSB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGhpdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zdCBoaXRzID0gYnZoLnJheWNhc3QoIHJheSwgdGhpcy5tYXRlcmlhbCApO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBoaXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBoaXQgPSBjb252ZXJ0UmF5Y2FzdEludGVyc2VjdCggaGl0c1sgaSBdLCB0aGlzLCByYXljYXN0ZXIgKTtcblx0XHRcdFx0XHRpZiAoIGhpdCApIHtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBoaXQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG9yaWdNZXNoUmF5Y2FzdEZ1bmMuY2FsbCggdGhpcywgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXB1dGVCb3VuZHNUcmVlKCBvcHRpb25zICkge1xuXG5cdFx0dGhpcy5ib3VuZHNUcmVlID0gbmV3IE1lc2hCVkgoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHRyZXR1cm4gdGhpcy5ib3VuZHNUcmVlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBkaXNwb3NlQm91bmRzVHJlZSgpIHtcblxuXHRcdHRoaXMuYm91bmRzVHJlZSA9IG51bGw7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvdW50VG9TdHJpbmdGb3JtYXQoIGNvdW50ICkge1xuXG5cdFx0c3dpdGNoICggY291bnQgKSB7XG5cblx0XHRcdGNhc2UgMTogcmV0dXJuICdSJztcblx0XHRcdGNhc2UgMjogcmV0dXJuICdSRyc7XG5cdFx0XHRjYXNlIDM6IHJldHVybiAnUkdCQSc7XG5cdFx0XHRjYXNlIDQ6IHJldHVybiAnUkdCQSc7XG5cblx0XHR9XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY291bnRUb0Zvcm1hdCggY291bnQgKSB7XG5cblx0XHRzd2l0Y2ggKCBjb3VudCApIHtcblxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhyZWUuUmVkRm9ybWF0O1xuXHRcdFx0Y2FzZSAyOiByZXR1cm4gdGhyZWUuUkdGb3JtYXQ7XG5cdFx0XHRjYXNlIDM6IHJldHVybiB0aHJlZS5SR0JBRm9ybWF0O1xuXHRcdFx0Y2FzZSA0OiByZXR1cm4gdGhyZWUuUkdCQUZvcm1hdDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gY291bnRUb0ludEZvcm1hdCggY291bnQgKSB7XG5cblx0XHRzd2l0Y2ggKCBjb3VudCApIHtcblxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhyZWUuUmVkSW50ZWdlckZvcm1hdDtcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRocmVlLlJHSW50ZWdlckZvcm1hdDtcblx0XHRcdGNhc2UgMzogcmV0dXJuIHRocmVlLlJHQkFJbnRlZ2VyRm9ybWF0O1xuXHRcdFx0Y2FzZSA0OiByZXR1cm4gdGhyZWUuUkdCQUludGVnZXJGb3JtYXQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFZlcnRleEF0dHJpYnV0ZVRleHR1cmUgZXh0ZW5kcyB0aHJlZS5EYXRhVGV4dHVyZSB7XG5cblx0XHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMubWluRmlsdGVyID0gdGhyZWUuTmVhcmVzdEZpbHRlcjtcblx0XHRcdHRoaXMubWFnRmlsdGVyID0gdGhyZWUuTmVhcmVzdEZpbHRlcjtcblx0XHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0XHR0aGlzLm92ZXJyaWRlSXRlbVNpemUgPSBudWxsO1xuXHRcdFx0dGhpcy5fZm9yY2VkVHlwZSA9IG51bGw7XG5cblx0XHR9XG5cblx0XHR1cGRhdGVGcm9tKCBhdHRyICkge1xuXG5cdFx0XHRjb25zdCBvdmVycmlkZUl0ZW1TaXplID0gdGhpcy5vdmVycmlkZUl0ZW1TaXplO1xuXHRcdFx0Y29uc3Qgb3JpZ2luYWxJdGVtU2l6ZSA9IGF0dHIuaXRlbVNpemU7XG5cdFx0XHRjb25zdCBvcmlnaW5hbENvdW50ID0gYXR0ci5jb3VudDtcblx0XHRcdGlmICggb3ZlcnJpZGVJdGVtU2l6ZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRpZiAoICggb3JpZ2luYWxJdGVtU2l6ZSAqIG9yaWdpbmFsQ291bnQgKSAlIG92ZXJyaWRlSXRlbVNpemUgIT09IDAuMCApIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1ZlcnRleEF0dHJpYnV0ZVRleHR1cmU6IG92ZXJyaWRlSXRlbVNpemUgbXVzdCBkaXZpZGUgZXZlbmx5IGludG8gYnVmZmVyIGxlbmd0aC4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGF0dHIuaXRlbVNpemUgPSBvdmVycmlkZUl0ZW1TaXplO1xuXHRcdFx0XHRhdHRyLmNvdW50ID0gb3JpZ2luYWxDb3VudCAqIG9yaWdpbmFsSXRlbVNpemUgLyBvdmVycmlkZUl0ZW1TaXplO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0ci5pdGVtU2l6ZTtcblx0XHRcdGNvbnN0IGNvdW50ID0gYXR0ci5jb3VudDtcblx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyLm5vcm1hbGl6ZWQ7XG5cdFx0XHRjb25zdCBvcmlnaW5hbEJ1ZmZlckNvbnMgPSBhdHRyLmFycmF5LmNvbnN0cnVjdG9yO1xuXHRcdFx0Y29uc3QgYnl0ZUNvdW50ID0gb3JpZ2luYWxCdWZmZXJDb25zLkJZVEVTX1BFUl9FTEVNRU5UO1xuXHRcdFx0bGV0IHRhcmdldFR5cGUgPSB0aGlzLl9mb3JjZWRUeXBlO1xuXHRcdFx0bGV0IGZpbmFsU3RyaWRlID0gaXRlbVNpemU7XG5cblx0XHRcdC8vIGRlcml2ZSB0aGUgdHlwZSBvZiB0ZXh0dXJlIHRoaXMgc2hvdWxkIGJlIGluIHRoZSBzaGFkZXJcblx0XHRcdGlmICggdGFyZ2V0VHlwZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRzd2l0Y2ggKCBvcmlnaW5hbEJ1ZmZlckNvbnMgKSB7XG5cblx0XHRcdFx0XHRjYXNlIEZsb2F0MzJBcnJheTpcblx0XHRcdFx0XHRcdHRhcmdldFR5cGUgPSB0aHJlZS5GbG9hdFR5cGU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgVWludDhBcnJheTpcblx0XHRcdFx0XHRjYXNlIFVpbnQxNkFycmF5OlxuXHRcdFx0XHRcdGNhc2UgVWludDMyQXJyYXk6XG5cdFx0XHRcdFx0XHR0YXJnZXRUeXBlID0gdGhyZWUuVW5zaWduZWRJbnRUeXBlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIEludDhBcnJheTpcblx0XHRcdFx0XHRjYXNlIEludDE2QXJyYXk6XG5cdFx0XHRcdFx0Y2FzZSBJbnQzMkFycmF5OlxuXHRcdFx0XHRcdFx0dGFyZ2V0VHlwZSA9IHRocmVlLkludFR5cGU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZ2V0IHRoZSB0YXJnZXQgZm9ybWF0IHRvIHN0b3JlIHRoZSB0ZXh0dXJlIGFzXG5cdFx0XHRsZXQgdHlwZSwgZm9ybWF0LCBub3JtYWxpemVWYWx1ZSwgdGFyZ2V0QnVmZmVyQ29ucztcblx0XHRcdGxldCBpbnRlcm5hbEZvcm1hdCA9IGNvdW50VG9TdHJpbmdGb3JtYXQoIGl0ZW1TaXplICk7XG5cdFx0XHRzd2l0Y2ggKCB0YXJnZXRUeXBlICkge1xuXG5cdFx0XHRcdGNhc2UgdGhyZWUuRmxvYXRUeXBlOlxuXHRcdFx0XHRcdG5vcm1hbGl6ZVZhbHVlID0gMS4wO1xuXHRcdFx0XHRcdGZvcm1hdCA9IGNvdW50VG9Gb3JtYXQoIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0XHRpZiAoIG5vcm1hbGl6ZWQgJiYgYnl0ZUNvdW50ID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXRCdWZmZXJDb25zID0gb3JpZ2luYWxCdWZmZXJDb25zO1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JtYXQgKz0gJzgnO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG9yaWdpbmFsQnVmZmVyQ29ucyA9PT0gVWludDhBcnJheSApIHtcblxuXHRcdFx0XHRcdFx0XHR0eXBlID0gdGhyZWUuVW5zaWduZWRCeXRlVHlwZTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR0eXBlID0gdGhyZWUuQnl0ZVR5cGU7XG5cdFx0XHRcdFx0XHRcdGludGVybmFsRm9ybWF0ICs9ICdfU05PUk0nO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXRCdWZmZXJDb25zID0gRmxvYXQzMkFycmF5O1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JtYXQgKz0gJzMyRic7XG5cdFx0XHRcdFx0XHR0eXBlID0gdGhyZWUuRmxvYXRUeXBlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSB0aHJlZS5JbnRUeXBlOlxuXHRcdFx0XHRcdGludGVybmFsRm9ybWF0ICs9IGJ5dGVDb3VudCAqIDggKyAnSSc7XG5cdFx0XHRcdFx0bm9ybWFsaXplVmFsdWUgPSBub3JtYWxpemVkID8gTWF0aC5wb3coIDIsIG9yaWdpbmFsQnVmZmVyQ29ucy5CWVRFU19QRVJfRUxFTUVOVCAqIDggLSAxICkgOiAxLjA7XG5cdFx0XHRcdFx0Zm9ybWF0ID0gY291bnRUb0ludEZvcm1hdCggaXRlbVNpemUgKTtcblxuXHRcdFx0XHRcdGlmICggYnl0ZUNvdW50ID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXRCdWZmZXJDb25zID0gSW50OEFycmF5O1xuXHRcdFx0XHRcdFx0dHlwZSA9IHRocmVlLkJ5dGVUeXBlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggYnl0ZUNvdW50ID09PSAyICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXRCdWZmZXJDb25zID0gSW50MTZBcnJheTtcblx0XHRcdFx0XHRcdHR5cGUgPSB0aHJlZS5TaG9ydFR5cGU7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXRCdWZmZXJDb25zID0gSW50MzJBcnJheTtcblx0XHRcdFx0XHRcdHR5cGUgPSB0aHJlZS5JbnRUeXBlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSB0aHJlZS5VbnNpZ25lZEludFR5cGU6XG5cdFx0XHRcdFx0aW50ZXJuYWxGb3JtYXQgKz0gYnl0ZUNvdW50ICogOCArICdVSSc7XG5cdFx0XHRcdFx0bm9ybWFsaXplVmFsdWUgPSBub3JtYWxpemVkID8gTWF0aC5wb3coIDIsIG9yaWdpbmFsQnVmZmVyQ29ucy5CWVRFU19QRVJfRUxFTUVOVCAqIDggLSAxICkgOiAxLjA7XG5cdFx0XHRcdFx0Zm9ybWF0ID0gY291bnRUb0ludEZvcm1hdCggaXRlbVNpemUgKTtcblxuXHRcdFx0XHRcdGlmICggYnl0ZUNvdW50ID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXRCdWZmZXJDb25zID0gVWludDhBcnJheTtcblx0XHRcdFx0XHRcdHR5cGUgPSB0aHJlZS5VbnNpZ25lZEJ5dGVUeXBlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggYnl0ZUNvdW50ID09PSAyICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXRCdWZmZXJDb25zID0gVWludDE2QXJyYXk7XG5cdFx0XHRcdFx0XHR0eXBlID0gdGhyZWUuVW5zaWduZWRTaG9ydFR5cGU7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXRCdWZmZXJDb25zID0gVWludDMyQXJyYXk7XG5cdFx0XHRcdFx0XHR0eXBlID0gdGhyZWUuVW5zaWduZWRJbnRUeXBlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gdGhlcmUgd2lsbCBiZSBhIG1pc21hdGNoIGJldHdlZW4gZm9ybWF0IGxlbmd0aCBhbmQgZmluYWwgbGVuZ3RoIGJlY2F1c2Vcblx0XHRcdC8vIFJHQkZvcm1hdCBhbmQgUkdCSW50ZWdlckZvcm1hdCB3YXMgcmVtb3ZlZFxuXHRcdFx0aWYgKCBmaW5hbFN0cmlkZSA9PT0gMyAmJiAoIGZvcm1hdCA9PT0gdGhyZWUuUkdCQUZvcm1hdCB8fCBmb3JtYXQgPT09IHRocmVlLlJHQkFJbnRlZ2VyRm9ybWF0ICkgKSB7XG5cblx0XHRcdFx0ZmluYWxTdHJpZGUgPSA0O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvcHkgdGhlIGRhdGEgb3ZlciB0byB0aGUgbmV3IHRleHR1cmUgYXJyYXlcblx0XHRcdGNvbnN0IGRpbWVuc2lvbiA9IE1hdGguY2VpbCggTWF0aC5zcXJ0KCBjb3VudCApICk7XG5cdFx0XHRjb25zdCBsZW5ndGggPSBmaW5hbFN0cmlkZSAqIGRpbWVuc2lvbiAqIGRpbWVuc2lvbjtcblx0XHRcdGNvbnN0IGRhdGFBcnJheSA9IG5ldyB0YXJnZXRCdWZmZXJDb25zKCBsZW5ndGggKTtcblxuXHRcdFx0Ly8gdGVtcG9yYXJpbHkgc2V0IHRoZSBub3JtYWxpemVkIHN0YXRlIHRvIGZhbHNlIHNpbmNlIHdlIGhhdmUgY3VzdG9tIG5vcm1hbGl6YXRpb24gbG9naWNcblx0XHRcdGNvbnN0IG9yaWdpbmFsTm9ybWFsaXplZCA9IGF0dHIubm9ybWFsaXplZDtcblx0XHRcdGF0dHIubm9ybWFsaXplZCA9IGZhbHNlO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaWkgPSBmaW5hbFN0cmlkZSAqIGk7XG5cdFx0XHRcdGRhdGFBcnJheVsgaWkgXSA9IGF0dHIuZ2V0WCggaSApIC8gbm9ybWFsaXplVmFsdWU7XG5cblx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSAyICkge1xuXG5cdFx0XHRcdFx0ZGF0YUFycmF5WyBpaSArIDEgXSA9IGF0dHIuZ2V0WSggaSApIC8gbm9ybWFsaXplVmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMyApIHtcblxuXHRcdFx0XHRcdGRhdGFBcnJheVsgaWkgKyAyIF0gPSBhdHRyLmdldFooIGkgKSAvIG5vcm1hbGl6ZVZhbHVlO1xuXG5cdFx0XHRcdFx0aWYgKCBmaW5hbFN0cmlkZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0ZGF0YUFycmF5WyBpaSArIDMgXSA9IDEuMDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSA0ICkge1xuXG5cdFx0XHRcdFx0ZGF0YUFycmF5WyBpaSArIDMgXSA9IGF0dHIuZ2V0VyggaSApIC8gbm9ybWFsaXplVmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGF0dHIubm9ybWFsaXplZCA9IG9yaWdpbmFsTm9ybWFsaXplZDtcblxuXHRcdFx0dGhpcy5pbnRlcm5hbEZvcm1hdCA9IGludGVybmFsRm9ybWF0O1xuXHRcdFx0dGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdFx0dGhpcy5pbWFnZS53aWR0aCA9IGRpbWVuc2lvbjtcblx0XHRcdHRoaXMuaW1hZ2UuaGVpZ2h0ID0gZGltZW5zaW9uO1xuXHRcdFx0dGhpcy5pbWFnZS5kYXRhID0gZGF0YUFycmF5O1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmRpc3Bvc2UoKTtcblxuXHRcdFx0YXR0ci5pdGVtU2l6ZSA9IG9yaWdpbmFsSXRlbVNpemU7XG5cdFx0XHRhdHRyLmNvdW50ID0gb3JpZ2luYWxDb3VudDtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgVUludFZlcnRleEF0dHJpYnV0ZVRleHR1cmUgZXh0ZW5kcyBWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy5fZm9yY2VkVHlwZSA9IHRocmVlLlVuc2lnbmVkSW50VHlwZTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgSW50VmVydGV4QXR0cmlidXRlVGV4dHVyZSBleHRlbmRzIFZlcnRleEF0dHJpYnV0ZVRleHR1cmUge1xuXG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLl9mb3JjZWRUeXBlID0gdGhyZWUuSW50VHlwZTtcblxuXHRcdH1cblxuXG5cdH1cblxuXHRjbGFzcyBGbG9hdFZlcnRleEF0dHJpYnV0ZVRleHR1cmUgZXh0ZW5kcyBWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy5fZm9yY2VkVHlwZSA9IHRocmVlLkZsb2F0VHlwZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gYnZoVG9UZXh0dXJlcyggYnZoLCBib3VuZHNUZXh0dXJlLCBjb250ZW50c1RleHR1cmUgKSB7XG5cblx0XHRjb25zdCByb290cyA9IGJ2aC5fcm9vdHM7XG5cblx0XHRpZiAoIHJvb3RzLmxlbmd0aCAhPT0gMSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTWVzaEJWSFVuaWZvcm1TdHJ1Y3Q6IE11bHRpLXJvb3QgQlZIcyBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHJvb3QgPSByb290c1sgMCBdO1xuXHRcdGNvbnN0IHVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCByb290ICk7XG5cdFx0Y29uc3QgdWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIHJvb3QgKTtcblx0XHRjb25zdCBmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCByb290ICk7XG5cblx0XHQvLyBCb3RoIGJvdW5kcyBuZWVkIHR3byBlbGVtZW50cyBwZXIgbm9kZSBzbyBjb21wdXRlIHRoZSBoZWlnaHQgc28gaXQncyB0d2ljZSBhcyBsb25nIGFzXG5cdFx0Ly8gdGhlIHdpZHRoIHNvIHdlIGNhbiBleHBhbmQgdGhlIHJvdyBieSB0d28gYW5kIHN0aWxsIGhhdmUgYSBzcXVhcmUgdGV4dHVyZVxuXHRcdGNvbnN0IG5vZGVDb3VudCA9IHJvb3QuYnl0ZUxlbmd0aCAvIEJZVEVTX1BFUl9OT0RFO1xuXHRcdGNvbnN0IGJvdW5kc0RpbWVuc2lvbiA9IDIgKiBNYXRoLmNlaWwoIE1hdGguc3FydCggbm9kZUNvdW50IC8gMiApICk7XG5cdFx0Y29uc3QgYm91bmRzQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA0ICogYm91bmRzRGltZW5zaW9uICogYm91bmRzRGltZW5zaW9uICk7XG5cblx0XHRjb25zdCBjb250ZW50c0RpbWVuc2lvbiA9IE1hdGguY2VpbCggTWF0aC5zcXJ0KCBub2RlQ291bnQgKSApO1xuXHRcdGNvbnN0IGNvbnRlbnRzQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIDIgKiBjb250ZW50c0RpbWVuc2lvbiAqIGNvbnRlbnRzRGltZW5zaW9uICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBub2RlQ291bnQ7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IG5vZGVJbmRleDMyID0gaSAqIEJZVEVTX1BFUl9OT0RFIC8gNDtcblx0XHRcdGNvbnN0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXHRcdFx0Y29uc3QgYm91bmRzSW5kZXggPSBCT1VORElOR19EQVRBX0lOREVYKCBub2RlSW5kZXgzMiApO1xuXHRcdFx0Zm9yICggbGV0IGIgPSAwOyBiIDwgMzsgYiArKyApIHtcblxuXHRcdFx0XHRib3VuZHNBcnJheVsgOCAqIGkgKyAwICsgYiBdID0gZmxvYXQzMkFycmF5WyBib3VuZHNJbmRleCArIDAgKyBiIF07XG5cdFx0XHRcdGJvdW5kc0FycmF5WyA4ICogaSArIDQgKyBiIF0gPSBmbG9hdDMyQXJyYXlbIGJvdW5kc0luZGV4ICsgMyArIGIgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApICkge1xuXG5cdFx0XHRcdGNvbnN0IGNvdW50ID0gQ09VTlQoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXG5cdFx0XHRcdGNvbnN0IG1lcmdlZExlYWZDb3VudCA9IDB4ZmZmZjAwMDAgfCBjb3VudDtcblx0XHRcdFx0Y29udGVudHNBcnJheVsgaSAqIDIgKyAwIF0gPSBtZXJnZWRMZWFmQ291bnQ7XG5cdFx0XHRcdGNvbnRlbnRzQXJyYXlbIGkgKiAyICsgMSBdID0gb2Zmc2V0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IHJpZ2h0SW5kZXggPSA0ICogUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICkgLyBCWVRFU19QRVJfTk9ERTtcblx0XHRcdFx0Y29uc3Qgc3BsaXRBeGlzID0gU1BMSVRfQVhJUyggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cblx0XHRcdFx0Y29udGVudHNBcnJheVsgaSAqIDIgKyAwIF0gPSBzcGxpdEF4aXM7XG5cdFx0XHRcdGNvbnRlbnRzQXJyYXlbIGkgKiAyICsgMSBdID0gcmlnaHRJbmRleDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ym91bmRzVGV4dHVyZS5pbWFnZS5kYXRhID0gYm91bmRzQXJyYXk7XG5cdFx0Ym91bmRzVGV4dHVyZS5pbWFnZS53aWR0aCA9IGJvdW5kc0RpbWVuc2lvbjtcblx0XHRib3VuZHNUZXh0dXJlLmltYWdlLmhlaWdodCA9IGJvdW5kc0RpbWVuc2lvbjtcblx0XHRib3VuZHNUZXh0dXJlLmZvcm1hdCA9IHRocmVlLlJHQkFGb3JtYXQ7XG5cdFx0Ym91bmRzVGV4dHVyZS50eXBlID0gdGhyZWUuRmxvYXRUeXBlO1xuXHRcdGJvdW5kc1RleHR1cmUuaW50ZXJuYWxGb3JtYXQgPSAnUkdCQTMyRic7XG5cdFx0Ym91bmRzVGV4dHVyZS5taW5GaWx0ZXIgPSB0aHJlZS5OZWFyZXN0RmlsdGVyO1xuXHRcdGJvdW5kc1RleHR1cmUubWFnRmlsdGVyID0gdGhyZWUuTmVhcmVzdEZpbHRlcjtcblx0XHRib3VuZHNUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdGJvdW5kc1RleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdGJvdW5kc1RleHR1cmUuZGlzcG9zZSgpO1xuXG5cdFx0Y29udGVudHNUZXh0dXJlLmltYWdlLmRhdGEgPSBjb250ZW50c0FycmF5O1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5pbWFnZS53aWR0aCA9IGNvbnRlbnRzRGltZW5zaW9uO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5pbWFnZS5oZWlnaHQgPSBjb250ZW50c0RpbWVuc2lvbjtcblx0XHRjb250ZW50c1RleHR1cmUuZm9ybWF0ID0gdGhyZWUuUkdJbnRlZ2VyRm9ybWF0O1xuXHRcdGNvbnRlbnRzVGV4dHVyZS50eXBlID0gdGhyZWUuVW5zaWduZWRJbnRUeXBlO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCA9ICdSRzMyVUknO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5taW5GaWx0ZXIgPSB0aHJlZS5OZWFyZXN0RmlsdGVyO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5tYWdGaWx0ZXIgPSB0aHJlZS5OZWFyZXN0RmlsdGVyO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0XHRjb250ZW50c1RleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5kaXNwb3NlKCk7XG5cblx0fVxuXG5cdGNsYXNzIE1lc2hCVkhVbmlmb3JtU3RydWN0IHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHR0aGlzLmF1dG9EaXNwb3NlID0gdHJ1ZTtcblx0XHRcdHRoaXMuaW5kZXggPSBuZXcgVUludFZlcnRleEF0dHJpYnV0ZVRleHR1cmUoKTtcblx0XHRcdHRoaXMucG9zaXRpb24gPSBuZXcgRmxvYXRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlKCk7XG5cdFx0XHR0aGlzLmJ2aEJvdW5kcyA9IG5ldyB0aHJlZS5EYXRhVGV4dHVyZSgpO1xuXHRcdFx0dGhpcy5idmhDb250ZW50cyA9IG5ldyB0aHJlZS5EYXRhVGV4dHVyZSgpO1xuXG5cdFx0XHR0aGlzLmluZGV4Lm92ZXJyaWRlSXRlbVNpemUgPSAzO1xuXG5cdFx0fVxuXG5cdFx0dXBkYXRlRnJvbSggYnZoICkge1xuXG5cdFx0XHRjb25zdCB7IGdlb21ldHJ5IH0gPSBidmg7XG5cblx0XHRcdGJ2aFRvVGV4dHVyZXMoIGJ2aCwgdGhpcy5idmhCb3VuZHMsIHRoaXMuYnZoQ29udGVudHMgKTtcblxuXHRcdFx0dGhpcy5pbmRleC51cGRhdGVGcm9tKCBnZW9tZXRyeS5pbmRleCApO1xuXHRcdFx0dGhpcy5wb3NpdGlvbi51cGRhdGVGcm9tKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG5cblx0XHR9XG5cblx0XHRkaXNwb3NlKCkge1xuXG5cdFx0XHRjb25zdCB7IGluZGV4LCBwb3NpdGlvbiwgYnZoQm91bmRzLCBidmhDb250ZW50cyB9ID0gdGhpcztcblxuXHRcdFx0aWYgKCBpbmRleCApIGluZGV4LmRpc3Bvc2UoKTtcblx0XHRcdGlmICggcG9zaXRpb24gKSBwb3NpdGlvbi5kaXNwb3NlKCk7XG5cdFx0XHRpZiAoIGJ2aEJvdW5kcyApIGJ2aEJvdW5kcy5kaXNwb3NlKCk7XG5cdFx0XHRpZiAoIGJ2aENvbnRlbnRzICkgYnZoQ29udGVudHMuZGlzcG9zZSgpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBOb3RlIHRoYXQgYSBzdHJ1Y3QgY2Fubm90IGJlIHVzZWQgZm9yIHRoZSBoaXQgcmVjb3JkIGluY2x1ZGluZyBmYWNlSW5kaWNlcywgZmFjZU5vcm1hbCwgYmFyeWNvb3JkLFxuXHQvLyBzaWRlLCBhbmQgZGlzdCBiZWNhdXNlIG9uIHNvbWUgbW9iaWxlIEdQVVMgKHN1Y2ggYXMgQWRyZW5vKSBudW1iZXJzIGFyZSBhZmZvcmRlZCBsZXNzIHByZWNpc2lvbiBzcGVjaWZpY2FsbHlcblx0Ly8gd2hlbiBpbiBhIHN0cnVjdCBsZWFkaW5nIHRvIGluYWNjdXJhdGUgaGl0IHJlc3VsdHMuIFNlZSBLaHJvbm9zR3JvdXAvV2ViR0wjMzM1MSBmb3IgbW9yZSBkZXRhaWxzLlxuXHRjb25zdCBzaGFkZXJTdHJ1Y3RzID0gLyogZ2xzbCAqL2BcbiNpZm5kZWYgVFJJX0lOVEVSU0VDVF9FUFNJTE9OXG4jZGVmaW5lIFRSSV9JTlRFUlNFQ1RfRVBTSUxPTiAxZS01XG4jZW5kaWZcblxuI2lmbmRlZiBJTkZJTklUWVxuI2RlZmluZSBJTkZJTklUWSAxZTIwXG4jZW5kaWZcblxuc3RydWN0IEJWSCB7XG5cblx0dXNhbXBsZXIyRCBpbmRleDtcblx0c2FtcGxlcjJEIHBvc2l0aW9uO1xuXG5cdHNhbXBsZXIyRCBidmhCb3VuZHM7XG5cdHVzYW1wbGVyMkQgYnZoQ29udGVudHM7XG5cbn07XG5gO1xuXG5cdGNvbnN0IHNoYWRlckludGVyc2VjdEZ1bmN0aW9uID0gLyogZ2xzbCAqL2BcblxuLy8gVXRpbGl0aWVzXG51dmVjNCB1VGV4ZWxGZXRjaDFEKCB1c2FtcGxlcjJEIHRleCwgdWludCBpbmRleCApIHtcblxuXHR1aW50IHdpZHRoID0gdWludCggdGV4dHVyZVNpemUoIHRleCwgMCApLnggKTtcblx0dXZlYzIgdXY7XG5cdHV2LnggPSBpbmRleCAlIHdpZHRoO1xuXHR1di55ID0gaW5kZXggLyB3aWR0aDtcblxuXHRyZXR1cm4gdGV4ZWxGZXRjaCggdGV4LCBpdmVjMiggdXYgKSwgMCApO1xuXG59XG5cbml2ZWM0IGlUZXhlbEZldGNoMUQoIGlzYW1wbGVyMkQgdGV4LCB1aW50IGluZGV4ICkge1xuXG5cdHVpbnQgd2lkdGggPSB1aW50KCB0ZXh0dXJlU2l6ZSggdGV4LCAwICkueCApO1xuXHR1dmVjMiB1djtcblx0dXYueCA9IGluZGV4ICUgd2lkdGg7XG5cdHV2LnkgPSBpbmRleCAvIHdpZHRoO1xuXG5cdHJldHVybiB0ZXhlbEZldGNoKCB0ZXgsIGl2ZWMyKCB1diApLCAwICk7XG5cbn1cblxudmVjNCB0ZXhlbEZldGNoMUQoIHNhbXBsZXIyRCB0ZXgsIHVpbnQgaW5kZXggKSB7XG5cblx0dWludCB3aWR0aCA9IHVpbnQoIHRleHR1cmVTaXplKCB0ZXgsIDAgKS54ICk7XG5cdHV2ZWMyIHV2O1xuXHR1di54ID0gaW5kZXggJSB3aWR0aDtcblx0dXYueSA9IGluZGV4IC8gd2lkdGg7XG5cblx0cmV0dXJuIHRleGVsRmV0Y2goIHRleCwgaXZlYzIoIHV2ICksIDAgKTtcblxufVxuXG52ZWM0IHRleHR1cmVTYW1wbGVCYXJ5Y29vcmQoIHNhbXBsZXIyRCB0ZXgsIHZlYzMgYmFyeWNvb3JkLCB1dmVjMyBmYWNlSW5kaWNlcyApIHtcblxuXHRyZXR1cm5cblx0XHRiYXJ5Y29vcmQueCAqIHRleGVsRmV0Y2gxRCggdGV4LCBmYWNlSW5kaWNlcy54ICkgK1xuXHRcdGJhcnljb29yZC55ICogdGV4ZWxGZXRjaDFEKCB0ZXgsIGZhY2VJbmRpY2VzLnkgKSArXG5cdFx0YmFyeWNvb3JkLnogKiB0ZXhlbEZldGNoMUQoIHRleCwgZmFjZUluZGljZXMueiApO1xuXG59XG5cbnZvaWQgbmRjVG9DYW1lcmFSYXkoXG5cdHZlYzIgY29vcmQsIG1hdDQgY2FtZXJhV29ybGQsIG1hdDQgaW52UHJvamVjdGlvbk1hdHJpeCxcblx0b3V0IHZlYzMgcmF5T3JpZ2luLCBvdXQgdmVjMyByYXlEaXJlY3Rpb25cbikge1xuXG5cdC8vIGdldCBjYW1lcmEgbG9vayBkaXJlY3Rpb24gYW5kIG5lYXIgcGxhbmUgZm9yIGNhbWVyYSBjbGlwcGluZ1xuXHR2ZWM0IGxvb2tEaXJlY3Rpb24gPSBjYW1lcmFXb3JsZCAqIHZlYzQoIDAuMCwgMC4wLCAtIDEuMCwgMC4wICk7XG5cdHZlYzQgbmVhclZlY3RvciA9IGludlByb2plY3Rpb25NYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgLSAxLjAsIDEuMCApO1xuXHRmbG9hdCBuZWFyID0gYWJzKCBuZWFyVmVjdG9yLnogLyBuZWFyVmVjdG9yLncgKTtcblxuXHQvLyBnZXQgdGhlIGNhbWVyYSBkaXJlY3Rpb24gYW5kIHBvc2l0aW9uIGZyb20gY2FtZXJhIG1hdHJpY2VzXG5cdHZlYzQgb3JpZ2luID0gY2FtZXJhV29ybGQgKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcblx0dmVjNCBkaXJlY3Rpb24gPSBpbnZQcm9qZWN0aW9uTWF0cml4ICogdmVjNCggY29vcmQsIDAuNSwgMS4wICk7XG5cdGRpcmVjdGlvbiAvPSBkaXJlY3Rpb24udztcblx0ZGlyZWN0aW9uID0gY2FtZXJhV29ybGQgKiBkaXJlY3Rpb24gLSBvcmlnaW47XG5cblx0Ly8gc2xpZGUgdGhlIG9yaWdpbiBhbG9uZyB0aGUgcmF5IHVudGlsIGl0IHNpdHMgYXQgdGhlIG5lYXIgY2xpcCBwbGFuZSBwb3NpdGlvblxuXHRvcmlnaW4ueHl6ICs9IGRpcmVjdGlvbi54eXogKiBuZWFyIC8gZG90KCBkaXJlY3Rpb24sIGxvb2tEaXJlY3Rpb24gKTtcblxuXHRyYXlPcmlnaW4gPSBvcmlnaW4ueHl6O1xuXHRyYXlEaXJlY3Rpb24gPSBkaXJlY3Rpb24ueHl6O1xuXG59XG5cbi8vIFJheWNhc3RpbmdcbmZsb2F0IGludGVyc2VjdHNCb3VuZHMoIHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpcmVjdGlvbiwgdmVjMyBib3VuZHNNaW4sIHZlYzMgYm91bmRzTWF4ICkge1xuXG5cdC8vIGh0dHBzOi8vd3d3LnJlZGRpdC5jb20vci9vcGVuZ2wvY29tbWVudHMvOG50eno1L2Zhc3RfZ2xzbF9yYXlfYm94X2ludGVyc2VjdGlvbi9cblx0Ly8gaHR0cHM6Ly90YXZpYW5hdG9yLmNvbS8yMDExL3JheV9ib3guaHRtbFxuXHR2ZWMzIGludkRpciA9IDEuMCAvIHJheURpcmVjdGlvbjtcblxuXHQvLyBmaW5kIGludGVyc2VjdGlvbiBkaXN0YW5jZXMgZm9yIGVhY2ggcGxhbmVcblx0dmVjMyB0TWluUGxhbmUgPSBpbnZEaXIgKiAoIGJvdW5kc01pbiAtIHJheU9yaWdpbiApO1xuXHR2ZWMzIHRNYXhQbGFuZSA9IGludkRpciAqICggYm91bmRzTWF4IC0gcmF5T3JpZ2luICk7XG5cblx0Ly8gZ2V0IHRoZSBtaW4gYW5kIG1heCBkaXN0YW5jZXMgZnJvbSBlYWNoIGludGVyc2VjdGlvblxuXHR2ZWMzIHRNaW5IaXQgPSBtaW4oIHRNYXhQbGFuZSwgdE1pblBsYW5lICk7XG5cdHZlYzMgdE1heEhpdCA9IG1heCggdE1heFBsYW5lLCB0TWluUGxhbmUgKTtcblxuXHQvLyBnZXQgdGhlIGZ1cnRoZXN0IGhpdCBkaXN0YW5jZVxuXHR2ZWMyIHQgPSBtYXgoIHRNaW5IaXQueHgsIHRNaW5IaXQueXogKTtcblx0ZmxvYXQgdDAgPSBtYXgoIHQueCwgdC55ICk7XG5cblx0Ly8gZ2V0IHRoZSBtaW5pbXVtIGhpdCBkaXN0YW5jZVxuXHR0ID0gbWluKCB0TWF4SGl0Lnh4LCB0TWF4SGl0Lnl6ICk7XG5cdGZsb2F0IHQxID0gbWluKCB0LngsIHQueSApO1xuXG5cdC8vIHNldCBkaXN0YW5jZSB0byAwLjAgaWYgdGhlIHJheSBzdGFydHMgaW5zaWRlIHRoZSBib3hcblx0ZmxvYXQgZGlzdCA9IG1heCggdDAsIDAuMCApO1xuXG5cdHJldHVybiB0MSA+PSBkaXN0ID8gZGlzdCA6IElORklOSVRZO1xuXG59XG5cbmJvb2wgaW50ZXJzZWN0c1RyaWFuZ2xlKFxuXHR2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIHZlYzMgYSwgdmVjMyBiLCB2ZWMzIGMsXG5cdG91dCB2ZWMzIGJhcnljb29yZCwgb3V0IHZlYzMgbm9ybSwgb3V0IGZsb2F0IGRpc3QsIG91dCBmbG9hdCBzaWRlXG4pIHtcblxuXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80Mjc0MDc2NS9pbnRlcnNlY3Rpb24tYmV0d2Vlbi1saW5lLWFuZC10cmlhbmdsZS1pbi0zZFxuXHR2ZWMzIGVkZ2UxID0gYiAtIGE7XG5cdHZlYzMgZWRnZTIgPSBjIC0gYTtcblx0bm9ybSA9IGNyb3NzKCBlZGdlMSwgZWRnZTIgKTtcblxuXHRmbG9hdCBkZXQgPSAtIGRvdCggcmF5RGlyZWN0aW9uLCBub3JtICk7XG5cdGZsb2F0IGludmRldCA9IDEuMCAvIGRldDtcblxuXHR2ZWMzIEFPID0gcmF5T3JpZ2luIC0gYTtcblx0dmVjMyBEQU8gPSBjcm9zcyggQU8sIHJheURpcmVjdGlvbiApO1xuXG5cdHZlYzQgdXZ0O1xuXHR1dnQueCA9IGRvdCggZWRnZTIsIERBTyApICogaW52ZGV0O1xuXHR1dnQueSA9IC0gZG90KCBlZGdlMSwgREFPICkgKiBpbnZkZXQ7XG5cdHV2dC56ID0gZG90KCBBTywgbm9ybSApICogaW52ZGV0O1xuXHR1dnQudyA9IDEuMCAtIHV2dC54IC0gdXZ0Lnk7XG5cblx0Ly8gc2V0IHRoZSBoaXQgaW5mb3JtYXRpb25cblx0YmFyeWNvb3JkID0gdXZ0Lnd4eTsgLy8gYXJyYW5nZWQgaW4gQSwgQiwgQyBvcmRlclxuXHRkaXN0ID0gdXZ0Lno7XG5cdHNpZGUgPSBzaWduKCBkZXQgKTtcblx0bm9ybSA9IHNpZGUgKiBub3JtYWxpemUoIG5vcm0gKTtcblxuXHQvLyBhZGQgYW4gZXBzaWxvbiB0byBhdm9pZCBtaXNzZXMgYmV0d2VlbiB0cmlhbmdsZXNcblx0dXZ0ICs9IHZlYzQoIFRSSV9JTlRFUlNFQ1RfRVBTSUxPTiApO1xuXG5cdHJldHVybiBhbGwoIGdyZWF0ZXJUaGFuRXF1YWwoIHV2dCwgdmVjNCggMC4wICkgKSApO1xuXG59XG5cbmJvb2wgaW50ZXJzZWN0VHJpYW5nbGVzKFxuXHRCVkggYnZoLCB2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIHVpbnQgb2Zmc2V0LCB1aW50IGNvdW50LFxuXHRpbm91dCBmbG9hdCBtaW5EaXN0YW5jZSxcblxuXHQvLyBvdXRwdXQgdmFyaWFibGVzXG5cdG91dCB1dmVjNCBmYWNlSW5kaWNlcywgb3V0IHZlYzMgZmFjZU5vcm1hbCwgb3V0IHZlYzMgYmFyeWNvb3JkLFxuXHRvdXQgZmxvYXQgc2lkZSwgb3V0IGZsb2F0IGRpc3Rcbikge1xuXG5cdGJvb2wgZm91bmQgPSBmYWxzZTtcblx0dmVjMyBsb2NhbEJhcnljb29yZCwgbG9jYWxOb3JtYWw7XG5cdGZsb2F0IGxvY2FsRGlzdCwgbG9jYWxTaWRlO1xuXHRmb3IgKCB1aW50IGkgPSBvZmZzZXQsIGwgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHR1dmVjMyBpbmRpY2VzID0gdVRleGVsRmV0Y2gxRCggYnZoLmluZGV4LCBpICkueHl6O1xuXHRcdHZlYzMgYSA9IHRleGVsRmV0Y2gxRCggYnZoLnBvc2l0aW9uLCBpbmRpY2VzLnggKS5yZ2I7XG5cdFx0dmVjMyBiID0gdGV4ZWxGZXRjaDFEKCBidmgucG9zaXRpb24sIGluZGljZXMueSApLnJnYjtcblx0XHR2ZWMzIGMgPSB0ZXhlbEZldGNoMUQoIGJ2aC5wb3NpdGlvbiwgaW5kaWNlcy56ICkucmdiO1xuXG5cdFx0aWYgKFxuXHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlKCByYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgYSwgYiwgYywgbG9jYWxCYXJ5Y29vcmQsIGxvY2FsTm9ybWFsLCBsb2NhbERpc3QsIGxvY2FsU2lkZSApXG5cdFx0XHQmJiBsb2NhbERpc3QgPCBtaW5EaXN0YW5jZVxuXHRcdCkge1xuXG5cdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRtaW5EaXN0YW5jZSA9IGxvY2FsRGlzdDtcblxuXHRcdFx0ZmFjZUluZGljZXMgPSB1dmVjNCggaW5kaWNlcy54eXosIGkgKTtcblx0XHRcdGZhY2VOb3JtYWwgPSBsb2NhbE5vcm1hbDtcblxuXHRcdFx0c2lkZSA9IGxvY2FsU2lkZTtcblx0XHRcdGJhcnljb29yZCA9IGxvY2FsQmFyeWNvb3JkO1xuXHRcdFx0ZGlzdCA9IGxvY2FsRGlzdDtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIGZvdW5kO1xuXG59XG5cbmZsb2F0IGludGVyc2VjdHNCVkhOb2RlQm91bmRzKCB2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIEJWSCBidmgsIHVpbnQgY3Vyck5vZGVJbmRleCApIHtcblxuXHR2ZWMzIGJvdW5kc01pbiA9IHRleGVsRmV0Y2gxRCggYnZoLmJ2aEJvdW5kcywgY3Vyck5vZGVJbmRleCAqIDJ1ICsgMHUgKS54eXo7XG5cdHZlYzMgYm91bmRzTWF4ID0gdGV4ZWxGZXRjaDFEKCBidmguYnZoQm91bmRzLCBjdXJyTm9kZUluZGV4ICogMnUgKyAxdSApLnh5ejtcblx0cmV0dXJuIGludGVyc2VjdHNCb3VuZHMoIHJheU9yaWdpbiwgcmF5RGlyZWN0aW9uLCBib3VuZHNNaW4sIGJvdW5kc01heCApO1xuXG59XG5cbmJvb2wgYnZoSW50ZXJzZWN0Rmlyc3RIaXQoXG5cdEJWSCBidmgsIHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpcmVjdGlvbixcblxuXHQvLyBvdXRwdXQgdmFyaWFibGVzXG5cdG91dCB1dmVjNCBmYWNlSW5kaWNlcywgb3V0IHZlYzMgZmFjZU5vcm1hbCwgb3V0IHZlYzMgYmFyeWNvb3JkLFxuXHRvdXQgZmxvYXQgc2lkZSwgb3V0IGZsb2F0IGRpc3Rcbikge1xuXG5cdC8vIHN0YWNrIG5lZWRzIHRvIGJlIHR3aWNlIGFzIGxvbmcgYXMgdGhlIGRlZXBlc3QgdHJlZSB3ZSBleHBlY3QgYmVjYXVzZVxuXHQvLyB3ZSBwdXNoIGJvdGggdGhlIGxlZnQgYW5kIHJpZ2h0IGNoaWxkIG9udG8gdGhlIHN0YWNrIGV2ZXJ5IHRyYXZlcnNhbFxuXHRpbnQgcHRyID0gMDtcblx0dWludCBzdGFja1sgNjAgXTtcblx0c3RhY2tbIDAgXSA9IDB1O1xuXG5cdGZsb2F0IHRyaWFuZ2xlRGlzdGFuY2UgPSAxZTIwO1xuXHRib29sIGZvdW5kID0gZmFsc2U7XG5cdHdoaWxlICggcHRyID4gLSAxICYmIHB0ciA8IDYwICkge1xuXG5cdFx0dWludCBjdXJyTm9kZUluZGV4ID0gc3RhY2tbIHB0ciBdO1xuXHRcdHB0ciAtLTtcblxuXHRcdC8vIGNoZWNrIGlmIHdlIGludGVyc2VjdCB0aGUgY3VycmVudCBib3VuZHNcblx0XHRmbG9hdCBib3VuZHNIaXREaXN0YW5jZSA9IGludGVyc2VjdHNCVkhOb2RlQm91bmRzKCByYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgYnZoLCBjdXJyTm9kZUluZGV4ICk7XG5cdFx0aWYgKCBib3VuZHNIaXREaXN0YW5jZSA9PSBJTkZJTklUWSB8fCBib3VuZHNIaXREaXN0YW5jZSA+IHRyaWFuZ2xlRGlzdGFuY2UgKSB7XG5cblx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0fVxuXG5cdFx0dXZlYzIgYm91bmRzSW5mbyA9IHVUZXhlbEZldGNoMUQoIGJ2aC5idmhDb250ZW50cywgY3Vyck5vZGVJbmRleCApLnh5O1xuXHRcdGJvb2wgaXNMZWFmID0gYm9vbCggYm91bmRzSW5mby54ICYgMHhmZmZmMDAwMHUgKTtcblxuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHR1aW50IGNvdW50ID0gYm91bmRzSW5mby54ICYgMHgwMDAwZmZmZnU7XG5cdFx0XHR1aW50IG9mZnNldCA9IGJvdW5kc0luZm8ueTtcblxuXHRcdFx0Zm91bmQgPSBpbnRlcnNlY3RUcmlhbmdsZXMoXG5cdFx0XHRcdGJ2aCwgcmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIG9mZnNldCwgY291bnQsIHRyaWFuZ2xlRGlzdGFuY2UsXG5cdFx0XHRcdGZhY2VJbmRpY2VzLCBmYWNlTm9ybWFsLCBiYXJ5Y29vcmQsIHNpZGUsIGRpc3Rcblx0XHRcdCkgfHwgZm91bmQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR1aW50IGxlZnRJbmRleCA9IGN1cnJOb2RlSW5kZXggKyAxdTtcblx0XHRcdHVpbnQgc3BsaXRBeGlzID0gYm91bmRzSW5mby54ICYgMHgwMDAwZmZmZnU7XG5cdFx0XHR1aW50IHJpZ2h0SW5kZXggPSBib3VuZHNJbmZvLnk7XG5cblx0XHRcdGJvb2wgbGVmdFRvUmlnaHQgPSByYXlEaXJlY3Rpb25bIHNwbGl0QXhpcyBdID49IDAuMDtcblx0XHRcdHVpbnQgYzEgPSBsZWZ0VG9SaWdodCA/IGxlZnRJbmRleCA6IHJpZ2h0SW5kZXg7XG5cdFx0XHR1aW50IGMyID0gbGVmdFRvUmlnaHQgPyByaWdodEluZGV4IDogbGVmdEluZGV4O1xuXG5cdFx0XHQvLyBzZXQgYzIgaW4gdGhlIHN0YWNrIHNvIHdlIHRyYXZlcnNlIGl0IGxhdGVyLiBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgYSBwb2ludGVyIGluXG5cdFx0XHQvLyB0aGUgc3RhY2sgd2hpbGUgd2UgdHJhdmVyc2UuIFRoZSBzZWNvbmQgcG9pbnRlciBhZGRlZCBpcyB0aGUgb25lIHRoYXQgd2lsbCBiZVxuXHRcdFx0Ly8gdHJhdmVyc2VkIGZpcnN0XG5cdFx0XHRwdHIgKys7XG5cdFx0XHRzdGFja1sgcHRyIF0gPSBjMjtcblxuXHRcdFx0cHRyICsrO1xuXHRcdFx0c3RhY2tbIHB0ciBdID0gYzE7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBmb3VuZDtcblxufVxuYDtcblxuXHQvLyBEaXN0YW5jZSB0byBQb2ludFxuXHRjb25zdCBzaGFkZXJEaXN0YW5jZUZ1bmN0aW9uID0gLyogZ2xzbCAqL2BcblxuZmxvYXQgZG90MiggaW4gdmVjMyB2ICkge1xuXG5cdHJldHVybiBkb3QoIHYsIHYgKTtcblxufVxuXG5cbi8vIGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy90dGZHV2xcbnZlYzMgY2xvc2VzdFBvaW50VG9UcmlhbmdsZSggdmVjMyBwLCB2ZWMzIHYwLCB2ZWMzIHYxLCB2ZWMzIHYyLCBvdXQgdmVjMyBiYXJ5Y29vcmQgKSB7XG5cbiAgICB2ZWMzIHYxMCA9IHYxIC0gdjA7XG4gICAgdmVjMyB2MjEgPSB2MiAtIHYxO1xuICAgIHZlYzMgdjAyID0gdjAgLSB2MjtcblxuXHR2ZWMzIHAwID0gcCAtIHYwO1xuXHR2ZWMzIHAxID0gcCAtIHYxO1xuXHR2ZWMzIHAyID0gcCAtIHYyO1xuXG4gICAgdmVjMyBub3IgPSBjcm9zcyggdjEwLCB2MDIgKTtcblxuICAgIC8vIG1ldGhvZCAyLCBpbiBiYXJ5Y2VudHJpYyBzcGFjZVxuICAgIHZlYzMgIHEgPSBjcm9zcyggbm9yLCBwMCApO1xuICAgIGZsb2F0IGQgPSAxLjAgLyBkb3QyKCBub3IgKTtcbiAgICBmbG9hdCB1ID0gZCAqIGRvdCggcSwgdjAyICk7XG4gICAgZmxvYXQgdiA9IGQgKiBkb3QoIHEsIHYxMCApO1xuICAgIGZsb2F0IHcgPSAxLjAgLSB1IC0gdjtcblxuXHRpZiggdSA8IDAuMCApIHtcblxuXHRcdHcgPSBjbGFtcCggZG90KCBwMiwgdjAyICkgLyBkb3QyKCB2MDIgKSwgMC4wLCAxLjAgKTtcblx0XHR1ID0gMC4wO1xuXHRcdHYgPSAxLjAgLSB3O1xuXG5cdH0gZWxzZSBpZiggdiA8IDAuMCApIHtcblxuXHRcdHUgPSBjbGFtcCggZG90KCBwMCwgdjEwICkgLyBkb3QyKCB2MTAgKSwgMC4wLCAxLjAgKTtcblx0XHR2ID0gMC4wO1xuXHRcdHcgPSAxLjAgLSB1O1xuXG5cdH0gZWxzZSBpZiggdyA8IDAuMCApIHtcblxuXHRcdHYgPSBjbGFtcCggZG90KCBwMSwgdjIxICkgLyBkb3QyKCB2MjEgKSwgMC4wLCAxLjAgKTtcblx0XHR3ID0gMC4wO1xuXHRcdHUgPSAxLjAtdjtcblxuXHR9XG5cblx0YmFyeWNvb3JkID0gdmVjMyggdSwgdiwgdyApO1xuICAgIHJldHVybiB1ICogdjEgKyB2ICogdjIgKyB3ICogdjA7XG5cbn1cblxuZmxvYXQgZGlzdGFuY2VUb1RyaWFuZ2xlcyhcblx0QlZIIGJ2aCwgdmVjMyBwb2ludCwgdWludCBvZmZzZXQsIHVpbnQgY291bnQsIGZsb2F0IGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQsXG5cblx0b3V0IHV2ZWM0IGZhY2VJbmRpY2VzLCBvdXQgdmVjMyBmYWNlTm9ybWFsLCBvdXQgdmVjMyBiYXJ5Y29vcmQsIG91dCBmbG9hdCBzaWRlLCBvdXQgdmVjMyBvdXRQb2ludFxuKSB7XG5cblx0Ym9vbCBmb3VuZCA9IGZhbHNlO1xuXHR1dmVjMyBsb2NhbEluZGljZXM7XG5cdHZlYzMgbG9jYWxCYXJ5Y29vcmQ7XG5cdHZlYzMgbG9jYWxOb3JtYWw7XG5cdGZvciAoIHVpbnQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHV2ZWMzIGluZGljZXMgPSB1VGV4ZWxGZXRjaDFEKCBidmguaW5kZXgsIGkgKS54eXo7XG5cdFx0dmVjMyBhID0gdGV4ZWxGZXRjaDFEKCBidmgucG9zaXRpb24sIGluZGljZXMueCApLnJnYjtcblx0XHR2ZWMzIGIgPSB0ZXhlbEZldGNoMUQoIGJ2aC5wb3NpdGlvbiwgaW5kaWNlcy55ICkucmdiO1xuXHRcdHZlYzMgYyA9IHRleGVsRmV0Y2gxRCggYnZoLnBvc2l0aW9uLCBpbmRpY2VzLnogKS5yZ2I7XG5cblx0XHQvLyBnZXQgdGhlIGNsb3Nlc3QgcG9pbnQgYW5kIGJhcnljb29yZFxuXHRcdHZlYzMgY2xvc2VzdFBvaW50ID0gY2xvc2VzdFBvaW50VG9UcmlhbmdsZSggcG9pbnQsIGEsIGIsIGMsIGxvY2FsQmFyeWNvb3JkICk7XG5cdFx0dmVjMyBkZWx0YSA9IHBvaW50IC0gY2xvc2VzdFBvaW50O1xuXHRcdGZsb2F0IHNxRGlzdCA9IGRvdDIoIGRlbHRhICk7XG5cdFx0aWYgKCBzcURpc3QgPCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkICkge1xuXG5cdFx0XHQvLyBzZXQgdGhlIG91dHB1dCByZXN1bHRzXG5cdFx0XHRjbG9zZXN0RGlzdGFuY2VTcXVhcmVkID0gc3FEaXN0O1xuXHRcdFx0ZmFjZUluZGljZXMgPSB1dmVjNCggaW5kaWNlcy54eXosIGkgKTtcblx0XHRcdGZhY2VOb3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCBhIC0gYiwgYiAtIGMgKSApO1xuXHRcdFx0YmFyeWNvb3JkID0gbG9jYWxCYXJ5Y29vcmQ7XG5cdFx0XHRvdXRQb2ludCA9IGNsb3Nlc3RQb2ludDtcblx0XHRcdHNpZGUgPSBzaWduKCBkb3QoIGZhY2VOb3JtYWwsIGRlbHRhICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQ7XG5cbn1cblxuZmxvYXQgZGlzdGFuY2VTcVRvQm91bmRzKCB2ZWMzIHBvaW50LCB2ZWMzIGJvdW5kc01pbiwgdmVjMyBib3VuZHNNYXggKSB7XG5cblx0dmVjMyBjbGFtcGVkUG9pbnQgPSBjbGFtcCggcG9pbnQsIGJvdW5kc01pbiwgYm91bmRzTWF4ICk7XG5cdHZlYzMgZGVsdGEgPSBwb2ludCAtIGNsYW1wZWRQb2ludDtcblx0cmV0dXJuIGRvdCggZGVsdGEsIGRlbHRhICk7XG5cbn1cblxuZmxvYXQgZGlzdGFuY2VTcVRvQlZITm9kZUJvdW5kc1BvaW50KCB2ZWMzIHBvaW50LCBCVkggYnZoLCB1aW50IGN1cnJOb2RlSW5kZXggKSB7XG5cblx0dmVjMyBib3VuZHNNaW4gPSB0ZXhlbEZldGNoMUQoIGJ2aC5idmhCb3VuZHMsIGN1cnJOb2RlSW5kZXggKiAydSArIDB1ICkueHl6O1xuXHR2ZWMzIGJvdW5kc01heCA9IHRleGVsRmV0Y2gxRCggYnZoLmJ2aEJvdW5kcywgY3Vyck5vZGVJbmRleCAqIDJ1ICsgMXUgKS54eXo7XG5cdHJldHVybiBkaXN0YW5jZVNxVG9Cb3VuZHMoIHBvaW50LCBib3VuZHNNaW4sIGJvdW5kc01heCApO1xuXG59XG5cbmZsb2F0IGJ2aENsb3Nlc3RQb2ludFRvUG9pbnQoXG5cdEJWSCBidmgsIHZlYzMgcG9pbnQsXG5cblx0Ly8gb3V0cHV0IHZhcmlhYmxlc1xuXHRvdXQgdXZlYzQgZmFjZUluZGljZXMsIG91dCB2ZWMzIGZhY2VOb3JtYWwsIG91dCB2ZWMzIGJhcnljb29yZCxcblx0b3V0IGZsb2F0IHNpZGUsIG91dCB2ZWMzIG91dFBvaW50XG4gKSB7XG5cblx0Ly8gc3RhY2sgbmVlZHMgdG8gYmUgdHdpY2UgYXMgbG9uZyBhcyB0aGUgZGVlcGVzdCB0cmVlIHdlIGV4cGVjdCBiZWNhdXNlXG5cdC8vIHdlIHB1c2ggYm90aCB0aGUgbGVmdCBhbmQgcmlnaHQgY2hpbGQgb250byB0aGUgc3RhY2sgZXZlcnkgdHJhdmVyc2FsXG5cdGludCBwdHIgPSAwO1xuXHR1aW50IHN0YWNrWyA2MCBdO1xuXHRzdGFja1sgMCBdID0gMHU7XG5cdGZsb2F0IGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgPSBwb3coIDEwMDAwMC4wLCAyLjAgKTtcblx0Ym9vbCBmb3VuZCA9IGZhbHNlO1xuXHR3aGlsZSAoIHB0ciA+IC0gMSAmJiBwdHIgPCA2MCApIHtcblxuXHRcdHVpbnQgY3Vyck5vZGVJbmRleCA9IHN0YWNrWyBwdHIgXTtcblx0XHRwdHIgLS07XG5cblx0XHQvLyBjaGVjayBpZiB3ZSBpbnRlcnNlY3QgdGhlIGN1cnJlbnQgYm91bmRzXG5cdFx0ZmxvYXQgYm91bmRzSGl0RGlzdGFuY2UgPSBkaXN0YW5jZVNxVG9CVkhOb2RlQm91bmRzUG9pbnQoIHBvaW50LCBidmgsIGN1cnJOb2RlSW5kZXggKTtcblx0XHRpZiAoIGJvdW5kc0hpdERpc3RhbmNlID4gY2xvc2VzdERpc3RhbmNlU3F1YXJlZCApIHtcblxuXHRcdFx0Y29udGludWU7XG5cblx0XHR9XG5cblx0XHR1dmVjMiBib3VuZHNJbmZvID0gdVRleGVsRmV0Y2gxRCggYnZoLmJ2aENvbnRlbnRzLCBjdXJyTm9kZUluZGV4ICkueHk7XG5cdFx0Ym9vbCBpc0xlYWYgPSBib29sKCBib3VuZHNJbmZvLnggJiAweGZmZmYwMDAwdSApO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHR1aW50IGNvdW50ID0gYm91bmRzSW5mby54ICYgMHgwMDAwZmZmZnU7XG5cdFx0XHR1aW50IG9mZnNldCA9IGJvdW5kc0luZm8ueTtcblx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgPSBkaXN0YW5jZVRvVHJpYW5nbGVzKFxuXHRcdFx0XHRidmgsIHBvaW50LCBvZmZzZXQsIGNvdW50LCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkLFxuXG5cdFx0XHRcdC8vIG91dHB1dHNcblx0XHRcdFx0ZmFjZUluZGljZXMsIGZhY2VOb3JtYWwsIGJhcnljb29yZCwgc2lkZSwgb3V0UG9pbnRcblx0XHRcdCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR1aW50IGxlZnRJbmRleCA9IGN1cnJOb2RlSW5kZXggKyAxdTtcblx0XHRcdHVpbnQgc3BsaXRBeGlzID0gYm91bmRzSW5mby54ICYgMHgwMDAwZmZmZnU7XG5cdFx0XHR1aW50IHJpZ2h0SW5kZXggPSBib3VuZHNJbmZvLnk7XG5cdFx0XHRib29sIGxlZnRUb1JpZ2h0ID0gZGlzdGFuY2VTcVRvQlZITm9kZUJvdW5kc1BvaW50KCBwb2ludCwgYnZoLCBsZWZ0SW5kZXggKSA8IGRpc3RhbmNlU3FUb0JWSE5vZGVCb3VuZHNQb2ludCggcG9pbnQsIGJ2aCwgcmlnaHRJbmRleCApOy8vcmF5RGlyZWN0aW9uWyBzcGxpdEF4aXMgXSA+PSAwLjA7XG5cdFx0XHR1aW50IGMxID0gbGVmdFRvUmlnaHQgPyBsZWZ0SW5kZXggOiByaWdodEluZGV4O1xuXHRcdFx0dWludCBjMiA9IGxlZnRUb1JpZ2h0ID8gcmlnaHRJbmRleCA6IGxlZnRJbmRleDtcblxuXHRcdFx0Ly8gc2V0IGMyIGluIHRoZSBzdGFjayBzbyB3ZSB0cmF2ZXJzZSBpdCBsYXRlci4gV2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGEgcG9pbnRlciBpblxuXHRcdFx0Ly8gdGhlIHN0YWNrIHdoaWxlIHdlIHRyYXZlcnNlLiBUaGUgc2Vjb25kIHBvaW50ZXIgYWRkZWQgaXMgdGhlIG9uZSB0aGF0IHdpbGwgYmVcblx0XHRcdC8vIHRyYXZlcnNlZCBmaXJzdFxuXHRcdFx0cHRyICsrO1xuXHRcdFx0c3RhY2tbIHB0ciBdID0gYzI7XG5cdFx0XHRwdHIgKys7XG5cdFx0XHRzdGFja1sgcHRyIF0gPSBjMTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHNxcnQoIGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgKTtcblxufVxuYDtcblxuXHRjb25zdCBfcG9zaXRpb25WZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGNvbnN0IF9ub3JtYWxWZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGNvbnN0IF90YW5nZW50VmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCBfdGFuZ2VudFZlY3RvcjQgPSAvKkBfX1BVUkVfXyovIG5ldyB0aHJlZS5WZWN0b3I0KCk7XG5cblx0Y29uc3QgX21vcnBoVmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCBfdGVtcCA9IC8qQF9fUFVSRV9fKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblxuXHRjb25zdCBfc2tpbkluZGV4ID0gLypAX19QVVJFX18qLyBuZXcgdGhyZWUuVmVjdG9yNCgpO1xuXHRjb25zdCBfc2tpbldlaWdodCA9IC8qQF9fUFVSRV9fKi8gbmV3IHRocmVlLlZlY3RvcjQoKTtcblx0Y29uc3QgX21hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IHRocmVlLk1hdHJpeDQoKTtcblx0Y29uc3QgX2JvbmVNYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyB0aHJlZS5NYXRyaXg0KCk7XG5cblx0Ly8gQ29uZmlybXMgdGhhdCB0aGUgdHdvIHByb3ZpZGVkIGF0dHJpYnV0ZXMgYXJlIGNvbXBhdGlibGVcblx0ZnVuY3Rpb24gdmFsaWRhdGVBdHRyaWJ1dGVzKCBhdHRyMSwgYXR0cjIgKSB7XG5cblx0XHRpZiAoICEgYXR0cjEgJiYgISBhdHRyMiApIHtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2FtZUNvdW50ID0gYXR0cjEuY291bnQgPT09IGF0dHIyLmNvdW50O1xuXHRcdGNvbnN0IHNhbWVOb3JtYWxpemVkID0gYXR0cjEubm9ybWFsaXplZCA9PT0gYXR0cjIubm9ybWFsaXplZDtcblx0XHRjb25zdCBzYW1lVHlwZSA9IGF0dHIxLmFycmF5LmNvbnN0cnVjdG9yID09PSBhdHRyMi5hcnJheS5jb25zdHJ1Y3Rvcjtcblx0XHRjb25zdCBzYW1lSXRlbVNpemUgPSBhdHRyMS5pdGVtU2l6ZSA9PT0gYXR0cjIuaXRlbVNpemU7XG5cblx0XHRpZiAoICEgc2FtZUNvdW50IHx8ICEgc2FtZU5vcm1hbGl6ZWQgfHwgISBzYW1lVHlwZSB8fCAhIHNhbWVJdGVtU2l6ZSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIENsb25lcyB0aGUgZ2l2ZW4gYXR0cmlidXRlIHdpdGggYSBuZXcgY29tcGF0aWJsZSBidWZmZXIgYXR0cmlidXRlIGJ1dCBubyBkYXRhXG5cdGZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZUNsb25lKCBhdHRyLCBjb3VudE92ZXJyaWRlID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IGNvbnMgPSBhdHRyLmFycmF5LmNvbnN0cnVjdG9yO1xuXHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyLm5vcm1hbGl6ZWQ7XG5cdFx0Y29uc3QgaXRlbVNpemUgPSBhdHRyLml0ZW1TaXplO1xuXHRcdGNvbnN0IGNvdW50ID0gY291bnRPdmVycmlkZSA9PT0gbnVsbCA/IGF0dHIuY291bnQgOiBjb3VudE92ZXJyaWRlO1xuXG5cdFx0cmV0dXJuIG5ldyB0aHJlZS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBjb25zKCBpdGVtU2l6ZSAqIGNvdW50ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG5cdC8vIHRhcmdldCBvZmZzZXQgaXMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdGFyZ2V0IGJ1ZmZlciBzdHJpZGUgdG8gc2tpcCBiZWZvcmUgY29weWluZyB0aGVcblx0Ly8gYXR0cmlidXRlcyBjb250ZW50cyBpbiB0by5cblx0ZnVuY3Rpb24gY29weUF0dHJpYnV0ZUNvbnRlbnRzKCBhdHRyLCB0YXJnZXQsIHRhcmdldE9mZnNldCA9IDAgKSB7XG5cblx0XHRpZiAoIGF0dHIuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0Y29uc3QgaXRlbVNpemUgPSBhdHRyLml0ZW1TaXplO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXR0ci5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW8gPSBpICsgdGFyZ2V0T2Zmc2V0O1xuXHRcdFx0XHR0YXJnZXQuc2V0WCggaW8sIGF0dHIuZ2V0WCggaSApICk7XG5cdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMiApIHRhcmdldC5zZXRZKCBpbywgYXR0ci5nZXRZKCBpICkgKTtcblx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSAzICkgdGFyZ2V0LnNldFooIGlvLCBhdHRyLmdldFooIGkgKSApO1xuXHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDQgKSB0YXJnZXQuc2V0VyggaW8sIGF0dHIuZ2V0VyggaSApICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gdGFyZ2V0LmFycmF5O1xuXHRcdFx0Y29uc3QgY29ucyA9IGFycmF5LmNvbnN0cnVjdG9yO1xuXHRcdFx0Y29uc3QgYnl0ZU9mZnNldCA9IGFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogYXR0ci5pdGVtU2l6ZSAqIHRhcmdldE9mZnNldDtcblx0XHRcdGNvbnN0IHRlbXAgPSBuZXcgY29ucyggYXJyYXkuYnVmZmVyLCBieXRlT2Zmc2V0LCBhdHRyLmFycmF5Lmxlbmd0aCApO1xuXHRcdFx0dGVtcC5zZXQoIGF0dHIuYXJyYXkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gQWRkcyB0aGUgXCJtYXRyaXhcIiBtdWx0aXBsaWVkIGJ5IFwic2NhbGVcIiB0byBcInRhcmdldFwiXG5cdGZ1bmN0aW9uIGFkZFNjYWxlZE1hdHJpeCggdGFyZ2V0LCBtYXRyaXgsIHNjYWxlICkge1xuXG5cdFx0Y29uc3QgdGFyZ2V0QXJyYXkgPSB0YXJnZXQuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWF0cml4QXJyYXkgPSBtYXRyaXguZWxlbWVudHM7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbWF0cml4QXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGFyZ2V0QXJyYXlbIGkgXSArPSBtYXRyaXhBcnJheVsgaSBdICogc2NhbGU7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIEEgdmVyc2lvbiBvZiBcIlNraW5uZWRNZXNoLmJvbmVUcmFuc2Zvcm1cIiBmb3Igbm9ybWFsc1xuXHRmdW5jdGlvbiBib25lTm9ybWFsVHJhbnNmb3JtKCBtZXNoLCBpbmRleCwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3Qgc2tlbGV0b24gPSBtZXNoLnNrZWxldG9uO1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHRjb25zdCBib25lcyA9IHNrZWxldG9uLmJvbmVzO1xuXHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHNrZWxldG9uLmJvbmVJbnZlcnNlcztcblxuXHRcdF9za2luSW5kZXguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luSW5kZXgsIGluZGV4ICk7XG5cdFx0X3NraW5XZWlnaHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luV2VpZ2h0LCBpbmRleCApO1xuXG5cdFx0X21hdHJpeC5lbGVtZW50cy5maWxsKCAwICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA0OyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB3ZWlnaHQgPSBfc2tpbldlaWdodC5nZXRDb21wb25lbnQoIGkgKTtcblxuXHRcdFx0aWYgKCB3ZWlnaHQgIT09IDAgKSB7XG5cblx0XHRcdFx0Y29uc3QgYm9uZUluZGV4ID0gX3NraW5JbmRleC5nZXRDb21wb25lbnQoIGkgKTtcblx0XHRcdFx0X2JvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggYm9uZXNbIGJvbmVJbmRleCBdLm1hdHJpeFdvcmxkLCBib25lSW52ZXJzZXNbIGJvbmVJbmRleCBdICk7XG5cblx0XHRcdFx0YWRkU2NhbGVkTWF0cml4KCBfbWF0cml4LCBfYm9uZU1hdHJpeCwgd2VpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdF9tYXRyaXgubXVsdGlwbHkoIG1lc2guYmluZE1hdHJpeCApLnByZW11bHRpcGx5KCBtZXNoLmJpbmRNYXRyaXhJbnZlcnNlICk7XG5cdFx0dGFyZ2V0LnRyYW5zZm9ybURpcmVjdGlvbiggX21hdHJpeCApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0Ly8gQXBwbGllcyB0aGUgbW9ycGggdGFyZ2V0IGRhdGEgdG8gdGhlIHRhcmdldCB2ZWN0b3Jcblx0ZnVuY3Rpb24gYXBwbHlNb3JwaFRhcmdldCggbW9ycGhEYXRhLCBtb3JwaEluZmx1ZW5jZXMsIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLCBpLCB0YXJnZXQgKSB7XG5cblx0XHRfbW9ycGhWZWN0b3Iuc2V0KCAwLCAwLCAwICk7XG5cdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG1vcnBoRGF0YS5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0Y29uc3QgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzWyBqIF07XG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoRGF0YVsgaiBdO1xuXG5cdFx0XHRpZiAoIGluZmx1ZW5jZSA9PT0gMCApIGNvbnRpbnVlO1xuXG5cdFx0XHRfdGVtcC5mcm9tQnVmZmVyQXR0cmlidXRlKCBtb3JwaEF0dHJpYnV0ZSwgaSApO1xuXG5cdFx0XHRpZiAoIG1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xuXG5cdFx0XHRcdF9tb3JwaFZlY3Rvci5hZGRTY2FsZWRWZWN0b3IoIF90ZW1wLCBpbmZsdWVuY2UgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfbW9ycGhWZWN0b3IuYWRkU2NhbGVkVmVjdG9yKCBfdGVtcC5zdWIoIHRhcmdldCApLCBpbmZsdWVuY2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGFyZ2V0LmFkZCggX21vcnBoVmVjdG9yICk7XG5cblx0fVxuXG5cdC8vIE1vZGlmaWVkIHZlcnNpb24gb2YgQnVmZmVyR2VvbWV0cnlVdGlscy5tZXJnZUJ1ZmZlckdlb21ldHJpZXMgdGhhdCBpZ25vcmVzIG1vcnBoIHRhcmdldHMgYW5kIHVwZGF0ZXMgYSBhdHRyaWJ1dGVzIGluIHBsYWNlXG5cdGZ1bmN0aW9uIG1lcmdlQnVmZmVyR2VvbWV0cmllcyggZ2VvbWV0cmllcywgb3B0aW9ucyA9IHsgdXNlR3JvdXBzOiBmYWxzZSwgdXBkYXRlSW5kZXg6IGZhbHNlLCBza2lwQXR0cmlidXRlczogW10gfSwgdGFyZ2V0R2VvbWV0cnkgPSBuZXcgdGhyZWUuQnVmZmVyR2VvbWV0cnkoKSApIHtcblxuXHRcdGNvbnN0IGlzSW5kZXhlZCA9IGdlb21ldHJpZXNbIDAgXS5pbmRleCAhPT0gbnVsbDtcblx0XHRjb25zdCB7IHVzZUdyb3VwcyA9IGZhbHNlLCB1cGRhdGVJbmRleCA9IGZhbHNlLCBza2lwQXR0cmlidXRlcyA9IFtdIH0gPSBvcHRpb25zO1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlc1VzZWQgPSBuZXcgU2V0KCBPYmplY3Qua2V5cyggZ2VvbWV0cmllc1sgMCBdLmF0dHJpYnV0ZXMgKSApO1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcblxuXHRcdGxldCBvZmZzZXQgPSAwO1xuXG5cdFx0dGFyZ2V0R2VvbWV0cnkuY2xlYXJHcm91cHMoKTtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBpIF07XG5cdFx0XHRsZXQgYXR0cmlidXRlc0NvdW50ID0gMDtcblxuXHRcdFx0Ly8gZW5zdXJlIHRoYXQgYWxsIGdlb21ldHJpZXMgYXJlIGluZGV4ZWQsIG9yIG5vbmVcblx0XHRcdGlmICggaXNJbmRleGVkICE9PSAoIGdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnU3RhdGljR2VvbWV0cnlHZW5lcmF0b3I6IEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBpbmRleCBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdhdGhlciBhdHRyaWJ1dGVzLCBleGl0IGVhcmx5IGlmIHRoZXkncmUgZGlmZmVyZW50XG5cdFx0XHRmb3IgKCBjb25zdCBuYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0aWYgKCAhIGF0dHJpYnV0ZXNVc2VkLmhhcyggbmFtZSApICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnU3RhdGljR2VvbWV0cnlHZW5lcmF0b3I6IEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBcIicgKyBuYW1lICsgJ1wiIGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGVzWyBuYW1lIF0gPSBbXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXR0cmlidXRlc1sgbmFtZSBdLnB1c2goIGdlb21ldHJ5LmF0dHJpYnV0ZXNbIG5hbWUgXSApO1xuXHRcdFx0XHRhdHRyaWJ1dGVzQ291bnQgKys7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZW5zdXJlIGdlb21ldHJpZXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgYXR0cmlidXRlc1xuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzQ291bnQgIT09IGF0dHJpYnV0ZXNVc2VkLnNpemUgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnU3RhdGljR2VvbWV0cnlHZW5lcmF0b3I6IE1ha2Ugc3VyZSBhbGwgZ2VvbWV0cmllcyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBhdHRyaWJ1dGVzLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHVzZUdyb3VwcyApIHtcblxuXHRcdFx0XHRsZXQgY291bnQ7XG5cdFx0XHRcdGlmICggaXNJbmRleGVkICkge1xuXG5cdFx0XHRcdFx0Y291bnQgPSBnZW9tZXRyeS5pbmRleC5jb3VudDtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb3VudCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1N0YXRpY0dlb21ldHJ5R2VuZXJhdG9yOiBUaGUgZ2VvbWV0cnkgbXVzdCBoYXZlIGVpdGhlciBhbiBpbmRleCBvciBhIHBvc2l0aW9uIGF0dHJpYnV0ZScgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuYWRkR3JvdXAoIG9mZnNldCwgY291bnQsIGkgKTtcblx0XHRcdFx0b2Zmc2V0ICs9IGNvdW50O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBtZXJnZSBpbmRpY2VzXG5cdFx0aWYgKCBpc0luZGV4ZWQgKSB7XG5cblx0XHRcdGxldCBmb3JjZVVwZGF0ZUluZGV4ID0gZmFsc2U7XG5cdFx0XHRpZiAoICEgdGFyZ2V0R2VvbWV0cnkuaW5kZXggKSB7XG5cblx0XHRcdFx0bGV0IGluZGV4Q291bnQgPSAwO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0XHRcdGluZGV4Q291bnQgKz0gZ2VvbWV0cmllc1sgaSBdLmluZGV4LmNvdW50O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5zZXRJbmRleCggbmV3IHRocmVlLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQzMkFycmF5KCBpbmRleENvdW50ICksIDEsIGZhbHNlICkgKTtcblx0XHRcdFx0Zm9yY2VVcGRhdGVJbmRleCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1cGRhdGVJbmRleCB8fCBmb3JjZVVwZGF0ZUluZGV4ICkge1xuXG5cdFx0XHRcdGNvbnN0IHRhcmdldEluZGV4ID0gdGFyZ2V0R2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdGxldCB0YXJnZXRPZmZzZXQgPSAwO1xuXHRcdFx0XHRsZXQgaW5kZXhPZmZzZXQgPSAwO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdFx0aWYgKCBza2lwQXR0cmlidXRlc1sgaSBdICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBpbmRleC5jb3VudDsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0XHR0YXJnZXRJbmRleC5zZXRYKCB0YXJnZXRPZmZzZXQsIGluZGV4LmdldFgoIGogKSArIGluZGV4T2Zmc2V0ICk7XG5cdFx0XHRcdFx0XHRcdHRhcmdldE9mZnNldCArKztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW5kZXhPZmZzZXQgKz0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIG1lcmdlIGF0dHJpYnV0ZXNcblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJMaXN0ID0gYXR0cmlidXRlc1sgbmFtZSBdO1xuXHRcdFx0aWYgKCAhICggbmFtZSBpbiB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzICkgKSB7XG5cblx0XHRcdFx0bGV0IGNvdW50ID0gMDtcblx0XHRcdFx0Zm9yICggY29uc3Qga2V5IGluIGF0dHJMaXN0ICkge1xuXG5cdFx0XHRcdFx0Y291bnQgKz0gYXR0ckxpc3RbIGtleSBdLmNvdW50O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoIG5hbWUsIGNyZWF0ZUF0dHJpYnV0ZUNsb25lKCBhdHRyaWJ1dGVzWyBuYW1lIF1bIDAgXSwgY291bnQgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRhcmdldEF0dHJpYnV0ZSA9IHRhcmdldEdlb21ldHJ5LmF0dHJpYnV0ZXNbIG5hbWUgXTtcblx0XHRcdGxldCBvZmZzZXQgPSAwO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXR0ckxpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhdHRyID0gYXR0ckxpc3RbIGkgXTtcblx0XHRcdFx0aWYgKCBza2lwQXR0cmlidXRlc1sgaSBdICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Y29weUF0dHJpYnV0ZUNvbnRlbnRzKCBhdHRyLCB0YXJnZXRBdHRyaWJ1dGUsIG9mZnNldCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvZmZzZXQgKz0gYXR0ci5jb3VudDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldEdlb21ldHJ5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1R5cGVkQXJyYXlFcXVhbGl0eSggYSwgYiApIHtcblxuXHRcdGlmICggYSA9PT0gbnVsbCB8fCBiID09PSBudWxsICkge1xuXG5cdFx0XHRyZXR1cm4gYSA9PT0gYjtcblxuXHRcdH1cblxuXHRcdGlmICggYS5sZW5ndGggIT09IGIubGVuZ3RoICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGlmICggYVsgaSBdICE9PSBiWyBpIF0gKSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0Ly8gQ2hlY2tzIHdoZXRoZXIgdGhlIGdlb21ldHJ5IGNoYW5nZWQgYmV0d2VlbiB0aGlzIGFuZCBsYXN0IGV2YWx1YXRpb25cblx0Y2xhc3MgR2VvbWV0cnlEaWZmIHtcblxuXHRcdGNvbnN0cnVjdG9yKCBtZXNoICkge1xuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IHRocmVlLk1hdHJpeDQoKTtcblx0XHRcdHRoaXMuZ2VvbWV0cnlIYXNoID0gbnVsbDtcblx0XHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbnVsbDtcblx0XHRcdHRoaXMucHJpbWl0aXZlQ291bnQgPSAtIDE7XG5cdFx0XHR0aGlzLm1lc2ggPSBtZXNoO1xuXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0dXBkYXRlKCkge1xuXG5cdFx0XHRjb25zdCBtZXNoID0gdGhpcy5tZXNoO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBtZXNoLnNrZWxldG9uO1xuXHRcdFx0Y29uc3QgcHJpbWl0aXZlQ291bnQgPSAoIGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuaW5kZXguY291bnQgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50ICkgLyAzO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cdFx0XHR0aGlzLmdlb21ldHJ5SGFzaCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmVyc2lvbjtcblx0XHRcdHRoaXMucHJpbWl0aXZlQ291bnQgPSBwcmltaXRpdmVDb3VudDtcblxuXHRcdFx0aWYgKCBza2VsZXRvbiApIHtcblxuXHRcdFx0XHQvLyBlbnN1cmUgdGhlIGJvbmUgbWF0cml4IGFycmF5IGlzIHVwZGF0ZWQgdG8gdGhlIGFwcHJvcHJpYXRlIGxlbmd0aFxuXHRcdFx0XHRpZiAoICEgc2tlbGV0b24uYm9uZVRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRza2VsZXRvbi5jb21wdXRlQm9uZVRleHR1cmUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2tlbGV0b24udXBkYXRlKCk7XG5cblx0XHRcdFx0Ly8gY29weSBkYXRhIGlmIHBvc3NpYmxlIG90aGVyd2lzZSBjbG9uZSBpdFxuXHRcdFx0XHRjb25zdCBib25lTWF0cmljZXMgPSBza2VsZXRvbi5ib25lTWF0cmljZXM7XG5cdFx0XHRcdGlmICggISB0aGlzLmJvbmVNYXRyaWNlcyB8fCB0aGlzLmJvbmVNYXRyaWNlcy5sZW5ndGggIT09IGJvbmVNYXRyaWNlcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IGJvbmVNYXRyaWNlcy5zbGljZSgpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvbmVNYXRyaWNlcy5zZXQoIGJvbmVNYXRyaWNlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGRpZENoYW5nZSgpIHtcblxuXHRcdFx0Y29uc3QgbWVzaCA9IHRoaXMubWVzaDtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IHByaW1pdGl2ZUNvdW50ID0gKCBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmluZGV4LmNvdW50IDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCApIC8gMztcblx0XHRcdGNvbnN0IGlkZW50aWNhbCA9XG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuZXF1YWxzKCBtZXNoLm1hdHJpeFdvcmxkICkgJiZcblx0XHRcdFx0dGhpcy5nZW9tZXRyeUhhc2ggPT09IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmVyc2lvbiAmJlxuXHRcdFx0XHRjaGVja1R5cGVkQXJyYXlFcXVhbGl0eSggbWVzaC5za2VsZXRvbiAmJiBtZXNoLnNrZWxldG9uLmJvbmVNYXRyaWNlcyB8fCBudWxsLCB0aGlzLmJvbmVNYXRyaWNlcyApICYmXG5cdFx0XHRcdHRoaXMucHJpbWl0aXZlQ291bnQgPT09IHByaW1pdGl2ZUNvdW50O1xuXG5cdFx0XHRyZXR1cm4gISBpZGVudGljYWw7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFN0YXRpY0dlb21ldHJ5R2VuZXJhdG9yIHtcblxuXHRcdGNvbnN0cnVjdG9yKCBtZXNoZXMgKSB7XG5cblx0XHRcdGlmICggISBBcnJheS5pc0FycmF5KCBtZXNoZXMgKSApIHtcblxuXHRcdFx0XHRtZXNoZXMgPSBbIG1lc2hlcyBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZpbmFsTWVzaGVzID0gW107XG5cdFx0XHRtZXNoZXMuZm9yRWFjaCggb2JqZWN0ID0+IHtcblxuXHRcdFx0XHRvYmplY3QudHJhdmVyc2VWaXNpYmxlKCBjID0+IHtcblxuXHRcdFx0XHRcdGlmICggYy5pc01lc2ggKSB7XG5cblx0XHRcdFx0XHRcdGZpbmFsTWVzaGVzLnB1c2goIGMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5tZXNoZXMgPSBmaW5hbE1lc2hlcztcblx0XHRcdHRoaXMudXNlR3JvdXBzID0gdHJ1ZTtcblx0XHRcdHRoaXMuYXBwbHlXb3JsZFRyYW5zZm9ybXMgPSB0cnVlO1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0gWyAncG9zaXRpb24nLCAnbm9ybWFsJywgJ2NvbG9yJywgJ3RhbmdlbnQnLCAndXYnLCAndXYyJyBdO1xuXHRcdFx0dGhpcy5faW50ZXJtZWRpYXRlR2VvbWV0cnkgPSBuZXcgQXJyYXkoIGZpbmFsTWVzaGVzLmxlbmd0aCApLmZpbGwoKS5tYXAoICgpID0+IG5ldyB0aHJlZS5CdWZmZXJHZW9tZXRyeSgpICk7XG5cdFx0XHR0aGlzLl9kaWZmTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdH1cblxuXHRcdGdldE1hdGVyaWFscygpIHtcblxuXHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gW107XG5cdFx0XHR0aGlzLm1lc2hlcy5mb3JFYWNoKCBtZXNoID0+IHtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1lc2gubWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCAuLi5tZXNoLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCBtZXNoLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xuXG5cdFx0fVxuXG5cdFx0Z2VuZXJhdGUoIHRhcmdldEdlb21ldHJ5ID0gbmV3IHRocmVlLkJ1ZmZlckdlb21ldHJ5KCkgKSB7XG5cblx0XHRcdC8vIHRyYWNrIHdoaWNoIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIHVwZGF0ZWQgYW5kIHdoaWNoIHRvIHNraXAgdG8gYXZvaWQgdW5uZWNlc3NhcnkgYXR0cmlidXRlIGNvcGllc1xuXHRcdFx0bGV0IHNraXBBdHRyaWJ1dGVzID0gW107XG5cdFx0XHRjb25zdCB7IG1lc2hlcywgdXNlR3JvdXBzLCBfaW50ZXJtZWRpYXRlR2VvbWV0cnksIF9kaWZmTWFwIH0gPSB0aGlzO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWVzaCA9IG1lc2hlc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBnZW9tID0gX2ludGVybWVkaWF0ZUdlb21ldHJ5WyBpIF07XG5cdFx0XHRcdGNvbnN0IGRpZmYgPSBfZGlmZk1hcC5nZXQoIG1lc2ggKTtcblx0XHRcdFx0aWYgKCAhIGRpZmYgfHwgZGlmZi5kaWRDaGFuZ2UoIG1lc2ggKSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX2NvbnZlcnRUb1N0YXRpY0dlb21ldHJ5KCBtZXNoLCBnZW9tICk7XG5cdFx0XHRcdFx0c2tpcEF0dHJpYnV0ZXMucHVzaCggZmFsc2UgKTtcblxuXHRcdFx0XHRcdGlmICggISBkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRfZGlmZk1hcC5zZXQoIG1lc2gsIG5ldyBHZW9tZXRyeURpZmYoIG1lc2ggKSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ZGlmZi51cGRhdGUoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2tpcEF0dHJpYnV0ZXMucHVzaCggdHJ1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRtZXJnZUJ1ZmZlckdlb21ldHJpZXMoIF9pbnRlcm1lZGlhdGVHZW9tZXRyeSwgeyB1c2VHcm91cHMsIHNraXBBdHRyaWJ1dGVzIH0sIHRhcmdldEdlb21ldHJ5ICk7XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdHRhcmdldEdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0R2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHRfY29udmVydFRvU3RhdGljR2VvbWV0cnkoIG1lc2gsIHRhcmdldEdlb21ldHJ5ID0gbmV3IHRocmVlLkJ1ZmZlckdlb21ldHJ5KCkgKSB7XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IGFwcGx5V29ybGRUcmFuc2Zvcm1zID0gdGhpcy5hcHBseVdvcmxkVHJhbnNmb3Jtcztcblx0XHRcdGNvbnN0IGluY2x1ZGVOb3JtYWwgPSB0aGlzLmF0dHJpYnV0ZXMuaW5jbHVkZXMoICdub3JtYWwnICk7XG5cdFx0XHRjb25zdCBpbmNsdWRlVGFuZ2VudCA9IHRoaXMuYXR0cmlidXRlcy5pbmNsdWRlcyggJ3RhbmdlbnQnICk7XG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdGNvbnN0IHRhcmdldEF0dHJpYnV0ZXMgPSB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0XHQvLyBpbml0aWFsaXplIHRoZSBhdHRyaWJ1dGVzIGlmIHRoZXkgZG9uJ3QgZXhpc3Rcblx0XHRcdGlmICggISB0YXJnZXRHZW9tZXRyeS5pbmRleCApIHtcblxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5pbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISB0YXJnZXRBdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xuXG5cdFx0XHRcdHRhcmdldEdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgY3JlYXRlQXR0cmlidXRlQ2xvbmUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaW5jbHVkZU5vcm1hbCAmJiAhIHRhcmdldEF0dHJpYnV0ZXMubm9ybWFsICYmIGF0dHJpYnV0ZXMubm9ybWFsICkge1xuXG5cdFx0XHRcdHRhcmdldEdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIGNyZWF0ZUF0dHJpYnV0ZUNsb25lKCBhdHRyaWJ1dGVzLm5vcm1hbCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpbmNsdWRlVGFuZ2VudCAmJiAhIHRhcmdldEF0dHJpYnV0ZXMudGFuZ2VudCAmJiBhdHRyaWJ1dGVzLnRhbmdlbnQgKSB7XG5cblx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndGFuZ2VudCcsIGNyZWF0ZUF0dHJpYnV0ZUNsb25lKCBhdHRyaWJ1dGVzLnRhbmdlbnQgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGVuc3VyZSB0aGUgYXR0cmlidXRlcyBhcmUgY29uc2lzdGVudFxuXHRcdFx0dmFsaWRhdGVBdHRyaWJ1dGVzKCBnZW9tZXRyeS5pbmRleCwgdGFyZ2V0R2VvbWV0cnkuaW5kZXggKTtcblx0XHRcdHZhbGlkYXRlQXR0cmlidXRlcyggYXR0cmlidXRlcy5wb3NpdGlvbiwgdGFyZ2V0QXR0cmlidXRlcy5wb3NpdGlvbiApO1xuXG5cdFx0XHRpZiAoIGluY2x1ZGVOb3JtYWwgKSB7XG5cblx0XHRcdFx0dmFsaWRhdGVBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzLm5vcm1hbCwgdGFyZ2V0QXR0cmlidXRlcy5ub3JtYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGluY2x1ZGVUYW5nZW50ICkge1xuXG5cdFx0XHRcdHZhbGlkYXRlQXR0cmlidXRlcyggYXR0cmlidXRlcy50YW5nZW50LCB0YXJnZXRBdHRyaWJ1dGVzLnRhbmdlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBnZW5lcmF0ZSB0cmFuc2Zvcm1lZCB2ZXJ0ZXggYXR0cmlidXRlIGRhdGFcblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGNvbnN0IG5vcm1hbCA9IGluY2x1ZGVOb3JtYWwgPyBhdHRyaWJ1dGVzLm5vcm1hbCA6IG51bGw7XG5cdFx0XHRjb25zdCB0YW5nZW50ID0gaW5jbHVkZVRhbmdlbnQgPyBhdHRyaWJ1dGVzLnRhbmdlbnQgOiBudWxsO1xuXHRcdFx0Y29uc3QgbW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGNvbnN0IG1vcnBoTm9ybWFsID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbDtcblx0XHRcdGNvbnN0IG1vcnBoVGFuZ2VudCA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy50YW5nZW50O1xuXHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblx0XHRcdGNvbnN0IG1vcnBoSW5mbHVlbmNlcyA9IG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXHRcdFx0Y29uc3Qgbm9ybWFsTWF0cml4ID0gbmV3IHRocmVlLk1hdHJpeDMoKTtcblx0XHRcdG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG1lc2gubWF0cml4V29ybGQgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3Bvc2l0aW9uVmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpICk7XG5cdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0X25vcm1hbFZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIGkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0YW5nZW50ICkge1xuXG5cdFx0XHRcdFx0X3RhbmdlbnRWZWN0b3I0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRhbmdlbnQsIGkgKTtcblx0XHRcdFx0XHRfdGFuZ2VudFZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0YW5nZW50LCBpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFwcGx5IG1vcnBoIHRhcmdldCB0cmFuc2Zvcm1cblx0XHRcdFx0aWYgKCBtb3JwaEluZmx1ZW5jZXMgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG1vcnBoUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0XHRcdGFwcGx5TW9ycGhUYXJnZXQoIG1vcnBoUG9zaXRpb24sIG1vcnBoSW5mbHVlbmNlcywgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIGksIF9wb3NpdGlvblZlY3RvciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBtb3JwaE5vcm1hbCApIHtcblxuXHRcdFx0XHRcdFx0YXBwbHlNb3JwaFRhcmdldCggbW9ycGhOb3JtYWwsIG1vcnBoSW5mbHVlbmNlcywgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIGksIF9ub3JtYWxWZWN0b3IgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggbW9ycGhUYW5nZW50ICkge1xuXG5cdFx0XHRcdFx0XHRhcHBseU1vcnBoVGFyZ2V0KCBtb3JwaFRhbmdlbnQsIG1vcnBoSW5mbHVlbmNlcywgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIGksIF90YW5nZW50VmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFwcGx5IGJvbmUgdHJhbnNmb3JtXG5cdFx0XHRcdGlmICggbWVzaC5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRcdFx0bWVzaC5hcHBseUJvbmVUcmFuc2Zvcm0oIGksIF9wb3NpdGlvblZlY3RvciApO1xuXHRcdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0XHRib25lTm9ybWFsVHJhbnNmb3JtKCBtZXNoLCBpLCBfbm9ybWFsVmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHRhbmdlbnQgKSB7XG5cblx0XHRcdFx0XHRcdGJvbmVOb3JtYWxUcmFuc2Zvcm0oIG1lc2gsIGksIF90YW5nZW50VmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHVwZGF0ZSB0aGUgdmVjdG9ycyBvZiB0aGUgYXR0cmlidXRlc1xuXHRcdFx0XHRpZiAoIGFwcGx5V29ybGRUcmFuc2Zvcm1zICkge1xuXG5cdFx0XHRcdFx0X3Bvc2l0aW9uVmVjdG9yLmFwcGx5TWF0cml4NCggbWVzaC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXRBdHRyaWJ1dGVzLnBvc2l0aW9uLnNldFhZWiggaSwgX3Bvc2l0aW9uVmVjdG9yLngsIF9wb3NpdGlvblZlY3Rvci55LCBfcG9zaXRpb25WZWN0b3IueiApO1xuXG5cdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0aWYgKCBhcHBseVdvcmxkVHJhbnNmb3JtcyApIHtcblxuXHRcdFx0XHRcdFx0X25vcm1hbFZlY3Rvci5hcHBseU5vcm1hbE1hdHJpeCggbm9ybWFsTWF0cml4ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0YXJnZXRBdHRyaWJ1dGVzLm5vcm1hbC5zZXRYWVooIGksIF9ub3JtYWxWZWN0b3IueCwgX25vcm1hbFZlY3Rvci55LCBfbm9ybWFsVmVjdG9yLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0YW5nZW50ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBhcHBseVdvcmxkVHJhbnNmb3JtcyApIHtcblxuXHRcdFx0XHRcdFx0X3RhbmdlbnRWZWN0b3IudHJhbnNmb3JtRGlyZWN0aW9uKCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0YXJnZXRBdHRyaWJ1dGVzLnRhbmdlbnQuc2V0WFlaVyggaSwgX3RhbmdlbnRWZWN0b3IueCwgX3RhbmdlbnRWZWN0b3IueSwgX3RhbmdlbnRWZWN0b3IueiwgX3RhbmdlbnRWZWN0b3I0LncgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29weSBvdGhlciBhdHRyaWJ1dGVzIG92ZXJcblx0XHRcdGZvciAoIGNvbnN0IGkgaW4gdGhpcy5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdGNvbnN0IGtleSA9IHRoaXMuYXR0cmlidXRlc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGtleSA9PT0gJ3Bvc2l0aW9uJyB8fCBrZXkgPT09ICd0YW5nZW50JyB8fCBrZXkgPT09ICdub3JtYWwnIHx8ICEgKCBrZXkgaW4gYXR0cmlidXRlcyApICkge1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggISB0YXJnZXRBdHRyaWJ1dGVzWyBrZXkgXSApIHtcblxuXHRcdFx0XHRcdHRhcmdldEdlb21ldHJ5LnNldEF0dHJpYnV0ZSgga2V5LCBjcmVhdGVBdHRyaWJ1dGVDbG9uZSggYXR0cmlidXRlc1sga2V5IF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YWxpZGF0ZUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXNbIGtleSBdLCB0YXJnZXRBdHRyaWJ1dGVzWyBrZXkgXSApO1xuXHRcdFx0XHRjb3B5QXR0cmlidXRlQ29udGVudHMoIGF0dHJpYnV0ZXNbIGtleSBdLCB0YXJnZXRBdHRyaWJ1dGVzWyBrZXkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0YXJnZXRHZW9tZXRyeTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZXhwb3J0cy5BVkVSQUdFID0gQVZFUkFHRTtcblx0ZXhwb3J0cy5DRU5URVIgPSBDRU5URVI7XG5cdGV4cG9ydHMuQ09OVEFJTkVEID0gQ09OVEFJTkVEO1xuXHRleHBvcnRzLkV4dGVuZGVkVHJpYW5nbGUgPSBFeHRlbmRlZFRyaWFuZ2xlO1xuXHRleHBvcnRzLkZsb2F0VmVydGV4QXR0cmlidXRlVGV4dHVyZSA9IEZsb2F0VmVydGV4QXR0cmlidXRlVGV4dHVyZTtcblx0ZXhwb3J0cy5JTlRFUlNFQ1RFRCA9IElOVEVSU0VDVEVEO1xuXHRleHBvcnRzLkludFZlcnRleEF0dHJpYnV0ZVRleHR1cmUgPSBJbnRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlO1xuXHRleHBvcnRzLk1lc2hCVkggPSBNZXNoQlZIO1xuXHRleHBvcnRzLk1lc2hCVkhVbmlmb3JtU3RydWN0ID0gTWVzaEJWSFVuaWZvcm1TdHJ1Y3Q7XG5cdGV4cG9ydHMuTWVzaEJWSFZpc3VhbGl6ZXIgPSBNZXNoQlZIVmlzdWFsaXplcjtcblx0ZXhwb3J0cy5OT1RfSU5URVJTRUNURUQgPSBOT1RfSU5URVJTRUNURUQ7XG5cdGV4cG9ydHMuT3JpZW50ZWRCb3ggPSBPcmllbnRlZEJveDtcblx0ZXhwb3J0cy5TQUggPSBTQUg7XG5cdGV4cG9ydHMuU3RhdGljR2VvbWV0cnlHZW5lcmF0b3IgPSBTdGF0aWNHZW9tZXRyeUdlbmVyYXRvcjtcblx0ZXhwb3J0cy5VSW50VmVydGV4QXR0cmlidXRlVGV4dHVyZSA9IFVJbnRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlO1xuXHRleHBvcnRzLlZlcnRleEF0dHJpYnV0ZVRleHR1cmUgPSBWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlO1xuXHRleHBvcnRzLmFjY2VsZXJhdGVkUmF5Y2FzdCA9IGFjY2VsZXJhdGVkUmF5Y2FzdDtcblx0ZXhwb3J0cy5jb21wdXRlQm91bmRzVHJlZSA9IGNvbXB1dGVCb3VuZHNUcmVlO1xuXHRleHBvcnRzLmRpc3Bvc2VCb3VuZHNUcmVlID0gZGlzcG9zZUJvdW5kc1RyZWU7XG5cdGV4cG9ydHMuZXN0aW1hdGVNZW1vcnlJbkJ5dGVzID0gZXN0aW1hdGVNZW1vcnlJbkJ5dGVzO1xuXHRleHBvcnRzLmdldEJWSEV4dHJlbWVzID0gZ2V0QlZIRXh0cmVtZXM7XG5cdGV4cG9ydHMuZ2V0SlNPTlN0cnVjdHVyZSA9IGdldEpTT05TdHJ1Y3R1cmU7XG5cdGV4cG9ydHMuZ2V0VHJpYW5nbGVIaXRQb2ludEluZm8gPSBnZXRUcmlhbmdsZUhpdFBvaW50SW5mbztcblx0ZXhwb3J0cy5zaGFkZXJEaXN0YW5jZUZ1bmN0aW9uID0gc2hhZGVyRGlzdGFuY2VGdW5jdGlvbjtcblx0ZXhwb3J0cy5zaGFkZXJJbnRlcnNlY3RGdW5jdGlvbiA9IHNoYWRlckludGVyc2VjdEZ1bmN0aW9uO1xuXHRleHBvcnRzLnNoYWRlclN0cnVjdHMgPSBzaGFkZXJTdHJ1Y3RzO1xuXHRleHBvcnRzLnZhbGlkYXRlQm91bmRzID0gdmFsaWRhdGVCb3VuZHM7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgudW1kLmNqcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-mesh-bvh/build/index.umd.cjs\n");

/***/ })

};
;