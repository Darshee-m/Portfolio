"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/webgl-fluid-enhanced";
exports.ids = ["vendor-chunks/webgl-fluid-enhanced"];
exports.modules = {

/***/ "(ssr)/./node_modules/webgl-fluid-enhanced/dist/webgl-fluid-enhanced.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/webgl-fluid-enhanced/dist/webgl-fluid-enhanced.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ht)\n/* harmony export */ });\nconst u = {\n  SIM_RESOLUTION: 128,\n  DYE_RESOLUTION: 1024,\n  CAPTURE_RESOLUTION: 512,\n  DENSITY_DISSIPATION: 1,\n  VELOCITY_DISSIPATION: 0.2,\n  PRESSURE: 0.8,\n  PRESSURE_ITERATIONS: 20,\n  CURL: 30,\n  INITIAL: !0,\n  SPLAT_AMOUNT: 5,\n  SPLAT_RADIUS: 0.25,\n  SPLAT_FORCE: 6e3,\n  SPLAT_KEY: \"Space\",\n  SHADING: !0,\n  COLORFUL: !0,\n  COLOR_UPDATE_SPEED: 10,\n  COLOR_PALETTE: [],\n  HOVER: !0,\n  BACK_COLOR: \"#000000\",\n  TRANSPARENT: !1,\n  BRIGHTNESS: 0.5,\n  BLOOM: !0,\n  BLOOM_ITERATIONS: 8,\n  BLOOM_RESOLUTION: 256,\n  BLOOM_INTENSITY: 0.8,\n  BLOOM_THRESHOLD: 0.6,\n  BLOOM_SOFT_KNEE: 0.7,\n  SUNRAYS: !0,\n  SUNRAYS_RESOLUTION: 196,\n  SUNRAYS_WEIGHT: 1\n};\nlet H = [], ee = [], w = !1;\nconst ht = {\n  // Trigger splats\n  splats() {\n    H.push(parseInt(Math.random() * u.SPLAT_AMOUNT * 4 + u.SPLAT_AMOUNT));\n  },\n  splat(s, C, y, g, D = void 0) {\n    ee.push([s, C, y, g, D]);\n  },\n  // Pause function\n  paused() {\n    w ? w = !1 : w = !0;\n  },\n  // Edit function\n  config(s) {\n    Object.assign(u, s);\n  },\n  // Simulation section\n  simulation(s, C = {}) {\n    Object.assign(u, C), ve();\n    function y() {\n      this.id = -1, this.texcoordX = 0, this.texcoordY = 0, this.prevTexcoordX = 0, this.prevTexcoordY = 0, this.deltaX = 0, this.deltaY = 0, this.down = !1, this.moved = !1, this.color = [30, 0, 300];\n    }\n    let g = [], D = [];\n    g.push(new y());\n    const { gl: t, ext: x } = Re(s);\n    x.supportLinearFiltering || (u.DYE_RESOLUTION = 512, u.SHADING = !1, u.BLOOM = !1, u.SUNRAYS = !1);\n    function Re(e) {\n      const i = {\n        alpha: !0,\n        depth: !1,\n        stencil: !1,\n        antialias: !1,\n        preserveDrawingBuffer: !1\n      };\n      let r = e.getContext(\"webgl2\", i);\n      const o = !!r;\n      o || (r = e.getContext(\"webgl\", i) || e.getContext(\"experimental-webgl\", i));\n      let a, n;\n      o ? (r.getExtension(\"EXT_color_buffer_float\"), n = r.getExtension(\"OES_texture_float_linear\")) : (a = r.getExtension(\"OES_texture_half_float\"), n = r.getExtension(\"OES_texture_half_float_linear\")), r.clearColor(0, 0, 0, 1);\n      const l = o ? r.HALF_FLOAT : a.HALF_FLOAT_OES;\n      let c, m, p;\n      return o ? (c = U(r, r.RGBA16F, r.RGBA, l), m = U(r, r.RG16F, r.RG, l), p = U(r, r.R16F, r.RED, l)) : (c = U(r, r.RGBA, r.RGBA, l), m = U(r, r.RGBA, r.RGBA, l), p = U(r, r.RGBA, r.RGBA, l)), {\n        gl: r,\n        ext: {\n          formatRGBA: c,\n          formatRG: m,\n          formatR: p,\n          halfFloatTexType: l,\n          supportLinearFiltering: n\n        }\n      };\n    }\n    function U(e, i, r, o) {\n      if (!Ae(e, i, r, o))\n        switch (i) {\n          case e.R16F:\n            return U(e, e.RG16F, e.RG, o);\n          case e.RG16F:\n            return U(e, e.RGBA16F, e.RGBA, o);\n          default:\n            return null;\n        }\n      return {\n        internalFormat: i,\n        format: r\n      };\n    }\n    function Ae(e, i, r, o) {\n      let a = e.createTexture();\n      e.bindTexture(e.TEXTURE_2D, a), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texImage2D(e.TEXTURE_2D, 0, i, 4, 4, 0, r, o, null);\n      let n = e.createFramebuffer();\n      return e.bindFramebuffer(e.FRAMEBUFFER, n), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, a, 0), e.checkFramebufferStatus(e.FRAMEBUFFER) == e.FRAMEBUFFER_COMPLETE;\n    }\n    class Se {\n      constructor(i, r) {\n        this.vertexShader = i, this.fragmentShaderSource = r, this.programs = [], this.activeProgram = null, this.uniforms = [];\n      }\n      setKeywords(i) {\n        let r = 0;\n        for (let a = 0; a < i.length; a++)\n          r += vt(i[a]);\n        let o = this.programs[r];\n        if (o == null) {\n          let a = h(t.FRAGMENT_SHADER, this.fragmentShaderSource, i);\n          o = te(this.vertexShader, a), this.programs[r] = o;\n        }\n        o != this.activeProgram && (this.uniforms = re(o), this.activeProgram = o);\n      }\n      bind() {\n        t.useProgram(this.activeProgram);\n      }\n    }\n    class d {\n      constructor(i, r) {\n        this.uniforms = {}, this.program = te(i, r), this.uniforms = re(this.program);\n      }\n      bind() {\n        t.useProgram(this.program);\n      }\n    }\n    function te(e, i) {\n      let r = t.createProgram();\n      return t.attachShader(r, e), t.attachShader(r, i), t.linkProgram(r), t.getProgramParameter(r, t.LINK_STATUS) || console.trace(t.getProgramInfoLog(r)), r;\n    }\n    function re(e) {\n      let i = [], r = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);\n      for (let o = 0; o < r; o++) {\n        let a = t.getActiveUniform(e, o).name;\n        i[a] = t.getUniformLocation(e, a);\n      }\n      return i;\n    }\n    function h(e, i, r) {\n      i = pe(i, r);\n      const o = t.createShader(e);\n      return t.shaderSource(o, i), t.compileShader(o), t.getShaderParameter(o, t.COMPILE_STATUS) || console.trace(t.getShaderInfoLog(o)), o;\n    }\n    function pe(e, i) {\n      if (i == null)\n        return e;\n      let r = \"\";\n      return i.forEach((o) => {\n        r += \"#define \" + o + `\n`;\n      }), r + e;\n    }\n    const T = h(\n      t.VERTEX_SHADER,\n      `\n    precision highp float;\n\n    attribute vec2 aPosition;\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform vec2 texelSize;\n\n    void main () {\n        vUv = aPosition * 0.5 + 0.5;\n        vL = vUv - vec2(texelSize.x, 0.0);\n        vR = vUv + vec2(texelSize.x, 0.0);\n        vT = vUv + vec2(0.0, texelSize.y);\n        vB = vUv - vec2(0.0, texelSize.y);\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n    }\n`\n    ), De = h(\n      t.VERTEX_SHADER,\n      `\n    precision highp float;\n\n    attribute vec2 aPosition;\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    uniform vec2 texelSize;\n\n    void main () {\n        vUv = aPosition * 0.5 + 0.5;\n        float offset = 1.33333333;\n        vL = vUv - texelSize * offset;\n        vR = vUv + texelSize * offset;\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n    }\n`\n    ), Ue = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    uniform sampler2D uTexture;\n\n    void main () {\n        vec4 sum = texture2D(uTexture, vUv) * 0.29411764;\n        sum += texture2D(uTexture, vL) * 0.35294117;\n        sum += texture2D(uTexture, vR) * 0.35294117;\n        gl_FragColor = sum;\n    }\n`\n    ), be = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    uniform sampler2D uTexture;\n\n    void main () {\n        gl_FragColor = texture2D(uTexture, vUv);\n    }\n`\n    ), Le = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float value;\n\n    void main () {\n        gl_FragColor = value * texture2D(uTexture, vUv);\n    }\n`\n    ), Fe = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision mediump float;\n\n    uniform vec4 color;\n\n    void main () {\n        gl_FragColor = color;\n    }\n`\n    ), Ne = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float aspectRatio;\n\n    #define SCALE 25.0\n\n    void main () {\n        vec2 uv = floor(vUv * SCALE * vec2(aspectRatio, 1.0));\n        float v = mod(uv.x + uv.y, 2.0);\n        v = v * 0.1 + 0.8;\n        gl_FragColor = vec4(vec3(v), 1.0);\n    }\n`\n    ), Oe = `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform sampler2D uBloom;\n    uniform sampler2D uSunrays;\n    uniform sampler2D uDithering;\n    uniform vec2 ditherScale;\n    uniform vec2 texelSize;\n\n    vec3 linearToGamma (vec3 color) {\n        color = max(color, vec3(0));\n        return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\n    }\n\n    void main () {\n        vec3 c = texture2D(uTexture, vUv).rgb;\n\n    #ifdef SHADING\n        vec3 lc = texture2D(uTexture, vL).rgb;\n        vec3 rc = texture2D(uTexture, vR).rgb;\n        vec3 tc = texture2D(uTexture, vT).rgb;\n        vec3 bc = texture2D(uTexture, vB).rgb;\n\n        float dx = length(rc) - length(lc);\n        float dy = length(tc) - length(bc);\n\n        vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n        vec3 l = vec3(0.0, 0.0, 1.0);\n\n        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n        c *= diffuse;\n    #endif\n\n    #ifdef BLOOM\n        vec3 bloom = texture2D(uBloom, vUv).rgb;\n    #endif\n\n    #ifdef SUNRAYS\n        float sunrays = texture2D(uSunrays, vUv).r;\n        c *= sunrays;\n    #ifdef BLOOM\n        bloom *= sunrays;\n    #endif\n    #endif\n\n    #ifdef BLOOM\n        float noise = texture2D(uDithering, vUv * ditherScale).r;\n        noise = noise * 2.0 - 1.0;\n        bloom += noise / 255.0;\n        bloom = linearToGamma(bloom);\n        c += bloom;\n    #endif\n\n        float a = max(c.r, max(c.g, c.b));\n        gl_FragColor = vec4(c, a);\n    }\n`, ye = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform vec3 curve;\n    uniform float threshold;\n\n    void main () {\n        vec3 c = texture2D(uTexture, vUv).rgb;\n        float br = max(c.r, max(c.g, c.b));\n        float rq = clamp(br - curve.x, 0.0, curve.y);\n        rq = curve.z * rq * rq;\n        c *= max(rq, br - threshold) / max(br, 0.0001);\n        gl_FragColor = vec4(c, 0.0);\n    }\n`\n    ), Be = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n\n    void main () {\n        vec4 sum = vec4(0.0);\n        sum += texture2D(uTexture, vL);\n        sum += texture2D(uTexture, vR);\n        sum += texture2D(uTexture, vT);\n        sum += texture2D(uTexture, vB);\n        sum *= 0.25;\n        gl_FragColor = sum;\n    }\n`\n    ), Ie = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform float intensity;\n\n    void main () {\n        vec4 sum = vec4(0.0);\n        sum += texture2D(uTexture, vL);\n        sum += texture2D(uTexture, vR);\n        sum += texture2D(uTexture, vT);\n        sum += texture2D(uTexture, vB);\n        sum *= 0.25;\n        gl_FragColor = sum * intensity;\n    }\n`\n    ), we = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n\n    void main () {\n        vec4 c = texture2D(uTexture, vUv);\n        float br = max(c.r, max(c.g, c.b));\n        c.a = 1.0 - min(max(br * 20.0, 0.0), 0.8);\n        gl_FragColor = c;\n    }\n`\n    ), Ce = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float weight;\n\n    #define ITERATIONS 16\n\n    void main () {\n        float Density = 0.3;\n        float Decay = 0.95;\n        float Exposure = 0.7;\n\n        vec2 coord = vUv;\n        vec2 dir = vUv - 0.5;\n\n        dir *= 1.0 / float(ITERATIONS) * Density;\n        float illuminationDecay = 1.0;\n\n        float color = texture2D(uTexture, vUv).a;\n\n        for (int i = 0; i < ITERATIONS; i++)\n        {\n            coord -= dir;\n            float col = texture2D(uTexture, coord).a;\n            color += col * illuminationDecay * weight;\n            illuminationDecay *= Decay;\n        }\n\n        gl_FragColor = vec4(color * Exposure, 0.0, 0.0, 1.0);\n    }\n`\n    ), Xe = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTarget;\n    uniform float aspectRatio;\n    uniform vec3 color;\n    uniform vec2 point;\n    uniform float radius;\n\n    void main () {\n        vec2 p = vUv - point.xy;\n        p.x *= aspectRatio;\n        vec3 splat = exp(-dot(p, p) / radius) * color;\n        vec3 base = texture2D(uTarget, vUv).xyz;\n        gl_FragColor = vec4(base + splat, 1.0);\n    }\n`\n    ), Ye = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uSource;\n    uniform vec2 texelSize;\n    uniform vec2 dyeTexelSize;\n    uniform float dt;\n    uniform float dissipation;\n\n    vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n        vec2 st = uv / tsize - 0.5;\n\n        vec2 iuv = floor(st);\n        vec2 fuv = fract(st);\n\n        vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n        vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n        vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n        vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n\n        return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n    }\n\n    void main () {\n    #ifdef MANUAL_FILTERING\n        vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n        vec4 result = bilerp(uSource, coord, dyeTexelSize);\n    #else\n        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n        vec4 result = texture2D(uSource, coord);\n    #endif\n        float decay = 1.0 + dissipation * dt;\n        gl_FragColor = result / decay;\n    }`,\n      x.supportLinearFiltering ? null : [\"MANUAL_FILTERING\"]\n    ), Me = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uVelocity;\n\n    void main () {\n        float L = texture2D(uVelocity, vL).x;\n        float R = texture2D(uVelocity, vR).x;\n        float T = texture2D(uVelocity, vT).y;\n        float B = texture2D(uVelocity, vB).y;\n\n        vec2 C = texture2D(uVelocity, vUv).xy;\n        if (vL.x < 0.0) { L = -C.x; }\n        if (vR.x > 1.0) { R = -C.x; }\n        if (vT.y > 1.0) { T = -C.y; }\n        if (vB.y < 0.0) { B = -C.y; }\n\n        float div = 0.5 * (R - L + T - B);\n        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n    }\n`\n    ), Pe = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uVelocity;\n\n    void main () {\n        float L = texture2D(uVelocity, vL).y;\n        float R = texture2D(uVelocity, vR).y;\n        float T = texture2D(uVelocity, vT).x;\n        float B = texture2D(uVelocity, vB).x;\n        float vorticity = R - L - T + B;\n        gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n    }\n`\n    ), ze = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uCurl;\n    uniform float curl;\n    uniform float dt;\n\n    void main () {\n        float L = texture2D(uCurl, vL).x;\n        float R = texture2D(uCurl, vR).x;\n        float T = texture2D(uCurl, vT).x;\n        float B = texture2D(uCurl, vB).x;\n        float C = texture2D(uCurl, vUv).x;\n\n        vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n        force /= length(force) + 0.0001;\n        force *= curl * C;\n        force.y *= -1.0;\n\n        vec2 velocity = texture2D(uVelocity, vUv).xy;\n        velocity += force * dt;\n        velocity = min(max(velocity, -1000.0), 1000.0);\n        gl_FragColor = vec4(velocity, 0.0, 1.0);\n    }\n`\n    ), Ve = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uPressure;\n    uniform sampler2D uDivergence;\n\n    void main () {\n        float L = texture2D(uPressure, vL).x;\n        float R = texture2D(uPressure, vR).x;\n        float T = texture2D(uPressure, vT).x;\n        float B = texture2D(uPressure, vB).x;\n        float C = texture2D(uPressure, vUv).x;\n        float divergence = texture2D(uDivergence, vUv).x;\n        float pressure = (L + R + B + T - divergence) * 0.25;\n        gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n    }\n`\n    ), Ge = h(\n      t.FRAGMENT_SHADER,\n      `\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uPressure;\n    uniform sampler2D uVelocity;\n\n    void main () {\n        float L = texture2D(uPressure, vL).x;\n        float R = texture2D(uPressure, vR).x;\n        float T = texture2D(uPressure, vT).x;\n        float B = texture2D(uPressure, vB).x;\n        vec2 velocity = texture2D(uVelocity, vUv).xy;\n        velocity.xy -= vec2(R - L, T - B);\n        gl_FragColor = vec4(velocity, 0.0, 1.0);\n    }\n`\n    ), v = (() => (t.bindBuffer(t.ARRAY_BUFFER, t.createBuffer()), t.bufferData(t.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, t.createBuffer()), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), t.STATIC_DRAW), t.vertexAttribPointer(0, 2, t.FLOAT, !1, 0, 0), t.enableVertexAttribArray(0), (e, i = !1) => {\n      e == null ? (t.viewport(0, 0, t.drawingBufferWidth, t.drawingBufferHeight), t.bindFramebuffer(t.FRAMEBUFFER, null)) : (t.viewport(0, 0, e.width, e.height), t.bindFramebuffer(t.FRAMEBUFFER, e.fbo)), i && (t.clearColor(0, 0, 0, 1), t.clear(t.COLOR_BUFFER_BIT)), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0);\n    }))();\n    let E, f, K, _, b, W, X, ie, oe = _e(\n      \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAQKADAAQAAAABAAAAQAAAAABGUUKwAAAeK0lEQVR4AT3aBbRuVdUG4HW5hNLdSHd3CyjdEtLd3Y1wKZHuLgFJRenuBqW7u7tTlu8zx//9ZwwG8J397b3WnG/NtU9bYokl+nfffdf//e9/96uuuqrPN998/ZRTTukbb7xxP/zww/u+++7bf/vb3/YddtihP/roo32SSSbpL7zwQj/99NP7Vltt1X/88ce+8sor13Vvv/12Hzp0aF999dX7Bx980P/617/2WWedtX/55Zd9++237zPMMEP/05/+1DfYYIP+0EMP9amnnrq/9957/ZZbbum//PJLf+yxx/pJJ53URxtttL7WWmv1P//5z/3bb7/t9913X63t9ddf7wsvvHBff/31+6GHHtovu+yyPuecc/YbbrihH3300fXshRZaqF900UW1zv/85z991FFHrfXce++9ffjhh+/nnXdeXe8e7tsuv/zy+vKEE07YDzzwwNpoz4/FPfnkk32VVVbpd911V7/66qv7Mccc0y+99NI+yiij9KWWWqoffPDB/frrr6+HWfjss8/e77jjju6ev/vd72ojNrfiiiv21lo98Pzzz6/fnXjiif0f//hH33rrrWujFr7JJpvU/d5///1+wQUX9N12261PNdVUfbnlluvDDTdc//TTT+vzW2+9tY844oj9q6++6i+++GKffPLJaz3W+fXXX1fx3N/6vv/++3rOG2+8Uc/66KOP+njjjVff22OPPXr7+OOPq4oqftZZZ3VdtLkxxhijX3zxxd0XFGeOOebof/zjH/tee+1VC7nnnnv6uuuuWwt55ZVXqurbbLNNH3fccdWv77333t0innrqqX7QQQf1tddeu3uWh88zzzz9m2++6WONNVZt7txzz61njDTSSP2AAw7oM888c1988cX77bffXgvdaKON+rBhw/oEE0xQKJltttn6Lrvs0k844YS+5ppr9i233LK/8847tTYo23bbbfurr75ahYYQaFUk9/Zd31twwQX7yCOP3JuO6cIzzzxTEJppppmqUzrrc50dMmRIf+211/rPP//cF1lkkeqKToK3ii+66KL98ccf74cddlhfZ511+gMPPNCnnXbavsACC9RGJ5tssv7Pf/6zFrLrrrvWxp5++ulC3DXXXFMFff7557uigjy6TTzxxP3zzz8vNM0999zVHDT6wx/+0H/44Yc+6aST1vXW869//aufccYZfZxxxql1oLIGQp/naQLaLbvssoVkdF9ttdUKTUPcaJZZZmnbbbddW2yxxVoW2rKolg0oTgtn0KTluvbggw+2VVddtWXxLbxvJ598cptuuulaqt/CxxZet2hHW2ONNdr444/fbrrpppYCtUCxhUr1WXShpRMtm2tZaJtxxhlbEFf3iP60LLq+Hzq18Lxlg/X9l156qT3yyCP17JtvvrmFw23eeedtvhO0tf3337+eEU1pKVRbYYUV2hZbbNGuu+46KG/Rl5ZN138HPW333Xdv1tJwRJfxjcDoIjHSAb9bb731+u9///uC0MMPP1y8JnogN+aYY5aYqSYhAm1dG3vssTtagPRRRx3VL7zwwu67BImwTTHFFP1vf/tbJ2r3339/T+H7lFNO+f/d9nkWXx3NQquDUObaaaaZpr/55pt9n332qa6iVZrQ05zSEDq133771f1Qw/OJIo2xt3POOafEkMin+L2BK9VNhfumm25am3rrrbf68ccf36effvp+2223lYh88sknxbtUvT7DJ4W54oor+tlnn103tWgLALt0qzaGYoR0zz337F988UUPKop/xx13XBXYIs8888wqqE0RS4JrU6eeempPt8shUIuKe4Zn0g+/41o777xzv+SSS+q7zz33XLmaooK6vaA1rXj55ZeLvhpMY9wHpDuOuRne/v3vfy9h2nHHHTue//rXv64v4h6r0TkbmWiiiTpx+u9//1uL9eC77767ukjEPJDlsUnCR5zYKx7TC87gc0oNGRBEYzbccMNyH88gnksuuSSKVhe5FEvlNoQN8o499tjSp2WWWaZ0gaYQa41TQAJ+5ZVXlk3TtBtvvLGa9Nlnn5VQN/bA71XYZiyanbAYAsOaQMoiRhhhhE683Cj873PNNVc93Pep/vLLL19dJXooQt0hhig9++yz5QTuwUp15c477ywnIcC+S4/cCxVlCcW3Ps2QP6i3Qi+99NKFsJ9++qlHa6rwHMyawZzS/+pXvypas1CiOfroo1c2WWmllaqAHAXyhqZDw6LmJWpZeEsh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\"\n    );\n    const B = new d(De, Ue), ae = new d(T, be), k = new d(T, Le), ne = new d(T, Fe), ue = new d(T, Ne), Y = new d(T, ye), I = new d(T, Be), M = new d(T, Ie), le = new d(T, we), q = new d(T, Ce), L = new d(T, Xe), R = new d(T, Ye), J = new d(T, Me), Z = new d(T, Pe), O = new d(T, ze), P = new d(T, Ve), z = new d(T, Ge), F = new Se(T, Oe);\n    function ce() {\n      let e = Q(u.SIM_RESOLUTION), i = Q(u.DYE_RESOLUTION);\n      const r = x.halfFloatTexType, o = x.formatRGBA, a = x.formatRG, n = x.formatR, l = x.supportLinearFiltering ? t.LINEAR : t.NEAREST;\n      t.disable(t.BLEND), E == null ? E = j(i.width, i.height, o.internalFormat, o.format, r, l) : E = fe(E, i.width, i.height, o.internalFormat, o.format, r, l), f == null ? f = j(e.width, e.height, a.internalFormat, a.format, r, l) : f = fe(f, e.width, e.height, a.internalFormat, a.format, r, l), K = A(e.width, e.height, n.internalFormat, n.format, r, t.NEAREST), _ = A(e.width, e.height, n.internalFormat, n.format, r, t.NEAREST), b = j(e.width, e.height, n.internalFormat, n.format, r, t.NEAREST), Qe(), He();\n    }\n    function Qe() {\n      let e = Q(u.BLOOM_RESOLUTION);\n      const i = x.halfFloatTexType, r = x.formatRGBA, o = x.supportLinearFiltering ? t.LINEAR : t.NEAREST;\n      W = A(e.width, e.height, r.internalFormat, r.format, i, o), D.length = 0;\n      for (let a = 0; a < u.BLOOM_ITERATIONS; a++) {\n        let n = e.width >> a + 1, l = e.height >> a + 1;\n        if (n < 2 || l < 2)\n          break;\n        let c = A(n, l, r.internalFormat, r.format, i, o);\n        D.push(c);\n      }\n    }\n    function He() {\n      let e = Q(u.SUNRAYS_RESOLUTION);\n      const i = x.halfFloatTexType, r = x.formatR, o = x.supportLinearFiltering ? t.LINEAR : t.NEAREST;\n      X = A(e.width, e.height, r.internalFormat, r.format, i, o), ie = A(e.width, e.height, r.internalFormat, r.format, i, o);\n    }\n    function A(e, i, r, o, a, n) {\n      t.activeTexture(t.TEXTURE0);\n      let l = t.createTexture();\n      t.bindTexture(t.TEXTURE_2D, l), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, n), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, n), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texImage2D(t.TEXTURE_2D, 0, r, e, i, 0, o, a, null);\n      let c = t.createFramebuffer();\n      t.bindFramebuffer(t.FRAMEBUFFER, c), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, l, 0), t.viewport(0, 0, e, i), t.clear(t.COLOR_BUFFER_BIT);\n      let m = 1 / e, p = 1 / i;\n      return {\n        texture: l,\n        fbo: c,\n        width: e,\n        height: i,\n        texelSizeX: m,\n        texelSizeY: p,\n        attach(N) {\n          return t.activeTexture(t.TEXTURE0 + N), t.bindTexture(t.TEXTURE_2D, l), N;\n        }\n      };\n    }\n    function j(e, i, r, o, a, n) {\n      let l = A(e, i, r, o, a, n), c = A(e, i, r, o, a, n);\n      return {\n        width: e,\n        height: i,\n        texelSizeX: l.texelSizeX,\n        texelSizeY: l.texelSizeY,\n        get read() {\n          return l;\n        },\n        set read(m) {\n          l = m;\n        },\n        get write() {\n          return c;\n        },\n        set write(m) {\n          c = m;\n        },\n        swap() {\n          let m = l;\n          l = c, c = m;\n        }\n      };\n    }\n    function Ke(e, i, r, o, a, n, l) {\n      let c = A(i, r, o, a, n, l);\n      return ae.bind(), t.uniform1i(ae.uniforms.uTexture, e.attach(0)), v(c), c;\n    }\n    function fe(e, i, r, o, a, n, l) {\n      return e.width == i && e.height == r || (e.read = Ke(e.read, i, r, o, a, n, l), e.write = A(i, r, o, a, n, l), e.width = i, e.height = r, e.texelSizeX = 1 / i, e.texelSizeY = 1 / r), e;\n    }\n    function _e(e) {\n      let i = t.createTexture();\n      t.bindTexture(t.TEXTURE_2D, i), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.REPEAT), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, new Uint8Array([255, 255, 255]));\n      let r = {\n        texture: i,\n        width: 1,\n        height: 1,\n        attach(a) {\n          return t.activeTexture(t.TEXTURE0 + a), t.bindTexture(t.TEXTURE_2D, i), a;\n        }\n      }, o = new Image();\n      return o.onload = () => {\n        r.width = o.width, r.height = o.height, t.bindTexture(t.TEXTURE_2D, i), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, t.RGB, t.UNSIGNED_BYTE, o);\n      }, o.src = e, r;\n    }\n    function We() {\n      let e = [];\n      u.SHADING && e.push(\"SHADING\"), u.BLOOM && e.push(\"BLOOM\"), u.SUNRAYS && e.push(\"SUNRAYS\"), F.setKeywords(e);\n    }\n    We(), ce(), C.INITIAL && he(parseInt(Math.random() * u.SPLAT_AMOUNT * 4 + u.SPLAT_AMOUNT));\n    let se = Date.now(), V = 0;\n    me();\n    function me() {\n      const e = ke();\n      ve() && ce(), qe(e), Je(), w || Ze(e), je(null), requestAnimationFrame(me);\n    }\n    function ke() {\n      let e = Date.now(), i = (e - se) / 1e3;\n      return i = Math.min(i, 0.016666), se = e, i;\n    }\n    function ve() {\n      let e = S(s.clientWidth), i = S(s.clientHeight);\n      return s.width != e || s.height != i ? (s.width = e, s.height = i, !0) : !1;\n    }\n    function qe(e) {\n      u.COLORFUL && (V += e * u.COLOR_UPDATE_SPEED, V >= 1 && (V = st(V, 0, 1), g.forEach((i) => {\n        i.color = G();\n      })));\n    }\n    function Je() {\n      if (H.length > 0 && he(H.pop()), ee.length > 0) {\n        const e = ee.pop(), i = e[0] / s.clientWidth;\n        console.log(i);\n        const r = 1 - e[1] / s.clientHeight, o = e[2] / 2, a = e[3] / 2;\n        let n;\n        if (e[4] != null) {\n          const l = xe(e[4]), c = ge(l.h, l.s, u.BRIGHTNESS);\n          c.r *= 0.15, c.g *= 0.15, c.b *= 0.15, n = c;\n        } else\n          n = G();\n        n.r *= 10, n.g *= 10, n.b *= 10, $(i, r, o, a, n);\n      }\n      g.forEach((e) => {\n        e.moved && (e.moved = !1, at(e));\n      });\n    }\n    function Ze(e) {\n      t.disable(t.BLEND), Z.bind(), t.uniform2f(Z.uniforms.texelSize, f.texelSizeX, f.texelSizeY), t.uniform1i(Z.uniforms.uVelocity, f.read.attach(0)), v(_), O.bind(), t.uniform2f(O.uniforms.texelSize, f.texelSizeX, f.texelSizeY), t.uniform1i(O.uniforms.uVelocity, f.read.attach(0)), t.uniform1i(O.uniforms.uCurl, _.attach(1)), t.uniform1f(O.uniforms.curl, u.CURL), t.uniform1f(O.uniforms.dt, e), v(f.write), f.swap(), J.bind(), t.uniform2f(J.uniforms.texelSize, f.texelSizeX, f.texelSizeY), t.uniform1i(J.uniforms.uVelocity, f.read.attach(0)), v(K), k.bind(), t.uniform1i(k.uniforms.uTexture, b.read.attach(0)), t.uniform1f(k.uniforms.value, u.PRESSURE), v(b.write), b.swap(), P.bind(), t.uniform2f(P.uniforms.texelSize, f.texelSizeX, f.texelSizeY), t.uniform1i(P.uniforms.uDivergence, K.attach(0));\n      for (let r = 0; r < u.PRESSURE_ITERATIONS; r++)\n        t.uniform1i(P.uniforms.uPressure, b.read.attach(1)), v(b.write), b.swap();\n      z.bind(), t.uniform2f(z.uniforms.texelSize, f.texelSizeX, f.texelSizeY), t.uniform1i(z.uniforms.uPressure, b.read.attach(0)), t.uniform1i(z.uniforms.uVelocity, f.read.attach(1)), v(f.write), f.swap(), R.bind(), t.uniform2f(R.uniforms.texelSize, f.texelSizeX, f.texelSizeY), x.supportLinearFiltering || t.uniform2f(R.uniforms.dyeTexelSize, f.texelSizeX, f.texelSizeY);\n      let i = f.read.attach(0);\n      t.uniform1i(R.uniforms.uVelocity, i), t.uniform1i(R.uniforms.uSource, i), t.uniform1f(R.uniforms.dt, e), t.uniform1f(R.uniforms.dissipation, u.VELOCITY_DISSIPATION), v(f.write), f.swap(), x.supportLinearFiltering || t.uniform2f(R.uniforms.dyeTexelSize, E.texelSizeX, E.texelSizeY), t.uniform1i(R.uniforms.uVelocity, f.read.attach(0)), t.uniform1i(R.uniforms.uSource, E.read.attach(1)), t.uniform1f(R.uniforms.dissipation, u.DENSITY_DISSIPATION), v(E.write), E.swap();\n    }\n    function je(e) {\n      u.BLOOM && rt(E.read, W), u.SUNRAYS && (it(E.read, E.write, X), ot(X, ie, 1)), e == null || !u.TRANSPARENT ? (t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA), t.enable(t.BLEND)) : t.disable(t.BLEND), u.TRANSPARENT || $e(e, ft(ct(u.BACK_COLOR))), e == null && u.TRANSPARENT && et(e), tt(e);\n    }\n    function $e(e, i) {\n      ne.bind(), t.uniform4f(ne.uniforms.color, i.r, i.g, i.b, 1), v(e);\n    }\n    function et(e) {\n      ue.bind(), t.uniform1f(ue.uniforms.aspectRatio, s.width / s.height), v(e);\n    }\n    function tt(e) {\n      let i = e == null ? t.drawingBufferWidth : e.width, r = e == null ? t.drawingBufferHeight : e.height;\n      if (F.bind(), u.SHADING && t.uniform2f(F.uniforms.texelSize, 1 / i, 1 / r), t.uniform1i(F.uniforms.uTexture, E.read.attach(0)), u.BLOOM) {\n        t.uniform1i(F.uniforms.uBloom, W.attach(1)), t.uniform1i(F.uniforms.uDithering, oe.attach(2));\n        let o = mt(oe, i, r);\n        t.uniform2f(F.uniforms.ditherScale, o.x, o.y);\n      }\n      u.SUNRAYS && t.uniform1i(F.uniforms.uSunrays, X.attach(3)), v(e);\n    }\n    function rt(e, i) {\n      if (D.length < 2)\n        return;\n      let r = i;\n      t.disable(t.BLEND), Y.bind();\n      let o = u.BLOOM_THRESHOLD * u.BLOOM_SOFT_KNEE + 1e-4, a = u.BLOOM_THRESHOLD - o, n = o * 2, l = 0.25 / o;\n      t.uniform3f(Y.uniforms.curve, a, n, l), t.uniform1f(Y.uniforms.threshold, u.BLOOM_THRESHOLD), t.uniform1i(Y.uniforms.uTexture, e.attach(0)), v(r), I.bind();\n      for (let c = 0; c < D.length; c++) {\n        let m = D[c];\n        t.uniform2f(I.uniforms.texelSize, r.texelSizeX, r.texelSizeY), t.uniform1i(I.uniforms.uTexture, r.attach(0)), v(m), r = m;\n      }\n      t.blendFunc(t.ONE, t.ONE), t.enable(t.BLEND);\n      for (let c = D.length - 2; c >= 0; c--) {\n        let m = D[c];\n        t.uniform2f(I.uniforms.texelSize, r.texelSizeX, r.texelSizeY), t.uniform1i(I.uniforms.uTexture, r.attach(0)), t.viewport(0, 0, m.width, m.height), v(m), r = m;\n      }\n      t.disable(t.BLEND), M.bind(), t.uniform2f(M.uniforms.texelSize, r.texelSizeX, r.texelSizeY), t.uniform1i(M.uniforms.uTexture, r.attach(0)), t.uniform1f(M.uniforms.intensity, u.BLOOM_INTENSITY), v(i);\n    }\n    function it(e, i, r) {\n      t.disable(t.BLEND), le.bind(), t.uniform1i(le.uniforms.uTexture, e.attach(0)), v(i), q.bind(), t.uniform1f(q.uniforms.weight, u.SUNRAYS_WEIGHT), t.uniform1i(q.uniforms.uTexture, i.attach(0)), v(r);\n    }\n    function ot(e, i, r) {\n      B.bind();\n      for (let o = 0; o < r; o++)\n        t.uniform2f(B.uniforms.texelSize, e.texelSizeX, 0), t.uniform1i(B.uniforms.uTexture, e.attach(0)), v(i), t.uniform2f(B.uniforms.texelSize, 0, e.texelSizeY), t.uniform1i(B.uniforms.uTexture, i.attach(0)), v(e);\n    }\n    function at(e) {\n      if (w)\n        return;\n      let i = e.deltaX * u.SPLAT_FORCE, r = e.deltaY * u.SPLAT_FORCE;\n      $(e.texcoordX, e.texcoordY, i, r, e.color);\n    }\n    function he(e) {\n      for (let i = 0; i < e; i++) {\n        const r = G();\n        r.r *= 10, r.g *= 10, r.b *= 10;\n        const o = Math.random(), a = Math.random(), n = 1e3 * (Math.random() - 0.5), l = 1e3 * (Math.random() - 0.5);\n        $(o, a, n, l, r);\n      }\n    }\n    function $(e, i, r, o, a) {\n      L.bind(), t.uniform1i(L.uniforms.uTarget, f.read.attach(0)), t.uniform1f(L.uniforms.aspectRatio, s.width / s.height), t.uniform2f(L.uniforms.point, e, i), t.uniform3f(L.uniforms.color, r, o, 0), t.uniform1f(L.uniforms.radius, nt(u.SPLAT_RADIUS / 100)), v(f.write), f.swap(), t.uniform1i(L.uniforms.uTarget, E.read.attach(0)), t.uniform3f(L.uniforms.color, a.r, a.g, a.b), v(E.write), E.swap();\n    }\n    function nt(e) {\n      let i = s.width / s.height;\n      return i > 1 && (e *= i), e;\n    }\n    s.addEventListener(\"mousedown\", (e) => {\n      let i = S(e.offsetX), r = S(e.offsetY), o = g.find((a) => a.id == -1);\n      o == null && (o = new y()), de(o, -1, i, r);\n    }), setTimeout(() => {\n      s.addEventListener(\"mousemove\", (e) => {\n        let i = g[0], r = S(e.offsetX), o = S(e.offsetY);\n        Te(i, r, o);\n      });\n    }, 500), window.addEventListener(\"mouseup\", () => {\n      Ee(g[0]);\n    }), s.addEventListener(\"touchstart\", (e) => {\n      e.preventDefault();\n      const i = e.targetTouches;\n      for (; i.length >= g.length; )\n        g.push(new y());\n      for (let r = 0; r < i.length; r++) {\n        let o = S(i[r].pageX), a = S(i[r].pageY);\n        de(g[r + 1], i[r].identifier, o, a);\n      }\n    }), s.addEventListener(\n      \"touchmove\",\n      (e) => {\n        e.preventDefault();\n        const i = e.targetTouches;\n        for (let r = 0; r < i.length; r++) {\n          let o = g[r + 1], a = S(i[r].pageX), n = S(i[r].pageY);\n          Te(o, a, n);\n        }\n      },\n      !1\n    ), window.addEventListener(\"touchend\", (e) => {\n      const i = e.changedTouches;\n      for (let r = 0; r < i.length; r++) {\n        let o = g.find((a) => a.id == i[r].identifier);\n        o != null && Ee(o);\n      }\n    }), window.addEventListener(\"keydown\", (e) => {\n      e.code === u.SPLAT_KEY && H.push(parseInt(Math.random() * u.SPLAT_AMOUNT * 4 + u.SPLAT_AMOUNT));\n    });\n    function de(e, i, r, o) {\n      e.id = i, e.down = !0, e.moved = !1, e.texcoordX = r / s.width, e.texcoordY = 1 - o / s.height, e.prevTexcoordX = e.texcoordX, e.prevTexcoordY = e.texcoordY, e.deltaX = 0, e.deltaY = 0, e.color = G();\n    }\n    function Te(e, i, r) {\n      e.prevTexcoordX = e.texcoordX, e.prevTexcoordY = e.texcoordY, e.texcoordX = i / s.width, e.texcoordY = 1 - r / s.height, e.deltaX = ut(e.texcoordX - e.prevTexcoordX), e.deltaY = lt(e.texcoordY - e.prevTexcoordY), u.HOVER ? e.moved = Math.abs(e.deltaX) > 0 || Math.abs(e.deltaY) > 0 : e.moved = e.down;\n    }\n    function Ee(e) {\n      e.down = !1;\n    }\n    function ut(e) {\n      let i = s.width / s.height;\n      return i < 1 && (e *= i), e;\n    }\n    function lt(e) {\n      let i = s.width / s.height;\n      return i > 1 && (e /= i), e;\n    }\n    function G() {\n      let e, i;\n      if (u.COLOR_PALETTE.length == 0)\n        e = Math.random(), i = 1;\n      else {\n        const o = Math.floor(Math.random() * u.COLOR_PALETTE.length), a = u.COLOR_PALETTE[o], n = xe(a);\n        e = n.h, i = n.s;\n      }\n      let r = ge(e, i, u.BRIGHTNESS);\n      return r.r *= 0.15, r.g *= 0.15, r.b *= 0.15, r;\n    }\n    function xe(e) {\n      e = e.replace(\"#\", \"\");\n      const i = parseInt(e.substring(0, 2), 16) / 255, r = parseInt(e.substring(2, 4), 16) / 255, o = parseInt(e.substring(4, 6), 16) / 255, a = Math.max(i, r, o), n = Math.min(i, r, o);\n      let l, c, m;\n      return a === n ? l = 0 : a === i ? l = ((r - o) / (a - n) + 6) % 6 : a === r ? l = (o - i) / (a - n) + 2 : l = (i - r) / (a - n) + 4, l /= 6, a === 0 ? c = 0 : c = (a - n) / a, m = a, { h: l, s: c, v: m };\n    }\n    function ct(e) {\n      e = e.replace(\"#\", \"\");\n      const i = parseInt(e.substr(0, 2), 16), r = parseInt(e.substr(2, 2), 16), o = parseInt(e.substr(4, 2), 16);\n      return { r: i, g: r, b: o };\n    }\n    function ge(e, i, r) {\n      let o, a, n, l, c, m, p, N;\n      switch (l = Math.floor(e * 6), c = e * 6 - l, m = r * (1 - i), p = r * (1 - c * i), N = r * (1 - (1 - c) * i), l % 6) {\n        case 0:\n          o = r, a = N, n = m;\n          break;\n        case 1:\n          o = p, a = r, n = m;\n          break;\n        case 2:\n          o = m, a = r, n = N;\n          break;\n        case 3:\n          o = m, a = p, n = r;\n          break;\n        case 4:\n          o = N, a = m, n = r;\n          break;\n        case 5:\n          o = r, a = m, n = p;\n          break;\n      }\n      return {\n        r: o,\n        g: a,\n        b: n\n      };\n    }\n    function ft(e) {\n      return {\n        r: e.r / 255,\n        g: e.g / 255,\n        b: e.b / 255\n      };\n    }\n    function st(e, i, r) {\n      let o = r - i;\n      return o == 0 ? i : (e - i) % o + i;\n    }\n    function Q(e) {\n      let i = t.drawingBufferWidth / t.drawingBufferHeight;\n      i < 1 && (i = 1 / i);\n      let r = Math.round(e), o = Math.round(e * i);\n      return t.drawingBufferWidth > t.drawingBufferHeight ? { width: o, height: r } : { width: r, height: o };\n    }\n    function mt(e, i, r) {\n      return {\n        x: i / e.width,\n        y: r / e.height\n      };\n    }\n    function S(e) {\n      let i = window.devicePixelRatio || 1;\n      return Math.floor(e * i);\n    }\n    function vt(e) {\n      if (e.length == 0)\n        return 0;\n      let i = 0;\n      for (let r = 0; r < e.length; r++)\n        i = (i << 5) - i + e.charCodeAt(r), i |= 0;\n      return i;\n    }\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViZ2wtZmx1aWQtZW5oYW5jZWQvZGlzdC93ZWJnbC1mbHVpZC1lbmhhbmNlZC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdNQUFnTTtBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHNCQUFzQixJQUFJO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3BlcnNvbmFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvd2ViZ2wtZmx1aWQtZW5oYW5jZWQvZGlzdC93ZWJnbC1mbHVpZC1lbmhhbmNlZC5tanM/OWNiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1ID0ge1xuICBTSU1fUkVTT0xVVElPTjogMTI4LFxuICBEWUVfUkVTT0xVVElPTjogMTAyNCxcbiAgQ0FQVFVSRV9SRVNPTFVUSU9OOiA1MTIsXG4gIERFTlNJVFlfRElTU0lQQVRJT046IDEsXG4gIFZFTE9DSVRZX0RJU1NJUEFUSU9OOiAwLjIsXG4gIFBSRVNTVVJFOiAwLjgsXG4gIFBSRVNTVVJFX0lURVJBVElPTlM6IDIwLFxuICBDVVJMOiAzMCxcbiAgSU5JVElBTDogITAsXG4gIFNQTEFUX0FNT1VOVDogNSxcbiAgU1BMQVRfUkFESVVTOiAwLjI1LFxuICBTUExBVF9GT1JDRTogNmUzLFxuICBTUExBVF9LRVk6IFwiU3BhY2VcIixcbiAgU0hBRElORzogITAsXG4gIENPTE9SRlVMOiAhMCxcbiAgQ09MT1JfVVBEQVRFX1NQRUVEOiAxMCxcbiAgQ09MT1JfUEFMRVRURTogW10sXG4gIEhPVkVSOiAhMCxcbiAgQkFDS19DT0xPUjogXCIjMDAwMDAwXCIsXG4gIFRSQU5TUEFSRU5UOiAhMSxcbiAgQlJJR0hUTkVTUzogMC41LFxuICBCTE9PTTogITAsXG4gIEJMT09NX0lURVJBVElPTlM6IDgsXG4gIEJMT09NX1JFU09MVVRJT046IDI1NixcbiAgQkxPT01fSU5URU5TSVRZOiAwLjgsXG4gIEJMT09NX1RIUkVTSE9MRDogMC42LFxuICBCTE9PTV9TT0ZUX0tORUU6IDAuNyxcbiAgU1VOUkFZUzogITAsXG4gIFNVTlJBWVNfUkVTT0xVVElPTjogMTk2LFxuICBTVU5SQVlTX1dFSUdIVDogMVxufTtcbmxldCBIID0gW10sIGVlID0gW10sIHcgPSAhMTtcbmNvbnN0IGh0ID0ge1xuICAvLyBUcmlnZ2VyIHNwbGF0c1xuICBzcGxhdHMoKSB7XG4gICAgSC5wdXNoKHBhcnNlSW50KE1hdGgucmFuZG9tKCkgKiB1LlNQTEFUX0FNT1VOVCAqIDQgKyB1LlNQTEFUX0FNT1VOVCkpO1xuICB9LFxuICBzcGxhdChzLCBDLCB5LCBnLCBEID0gdm9pZCAwKSB7XG4gICAgZWUucHVzaChbcywgQywgeSwgZywgRF0pO1xuICB9LFxuICAvLyBQYXVzZSBmdW5jdGlvblxuICBwYXVzZWQoKSB7XG4gICAgdyA/IHcgPSAhMSA6IHcgPSAhMDtcbiAgfSxcbiAgLy8gRWRpdCBmdW5jdGlvblxuICBjb25maWcocykge1xuICAgIE9iamVjdC5hc3NpZ24odSwgcyk7XG4gIH0sXG4gIC8vIFNpbXVsYXRpb24gc2VjdGlvblxuICBzaW11bGF0aW9uKHMsIEMgPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odSwgQyksIHZlKCk7XG4gICAgZnVuY3Rpb24geSgpIHtcbiAgICAgIHRoaXMuaWQgPSAtMSwgdGhpcy50ZXhjb29yZFggPSAwLCB0aGlzLnRleGNvb3JkWSA9IDAsIHRoaXMucHJldlRleGNvb3JkWCA9IDAsIHRoaXMucHJldlRleGNvb3JkWSA9IDAsIHRoaXMuZGVsdGFYID0gMCwgdGhpcy5kZWx0YVkgPSAwLCB0aGlzLmRvd24gPSAhMSwgdGhpcy5tb3ZlZCA9ICExLCB0aGlzLmNvbG9yID0gWzMwLCAwLCAzMDBdO1xuICAgIH1cbiAgICBsZXQgZyA9IFtdLCBEID0gW107XG4gICAgZy5wdXNoKG5ldyB5KCkpO1xuICAgIGNvbnN0IHsgZ2w6IHQsIGV4dDogeCB9ID0gUmUocyk7XG4gICAgeC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nIHx8ICh1LkRZRV9SRVNPTFVUSU9OID0gNTEyLCB1LlNIQURJTkcgPSAhMSwgdS5CTE9PTSA9ICExLCB1LlNVTlJBWVMgPSAhMSk7XG4gICAgZnVuY3Rpb24gUmUoZSkge1xuICAgICAgY29uc3QgaSA9IHtcbiAgICAgICAgYWxwaGE6ICEwLFxuICAgICAgICBkZXB0aDogITEsXG4gICAgICAgIHN0ZW5jaWw6ICExLFxuICAgICAgICBhbnRpYWxpYXM6ICExLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ICExXG4gICAgICB9O1xuICAgICAgbGV0IHIgPSBlLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgaSk7XG4gICAgICBjb25zdCBvID0gISFyO1xuICAgICAgbyB8fCAociA9IGUuZ2V0Q29udGV4dChcIndlYmdsXCIsIGkpIHx8IGUuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBpKSk7XG4gICAgICBsZXQgYSwgbjtcbiAgICAgIG8gPyAoci5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpLCBuID0gci5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIikpIDogKGEgPSByLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIiksIG4gPSByLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyXCIpKSwgci5jbGVhckNvbG9yKDAsIDAsIDAsIDEpO1xuICAgICAgY29uc3QgbCA9IG8gPyByLkhBTEZfRkxPQVQgOiBhLkhBTEZfRkxPQVRfT0VTO1xuICAgICAgbGV0IGMsIG0sIHA7XG4gICAgICByZXR1cm4gbyA/IChjID0gVShyLCByLlJHQkExNkYsIHIuUkdCQSwgbCksIG0gPSBVKHIsIHIuUkcxNkYsIHIuUkcsIGwpLCBwID0gVShyLCByLlIxNkYsIHIuUkVELCBsKSkgOiAoYyA9IFUociwgci5SR0JBLCByLlJHQkEsIGwpLCBtID0gVShyLCByLlJHQkEsIHIuUkdCQSwgbCksIHAgPSBVKHIsIHIuUkdCQSwgci5SR0JBLCBsKSksIHtcbiAgICAgICAgZ2w6IHIsXG4gICAgICAgIGV4dDoge1xuICAgICAgICAgIGZvcm1hdFJHQkE6IGMsXG4gICAgICAgICAgZm9ybWF0Ukc6IG0sXG4gICAgICAgICAgZm9ybWF0UjogcCxcbiAgICAgICAgICBoYWxmRmxvYXRUZXhUeXBlOiBsLFxuICAgICAgICAgIHN1cHBvcnRMaW5lYXJGaWx0ZXJpbmc6IG5cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVShlLCBpLCByLCBvKSB7XG4gICAgICBpZiAoIUFlKGUsIGksIHIsIG8pKVxuICAgICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgICBjYXNlIGUuUjE2RjpcbiAgICAgICAgICAgIHJldHVybiBVKGUsIGUuUkcxNkYsIGUuUkcsIG8pO1xuICAgICAgICAgIGNhc2UgZS5SRzE2RjpcbiAgICAgICAgICAgIHJldHVybiBVKGUsIGUuUkdCQTE2RiwgZS5SR0JBLCBvKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGludGVybmFsRm9ybWF0OiBpLFxuICAgICAgICBmb3JtYXQ6IHJcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFlKGUsIGksIHIsIG8pIHtcbiAgICAgIGxldCBhID0gZS5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCwgYSksIGUudGV4UGFyYW1ldGVyaShlLlRFWFRVUkVfMkQsIGUuVEVYVFVSRV9NSU5fRklMVEVSLCBlLk5FQVJFU1QpLCBlLnRleFBhcmFtZXRlcmkoZS5URVhUVVJFXzJELCBlLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZS5ORUFSRVNUKSwgZS50ZXhQYXJhbWV0ZXJpKGUuVEVYVFVSRV8yRCwgZS5URVhUVVJFX1dSQVBfUywgZS5DTEFNUF9UT19FREdFKSwgZS50ZXhQYXJhbWV0ZXJpKGUuVEVYVFVSRV8yRCwgZS5URVhUVVJFX1dSQVBfVCwgZS5DTEFNUF9UT19FREdFKSwgZS50ZXhJbWFnZTJEKGUuVEVYVFVSRV8yRCwgMCwgaSwgNCwgNCwgMCwgciwgbywgbnVsbCk7XG4gICAgICBsZXQgbiA9IGUuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIHJldHVybiBlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLCBuKSwgZS5mcmFtZWJ1ZmZlclRleHR1cmUyRChlLkZSQU1FQlVGRkVSLCBlLkNPTE9SX0FUVEFDSE1FTlQwLCBlLlRFWFRVUkVfMkQsIGEsIDApLCBlLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZS5GUkFNRUJVRkZFUikgPT0gZS5GUkFNRUJVRkZFUl9DT01QTEVURTtcbiAgICB9XG4gICAgY2xhc3MgU2Uge1xuICAgICAgY29uc3RydWN0b3IoaSwgcikge1xuICAgICAgICB0aGlzLnZlcnRleFNoYWRlciA9IGksIHRoaXMuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSByLCB0aGlzLnByb2dyYW1zID0gW10sIHRoaXMuYWN0aXZlUHJvZ3JhbSA9IG51bGwsIHRoaXMudW5pZm9ybXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHNldEtleXdvcmRzKGkpIHtcbiAgICAgICAgbGV0IHIgPSAwO1xuICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGkubGVuZ3RoOyBhKyspXG4gICAgICAgICAgciArPSB2dChpW2FdKTtcbiAgICAgICAgbGV0IG8gPSB0aGlzLnByb2dyYW1zW3JdO1xuICAgICAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICAgICAgbGV0IGEgPSBoKHQuRlJBR01FTlRfU0hBREVSLCB0aGlzLmZyYWdtZW50U2hhZGVyU291cmNlLCBpKTtcbiAgICAgICAgICBvID0gdGUodGhpcy52ZXJ0ZXhTaGFkZXIsIGEpLCB0aGlzLnByb2dyYW1zW3JdID0gbztcbiAgICAgICAgfVxuICAgICAgICBvICE9IHRoaXMuYWN0aXZlUHJvZ3JhbSAmJiAodGhpcy51bmlmb3JtcyA9IHJlKG8pLCB0aGlzLmFjdGl2ZVByb2dyYW0gPSBvKTtcbiAgICAgIH1cbiAgICAgIGJpbmQoKSB7XG4gICAgICAgIHQudXNlUHJvZ3JhbSh0aGlzLmFjdGl2ZVByb2dyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjbGFzcyBkIHtcbiAgICAgIGNvbnN0cnVjdG9yKGksIHIpIHtcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHt9LCB0aGlzLnByb2dyYW0gPSB0ZShpLCByKSwgdGhpcy51bmlmb3JtcyA9IHJlKHRoaXMucHJvZ3JhbSk7XG4gICAgICB9XG4gICAgICBiaW5kKCkge1xuICAgICAgICB0LnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGUoZSwgaSkge1xuICAgICAgbGV0IHIgPSB0LmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgIHJldHVybiB0LmF0dGFjaFNoYWRlcihyLCBlKSwgdC5hdHRhY2hTaGFkZXIociwgaSksIHQubGlua1Byb2dyYW0ociksIHQuZ2V0UHJvZ3JhbVBhcmFtZXRlcihyLCB0LkxJTktfU1RBVFVTKSB8fCBjb25zb2xlLnRyYWNlKHQuZ2V0UHJvZ3JhbUluZm9Mb2cocikpLCByO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZShlKSB7XG4gICAgICBsZXQgaSA9IFtdLCByID0gdC5nZXRQcm9ncmFtUGFyYW1ldGVyKGUsIHQuQUNUSVZFX1VOSUZPUk1TKTtcbiAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgcjsgbysrKSB7XG4gICAgICAgIGxldCBhID0gdC5nZXRBY3RpdmVVbmlmb3JtKGUsIG8pLm5hbWU7XG4gICAgICAgIGlbYV0gPSB0LmdldFVuaWZvcm1Mb2NhdGlvbihlLCBhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoKGUsIGksIHIpIHtcbiAgICAgIGkgPSBwZShpLCByKTtcbiAgICAgIGNvbnN0IG8gPSB0LmNyZWF0ZVNoYWRlcihlKTtcbiAgICAgIHJldHVybiB0LnNoYWRlclNvdXJjZShvLCBpKSwgdC5jb21waWxlU2hhZGVyKG8pLCB0LmdldFNoYWRlclBhcmFtZXRlcihvLCB0LkNPTVBJTEVfU1RBVFVTKSB8fCBjb25zb2xlLnRyYWNlKHQuZ2V0U2hhZGVySW5mb0xvZyhvKSksIG87XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlKGUsIGkpIHtcbiAgICAgIGlmIChpID09IG51bGwpXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgbGV0IHIgPSBcIlwiO1xuICAgICAgcmV0dXJuIGkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICByICs9IFwiI2RlZmluZSBcIiArIG8gKyBgXG5gO1xuICAgICAgfSksIHIgKyBlO1xuICAgIH1cbiAgICBjb25zdCBUID0gaChcbiAgICAgIHQuVkVSVEVYX1NIQURFUixcbiAgICAgIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cbiAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcblxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZVdiA9IGFQb3NpdGlvbiAqIDAuNSArIDAuNTtcbiAgICAgICAgdkwgPSB2VXYgLSB2ZWMyKHRleGVsU2l6ZS54LCAwLjApO1xuICAgICAgICB2UiA9IHZVdiArIHZlYzIodGV4ZWxTaXplLngsIDAuMCk7XG4gICAgICAgIHZUID0gdlV2ICsgdmVjMigwLjAsIHRleGVsU2l6ZS55KTtcbiAgICAgICAgdkIgPSB2VXYgLSB2ZWMyKDAuMCwgdGV4ZWxTaXplLnkpO1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uLCAwLjAsIDEuMCk7XG4gICAgfVxuYFxuICAgICksIERlID0gaChcbiAgICAgIHQuVkVSVEVYX1NIQURFUixcbiAgICAgIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cbiAgICBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2VXYgPSBhUG9zaXRpb24gKiAwLjUgKyAwLjU7XG4gICAgICAgIGZsb2F0IG9mZnNldCA9IDEuMzMzMzMzMzM7XG4gICAgICAgIHZMID0gdlV2IC0gdGV4ZWxTaXplICogb2Zmc2V0O1xuICAgICAgICB2UiA9IHZVdiArIHRleGVsU2l6ZSAqIG9mZnNldDtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xuICAgIH1cbmBcbiAgICApLCBVZSA9IGgoXG4gICAgICB0LkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIHZlYzIgdlI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2ZWM0IHN1bSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KSAqIDAuMjk0MTE3NjQ7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZMKSAqIDAuMzUyOTQxMTc7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZSKSAqIDAuMzUyOTQxMTc7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHN1bTtcbiAgICB9XG5gXG4gICAgKSwgYmUgPSBoKFxuICAgICAgdC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcblxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlV2KTtcbiAgICB9XG5gXG4gICAgKSwgTGUgPSBoKFxuICAgICAgdC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIGZsb2F0IHZhbHVlO1xuXG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmFsdWUgKiB0ZXh0dXJlMkQodVRleHR1cmUsIHZVdik7XG4gICAgfVxuYFxuICAgICksIEZlID0gaChcbiAgICAgIHQuRlJBR01FTlRfU0hBREVSLFxuICAgICAgYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgdW5pZm9ybSB2ZWM0IGNvbG9yO1xuXG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG4gICAgfVxuYFxuICAgICksIE5lID0gaChcbiAgICAgIHQuRlJBR01FTlRfU0hBREVSLFxuICAgICAgYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIGZsb2F0IGFzcGVjdFJhdGlvO1xuXG4gICAgI2RlZmluZSBTQ0FMRSAyNS4wXG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2ZWMyIHV2ID0gZmxvb3IodlV2ICogU0NBTEUgKiB2ZWMyKGFzcGVjdFJhdGlvLCAxLjApKTtcbiAgICAgICAgZmxvYXQgdiA9IG1vZCh1di54ICsgdXYueSwgMi4wKTtcbiAgICAgICAgdiA9IHYgKiAwLjEgKyAwLjg7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodmVjMyh2KSwgMS4wKTtcbiAgICB9XG5gXG4gICAgKSwgT2UgPSBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgIHZhcnlpbmcgdmVjMiB2TDtcbiAgICB2YXJ5aW5nIHZlYzIgdlI7XG4gICAgdmFyeWluZyB2ZWMyIHZUO1xuICAgIHZhcnlpbmcgdmVjMiB2QjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1Qmxvb207XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVN1bnJheXM7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdURpdGhlcmluZztcbiAgICB1bmlmb3JtIHZlYzIgZGl0aGVyU2NhbGU7XG4gICAgdW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcblxuICAgIHZlYzMgbGluZWFyVG9HYW1tYSAodmVjMyBjb2xvcikge1xuICAgICAgICBjb2xvciA9IG1heChjb2xvciwgdmVjMygwKSk7XG4gICAgICAgIHJldHVybiBtYXgoMS4wNTUgKiBwb3coY29sb3IsIHZlYzMoMC40MTY2NjY2NjcpKSAtIDAuMDU1LCB2ZWMzKDApKTtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2ZWMzIGMgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZVdikucmdiO1xuXG4gICAgI2lmZGVmIFNIQURJTkdcbiAgICAgICAgdmVjMyBsYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkwpLnJnYjtcbiAgICAgICAgdmVjMyByYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlIpLnJnYjtcbiAgICAgICAgdmVjMyB0YyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlQpLnJnYjtcbiAgICAgICAgdmVjMyBiYyA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkIpLnJnYjtcblxuICAgICAgICBmbG9hdCBkeCA9IGxlbmd0aChyYykgLSBsZW5ndGgobGMpO1xuICAgICAgICBmbG9hdCBkeSA9IGxlbmd0aCh0YykgLSBsZW5ndGgoYmMpO1xuXG4gICAgICAgIHZlYzMgbiA9IG5vcm1hbGl6ZSh2ZWMzKGR4LCBkeSwgbGVuZ3RoKHRleGVsU2l6ZSkpKTtcbiAgICAgICAgdmVjMyBsID0gdmVjMygwLjAsIDAuMCwgMS4wKTtcblxuICAgICAgICBmbG9hdCBkaWZmdXNlID0gY2xhbXAoZG90KG4sIGwpICsgMC43LCAwLjcsIDEuMCk7XG4gICAgICAgIGMgKj0gZGlmZnVzZTtcbiAgICAjZW5kaWZcblxuICAgICNpZmRlZiBCTE9PTVxuICAgICAgICB2ZWMzIGJsb29tID0gdGV4dHVyZTJEKHVCbG9vbSwgdlV2KS5yZ2I7XG4gICAgI2VuZGlmXG5cbiAgICAjaWZkZWYgU1VOUkFZU1xuICAgICAgICBmbG9hdCBzdW5yYXlzID0gdGV4dHVyZTJEKHVTdW5yYXlzLCB2VXYpLnI7XG4gICAgICAgIGMgKj0gc3VucmF5cztcbiAgICAjaWZkZWYgQkxPT01cbiAgICAgICAgYmxvb20gKj0gc3VucmF5cztcbiAgICAjZW5kaWZcbiAgICAjZW5kaWZcblxuICAgICNpZmRlZiBCTE9PTVxuICAgICAgICBmbG9hdCBub2lzZSA9IHRleHR1cmUyRCh1RGl0aGVyaW5nLCB2VXYgKiBkaXRoZXJTY2FsZSkucjtcbiAgICAgICAgbm9pc2UgPSBub2lzZSAqIDIuMCAtIDEuMDtcbiAgICAgICAgYmxvb20gKz0gbm9pc2UgLyAyNTUuMDtcbiAgICAgICAgYmxvb20gPSBsaW5lYXJUb0dhbW1hKGJsb29tKTtcbiAgICAgICAgYyArPSBibG9vbTtcbiAgICAjZW5kaWZcblxuICAgICAgICBmbG9hdCBhID0gbWF4KGMuciwgbWF4KGMuZywgYy5iKSk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoYywgYSk7XG4gICAgfVxuYCwgeWUgPSBoKFxuICAgICAgdC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIHZlYzMgY3VydmU7XG4gICAgdW5pZm9ybSBmbG9hdCB0aHJlc2hvbGQ7XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2ZWMzIGMgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZVdikucmdiO1xuICAgICAgICBmbG9hdCBiciA9IG1heChjLnIsIG1heChjLmcsIGMuYikpO1xuICAgICAgICBmbG9hdCBycSA9IGNsYW1wKGJyIC0gY3VydmUueCwgMC4wLCBjdXJ2ZS55KTtcbiAgICAgICAgcnEgPSBjdXJ2ZS56ICogcnEgKiBycTtcbiAgICAgICAgYyAqPSBtYXgocnEsIGJyIC0gdGhyZXNob2xkKSAvIG1heChiciwgMC4wMDAxKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjLCAwLjApO1xuICAgIH1cbmBcbiAgICApLCBCZSA9IGgoXG4gICAgICB0LkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2ZWM0IHN1bSA9IHZlYzQoMC4wKTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkwpO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2Uik7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUKTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkIpO1xuICAgICAgICBzdW0gKj0gMC4yNTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gc3VtO1xuICAgIH1cbmBcbiAgICApLCBJZSA9IGgoXG4gICAgICB0LkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkQ7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdkw7XG4gICAgdmFyeWluZyB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIHZlYzIgdkI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBmbG9hdCBpbnRlbnNpdHk7XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2ZWM0IHN1bSA9IHZlYzQoMC4wKTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkwpO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2Uik7XG4gICAgICAgIHN1bSArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUKTtcbiAgICAgICAgc3VtICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdkIpO1xuICAgICAgICBzdW0gKj0gMC4yNTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gc3VtICogaW50ZW5zaXR5O1xuICAgIH1cbmBcbiAgICApLCB3ZSA9IGgoXG4gICAgICB0LkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcblxuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2ZWM0IGMgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZVdik7XG4gICAgICAgIGZsb2F0IGJyID0gbWF4KGMuciwgbWF4KGMuZywgYy5iKSk7XG4gICAgICAgIGMuYSA9IDEuMCAtIG1pbihtYXgoYnIgKiAyMC4wLCAwLjApLCAwLjgpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjO1xuICAgIH1cbmBcbiAgICApLCBDZSA9IGgoXG4gICAgICB0LkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcblxuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XG4gICAgdW5pZm9ybSBmbG9hdCB3ZWlnaHQ7XG5cbiAgICAjZGVmaW5lIElURVJBVElPTlMgMTZcblxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGZsb2F0IERlbnNpdHkgPSAwLjM7XG4gICAgICAgIGZsb2F0IERlY2F5ID0gMC45NTtcbiAgICAgICAgZmxvYXQgRXhwb3N1cmUgPSAwLjc7XG5cbiAgICAgICAgdmVjMiBjb29yZCA9IHZVdjtcbiAgICAgICAgdmVjMiBkaXIgPSB2VXYgLSAwLjU7XG5cbiAgICAgICAgZGlyICo9IDEuMCAvIGZsb2F0KElURVJBVElPTlMpICogRGVuc2l0eTtcbiAgICAgICAgZmxvYXQgaWxsdW1pbmF0aW9uRGVjYXkgPSAxLjA7XG5cbiAgICAgICAgZmxvYXQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZVdikuYTtcblxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IElURVJBVElPTlM7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgY29vcmQgLT0gZGlyO1xuICAgICAgICAgICAgZmxvYXQgY29sID0gdGV4dHVyZTJEKHVUZXh0dXJlLCBjb29yZCkuYTtcbiAgICAgICAgICAgIGNvbG9yICs9IGNvbCAqIGlsbHVtaW5hdGlvbkRlY2F5ICogd2VpZ2h0O1xuICAgICAgICAgICAgaWxsdW1pbmF0aW9uRGVjYXkgKj0gRGVjYXk7XG4gICAgICAgIH1cblxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yICogRXhwb3N1cmUsIDAuMCwgMC4wLCAxLjApO1xuICAgIH1cbmBcbiAgICApLCBYZSA9IGgoXG4gICAgICB0LkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcblxuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVRhcmdldDtcbiAgICB1bmlmb3JtIGZsb2F0IGFzcGVjdFJhdGlvO1xuICAgIHVuaWZvcm0gdmVjMyBjb2xvcjtcbiAgICB1bmlmb3JtIHZlYzIgcG9pbnQ7XG4gICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG5cbiAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB2ZWMyIHAgPSB2VXYgLSBwb2ludC54eTtcbiAgICAgICAgcC54ICo9IGFzcGVjdFJhdGlvO1xuICAgICAgICB2ZWMzIHNwbGF0ID0gZXhwKC1kb3QocCwgcCkgLyByYWRpdXMpICogY29sb3I7XG4gICAgICAgIHZlYzMgYmFzZSA9IHRleHR1cmUyRCh1VGFyZ2V0LCB2VXYpLnh5ejtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChiYXNlICsgc3BsYXQsIDEuMCk7XG4gICAgfVxuYFxuICAgICksIFllID0gaChcbiAgICAgIHQuRlJBR01FTlRfU0hBREVSLFxuICAgICAgYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VmVsb2NpdHk7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNvdXJjZTtcbiAgICB1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xuICAgIHVuaWZvcm0gdmVjMiBkeWVUZXhlbFNpemU7XG4gICAgdW5pZm9ybSBmbG9hdCBkdDtcbiAgICB1bmlmb3JtIGZsb2F0IGRpc3NpcGF0aW9uO1xuXG4gICAgdmVjNCBiaWxlcnAgKHNhbXBsZXIyRCBzYW0sIHZlYzIgdXYsIHZlYzIgdHNpemUpIHtcbiAgICAgICAgdmVjMiBzdCA9IHV2IC8gdHNpemUgLSAwLjU7XG5cbiAgICAgICAgdmVjMiBpdXYgPSBmbG9vcihzdCk7XG4gICAgICAgIHZlYzIgZnV2ID0gZnJhY3Qoc3QpO1xuXG4gICAgICAgIHZlYzQgYSA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDAuNSwgMC41KSkgKiB0c2l6ZSk7XG4gICAgICAgIHZlYzQgYiA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDEuNSwgMC41KSkgKiB0c2l6ZSk7XG4gICAgICAgIHZlYzQgYyA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDAuNSwgMS41KSkgKiB0c2l6ZSk7XG4gICAgICAgIHZlYzQgZCA9IHRleHR1cmUyRChzYW0sIChpdXYgKyB2ZWMyKDEuNSwgMS41KSkgKiB0c2l6ZSk7XG5cbiAgICAgICAgcmV0dXJuIG1peChtaXgoYSwgYiwgZnV2LngpLCBtaXgoYywgZCwgZnV2LngpLCBmdXYueSk7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAjaWZkZWYgTUFOVUFMX0ZJTFRFUklOR1xuICAgICAgICB2ZWMyIGNvb3JkID0gdlV2IC0gZHQgKiBiaWxlcnAodVZlbG9jaXR5LCB2VXYsIHRleGVsU2l6ZSkueHkgKiB0ZXhlbFNpemU7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gYmlsZXJwKHVTb3VyY2UsIGNvb3JkLCBkeWVUZXhlbFNpemUpO1xuICAgICNlbHNlXG4gICAgICAgIHZlYzIgY29vcmQgPSB2VXYgLSBkdCAqIHRleHR1cmUyRCh1VmVsb2NpdHksIHZVdikueHkgKiB0ZXhlbFNpemU7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdGV4dHVyZTJEKHVTb3VyY2UsIGNvb3JkKTtcbiAgICAjZW5kaWZcbiAgICAgICAgZmxvYXQgZGVjYXkgPSAxLjAgKyBkaXNzaXBhdGlvbiAqIGR0O1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSByZXN1bHQgLyBkZWNheTtcbiAgICB9YCxcbiAgICAgIHguc3VwcG9ydExpbmVhckZpbHRlcmluZyA/IG51bGwgOiBbXCJNQU5VQUxfRklMVEVSSU5HXCJdXG4gICAgKSwgTWUgPSBoKFxuICAgICAgdC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkw7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVZlbG9jaXR5O1xuXG4gICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZmxvYXQgTCA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZMKS54O1xuICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlIpLng7XG4gICAgICAgIGZsb2F0IFQgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VCkueTtcbiAgICAgICAgZmxvYXQgQiA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZCKS55O1xuXG4gICAgICAgIHZlYzIgQyA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZVdikueHk7XG4gICAgICAgIGlmICh2TC54IDwgMC4wKSB7IEwgPSAtQy54OyB9XG4gICAgICAgIGlmICh2Ui54ID4gMS4wKSB7IFIgPSAtQy54OyB9XG4gICAgICAgIGlmICh2VC55ID4gMS4wKSB7IFQgPSAtQy55OyB9XG4gICAgICAgIGlmICh2Qi55IDwgMC4wKSB7IEIgPSAtQy55OyB9XG5cbiAgICAgICAgZmxvYXQgZGl2ID0gMC41ICogKFIgLSBMICsgVCAtIEIpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGRpdiwgMC4wLCAwLjAsIDEuMCk7XG4gICAgfVxuYFxuICAgICksIFBlID0gaChcbiAgICAgIHQuRlJBR01FTlRfU0hBREVSLFxuICAgICAgYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcblxuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2UjtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlQ7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcblxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2TCkueTtcbiAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZSKS55O1xuICAgICAgICBmbG9hdCBUID0gdGV4dHVyZTJEKHVWZWxvY2l0eSwgdlQpLng7XG4gICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2QikueDtcbiAgICAgICAgZmxvYXQgdm9ydGljaXR5ID0gUiAtIEwgLSBUICsgQjtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjUgKiB2b3J0aWNpdHksIDAuMCwgMC4wLCAxLjApO1xuICAgIH1cbmBcbiAgICApLCB6ZSA9IGgoXG4gICAgICB0LkZSQUdNRU5UX1NIQURFUixcbiAgICAgIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcblxuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgdmFyeWluZyB2ZWMyIHZMO1xuICAgIHZhcnlpbmcgdmVjMiB2UjtcbiAgICB2YXJ5aW5nIHZlYzIgdlQ7XG4gICAgdmFyeWluZyB2ZWMyIHZCO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1Q3VybDtcbiAgICB1bmlmb3JtIGZsb2F0IGN1cmw7XG4gICAgdW5pZm9ybSBmbG9hdCBkdDtcblxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodUN1cmwsIHZMKS54O1xuICAgICAgICBmbG9hdCBSID0gdGV4dHVyZTJEKHVDdXJsLCB2UikueDtcbiAgICAgICAgZmxvYXQgVCA9IHRleHR1cmUyRCh1Q3VybCwgdlQpLng7XG4gICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodUN1cmwsIHZCKS54O1xuICAgICAgICBmbG9hdCBDID0gdGV4dHVyZTJEKHVDdXJsLCB2VXYpLng7XG5cbiAgICAgICAgdmVjMiBmb3JjZSA9IDAuNSAqIHZlYzIoYWJzKFQpIC0gYWJzKEIpLCBhYnMoUikgLSBhYnMoTCkpO1xuICAgICAgICBmb3JjZSAvPSBsZW5ndGgoZm9yY2UpICsgMC4wMDAxO1xuICAgICAgICBmb3JjZSAqPSBjdXJsICogQztcbiAgICAgICAgZm9yY2UueSAqPSAtMS4wO1xuXG4gICAgICAgIHZlYzIgdmVsb2NpdHkgPSB0ZXh0dXJlMkQodVZlbG9jaXR5LCB2VXYpLnh5O1xuICAgICAgICB2ZWxvY2l0eSArPSBmb3JjZSAqIGR0O1xuICAgICAgICB2ZWxvY2l0eSA9IG1pbihtYXgodmVsb2NpdHksIC0xMDAwLjApLCAxMDAwLjApO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlbG9jaXR5LCAwLjAsIDEuMCk7XG4gICAgfVxuYFxuICAgICksIFZlID0gaChcbiAgICAgIHQuRlJBR01FTlRfU0hBREVSLFxuICAgICAgYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIHByZWNpc2lvbiBtZWRpdW1wIHNhbXBsZXIyRDtcblxuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VXY7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZMO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2UjtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlQ7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZCO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVQcmVzc3VyZTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1RGl2ZXJnZW5jZTtcblxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2TCkueDtcbiAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZSKS54O1xuICAgICAgICBmbG9hdCBUID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlQpLng7XG4gICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2QikueDtcbiAgICAgICAgZmxvYXQgQyA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZVdikueDtcbiAgICAgICAgZmxvYXQgZGl2ZXJnZW5jZSA9IHRleHR1cmUyRCh1RGl2ZXJnZW5jZSwgdlV2KS54O1xuICAgICAgICBmbG9hdCBwcmVzc3VyZSA9IChMICsgUiArIEIgKyBUIC0gZGl2ZXJnZW5jZSkgKiAwLjI1O1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHByZXNzdXJlLCAwLjAsIDAuMCwgMS4wKTtcbiAgICB9XG5gXG4gICAgKSwgR2UgPSBoKFxuICAgICAgdC5GUkFHTUVOVF9TSEFERVIsXG4gICAgICBgXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEO1xuXG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZVdjtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkw7XG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZSO1xuICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VDtcbiAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdkI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVByZXNzdXJlO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWZWxvY2l0eTtcblxuICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIGZsb2F0IEwgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2TCkueDtcbiAgICAgICAgZmxvYXQgUiA9IHRleHR1cmUyRCh1UHJlc3N1cmUsIHZSKS54O1xuICAgICAgICBmbG9hdCBUID0gdGV4dHVyZTJEKHVQcmVzc3VyZSwgdlQpLng7XG4gICAgICAgIGZsb2F0IEIgPSB0ZXh0dXJlMkQodVByZXNzdXJlLCB2QikueDtcbiAgICAgICAgdmVjMiB2ZWxvY2l0eSA9IHRleHR1cmUyRCh1VmVsb2NpdHksIHZVdikueHk7XG4gICAgICAgIHZlbG9jaXR5Lnh5IC09IHZlYzIoUiAtIEwsIFQgLSBCKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWxvY2l0eSwgMC4wLCAxLjApO1xuICAgIH1cbmBcbiAgICApLCB2ID0gKCgpID0+ICh0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIsIHQuY3JlYXRlQnVmZmVyKCkpLCB0LmJ1ZmZlckRhdGEodC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAtMSwgLTEsIDEsIDEsIDEsIDEsIC0xXSksIHQuU1RBVElDX0RSQVcpLCB0LmJpbmRCdWZmZXIodC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdC5jcmVhdGVCdWZmZXIoKSksIHQuYnVmZmVyRGF0YSh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKSwgdC5TVEFUSUNfRFJBVyksIHQudmVydGV4QXR0cmliUG9pbnRlcigwLCAyLCB0LkZMT0FULCAhMSwgMCwgMCksIHQuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoMCksIChlLCBpID0gITEpID0+IHtcbiAgICAgIGUgPT0gbnVsbCA/ICh0LnZpZXdwb3J0KDAsIDAsIHQuZHJhd2luZ0J1ZmZlcldpZHRoLCB0LmRyYXdpbmdCdWZmZXJIZWlnaHQpLCB0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLCBudWxsKSkgOiAodC52aWV3cG9ydCgwLCAwLCBlLndpZHRoLCBlLmhlaWdodCksIHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsIGUuZmJvKSksIGkgJiYgKHQuY2xlYXJDb2xvcigwLCAwLCAwLCAxKSwgdC5jbGVhcih0LkNPTE9SX0JVRkZFUl9CSVQpKSwgdC5kcmF3RWxlbWVudHModC5UUklBTkdMRVMsIDYsIHQuVU5TSUdORURfU0hPUlQsIDApO1xuICAgIH0pKSgpO1xuICAgIGxldCBFLCBmLCBLLCBfLCBiLCBXLCBYLCBpZSwgb2UgPSBfZShcbiAgICAgIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFQUFBQUJBQ0FZQUFBQ3FhWEhlQUFBQUFYTlNSMElBcnM0YzZRQUFBRVJsV0VsbVRVMEFLZ0FBQUFnQUFZZHBBQVFBQUFBQkFBQUFHZ0FBQUFBQUE2QUJBQU1BQUFBQkFBRUFBS0FDQUFRQUFBQUJBQUFBUUtBREFBUUFBQUFCQUFBQVFBQUFBQUJHVVVLd0FBQWVLMGxFUVZSNEFUM2FCYlJ1VmRVRzRIVzVoTkxkU0hkM0N5amRFdExkM1kxd0taSHVMZ0ZKUmVudUJxVzd1N3RUbHU4engvLzlad3dHOEozOTdiM1duRy9OdFU5Yllva2wrbmZmZmRmLy9lOS85NnV1dXFyUE45OTgvWlJUVHVrYmI3eHhQL3p3dy91KysrN2JmL3ZiMy9ZZGR0aWhQL3JvbzMyU1NTYnBMN3p3UWovOTlOUDdWbHR0MVgvODhjZSs4c29yMTNWdnYvMTJIenAwYUY5OTlkWDdCeDk4MFAvNjE3LzJXV2VkdFgvNTVaZDkrKzIzN3pQTU1FUC8wNS8rMURmWVlJUCswRU1QOWFtbm5ycS85OTU3L1paYmJ1bS8vUEpMZit5eHgvcEpKNTNVUnh0dHRMN1dXbXYxUC8vNXovM2JiNy90OTkxM1g2M3Q5ZGRmN3dzdnZIQmZmLzMxKzZHSEh0b3Z1K3l5UHVlY2MvWWJicmloSDMzMDBmWHNoUlphcUY5MDBVVzF6di84NXo5OTFGRkhyZlhjZSsrOWZmamhoKy9ublhkZVhlOGU3dHN1di96eSt2S0VFMDdZRHp6d3dOcG96NC9GUGZua2szMlZWVmJwZDkxMVY3LzY2cXY3TWNjYzB5Kzk5TkkreWlpajlLV1dXcW9mZlBEQi9mcnJyNitIV2Zqc3M4L2U3N2pqanU2ZXYvdmQ3Mm9qTnJmaWlpdjIxbG85OFB6eno2L2ZuWGppaWYwZi8vaEgzM3Jycld1akZyN0pKcHZVL2Q1Ly8vMSt3UVVYOU4xMjI2MVBOZFZVZmJubGx1dkREVGRjLy9UVFQrdnpXMis5dFk4NDRvajlxNisrNmkrKytHS2ZmUExKYXozVytmWFhYMWZ4M04vNnZ2LysrM3JPRzIrOFVjLzY2S09QK25qampWZmYyMk9QUFhyNytPT1BxNG9xZnRaWlozVmR0TGt4eGhpalgzenh4ZDBYRkdlT09lYm9mL3pqSC90ZWUrMVZDN25ubm52NnV1dXVXd3Q1NVpWWHF1cmJiTE5OSDNmY2NkV3Y3NzMzM3QwaW5ucnFxWDdRUVFmMXRkZGV1M3VXaDg4enp6ejltMisrNldPTk5WWnQ3dHh6ejYxbmpEVFNTUDJBQXc3b004ODhjMTk4OGNYNzdiZmZYZ3ZkYUtPTityQmh3L29FRTB4UUtKbHR0dG42THJ2czBrODQ0WVMrNXBwcjlpMjMzTEsvODg0N3RUWW8yM2JiYmZ1cnI3NWFoWVlRYUZVazkvWmQzMXR3d1FYN3lDT1AzSnVPNmNJenp6eFRFSnBwcHBtcVV6cnJjNTBkTW1SSWYrMjExL3JQUC8vY0YxbGtrZXFLVG9LM2lpKzY2S0w5OGNjZjc0Y2RkbGhmWjUxMStnTVBQTkNublhiYXZzQUNDOVJHSjV0c3N2N1BmLzZ6RnJMcnJydld4cDUrK3VsQzNEWFhYRk1GZmY3NTU3dWlnank2VFR6eHhQM3p6ejh2Tk0wOTk5elZIRFQ2d3gvKzBILzQ0WWMrNmFTVDF2WFc4NjkvL2F1ZmNjWVpmWnh4eHFsMW9MSUdRcC9uYVFMYUxidnNzb1ZrZEY5dHRkVUtUVVBjYUpaWlptbmJiYmRkVzJ5eHhWb1cycktvbGcwb1RndG4wS1RsdXZiZ2d3KzJWVmRkdFdYeExieHZKNTk4Y3B0dXV1bGFxdC9DeHhaZXQyaEhXMk9OTmRyNDQ0L2ZicnJwcHBZQ3RVQ3hoVXIxV1hTaHBSTXRtMnRaYUp0eHhobGJFRmYzaVA2MExMcStIenExOEx4bGcvWDlsMTU2cVQzeXlDUDE3SnR2dnJtRncyM2VlZWR0dmhPMHRmMzMzNytlRVUxcEtWUmJZWVVWMmhaYmJOR3V1KzQ2S0cvUmw1Wk4xMzhIUFczMzNYZHYxdEp3UkpmeGpjRG9JakhTQWI5YmI3MzErdTkvLy91QzBNTVBQMXk4Sm5vZ04rYVlZNWFZcVNZaEFtMWRHM3Zzc1R0YWdQUlJSeDNWTDd6d3d1NjdCSW13VFRIRkZQMXZmL3RiSjJyMzMzOS9UK0g3bEZOTytmL2Q5bmtXWHgzTlFxdURVT2JhYWFhWnByLzU1cHQ5bjMzMnFhNmlWWnJRMDV6U0VEcTEzMzc3MWYxUXcvT0pJbzJ4dDNQT09hZkVrTWluK0wyQks5Vk5oZnVtbTI1YW0zcnJyYmY2OGNjZjM2ZWZmdnArMjIyM2xZaDg4c2tueGJ0VXZUN0RKNFc1NG9vcit0bG5uMTAzdFdnTEFMdDBxemFHWW9SMHp6MzM3Rjk4OFVVUEtvcC94eDEzWEJYWUlzODg4OHdxcUUwUlM0SnJVNmVlZW1wUHQ4c2hVSXVLZTRabjBnKy80MW83Nzd4enYrU1NTK3E3enozM1hMbWFvb0s2dmFBMXJYajU1WmVMdmhwTVk5d0hwRHVPdVJuZS92M3ZmeTloMm5ISEhUdWUvL3JYdjY0djRoNnIwVGtibVdpaWlUcHgrdTkvLzF1TDllQzc3NzY3dWtqRVBKRGxzVW5DUjV6WUt4N1RDODdnYzBvTkdSQkVZemJjY01OeUg4OGdua3N1dVNTS1ZoZTVGRXZsTm9RTjhvNDk5dGpTcDJXV1dhWjBnYVlRYTQxVFFBSis1WlZYbGszVHRCdHZ2TEdhOU5sbm41VlFOL2JBNzFYWVppeWFuYkFZQXNPYVFNb2lSaGhoaEU2ODNDajg3M1BOTlZjOTNQZXAvdkxMTDE5ZEpYb29RdDBoaGlnOSsreXo1UVR1d1VwMTVjNDc3eXduSWNDK1M0L2NDeFZsQ2NXM1BzMlFQNmkzUWkrOTlOS0ZzSjkrK3FsSGE2cndITXlhd1p6Uy8rcFh2eXBhczFDaU9mcm9vMWMyV1dtbGxhcUFIQVh5aHFaRHc2TG1KV3BaZUVzaFdtN1N3dFdXYnJkMHZnUXFWVzNoVDRzbWxCZ0ZkaTBMYlZIV2xvVzJaSVlTd1hTMWhmc3RsVyt4MWhaRmIzbG8zUy9jYm9GaGkvMlVPUG84OUN0QkNtSmFxTk95bnBZaWxaaW1xeTBLM3Z5YjBLVUFMWVZyUVVkTENHc0pYYzJhMDJsYVZrSVg2eXdodDZjVXRnVkZMVWd1OFV2RFNzeGp3UzJiYnlseW84WlZlWndRUUhRM0tsNDhQT0tJSTZveitFYUFvT1NRUXc0cG1xZ2tMNDZTbHIvVEV0M2kxOUxsRTA4OFVYQ1BHaGZ2ZEVnYWsrQWdoQmpSRVB3bGJOWWhSN0F5SGNSWFlzbStvSWhuMHdaaVJqQUpvU1NJNnl4YlhwRlVDWEFjcmRaTElPbVlaOUVrZG81R3FBYVZiTEZ5Z0xnTGtvVEpSbkJTd2hKNkpFSzhKVGF4eEFvakZrczBDWmJ2Ykw3NTVuVkRHeEdlUUpFUEV4bUtqa0kyaHVlQ0NlNzZ2UXhCTk1Wbjhack9FRW02Z2R2Z0s5VElCckc1cmlHYmJiWlppYTQxNERwM1VSelVzVllwMUpxRXVVRktGZkprQyttVTQvM21ONzhwZWlncytGUklZVnVFYVNCeWtoSjFaNFUyb3VKNGJBSDRUaCtJblRsQ0oxa2lyaEpVRGdJdHJFa1lzZ0hpUnZ5a1E1MG1WcnJpYzRsdmdCd2JZSithUWtkd25DYUp4cHFpY0pBRUpRb0xUUnFqV0lvSXZYNDRtdzBTV1lVV3hONTk5OTFhTTNRcG5BSTJrZFJEUUEyOHdZdU5VWGdMazhIZGxBTlFjc0prRXpaQTlUM0F6TUJOV0I1a2NBam80Yk9ESEdCK0lGN1UxelU2cXNnMlJtQkZjTXBPZEJVTmhUVGcybXV2cmM0TnJJeFFVM3hkTm94Qm1DYWhJNHE0bDN2N0hKMDFXTW9rZWdPRXNWSm9NayswblhiYXFUWWd4S2k0QitJOFpSWjFGUVdYY00wUWdtZHVSQzhValhJTE9qemM0bXpDUnVVR1VWUmhLTGRBQXpGNDY4R0dIRHJpT3lobkE3cXBRR2dvQjNBQ3owY1J6Nk1YM0lEblF5Tk9XNU5PQ3phY1NWYUFFQlpPZjlnaFJHa0kvWUFXKy92d3d3OEx1ZUpxMlpVT2dkcGdQQVpqSW1Ha2xBcEJFblQ5c0RjRnMzQXpBaDVEaDQwWk13VU5rNTRGVHA0aFJOZ2hQSGg5UjFBaVhWcUFjUlIzY1JWUFpmWWpqenl5NktSZ09pdWNzVjZvTTBLN2xrMHFEQzB4QTlpUVo4b09HdVgrSmtjaWltYUtZeiswaFpnTGNScEJJSWNHZ3NOa2VqYkVjdUtaTFZWczZYVFpUMFN0Y25ZNDNyTFltZzh5ZkZUV0R1ZkxLalBFdEN5c3hVbktnckx4dWxjZzJQN3lsNyswTEtSbGNxd1pnMDE2VHZqYzB2Mnl4NkNueFNWYVVORUM0NW9CMkZqMHB0WVJYV2tKVVMyKzMxSzBGc1ExenpZVGhEcE4vZy95V3ZTb2JEeUZiaEhpK3R5c2thSzNqTDQxTjdqZVRHTnQwYVRHUjR1TG9PMFFReWNsdEVHV1Z6VU9NT0NvQ2dvYllFMC93QXhLVkJTMzZBblJ3VVdxaTQ5R1lkUWlwQ3hKUjAxd0VoMTBTSHZzaVZoU2ZRTG5Xa2hMQVN2OW9RdjlZYWNjQlJxdFJjUm12OURsTXpTR0N1dURKdmVFRUZvbEVmbzlTa0VZeWdnS3BmTGdhek8raklOZzVzQUFWOTBJbDNGWUZBVlhjNy80TE41YUdCV25EUlNXT0JKTk9zSWRQSWo5U1dldUFVM3BqSTA2RVFKVEc4TnZIR1pWaW9aaTdJdG9FbFRQMHdodVlrM3VxVm5FV3ZTbURSSWZFYlZlRGFGREJKVFdTWnVFbFhpeVVlTTNhRllGWGFCemxGUTNjTWlOS1R5ZlowRWNnUkNacmp3RVAzbXZ3eEliY25NT29taUNocWtSZ21RREZvbWpiRlNCV1JnbHQxRjZnWThLeDhyRWNUK1FKY3Y3SEk4VjJWVElxaUdDam5BTnpZSXFHNVZCYUFXRUtURHI0d1QySVhwektQZUFTTTB4aTljbWlJUnNiNEdVM2NLbytXbW5uVllJc1NnQ21mbTZ1c3ZqS1ROMXBjakVUUW9EWjY1QmVTM09kVGFuaXdZUm5adC8vdmxMWUhYSElvemlKa2JmODN6VThSeWZzVW9GaENMWm42Z3FzdnVETkFSeUVpaEVUUmJwOTY0amRoTHVBRTB5QzZwQUtZZURKS0pYWEdNWC9GTFE0SkdxaktOUzFpQ01pSnR1N0xnSjFCU0lCYnFwWUVSOURUb1VteTFhdkVYaHJPSXBsb0NpSzJ3S1JhQ0NQWGttMUFoUzRyVTg0dXdBVlBHY285aWNOVUt0OWRJcGRQSXNlVUtCQmF1QjFuQWVLRkpBVmdteDNJeDcySi83TnpjSEZSOHVGZ3VSa0ZTVVBlSWJEaElTbTdNeGNNY2hjQlNRYUlMRmljdG1iL0JUWFF2VllWUXlkVmswcTVMSUNPUmduQmFmNlE0N3BVT0tCSzZRb2RCc0ZaeWhrMjBLVm1BK3lDaWFRRGh0VktNZ0diYzF6K2MrVTF6VVFsZXBsdTVBK1VZSmUzVW82Z0dTRTVqYkhNaUt4WlRVOEtLVE5vWjNnb1FDU1dwdTRydkNpTE1FMXpyZWxodUlrcUZFcFdWdjhITlBBdWR6M1hHOWdpdXloVUlqdU1vam9PMDZybVRCTW9JMFIra1ZGTjEwVnVDQ0dnM1VLUHhXU0RGWFdyVm1LS0pkbW9xaVVPMFpxT2o4ck5UZHpha29ybEZyeVBBZ3lneldraG1vRVVrUDhLN0E3MVZSOTFpbERlb21ibEp6M2RGRkM0U1lRYlFtcU55QWRhSUc2SElnRzlKWmRnenVWRjlBWTRmdXpWSnBnMmREbjAwUVpvM1NDR2lpTlN4UFlSUlJBWWtmNnhPZUZOa2FPUThSTmpQWElNRlRRVXZuY0ZUMUxJNzY2cllxNHJJSGNBd3dZNHVTSExza0tHeUw5VmlvVFVpSWtFTlhmSzZUdE1MMXZvOU92Z041Y29oclFCdzlPSkdjb2JEdWc3OVFCTWFvNW5uV3BsRWdibFBjaWdCeUtYVHpYTTN4VEpxRGhxaGhSaUN3VU5UWURmdXlFVkFuY3Zoa2NhSW9mdU95UU1JeDNFVGxiTkJOWE1PTFFWMEJkWk10c1M1MmFFRnNqcHZvQnZ1Qk5zOGtxcWhIVzFpd3pWRm9IYVlWWU13aEZPZU91SXpUSktnUnd3a3ZWeERrS0wzMWNBSW9rdytzbGVBSldxN2xScDduZXNHSlExaExNOUNBcXhHWGJkbXNEcXNxWmVYbEtrWlpKVFRWeFdtelBTNDVlR1JianFzTUw4U0d5TkVLOThaMVNOSXg2RklrSVluZHVZK3hXZUVWbXZvYml1UUVOc2RldVl6UTVSbFVYM0REWjlSd3ZVMTRIZ1NqaVIvQ2licG9BVVhXQmIzU0h6clRMRnFCTXMyR0JtZDdGQklrY1ZSWFZSVThkWS90V1ppcVc3REsrcDFEVkdnUmRLQ0h0VkJ3NnE5NDlJVFlLYUJGb0ljaEN3ZDlWNGQxVjNLekdVWHpETThrckxLQndyTTMrZ1IxK0kxYWRBSWlGVVpIUVZyVWhsWjAwMHozNENxb05MQlJTQ0hHcnFrZ1JFeHdmS0RTT09QR1BuY0Rhc21qd1ptUTZJd0hnYTlxRzJHTm9ISTJyb0lzTy9NZEFnV1MrRXJrV0Jrbys5RTUxUFA5d2N6dS9ockNqU2k0eEVoNEIrNWlVMXpLN3lHRERkc01kMUJRZWlWWFFER1VRTEdpUzRQUXFFSFFaNDJRMUFpTVlVSHdJQndIL3QrWkdhN3BsSWdKUmpiSzN0Z05SVlZOQzFGMU42Zk9ZTXhKOEk5T2lMRXlQc2poTjY0ckp0dkRkZFNBQ21jSTdzVTFvRTdJSVdERVRqY1YxM2NJbVlMU0dDZEhrT1ZhM2JWK2EvTWRXb09Tc2oreGhTcFpSeUhGWlpRZ3RHeHphQlkwTEp0b2dWbXVhZlVxTEh4dGdXQ053N0c1bHB2WHFYRnNzTWJNSUtFRnVpMUhZWFV5R3ppMmJMS2wrM1hhR3R0cHFYYWRIcWZSTGVyY0VwdHJCSFd2TEtwT2pyUEF1aTZkYnJHek9qME9sK3VVTjdaWnA4MmVGZXJWbU8yME9CdHNRVWdMV3V0RU9HaXRVZHNydlJTNUdaM2ROL1JzMlZ1OUhqTStCekUxdXZzOERXK2hUWjFjZXpkWFhhYVFJRXQ4S0taS0NnN1NGTmpvRnNqcThPQ1FsTWdRTkQrVVhWZFJoNUFSR0J4VGJWNnR1KzZyczdRQ1o5a3RQdkowUTVQZ1ExaFpNMjF3TDI0Qmlld00zR21SK0NzM3lBd21VemxCOWhCeVJHOU9RT3lJSHBwQUNvUndDOUZiSEtkSmtEbkU0Z0xOZXJrWjRhdERBOVhLZ2x0NDJ3S3hsZ0dtWGtRR1lpMFVhVkhRQmhrK1Q1SHFnRUluVXFBV2dhcjNBWGxvWGFjeldXaUwvN2FJYkozVko2RFVPNFlJY0F0SDY5QWovbCtkVCtRdU5JYUMxZW5ZS2FGdTBaMUNwTU9WVElGZTZMUTRVUE05L3g5aHJuY1d5U2IxWGlNNlVBY2kzaWRFbTFvRWx1UFZBWXIvVDhQclhVSFRVU29xTGFtV3lxc2tkMUFwZkJKOVZSZ1hDYVVFU0lsVkh5cDBrcVhocTk4VE5ia2dSYXJnSWVZU1RkWWpQQkVnbWtGSEJCbDhoQ1JLVDFpRk1GMkRScmtDY2lDRzIraWlORWZBOEpzdTBTM2p1ZkVZeDRVMWF5QzJkQTI2ekRMMGdqMksxVkJ0WDBPejZXRVJsbnJWcmNvUnNoWjRWQmNEdDNyVkhBRXNmWWkxdFNodHZjRkpaaWlFT0pwS2dxdlgySTZvVkQ0eHQ2b2JDTFpRcU40ZzBRaGREWlJickxFbDg3ZlFxbzdFZkNkRmJZRnlTNkViUkVaSTY2MVI4a2FMb0xia2k1WmcweUtTeFYrZFQ2T3FvNUFYcXRWeFh1aFRlZ09KRWNzNk5rdVJhMTBwV2lISnRhRm52VFZxcGllOHdqZkJBbmQ1TkFXbnZHWitEbkJlZ2sycVVJN0FZblJMNXViNVFwRW9LcXBDaXZ6UFhYQ2RFdU1sYm5NVUF4VGJNZ3U0em93aDliRXFkSFJ2R1lTZG1UMmdVNmZrRFBiTHNkaXQ4WmJtc0drV1NlbTVFQ3NVaVZrcGhFRTIvWUNRd2VERkdoMnVDazlENDgzRFZDU2hwZmlkUWhUWGdveFMzOWhVOFZVM3FURU9VbG44ejNkYnZMYmUxeVcyMWg4djZINUVyVUVQUkNTRUZJcW9idUJaSGZDK0xyWlh2SFJOb20vTDRrb2ozSk1UUUlyT2M2VFlidjJUSWxiblVwQ1d3cGZxUTBiaWVMMVRoRnhkcGlQUUVqRXNMZk85dkRocG9VWTloNDV4aTRTc05qUVhEV041WUJSRnJyL2VjRk9RQmJNa3IzcWhTYXlTMEZyQ1ViMjg5UHY0YnhXQnhUbHRkZEpLc01MeG9oQ2hZVUZ4aVBvcmsraEpGWXdWRWFKd3UwNkgwOEdDdi9zRkVYVkM3VHZoZXd0YVdwQlNwOHRCYXhYRWVoVWhTbCtueUVSYlV4S1N6RGExVHZkQ3B6aFdpNDYwUlB1eWR2U3lQbXRONm0yNlVOT2dCRWZrUUpDb0VSOHB6R0Fpd0xCRHRzSGFmRTRrQlJDSkRNUVd5MkVLbTVMVlFVdGtGWVBOQ2tUT1VSZzRveEVCSkpKb0psMkNMQ29TTVVMcFdVU0xWYm1XRFVxSUlDN1dTcXFFMVQwbFdCTWVDeFdWMlNOYW1USFF5UHI5U0gvbUhUUWk5b1RZcy8wdFVHMEFMM0dKU2t0bllxdmhDRTk5Z1pyS0RManNjMHBLTzJSMTB4NFZwN0ltTlFXa0p3WWorb0cvVk5uN093V2pGUlpDSi9EWkJoV0xQdEFWeitKQTFKdmFLeWlYd1YyNllOSlVJQm1CWTBtSDhnUzM0RTdXYitMakR1WUkzdzkxNjN5QlU1bDVOTXdrMnl4VWNKQ2JaV2paM01JTkk4S0RpM1NUVUxFeVJSS0tvTVZpMlE0N1pFYzZSRGhGWVF1R0ZIRlR4eFRKSEtDVENzck94R09vRW12TkFtS3pvT0o1cm5kUFlpWnFhd1NFR1pvSUhYUVl0eUVPbXB3a0NXYWU2VnhCRUNLcVJtRVJXZ09FTWZlRE5CTXVOQTRORDRiaEt0RmlXVUlMdnVDSnFNdXlXR09xWFJxUktiREZBY3JTMHZYaVVhclprdkFxeUFnYm9pYStzejFpRis4dGNhSWI0bXdHbDdxSHQwTXBVSXVETkZaTVkxS2dFdU1vZk9rQnZhQS9jYVltSHRNa2Iza0dBcHQ4M3pKc2xYWFNpNlRRaXRkRTNSOVUwSTJjTlRTMm5lWlVsSGZQTks5RVdlb3FPTE03WE1VL3d3OEltdUo4TGxDd1BTT29UdUNsTXdTOGd4WVFOc1E0Z2pMVW1QdDFRWngySGN0RG1ZRjlDVHFnRGE2R0tjZ0FkNThidE9pUisvZzlxT3FtWTdqQm1SNXUwdzJRMTJWanQzVVp0Q0xjaFNUcllzTlF6WnBadXpGZm9LSmZLSUkrUXl4QXJLU29sSm1LQjM0dFBLN0JRMGdSTGtLVitwMXVHMTY4YzR2b1ZLUU12T3J2QjNVVWluU2NMWHBmcUZPaFExa2JsRVM4S2ppeE1aSFlJT1ZlQWs4MjBReFM3RW1YREVMUkF4TnJoVE9kRjJvRUp2ZnhqeTZ6WHNFbWhhOUF4aFhTbEZwdlRvQ3E4MUFTZ2F5QkNPb01jOGtKYlhpZXlEdFQxY2I3UWRDaU14alZ3aFFDL00wQmljMzFvS2grMll1TjhXbi9qb0RWaGxIRW90SEU1TWVLMEl0RldRdzRLMDRDVjlsY0FsYkJNWTVRdE5PQWNMOWVsSWJ2ZFg4SjFITk1yS3lSN2RvTWVDdFVGTDR5eEtCUVpoajBNemxLbUtpTUdnbERWVnh6aTN1aXEyaGI4S0tzMlZoTmNtQUZ2Z1NIOGp1aFNWRnFEaWRPckFoODVIV0s3cnFCMHJNa1ZrUXdLYlZrNlNRSkRBa3RxS0pURmxnQ3htNTlEc2FEZzFkUUpyYUUxejBJbHhuRFBBL1N6ZytkOTdGUlNjL3BGRUdGWms1a1Q5Ym1OQnB0elR0RTEzRWMyN2MyQXU3OFFPZnFsTlpwQ1NYMUVLTXR4YVdlZUdhQllpZUg4TGtoaFoxeEFFcnRkN2dyRXZObXc0ckZzMGxXUkJ0d1ZuR2NOZkxtZExRMjRDVEhJbzIyaWlRdTB4Q0Y0K3NzMVROc0tKMHR6WEVxSk9iU0ZXdWlFZmdkTk5SR05ZaU9lRDZ1RzdjOWg2czVxYklmcnNCNWhoQTVuSXF3RmJ3Tk42SXBia1VVYStTa3FNWlN2TTM1WGNWTWNFeWxhMlNWek1ESk5aSmk3S2taUytrQlhYRXdBWmF4c3hxZktYNDJWQWNaZElUK2NDSnBFa3g5RndVNUVWaUwwM1FIUlRrUDdvdmk2QURpUm5kVUZhSDluY0JBVzlBdkJTMnF1SmRZajhhZTRYdWU1MkdWK29RTWdjSTVITWpKQnNJRHp3UWJvNmdLZzVoci9BZ3lVQ01NcVRwWWdqdmZWbmtRTllUSUI1S1hsS21iTWdSbmNSUW1pS0VURlBGbHg5YWdDa25DRWVxaEljZmhGdktGWi9xUlZhd05TdEJxY043b3dBWmx1QWJLT0I1RFhXNlY0aFUxT0lGN3l0b0ZjdzhEVXhZSXRxbFFwU3ZCUmlyMFJkWUNNYUNGcCt4UTZsSXNmR09kb2pKcU9Ba1NQUVVSQVFUblJWUlRtQUtLMFU2Z3hGRThSaHRuZldoRVF4VFFldGlXZXdsa251bjh3Ty93SFpWTWVPek81N2lOUmlJM08xUk1ad2FtU1kybUp6U0hia21iOWpFMDBYVVk1UVVmSnl3Q1F4NWNVS0xjcVhiOWFRekZaVXNtS2pUSmx3dDZhR0F3TWRBa2Y5ZFVsczNVK2FBUTVWNHBVQTFIYVZwTmFrRlZDeGZMWlZndTUwRWJFT2NnZVFkUU5wV09GaFY5YmhJMTdiRzhhRkNGcldTRGVtWkV1LzUweGo2aVViVjJreVJiUmkzMnlObjh0N0NWNUZrVVF6T2VYWGtkbkFpUjZuSUVFTlFKZ1VUY1ZGMmh4dENpbWh2bHRBZWtpSWxoQ2FTNGhhNkF0eENEUWpxRVBzNEw1SFcvTjVoQUM1SDF6dER2T1ltelFPSUhaVHBKZ0pNN0txQjVVMDE4aWFocmhDdW9RaHZyQm5lZEpZeldhMll4aUtFWEJJdSswSW1PMW9CNmdsZTlHc05UNllxYWVoMUYwU1U1TndOWmNFMzF5bTVReENBRFdnNGpMY0FtS2JSaTJnVDZEQTVDSEpqZ3BNeHZabUN2aGhPMnFVQVdhWE1VSDVWczBnRGxhQTUwOGRmdzVSMEZPb0t3K1FMbEtELzYrSzU3MktTNXdFU3BvWU0zUXpUTmZJRXFORXpUVUVRRHdLbHV3aGZaaEwvNnhFZUM1Z1RYelVWa0l1WW1GcTN5Z1dWeFhJZWN3ZWtDdmtLUFUyRW5URHlmcmJvbk1WVWdreGhidEFGZXo4N2NpNWZ6ZDRPV3hSRkxxTkFwQXhRTDliWUpiNTMrT0tFU3B4WGFBR1Q4dFg1clZqeUY5bDJGOW82QzdXcVlhVklqTkxFR0lwVnpJNUN6U0tMRkVYU0p1aElPQ3VxTnJpNDYzbEpSTjFFb2krWDV2TllreDJPTnhDWThvcWRiRnVEN2lralJMZGoxQWdxcVFSbkJKSjYrUjgyTnV0d0ZNcjBmSktUUWhXNm1TMnZUR00valFGQU0wcDZCdXJIcmNndDBkSCtIclY3cHVaNVRhWmp4ZkdnUzFEQXhrKytManNUQ2hFV3dDRi9TWVhreFVlRzlQRlllTUdIeFl6R1VnS1pETlRtYXNvaWY3RTJjSEVXSm5iR2wrbTVvVlRGVkxIWUtKV09ZQVloaVhLYnlBbUhrMStLcjc1a1hBdjJXVGRUeHQvdUx6azZOWW9NdE5HZ3BhbVVaUXBlbTFDR3BnMVZIYktJd3diUWVZdXI0VGNheFQ4cGY5b0pQT3F5TEtzaGYyUW5ZT096QVE5ekJMNytESE5kQmpUbWVoVGxxSm95c2tZYndjS2xPNTN6ZnhPZEFnZ2pwSHQxQUY4K1VDWGc4aUVNV1gwY2RNRFg3MHh6ZlIwRXBsQkJMaENqRExxR0hkbm1lSk91Y3crZlFwTlAwamFCN25qZk50SVN1bVk3cURRb3h3MkhpQVhaOEZrekIxWTF4R3hSOUxoQ0JzcUJqa3p3WXg0Z1dvWEVkdmxvY3FNb1F2ZytpQkZIZ3dtSGlpYWZFQ3JVc2xKb0xURElIaW5nZW1vQTRKK0ZFUVdYTkRrU00xd3RlWUMzbTJoanRVV1N4Mm1ldW9TOEVWYU9kTEN1TytXRzRMTEFPSE1FbHZDZ3FpS3hHVHhFVmhNQ1c5enVVUUJGUVRHZnExQlpVZlpaajZwYUVWMitEVEphTEo2WUdJUVZMWTNBNFdRZXVEai9rQy9sQi9QWTcvNTNzWGhRejZVV3A2NTZ5UWNTcTNsZG1zVFVGcGxoRnFjRzZUSGJXSGtUVXhNamJVZFMrSEtxNEI3b2s5OWRCcjJndVRrZnI2bVRZU1V4QmhwMVFidEQyTndLNlE1Q0lEeEVCRjZvTXB0UWJySFZZYkVVVnNWakN5MmFxeXFESFlRYXZyY0dZVW9NN3RYWTRna29TbnZjQXJ0TmRBZ2Q1WEFuY1JWb29neWlLenRlSk1QR0ZRQUlzeFJxS3ZDdmdVRElHT29yTWZOK3ozSitidUpZRGVRK0J6djZBdVdBcGpBZzVvSkx1bFpXNEVHendXYmpnNzVRVVpJM01GaXJJZ0RPUDV2bCs3eDdpdElJSlIzUkdJVkZGWUtMUWJJOWw0Ym1nWWo3Z1FLWk5lVUNROFYzdVFJZUVLTk9iYSttRWFZLysyQVR0NGppb2k4THVoZXQrM0Y4QkZZdWpzV0VXS1dScDlQQW1OU2N3VGxIQU9XSlNMeGRUbUtJRHBRMC82eXdOakVBcWYwTlVDaTJXT3FOekJraXBRUjQ5WW9OMWZRcFdWRENScFVNVmVVMkxGTmpMek9oQ3ZSdXdoaFN4SWlvbmNrRGpCUTJGcDlyaXVITi9VQmVISGI2Z2h2OE8xOHRkZ3NpSzNVRnJUWi91STdZSGxmVTZ6ZHA5NWpER2ZhSmg1UTRPTGF1YW9FSFZDUXgxNVo5VW43b1NHekZUNkJDQkNhQXp3SUhmKzZNcWdZaXFvd1k0eWhhRTBXZEV6SDJGSWwzVVdmVHcrdHE1by9RcCtIZysyb0d5KzZDRzBPVGNrdkpEQ0ZFam5BUlRKd2thWVlWQzl5YlExbVpRRTdraEEvSk1oV0swNE9YNWhKSHcvZzhYT3c3VDc5VmQyZ0FBQUFCSlJVNUVya0pnZ2dcIlxuICAgICk7XG4gICAgY29uc3QgQiA9IG5ldyBkKERlLCBVZSksIGFlID0gbmV3IGQoVCwgYmUpLCBrID0gbmV3IGQoVCwgTGUpLCBuZSA9IG5ldyBkKFQsIEZlKSwgdWUgPSBuZXcgZChULCBOZSksIFkgPSBuZXcgZChULCB5ZSksIEkgPSBuZXcgZChULCBCZSksIE0gPSBuZXcgZChULCBJZSksIGxlID0gbmV3IGQoVCwgd2UpLCBxID0gbmV3IGQoVCwgQ2UpLCBMID0gbmV3IGQoVCwgWGUpLCBSID0gbmV3IGQoVCwgWWUpLCBKID0gbmV3IGQoVCwgTWUpLCBaID0gbmV3IGQoVCwgUGUpLCBPID0gbmV3IGQoVCwgemUpLCBQID0gbmV3IGQoVCwgVmUpLCB6ID0gbmV3IGQoVCwgR2UpLCBGID0gbmV3IFNlKFQsIE9lKTtcbiAgICBmdW5jdGlvbiBjZSgpIHtcbiAgICAgIGxldCBlID0gUSh1LlNJTV9SRVNPTFVUSU9OKSwgaSA9IFEodS5EWUVfUkVTT0xVVElPTik7XG4gICAgICBjb25zdCByID0geC5oYWxmRmxvYXRUZXhUeXBlLCBvID0geC5mb3JtYXRSR0JBLCBhID0geC5mb3JtYXRSRywgbiA9IHguZm9ybWF0UiwgbCA9IHguc3VwcG9ydExpbmVhckZpbHRlcmluZyA/IHQuTElORUFSIDogdC5ORUFSRVNUO1xuICAgICAgdC5kaXNhYmxlKHQuQkxFTkQpLCBFID09IG51bGwgPyBFID0gaihpLndpZHRoLCBpLmhlaWdodCwgby5pbnRlcm5hbEZvcm1hdCwgby5mb3JtYXQsIHIsIGwpIDogRSA9IGZlKEUsIGkud2lkdGgsIGkuaGVpZ2h0LCBvLmludGVybmFsRm9ybWF0LCBvLmZvcm1hdCwgciwgbCksIGYgPT0gbnVsbCA/IGYgPSBqKGUud2lkdGgsIGUuaGVpZ2h0LCBhLmludGVybmFsRm9ybWF0LCBhLmZvcm1hdCwgciwgbCkgOiBmID0gZmUoZiwgZS53aWR0aCwgZS5oZWlnaHQsIGEuaW50ZXJuYWxGb3JtYXQsIGEuZm9ybWF0LCByLCBsKSwgSyA9IEEoZS53aWR0aCwgZS5oZWlnaHQsIG4uaW50ZXJuYWxGb3JtYXQsIG4uZm9ybWF0LCByLCB0Lk5FQVJFU1QpLCBfID0gQShlLndpZHRoLCBlLmhlaWdodCwgbi5pbnRlcm5hbEZvcm1hdCwgbi5mb3JtYXQsIHIsIHQuTkVBUkVTVCksIGIgPSBqKGUud2lkdGgsIGUuaGVpZ2h0LCBuLmludGVybmFsRm9ybWF0LCBuLmZvcm1hdCwgciwgdC5ORUFSRVNUKSwgUWUoKSwgSGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUWUoKSB7XG4gICAgICBsZXQgZSA9IFEodS5CTE9PTV9SRVNPTFVUSU9OKTtcbiAgICAgIGNvbnN0IGkgPSB4LmhhbGZGbG9hdFRleFR5cGUsIHIgPSB4LmZvcm1hdFJHQkEsIG8gPSB4LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgPyB0LkxJTkVBUiA6IHQuTkVBUkVTVDtcbiAgICAgIFcgPSBBKGUud2lkdGgsIGUuaGVpZ2h0LCByLmludGVybmFsRm9ybWF0LCByLmZvcm1hdCwgaSwgbyksIEQubGVuZ3RoID0gMDtcbiAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgdS5CTE9PTV9JVEVSQVRJT05TOyBhKyspIHtcbiAgICAgICAgbGV0IG4gPSBlLndpZHRoID4+IGEgKyAxLCBsID0gZS5oZWlnaHQgPj4gYSArIDE7XG4gICAgICAgIGlmIChuIDwgMiB8fCBsIDwgMilcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGMgPSBBKG4sIGwsIHIuaW50ZXJuYWxGb3JtYXQsIHIuZm9ybWF0LCBpLCBvKTtcbiAgICAgICAgRC5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBIZSgpIHtcbiAgICAgIGxldCBlID0gUSh1LlNVTlJBWVNfUkVTT0xVVElPTik7XG4gICAgICBjb25zdCBpID0geC5oYWxmRmxvYXRUZXhUeXBlLCByID0geC5mb3JtYXRSLCBvID0geC5zdXBwb3J0TGluZWFyRmlsdGVyaW5nID8gdC5MSU5FQVIgOiB0Lk5FQVJFU1Q7XG4gICAgICBYID0gQShlLndpZHRoLCBlLmhlaWdodCwgci5pbnRlcm5hbEZvcm1hdCwgci5mb3JtYXQsIGksIG8pLCBpZSA9IEEoZS53aWR0aCwgZS5oZWlnaHQsIHIuaW50ZXJuYWxGb3JtYXQsIHIuZm9ybWF0LCBpLCBvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQShlLCBpLCByLCBvLCBhLCBuKSB7XG4gICAgICB0LmFjdGl2ZVRleHR1cmUodC5URVhUVVJFMCk7XG4gICAgICBsZXQgbCA9IHQuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsIGwpLCB0LnRleFBhcmFtZXRlcmkodC5URVhUVVJFXzJELCB0LlRFWFRVUkVfTUlOX0ZJTFRFUiwgbiksIHQudGV4UGFyYW1ldGVyaSh0LlRFWFRVUkVfMkQsIHQuVEVYVFVSRV9NQUdfRklMVEVSLCBuKSwgdC50ZXhQYXJhbWV0ZXJpKHQuVEVYVFVSRV8yRCwgdC5URVhUVVJFX1dSQVBfUywgdC5DTEFNUF9UT19FREdFKSwgdC50ZXhQYXJhbWV0ZXJpKHQuVEVYVFVSRV8yRCwgdC5URVhUVVJFX1dSQVBfVCwgdC5DTEFNUF9UT19FREdFKSwgdC50ZXhJbWFnZTJEKHQuVEVYVFVSRV8yRCwgMCwgciwgZSwgaSwgMCwgbywgYSwgbnVsbCk7XG4gICAgICBsZXQgYyA9IHQuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsIGMpLCB0LmZyYW1lYnVmZmVyVGV4dHVyZTJEKHQuRlJBTUVCVUZGRVIsIHQuQ09MT1JfQVRUQUNITUVOVDAsIHQuVEVYVFVSRV8yRCwgbCwgMCksIHQudmlld3BvcnQoMCwgMCwgZSwgaSksIHQuY2xlYXIodC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgIGxldCBtID0gMSAvIGUsIHAgPSAxIC8gaTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHR1cmU6IGwsXG4gICAgICAgIGZibzogYyxcbiAgICAgICAgd2lkdGg6IGUsXG4gICAgICAgIGhlaWdodDogaSxcbiAgICAgICAgdGV4ZWxTaXplWDogbSxcbiAgICAgICAgdGV4ZWxTaXplWTogcCxcbiAgICAgICAgYXR0YWNoKE4pIHtcbiAgICAgICAgICByZXR1cm4gdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTAgKyBOKSwgdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsIGwpLCBOO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBqKGUsIGksIHIsIG8sIGEsIG4pIHtcbiAgICAgIGxldCBsID0gQShlLCBpLCByLCBvLCBhLCBuKSwgYyA9IEEoZSwgaSwgciwgbywgYSwgbik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogZSxcbiAgICAgICAgaGVpZ2h0OiBpLFxuICAgICAgICB0ZXhlbFNpemVYOiBsLnRleGVsU2l6ZVgsXG4gICAgICAgIHRleGVsU2l6ZVk6IGwudGV4ZWxTaXplWSxcbiAgICAgICAgZ2V0IHJlYWQoKSB7XG4gICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCByZWFkKG0pIHtcbiAgICAgICAgICBsID0gbTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHdyaXRlKCkge1xuICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgd3JpdGUobSkge1xuICAgICAgICAgIGMgPSBtO1xuICAgICAgICB9LFxuICAgICAgICBzd2FwKCkge1xuICAgICAgICAgIGxldCBtID0gbDtcbiAgICAgICAgICBsID0gYywgYyA9IG07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEtlKGUsIGksIHIsIG8sIGEsIG4sIGwpIHtcbiAgICAgIGxldCBjID0gQShpLCByLCBvLCBhLCBuLCBsKTtcbiAgICAgIHJldHVybiBhZS5iaW5kKCksIHQudW5pZm9ybTFpKGFlLnVuaWZvcm1zLnVUZXh0dXJlLCBlLmF0dGFjaCgwKSksIHYoYyksIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZlKGUsIGksIHIsIG8sIGEsIG4sIGwpIHtcbiAgICAgIHJldHVybiBlLndpZHRoID09IGkgJiYgZS5oZWlnaHQgPT0gciB8fCAoZS5yZWFkID0gS2UoZS5yZWFkLCBpLCByLCBvLCBhLCBuLCBsKSwgZS53cml0ZSA9IEEoaSwgciwgbywgYSwgbiwgbCksIGUud2lkdGggPSBpLCBlLmhlaWdodCA9IHIsIGUudGV4ZWxTaXplWCA9IDEgLyBpLCBlLnRleGVsU2l6ZVkgPSAxIC8gciksIGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lKGUpIHtcbiAgICAgIGxldCBpID0gdC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCwgaSksIHQudGV4UGFyYW1ldGVyaSh0LlRFWFRVUkVfMkQsIHQuVEVYVFVSRV9NSU5fRklMVEVSLCB0LkxJTkVBUiksIHQudGV4UGFyYW1ldGVyaSh0LlRFWFRVUkVfMkQsIHQuVEVYVFVSRV9NQUdfRklMVEVSLCB0LkxJTkVBUiksIHQudGV4UGFyYW1ldGVyaSh0LlRFWFRVUkVfMkQsIHQuVEVYVFVSRV9XUkFQX1MsIHQuUkVQRUFUKSwgdC50ZXhQYXJhbWV0ZXJpKHQuVEVYVFVSRV8yRCwgdC5URVhUVVJFX1dSQVBfVCwgdC5SRVBFQVQpLCB0LnRleEltYWdlMkQodC5URVhUVVJFXzJELCAwLCB0LlJHQiwgMSwgMSwgMCwgdC5SR0IsIHQuVU5TSUdORURfQllURSwgbmV3IFVpbnQ4QXJyYXkoWzI1NSwgMjU1LCAyNTVdKSk7XG4gICAgICBsZXQgciA9IHtcbiAgICAgICAgdGV4dHVyZTogaSxcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgYXR0YWNoKGEpIHtcbiAgICAgICAgICByZXR1cm4gdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTAgKyBhKSwgdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsIGkpLCBhO1xuICAgICAgICB9XG4gICAgICB9LCBvID0gbmV3IEltYWdlKCk7XG4gICAgICByZXR1cm4gby5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHIud2lkdGggPSBvLndpZHRoLCByLmhlaWdodCA9IG8uaGVpZ2h0LCB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCwgaSksIHQudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsIDAsIHQuUkdCLCB0LlJHQiwgdC5VTlNJR05FRF9CWVRFLCBvKTtcbiAgICAgIH0sIG8uc3JjID0gZSwgcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gV2UoKSB7XG4gICAgICBsZXQgZSA9IFtdO1xuICAgICAgdS5TSEFESU5HICYmIGUucHVzaChcIlNIQURJTkdcIiksIHUuQkxPT00gJiYgZS5wdXNoKFwiQkxPT01cIiksIHUuU1VOUkFZUyAmJiBlLnB1c2goXCJTVU5SQVlTXCIpLCBGLnNldEtleXdvcmRzKGUpO1xuICAgIH1cbiAgICBXZSgpLCBjZSgpLCBDLklOSVRJQUwgJiYgaGUocGFyc2VJbnQoTWF0aC5yYW5kb20oKSAqIHUuU1BMQVRfQU1PVU5UICogNCArIHUuU1BMQVRfQU1PVU5UKSk7XG4gICAgbGV0IHNlID0gRGF0ZS5ub3coKSwgViA9IDA7XG4gICAgbWUoKTtcbiAgICBmdW5jdGlvbiBtZSgpIHtcbiAgICAgIGNvbnN0IGUgPSBrZSgpO1xuICAgICAgdmUoKSAmJiBjZSgpLCBxZShlKSwgSmUoKSwgdyB8fCBaZShlKSwgamUobnVsbCksIHJlcXVlc3RBbmltYXRpb25GcmFtZShtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtlKCkge1xuICAgICAgbGV0IGUgPSBEYXRlLm5vdygpLCBpID0gKGUgLSBzZSkgLyAxZTM7XG4gICAgICByZXR1cm4gaSA9IE1hdGgubWluKGksIDAuMDE2NjY2KSwgc2UgPSBlLCBpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2ZSgpIHtcbiAgICAgIGxldCBlID0gUyhzLmNsaWVudFdpZHRoKSwgaSA9IFMocy5jbGllbnRIZWlnaHQpO1xuICAgICAgcmV0dXJuIHMud2lkdGggIT0gZSB8fCBzLmhlaWdodCAhPSBpID8gKHMud2lkdGggPSBlLCBzLmhlaWdodCA9IGksICEwKSA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxZShlKSB7XG4gICAgICB1LkNPTE9SRlVMICYmIChWICs9IGUgKiB1LkNPTE9SX1VQREFURV9TUEVFRCwgViA+PSAxICYmIChWID0gc3QoViwgMCwgMSksIGcuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBpLmNvbG9yID0gRygpO1xuICAgICAgfSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSmUoKSB7XG4gICAgICBpZiAoSC5sZW5ndGggPiAwICYmIGhlKEgucG9wKCkpLCBlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGUgPSBlZS5wb3AoKSwgaSA9IGVbMF0gLyBzLmNsaWVudFdpZHRoO1xuICAgICAgICBjb25zb2xlLmxvZyhpKTtcbiAgICAgICAgY29uc3QgciA9IDEgLSBlWzFdIC8gcy5jbGllbnRIZWlnaHQsIG8gPSBlWzJdIC8gMiwgYSA9IGVbM10gLyAyO1xuICAgICAgICBsZXQgbjtcbiAgICAgICAgaWYgKGVbNF0gIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGwgPSB4ZShlWzRdKSwgYyA9IGdlKGwuaCwgbC5zLCB1LkJSSUdIVE5FU1MpO1xuICAgICAgICAgIGMuciAqPSAwLjE1LCBjLmcgKj0gMC4xNSwgYy5iICo9IDAuMTUsIG4gPSBjO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBuID0gRygpO1xuICAgICAgICBuLnIgKj0gMTAsIG4uZyAqPSAxMCwgbi5iICo9IDEwLCAkKGksIHIsIG8sIGEsIG4pO1xuICAgICAgfVxuICAgICAgZy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIGUubW92ZWQgJiYgKGUubW92ZWQgPSAhMSwgYXQoZSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFplKGUpIHtcbiAgICAgIHQuZGlzYWJsZSh0LkJMRU5EKSwgWi5iaW5kKCksIHQudW5pZm9ybTJmKFoudW5pZm9ybXMudGV4ZWxTaXplLCBmLnRleGVsU2l6ZVgsIGYudGV4ZWxTaXplWSksIHQudW5pZm9ybTFpKFoudW5pZm9ybXMudVZlbG9jaXR5LCBmLnJlYWQuYXR0YWNoKDApKSwgdihfKSwgTy5iaW5kKCksIHQudW5pZm9ybTJmKE8udW5pZm9ybXMudGV4ZWxTaXplLCBmLnRleGVsU2l6ZVgsIGYudGV4ZWxTaXplWSksIHQudW5pZm9ybTFpKE8udW5pZm9ybXMudVZlbG9jaXR5LCBmLnJlYWQuYXR0YWNoKDApKSwgdC51bmlmb3JtMWkoTy51bmlmb3Jtcy51Q3VybCwgXy5hdHRhY2goMSkpLCB0LnVuaWZvcm0xZihPLnVuaWZvcm1zLmN1cmwsIHUuQ1VSTCksIHQudW5pZm9ybTFmKE8udW5pZm9ybXMuZHQsIGUpLCB2KGYud3JpdGUpLCBmLnN3YXAoKSwgSi5iaW5kKCksIHQudW5pZm9ybTJmKEoudW5pZm9ybXMudGV4ZWxTaXplLCBmLnRleGVsU2l6ZVgsIGYudGV4ZWxTaXplWSksIHQudW5pZm9ybTFpKEoudW5pZm9ybXMudVZlbG9jaXR5LCBmLnJlYWQuYXR0YWNoKDApKSwgdihLKSwgay5iaW5kKCksIHQudW5pZm9ybTFpKGsudW5pZm9ybXMudVRleHR1cmUsIGIucmVhZC5hdHRhY2goMCkpLCB0LnVuaWZvcm0xZihrLnVuaWZvcm1zLnZhbHVlLCB1LlBSRVNTVVJFKSwgdihiLndyaXRlKSwgYi5zd2FwKCksIFAuYmluZCgpLCB0LnVuaWZvcm0yZihQLnVuaWZvcm1zLnRleGVsU2l6ZSwgZi50ZXhlbFNpemVYLCBmLnRleGVsU2l6ZVkpLCB0LnVuaWZvcm0xaShQLnVuaWZvcm1zLnVEaXZlcmdlbmNlLCBLLmF0dGFjaCgwKSk7XG4gICAgICBmb3IgKGxldCByID0gMDsgciA8IHUuUFJFU1NVUkVfSVRFUkFUSU9OUzsgcisrKVxuICAgICAgICB0LnVuaWZvcm0xaShQLnVuaWZvcm1zLnVQcmVzc3VyZSwgYi5yZWFkLmF0dGFjaCgxKSksIHYoYi53cml0ZSksIGIuc3dhcCgpO1xuICAgICAgei5iaW5kKCksIHQudW5pZm9ybTJmKHoudW5pZm9ybXMudGV4ZWxTaXplLCBmLnRleGVsU2l6ZVgsIGYudGV4ZWxTaXplWSksIHQudW5pZm9ybTFpKHoudW5pZm9ybXMudVByZXNzdXJlLCBiLnJlYWQuYXR0YWNoKDApKSwgdC51bmlmb3JtMWkoei51bmlmb3Jtcy51VmVsb2NpdHksIGYucmVhZC5hdHRhY2goMSkpLCB2KGYud3JpdGUpLCBmLnN3YXAoKSwgUi5iaW5kKCksIHQudW5pZm9ybTJmKFIudW5pZm9ybXMudGV4ZWxTaXplLCBmLnRleGVsU2l6ZVgsIGYudGV4ZWxTaXplWSksIHguc3VwcG9ydExpbmVhckZpbHRlcmluZyB8fCB0LnVuaWZvcm0yZihSLnVuaWZvcm1zLmR5ZVRleGVsU2l6ZSwgZi50ZXhlbFNpemVYLCBmLnRleGVsU2l6ZVkpO1xuICAgICAgbGV0IGkgPSBmLnJlYWQuYXR0YWNoKDApO1xuICAgICAgdC51bmlmb3JtMWkoUi51bmlmb3Jtcy51VmVsb2NpdHksIGkpLCB0LnVuaWZvcm0xaShSLnVuaWZvcm1zLnVTb3VyY2UsIGkpLCB0LnVuaWZvcm0xZihSLnVuaWZvcm1zLmR0LCBlKSwgdC51bmlmb3JtMWYoUi51bmlmb3Jtcy5kaXNzaXBhdGlvbiwgdS5WRUxPQ0lUWV9ESVNTSVBBVElPTiksIHYoZi53cml0ZSksIGYuc3dhcCgpLCB4LnN1cHBvcnRMaW5lYXJGaWx0ZXJpbmcgfHwgdC51bmlmb3JtMmYoUi51bmlmb3Jtcy5keWVUZXhlbFNpemUsIEUudGV4ZWxTaXplWCwgRS50ZXhlbFNpemVZKSwgdC51bmlmb3JtMWkoUi51bmlmb3Jtcy51VmVsb2NpdHksIGYucmVhZC5hdHRhY2goMCkpLCB0LnVuaWZvcm0xaShSLnVuaWZvcm1zLnVTb3VyY2UsIEUucmVhZC5hdHRhY2goMSkpLCB0LnVuaWZvcm0xZihSLnVuaWZvcm1zLmRpc3NpcGF0aW9uLCB1LkRFTlNJVFlfRElTU0lQQVRJT04pLCB2KEUud3JpdGUpLCBFLnN3YXAoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gamUoZSkge1xuICAgICAgdS5CTE9PTSAmJiBydChFLnJlYWQsIFcpLCB1LlNVTlJBWVMgJiYgKGl0KEUucmVhZCwgRS53cml0ZSwgWCksIG90KFgsIGllLCAxKSksIGUgPT0gbnVsbCB8fCAhdS5UUkFOU1BBUkVOVCA/ICh0LmJsZW5kRnVuYyh0Lk9ORSwgdC5PTkVfTUlOVVNfU1JDX0FMUEhBKSwgdC5lbmFibGUodC5CTEVORCkpIDogdC5kaXNhYmxlKHQuQkxFTkQpLCB1LlRSQU5TUEFSRU5UIHx8ICRlKGUsIGZ0KGN0KHUuQkFDS19DT0xPUikpKSwgZSA9PSBudWxsICYmIHUuVFJBTlNQQVJFTlQgJiYgZXQoZSksIHR0KGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiAkZShlLCBpKSB7XG4gICAgICBuZS5iaW5kKCksIHQudW5pZm9ybTRmKG5lLnVuaWZvcm1zLmNvbG9yLCBpLnIsIGkuZywgaS5iLCAxKSwgdihlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXQoZSkge1xuICAgICAgdWUuYmluZCgpLCB0LnVuaWZvcm0xZih1ZS51bmlmb3Jtcy5hc3BlY3RSYXRpbywgcy53aWR0aCAvIHMuaGVpZ2h0KSwgdihlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHQoZSkge1xuICAgICAgbGV0IGkgPSBlID09IG51bGwgPyB0LmRyYXdpbmdCdWZmZXJXaWR0aCA6IGUud2lkdGgsIHIgPSBlID09IG51bGwgPyB0LmRyYXdpbmdCdWZmZXJIZWlnaHQgOiBlLmhlaWdodDtcbiAgICAgIGlmIChGLmJpbmQoKSwgdS5TSEFESU5HICYmIHQudW5pZm9ybTJmKEYudW5pZm9ybXMudGV4ZWxTaXplLCAxIC8gaSwgMSAvIHIpLCB0LnVuaWZvcm0xaShGLnVuaWZvcm1zLnVUZXh0dXJlLCBFLnJlYWQuYXR0YWNoKDApKSwgdS5CTE9PTSkge1xuICAgICAgICB0LnVuaWZvcm0xaShGLnVuaWZvcm1zLnVCbG9vbSwgVy5hdHRhY2goMSkpLCB0LnVuaWZvcm0xaShGLnVuaWZvcm1zLnVEaXRoZXJpbmcsIG9lLmF0dGFjaCgyKSk7XG4gICAgICAgIGxldCBvID0gbXQob2UsIGksIHIpO1xuICAgICAgICB0LnVuaWZvcm0yZihGLnVuaWZvcm1zLmRpdGhlclNjYWxlLCBvLngsIG8ueSk7XG4gICAgICB9XG4gICAgICB1LlNVTlJBWVMgJiYgdC51bmlmb3JtMWkoRi51bmlmb3Jtcy51U3VucmF5cywgWC5hdHRhY2goMykpLCB2KGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydChlLCBpKSB7XG4gICAgICBpZiAoRC5sZW5ndGggPCAyKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgciA9IGk7XG4gICAgICB0LmRpc2FibGUodC5CTEVORCksIFkuYmluZCgpO1xuICAgICAgbGV0IG8gPSB1LkJMT09NX1RIUkVTSE9MRCAqIHUuQkxPT01fU09GVF9LTkVFICsgMWUtNCwgYSA9IHUuQkxPT01fVEhSRVNIT0xEIC0gbywgbiA9IG8gKiAyLCBsID0gMC4yNSAvIG87XG4gICAgICB0LnVuaWZvcm0zZihZLnVuaWZvcm1zLmN1cnZlLCBhLCBuLCBsKSwgdC51bmlmb3JtMWYoWS51bmlmb3Jtcy50aHJlc2hvbGQsIHUuQkxPT01fVEhSRVNIT0xEKSwgdC51bmlmb3JtMWkoWS51bmlmb3Jtcy51VGV4dHVyZSwgZS5hdHRhY2goMCkpLCB2KHIpLCBJLmJpbmQoKTtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgRC5sZW5ndGg7IGMrKykge1xuICAgICAgICBsZXQgbSA9IERbY107XG4gICAgICAgIHQudW5pZm9ybTJmKEkudW5pZm9ybXMudGV4ZWxTaXplLCByLnRleGVsU2l6ZVgsIHIudGV4ZWxTaXplWSksIHQudW5pZm9ybTFpKEkudW5pZm9ybXMudVRleHR1cmUsIHIuYXR0YWNoKDApKSwgdihtKSwgciA9IG07XG4gICAgICB9XG4gICAgICB0LmJsZW5kRnVuYyh0Lk9ORSwgdC5PTkUpLCB0LmVuYWJsZSh0LkJMRU5EKTtcbiAgICAgIGZvciAobGV0IGMgPSBELmxlbmd0aCAtIDI7IGMgPj0gMDsgYy0tKSB7XG4gICAgICAgIGxldCBtID0gRFtjXTtcbiAgICAgICAgdC51bmlmb3JtMmYoSS51bmlmb3Jtcy50ZXhlbFNpemUsIHIudGV4ZWxTaXplWCwgci50ZXhlbFNpemVZKSwgdC51bmlmb3JtMWkoSS51bmlmb3Jtcy51VGV4dHVyZSwgci5hdHRhY2goMCkpLCB0LnZpZXdwb3J0KDAsIDAsIG0ud2lkdGgsIG0uaGVpZ2h0KSwgdihtKSwgciA9IG07XG4gICAgICB9XG4gICAgICB0LmRpc2FibGUodC5CTEVORCksIE0uYmluZCgpLCB0LnVuaWZvcm0yZihNLnVuaWZvcm1zLnRleGVsU2l6ZSwgci50ZXhlbFNpemVYLCByLnRleGVsU2l6ZVkpLCB0LnVuaWZvcm0xaShNLnVuaWZvcm1zLnVUZXh0dXJlLCByLmF0dGFjaCgwKSksIHQudW5pZm9ybTFmKE0udW5pZm9ybXMuaW50ZW5zaXR5LCB1LkJMT09NX0lOVEVOU0lUWSksIHYoaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGl0KGUsIGksIHIpIHtcbiAgICAgIHQuZGlzYWJsZSh0LkJMRU5EKSwgbGUuYmluZCgpLCB0LnVuaWZvcm0xaShsZS51bmlmb3Jtcy51VGV4dHVyZSwgZS5hdHRhY2goMCkpLCB2KGkpLCBxLmJpbmQoKSwgdC51bmlmb3JtMWYocS51bmlmb3Jtcy53ZWlnaHQsIHUuU1VOUkFZU19XRUlHSFQpLCB0LnVuaWZvcm0xaShxLnVuaWZvcm1zLnVUZXh0dXJlLCBpLmF0dGFjaCgwKSksIHYocik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG90KGUsIGksIHIpIHtcbiAgICAgIEIuYmluZCgpO1xuICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCByOyBvKyspXG4gICAgICAgIHQudW5pZm9ybTJmKEIudW5pZm9ybXMudGV4ZWxTaXplLCBlLnRleGVsU2l6ZVgsIDApLCB0LnVuaWZvcm0xaShCLnVuaWZvcm1zLnVUZXh0dXJlLCBlLmF0dGFjaCgwKSksIHYoaSksIHQudW5pZm9ybTJmKEIudW5pZm9ybXMudGV4ZWxTaXplLCAwLCBlLnRleGVsU2l6ZVkpLCB0LnVuaWZvcm0xaShCLnVuaWZvcm1zLnVUZXh0dXJlLCBpLmF0dGFjaCgwKSksIHYoZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0KGUpIHtcbiAgICAgIGlmICh3KVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgaSA9IGUuZGVsdGFYICogdS5TUExBVF9GT1JDRSwgciA9IGUuZGVsdGFZICogdS5TUExBVF9GT1JDRTtcbiAgICAgICQoZS50ZXhjb29yZFgsIGUudGV4Y29vcmRZLCBpLCByLCBlLmNvbG9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGUoZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlOyBpKyspIHtcbiAgICAgICAgY29uc3QgciA9IEcoKTtcbiAgICAgICAgci5yICo9IDEwLCByLmcgKj0gMTAsIHIuYiAqPSAxMDtcbiAgICAgICAgY29uc3QgbyA9IE1hdGgucmFuZG9tKCksIGEgPSBNYXRoLnJhbmRvbSgpLCBuID0gMWUzICogKE1hdGgucmFuZG9tKCkgLSAwLjUpLCBsID0gMWUzICogKE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuICAgICAgICAkKG8sIGEsIG4sIGwsIHIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiAkKGUsIGksIHIsIG8sIGEpIHtcbiAgICAgIEwuYmluZCgpLCB0LnVuaWZvcm0xaShMLnVuaWZvcm1zLnVUYXJnZXQsIGYucmVhZC5hdHRhY2goMCkpLCB0LnVuaWZvcm0xZihMLnVuaWZvcm1zLmFzcGVjdFJhdGlvLCBzLndpZHRoIC8gcy5oZWlnaHQpLCB0LnVuaWZvcm0yZihMLnVuaWZvcm1zLnBvaW50LCBlLCBpKSwgdC51bmlmb3JtM2YoTC51bmlmb3Jtcy5jb2xvciwgciwgbywgMCksIHQudW5pZm9ybTFmKEwudW5pZm9ybXMucmFkaXVzLCBudCh1LlNQTEFUX1JBRElVUyAvIDEwMCkpLCB2KGYud3JpdGUpLCBmLnN3YXAoKSwgdC51bmlmb3JtMWkoTC51bmlmb3Jtcy51VGFyZ2V0LCBFLnJlYWQuYXR0YWNoKDApKSwgdC51bmlmb3JtM2YoTC51bmlmb3Jtcy5jb2xvciwgYS5yLCBhLmcsIGEuYiksIHYoRS53cml0ZSksIEUuc3dhcCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBudChlKSB7XG4gICAgICBsZXQgaSA9IHMud2lkdGggLyBzLmhlaWdodDtcbiAgICAgIHJldHVybiBpID4gMSAmJiAoZSAqPSBpKSwgZTtcbiAgICB9XG4gICAgcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICBsZXQgaSA9IFMoZS5vZmZzZXRYKSwgciA9IFMoZS5vZmZzZXRZKSwgbyA9IGcuZmluZCgoYSkgPT4gYS5pZCA9PSAtMSk7XG4gICAgICBvID09IG51bGwgJiYgKG8gPSBuZXcgeSgpKSwgZGUobywgLTEsIGksIHIpO1xuICAgIH0pLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAoZSkgPT4ge1xuICAgICAgICBsZXQgaSA9IGdbMF0sIHIgPSBTKGUub2Zmc2V0WCksIG8gPSBTKGUub2Zmc2V0WSk7XG4gICAgICAgIFRlKGksIHIsIG8pO1xuICAgICAgfSk7XG4gICAgfSwgNTAwKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsICgpID0+IHtcbiAgICAgIEVlKGdbMF0pO1xuICAgIH0pLCBzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBpID0gZS50YXJnZXRUb3VjaGVzO1xuICAgICAgZm9yICg7IGkubGVuZ3RoID49IGcubGVuZ3RoOyApXG4gICAgICAgIGcucHVzaChuZXcgeSgpKTtcbiAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgaS5sZW5ndGg7IHIrKykge1xuICAgICAgICBsZXQgbyA9IFMoaVtyXS5wYWdlWCksIGEgPSBTKGlbcl0ucGFnZVkpO1xuICAgICAgICBkZShnW3IgKyAxXSwgaVtyXS5pZGVudGlmaWVyLCBvLCBhKTtcbiAgICAgIH1cbiAgICB9KSwgcy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaG1vdmVcIixcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgaSA9IGUudGFyZ2V0VG91Y2hlcztcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBpLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgbGV0IG8gPSBnW3IgKyAxXSwgYSA9IFMoaVtyXS5wYWdlWCksIG4gPSBTKGlbcl0ucGFnZVkpO1xuICAgICAgICAgIFRlKG8sIGEsIG4pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgITFcbiAgICApLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIChlKSA9PiB7XG4gICAgICBjb25zdCBpID0gZS5jaGFuZ2VkVG91Y2hlcztcbiAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgaS5sZW5ndGg7IHIrKykge1xuICAgICAgICBsZXQgbyA9IGcuZmluZCgoYSkgPT4gYS5pZCA9PSBpW3JdLmlkZW50aWZpZXIpO1xuICAgICAgICBvICE9IG51bGwgJiYgRWUobyk7XG4gICAgICB9XG4gICAgfSksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgZS5jb2RlID09PSB1LlNQTEFUX0tFWSAmJiBILnB1c2gocGFyc2VJbnQoTWF0aC5yYW5kb20oKSAqIHUuU1BMQVRfQU1PVU5UICogNCArIHUuU1BMQVRfQU1PVU5UKSk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZGUoZSwgaSwgciwgbykge1xuICAgICAgZS5pZCA9IGksIGUuZG93biA9ICEwLCBlLm1vdmVkID0gITEsIGUudGV4Y29vcmRYID0gciAvIHMud2lkdGgsIGUudGV4Y29vcmRZID0gMSAtIG8gLyBzLmhlaWdodCwgZS5wcmV2VGV4Y29vcmRYID0gZS50ZXhjb29yZFgsIGUucHJldlRleGNvb3JkWSA9IGUudGV4Y29vcmRZLCBlLmRlbHRhWCA9IDAsIGUuZGVsdGFZID0gMCwgZS5jb2xvciA9IEcoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVGUoZSwgaSwgcikge1xuICAgICAgZS5wcmV2VGV4Y29vcmRYID0gZS50ZXhjb29yZFgsIGUucHJldlRleGNvb3JkWSA9IGUudGV4Y29vcmRZLCBlLnRleGNvb3JkWCA9IGkgLyBzLndpZHRoLCBlLnRleGNvb3JkWSA9IDEgLSByIC8gcy5oZWlnaHQsIGUuZGVsdGFYID0gdXQoZS50ZXhjb29yZFggLSBlLnByZXZUZXhjb29yZFgpLCBlLmRlbHRhWSA9IGx0KGUudGV4Y29vcmRZIC0gZS5wcmV2VGV4Y29vcmRZKSwgdS5IT1ZFUiA/IGUubW92ZWQgPSBNYXRoLmFicyhlLmRlbHRhWCkgPiAwIHx8IE1hdGguYWJzKGUuZGVsdGFZKSA+IDAgOiBlLm1vdmVkID0gZS5kb3duO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFZShlKSB7XG4gICAgICBlLmRvd24gPSAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXQoZSkge1xuICAgICAgbGV0IGkgPSBzLndpZHRoIC8gcy5oZWlnaHQ7XG4gICAgICByZXR1cm4gaSA8IDEgJiYgKGUgKj0gaSksIGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGx0KGUpIHtcbiAgICAgIGxldCBpID0gcy53aWR0aCAvIHMuaGVpZ2h0O1xuICAgICAgcmV0dXJuIGkgPiAxICYmIChlIC89IGkpLCBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBHKCkge1xuICAgICAgbGV0IGUsIGk7XG4gICAgICBpZiAodS5DT0xPUl9QQUxFVFRFLmxlbmd0aCA9PSAwKVxuICAgICAgICBlID0gTWF0aC5yYW5kb20oKSwgaSA9IDE7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHUuQ09MT1JfUEFMRVRURS5sZW5ndGgpLCBhID0gdS5DT0xPUl9QQUxFVFRFW29dLCBuID0geGUoYSk7XG4gICAgICAgIGUgPSBuLmgsIGkgPSBuLnM7XG4gICAgICB9XG4gICAgICBsZXQgciA9IGdlKGUsIGksIHUuQlJJR0hUTkVTUyk7XG4gICAgICByZXR1cm4gci5yICo9IDAuMTUsIHIuZyAqPSAwLjE1LCByLmIgKj0gMC4xNSwgcjtcbiAgICB9XG4gICAgZnVuY3Rpb24geGUoZSkge1xuICAgICAgZSA9IGUucmVwbGFjZShcIiNcIiwgXCJcIik7XG4gICAgICBjb25zdCBpID0gcGFyc2VJbnQoZS5zdWJzdHJpbmcoMCwgMiksIDE2KSAvIDI1NSwgciA9IHBhcnNlSW50KGUuc3Vic3RyaW5nKDIsIDQpLCAxNikgLyAyNTUsIG8gPSBwYXJzZUludChlLnN1YnN0cmluZyg0LCA2KSwgMTYpIC8gMjU1LCBhID0gTWF0aC5tYXgoaSwgciwgbyksIG4gPSBNYXRoLm1pbihpLCByLCBvKTtcbiAgICAgIGxldCBsLCBjLCBtO1xuICAgICAgcmV0dXJuIGEgPT09IG4gPyBsID0gMCA6IGEgPT09IGkgPyBsID0gKChyIC0gbykgLyAoYSAtIG4pICsgNikgJSA2IDogYSA9PT0gciA/IGwgPSAobyAtIGkpIC8gKGEgLSBuKSArIDIgOiBsID0gKGkgLSByKSAvIChhIC0gbikgKyA0LCBsIC89IDYsIGEgPT09IDAgPyBjID0gMCA6IGMgPSAoYSAtIG4pIC8gYSwgbSA9IGEsIHsgaDogbCwgczogYywgdjogbSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjdChlKSB7XG4gICAgICBlID0gZS5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcbiAgICAgIGNvbnN0IGkgPSBwYXJzZUludChlLnN1YnN0cigwLCAyKSwgMTYpLCByID0gcGFyc2VJbnQoZS5zdWJzdHIoMiwgMiksIDE2KSwgbyA9IHBhcnNlSW50KGUuc3Vic3RyKDQsIDIpLCAxNik7XG4gICAgICByZXR1cm4geyByOiBpLCBnOiByLCBiOiBvIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlKGUsIGksIHIpIHtcbiAgICAgIGxldCBvLCBhLCBuLCBsLCBjLCBtLCBwLCBOO1xuICAgICAgc3dpdGNoIChsID0gTWF0aC5mbG9vcihlICogNiksIGMgPSBlICogNiAtIGwsIG0gPSByICogKDEgLSBpKSwgcCA9IHIgKiAoMSAtIGMgKiBpKSwgTiA9IHIgKiAoMSAtICgxIC0gYykgKiBpKSwgbCAlIDYpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIG8gPSByLCBhID0gTiwgbiA9IG07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBvID0gcCwgYSA9IHIsIG4gPSBtO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbyA9IG0sIGEgPSByLCBuID0gTjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG8gPSBtLCBhID0gcCwgbiA9IHI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBvID0gTiwgYSA9IG0sIG4gPSByO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgbyA9IHIsIGEgPSBtLCBuID0gcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHI6IG8sXG4gICAgICAgIGc6IGEsXG4gICAgICAgIGI6IG5cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZ0KGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHI6IGUuciAvIDI1NSxcbiAgICAgICAgZzogZS5nIC8gMjU1LFxuICAgICAgICBiOiBlLmIgLyAyNTVcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0KGUsIGksIHIpIHtcbiAgICAgIGxldCBvID0gciAtIGk7XG4gICAgICByZXR1cm4gbyA9PSAwID8gaSA6IChlIC0gaSkgJSBvICsgaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUShlKSB7XG4gICAgICBsZXQgaSA9IHQuZHJhd2luZ0J1ZmZlcldpZHRoIC8gdC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xuICAgICAgaSA8IDEgJiYgKGkgPSAxIC8gaSk7XG4gICAgICBsZXQgciA9IE1hdGgucm91bmQoZSksIG8gPSBNYXRoLnJvdW5kKGUgKiBpKTtcbiAgICAgIHJldHVybiB0LmRyYXdpbmdCdWZmZXJXaWR0aCA+IHQuZHJhd2luZ0J1ZmZlckhlaWdodCA/IHsgd2lkdGg6IG8sIGhlaWdodDogciB9IDogeyB3aWR0aDogciwgaGVpZ2h0OiBvIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG10KGUsIGksIHIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGkgLyBlLndpZHRoLFxuICAgICAgICB5OiByIC8gZS5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIFMoZSkge1xuICAgICAgbGV0IGkgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZSAqIGkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2dChlKSB7XG4gICAgICBpZiAoZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGxldCByID0gMDsgciA8IGUubGVuZ3RoOyByKyspXG4gICAgICAgIGkgPSAoaSA8PCA1KSAtIGkgKyBlLmNoYXJDb2RlQXQociksIGkgfD0gMDtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydCB7XG4gIGh0IGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/webgl-fluid-enhanced/dist/webgl-fluid-enhanced.mjs\n");

/***/ })

};
;